var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// node_modules/smart-collections/long_term_memory.js
var require_long_term_memory = __commonJS({
  "node_modules/smart-collections/long_term_memory.js"(exports2) {
    var LongTermMemory = class {
      /**
       * Creates an instance of LongTermMemory.
       * @param {Object} collection - The collection object containing the environment and items.
       */
      constructor(collection) {
        this.env = collection.env;
        this.brain = this.env;
        this.collection = collection;
        this.save_timeout = null;
      }
      /**
       * Static method to initialize a LongTermMemory instance using a specific adapter.
       * @param {Object} collection - The collection object to be used.
       * @param {Function} adapter - The adapter class to be instantiated.
       * @returns {LongTermMemory} An instance of the adapter class.
       */
      static wake_up(collection, adapter) {
        const ltm = new adapter(collection);
        return ltm;
      }
      /**
       * Gets the name of the collection.
       * @returns {string} The name of the collection.
       */
      get collection_name() {
        return this.collection.collection_name;
      }
      /**
       * Gets the name of the item in the collection.
       * @returns {string} The name of the item.
       */
      get item_name() {
        return this.collection.item_name;
      }
      /**
       * Gets the data path from the environment.
       * @returns {string} The data path.
       */
      get data_path() {
        return this.env.data_path;
      }
      /**
       * Gets the file name, defaulting to the collection name if not explicitly set.
       * @returns {string} The file name.
       */
      get file_name() {
        return this.collection.file_name || this.collection.collection_name;
      }
      /**
       * Constructs the full file path for the collection's data.
       * @returns {string} The full file path.
       */
      get file_path() {
        return this.data_path + "/" + this.file_name;
      }
      /**
       * Gets the items of the collection.
       * @returns {Array} The items of the collection.
       */
      get items() {
        return this.collection.items;
      }
      /**
       * Sets the items of the collection.
       * @param {Array} items - The new items of the collection.
       */
      set items(items) {
        this.collection.items = items;
      }
      /**
       * Gets the keys of the collection.
       * @returns {Array} The keys of the collection.
       */
      get keys() {
        return this.collection.keys;
      }
      /**
       * Placeholder for loading data, to be implemented by subclasses.
       */
      async load() {
      }
      /**
       * Default save method, logs a message if not overridden.
       */
      save() {
        if (this.constructor.name !== "LongTermMemory")
          console.log("called default, override me");
      }
      /**
       * Default asynchronous save method, logs a message if not overridden.
       */
      async _save() {
        if (this.constructor.name !== "LongTermMemory")
          console.log("called default, override me");
      }
      /**
       * Revives a value from a key-value pair.
       * @param {string} key - The key in the key-value pair.
       * @param {*} value - The value in the key-value pair.
       * @returns {*} The possibly transformed value.
       */
      reviver(key, value) {
        return this.collection.reviver(key, value);
      }
      /**
       * Replaces a value before it is serialized.
       * @param {string} key - The key in the key-value pair.
       * @param {*} value - The value in the key-value pair.
       * @returns {*} The possibly transformed value.
       */
      replacer(key, value) {
        return this.collection.replacer(key, value);
      }
    };
    exports2.LongTermMemory = LongTermMemory;
  }
});

// node_modules/smart-collections/ObsAJSON.js
var require_ObsAJSON = __commonJS({
  "node_modules/smart-collections/ObsAJSON.js"(exports2) {
    var { LongTermMemory } = require_long_term_memory();
    var ObsAJSON2 = class extends LongTermMemory {
      /**
       * Constructs an instance of ObsAJSON.
       * @param {Object} collection - The collection to be managed.
       */
      constructor(collection) {
        super(collection);
        this.adapter = this.env.main.app.vault.adapter;
      }
      /**
       * Asynchronously loads the collection from a JSON file.
       * Parses the file content and initializes collection items based on the stored data.
       * Handles file not found errors by creating necessary directories and files.
       */
      async load() {
        console.log("Loading: " + this.file_path);
        try {
          (await this.adapter.read(this.file_path)).split(",\n").filter((batch) => batch).forEach((batch, i) => {
            const items = JSON.parse(`{${batch}}`);
            Object.entries(items).forEach(([key, value]) => {
              this.collection.items[key] = new this.env.item_types[value.class_name](this.env, value);
            });
          });
          console.log("Loaded: " + this.file_name);
        } catch (err) {
          console.log("Error loading: " + this.file_path);
          console.log(err.stack);
          if (err.code === "ENOENT") {
            this.items = {};
            try {
              await this.adapter.mkdir(this.data_path);
              await this.adapter.write(this.file_path, "");
            } catch (creationErr) {
              console.log("Failed to create folder or file: ", creationErr);
            }
          }
        }
      }
      // wraps _save in timeout to prevent multiple saves at once
      save() {
        if (this.save_timeout)
          clearTimeout(this.save_timeout);
        this.save_timeout = setTimeout(() => {
          this._save();
        }, 1e4);
      }
      /**
       * Saves the collection to a JSON file. This method is throttled to prevent multiple saves at once.
       * @param {boolean} [force=false] - Forces the save operation even if currently saving.
       */
      async _save(force = false) {
        if (this.save_timeout)
          clearTimeout(this.save_timeout);
        this.save_timeout = null;
        if (this._saving)
          return console.log("Already saving: " + this.file_name);
        this._saving = true;
        setTimeout(() => {
          this._saving = false;
        }, 1e4);
        const start = Date.now();
        console.log("Saving: " + this.file_name);
        const temp_file_path = this.file_path.replace(".ajson", ".temp.ajson");
        if (await this.adapter.exists(temp_file_path))
          await this.adapter.remove(temp_file_path);
        try {
          await this.adapter.write(temp_file_path, "");
          let file_content = [];
          const items = Object.values(this.items).filter((i) => i.vec);
          const batches = Math.ceil(items.length / 1e3);
          for (let i = 0; i < batches; i++) {
            file_content = items.slice(i * 1e3, (i + 1) * 1e3).map((i2) => i2.ajson);
            const batch_content = file_content.join(",");
            await this.adapter.append(temp_file_path, batch_content + ",\n");
          }
          if (items.length > batches * 1e3) {
            await this.adapter.append(temp_file_path, items.slice(batches * 1e3).map((i) => i.ajson).join(",") + ",\n");
          }
          const end = Date.now();
          const time = end - start;
          if (force || await this.validate_save(temp_file_path, this.file_path)) {
            if (await this.adapter.exists(this.file_path))
              await this.adapter.remove(this.file_path);
            await this.adapter.rename(temp_file_path, this.file_path);
            console.log("Saved " + this.file_name + " in " + time + "ms");
          } else {
            console.log("Not saving " + this.file_name + " because new file is less than 50% of old file");
          }
        } catch (err) {
          console.error("Error saving: " + this.file_name);
          console.error(err.stack);
          const failed_file_path = temp_file_path.replace(".temp.", ".failed-" + Date.now() + ".");
          await this.adapter.rename(temp_file_path, failed_file_path);
        }
        this._saving = false;
        if (await this.adapter.exists(temp_file_path) && await this.adapter.exists(this.file_path))
          await this.adapter.remove(temp_file_path);
      }
      /**
       * Validates the new file size against the old file size to ensure data integrity.
       * @param {string} new_file_path - Path to the new file.
       * @param {string} old_file_path - Path to the old file.
       * @returns {Promise<boolean>} True if the new file size is more than 50% of the old file size, otherwise false.
       */
      async validate_save(new_file_path, old_file_path) {
        var _a, _b;
        const new_file_size = (_a = await this.adapter.stat(new_file_path)) == null ? void 0 : _a.size;
        const old_file_size = (_b = await this.adapter.stat(old_file_path)) == null ? void 0 : _b.size;
        if (!old_file_size)
          return true;
        console.log("New file size: " + new_file_size + " bytes");
        console.log("Old file size: " + old_file_size + " bytes");
        return new_file_size > old_file_size * 0.5;
      }
      get file_name() {
        return super.file_name + ".ajson";
      }
    };
    exports2.ObsAJSON = ObsAJSON2;
  }
});

// node_modules/smart-collections/ObsMultiAJSON.js
var require_ObsMultiAJSON = __commonJS({
  "node_modules/smart-collections/ObsMultiAJSON.js"(exports2) {
    var { LongTermMemory } = require_long_term_memory();
    var ObsMultiAJSON2 = class extends LongTermMemory {
      /**
       * Creates an instance of ObsMultiAJSON.
       * @param {Object} collection - The collection of items to be managed.
       */
      constructor(collection) {
        super(collection);
        this.adapter = this.env.main.app.vault.adapter;
      }
      /**
       * Asynchronously loads collection items from .ajson files within the specified data path.
       * It ensures that only .ajson files are processed and handles JSON parsing and item instantiation.
       */
      async load() {
        console.log("Loading collection items");
        if (!await this.adapter.exists(this.data_path))
          await this.adapter.mkdir(this.data_path);
        const files = (await this.adapter.list(this.data_path)).files;
        for (const file_path of files) {
          try {
            if (file_path.endsWith(".ajson")) {
              const content = await this.adapter.read(file_path);
              const data = JSON.parse(`{${content.endsWith(",") ? content.slice(0, -1) : content}}`);
              let pruned = "";
              Object.entries(data).forEach(([key, value]) => {
                const entity = new this.env.item_types[value.class_name](this.env, value);
                this.env[entity.collection_name].items[key] = entity;
                pruned += entity.ajson + ",\n";
              });
              await this.adapter.write(file_path, pruned.trim());
            }
          } catch (err) {
            console.log("Error loading file: " + file_path);
            console.log(err.stack);
          }
        }
        console.log("Loaded collection items");
      }
      /**
       * Schedules a save operation to prevent multiple saves happening at the same time.
       */
      save() {
        if (this.save_timeout)
          clearTimeout(this.save_timeout);
        this.save_timeout = setTimeout(() => {
          this._save();
        }, 1e4);
      }
      /**
       * Asynchronously saves modified collection items to their respective .ajson files.
       * @param {boolean} [force=false] - Forces the save operation even if it's currently flagged as saving.
       */
      async _save(force = false) {
        let saved_ct = 0;
        if (this._saving)
          return console.log("Already saving");
        this._saving = true;
        setTimeout(() => {
          this._saving = false;
        }, 1e4);
        const start = Date.now();
        console.log("Saving collection items");
        if (!await this.adapter.exists(this.data_path))
          await this.adapter.mkdir(this.data_path);
        const items = Object.values(this.items).filter((i) => i.vec && i.changed);
        if (items.length === 0) {
          this._saving = false;
          console.log("Nothing to save");
          return;
        }
        try {
          for (const item of items) {
            const item_file_path = `${this.data_path}/${item.multi_ajson_file_name}.ajson`;
            await this.adapter.append(item_file_path, "\n" + item.ajson + ",");
            saved_ct++;
          }
          const end = Date.now();
          const time = end - start;
          console.log(`Saved ${saved_ct} collection items in ${time}ms`);
        } catch (err) {
          console.error("Error saving collection items");
          console.error(err.stack);
        }
        this._saving = false;
      }
      /**
       * Validates the save operation by comparing the file sizes of the new and old files.
       * @param {string} new_file_path - Path to the new file.
       * @param {string} old_file_path - Path to the old file.
       * @returns {Promise<boolean>} - True if the new file size is at least 50% of the old file size, otherwise false.
       */
      async validate_save(new_file_path, old_file_path) {
        var _a, _b;
        const new_file_size = (_a = await this.adapter.stat(new_file_path)) == null ? void 0 : _a.size;
        const old_file_size = (_b = await this.adapter.stat(old_file_path)) == null ? void 0 : _b.size;
        if (!old_file_size)
          return true;
        console.log("New file size: " + new_file_size + " bytes");
        console.log("Old file size: " + old_file_size + " bytes");
        return new_file_size > old_file_size * 0.5;
      }
      /**
       * Gets the data path for storing .ajson files, appending '/multi' to the base path.
       * @returns {string} The data path for .ajson files.
       */
      get data_path() {
        return super.data_path + "/multi";
      }
    };
    exports2.ObsMultiAJSON = ObsMultiAJSON2;
  }
});

// node_modules/smart-collections/env.js
var require_env = __commonJS({
  "node_modules/smart-collections/env.js"(exports2) {
    var { LongTermMemory: LTM } = require_long_term_memory();
    var SmartEnv = class {
      constructor(ltm_adapter = LTM) {
        this.config = {};
        this.item_types = {};
        this.collections = {};
        this.ltm_adapter = ltm_adapter;
        this.data_path = "./test/data";
      }
      init() {
        this.load_collections();
      }
      load_collections() {
        Object.entries(this.collections).map(([collection_name, collection]) => this[collection_name] = collection.load(this));
      }
      get_ref(ref) {
        return this[ref.collection_name].get(ref.key);
      }
    };
    exports2.SmartEnv = SmartEnv;
  }
});

// node_modules/smart-collections/Brain.js
var require_Brain = __commonJS({
  "node_modules/smart-collections/Brain.js"(exports2) {
    var { SmartEnv } = require_env();
    exports2.Brain = SmartEnv;
  }
});

// node_modules/smart-chunks/SmartMarkdown.js
var require_SmartMarkdown = __commonJS({
  "node_modules/smart-chunks/SmartMarkdown.js"(exports2) {
    var SmartMarkdown = class {
      /**
       * Returns the default configuration for the SmartMarkdown parser.
       * @returns {Object} Default configuration settings.
       */
      static get defaults() {
        return {
          excluded_headings: null,
          // comma separated list of headings to exclude
          embed_input_max_chars: 1e3,
          // max length of block
          embed_input_min_chars: 50,
          // min length of block
          skip_blocks_with_headings_only: false
          // skip blocks that only contain headings
        };
      }
      /**
       * Creates an instance of SmartMarkdown with the given configuration.
       * @param {Object} config - User-defined configuration settings.
       */
      constructor(config) {
        this.config = { ...SmartMarkdown.defaults, ...config };
      }
      /**
       * Retrieves the list of headings to be excluded from parsing, if any.
       * @returns {Array|null} An array of headings to exclude, or null if none.
       */
      get excluded_headings() {
        var _a;
        ((_a = this.config.excluded_headings) == null ? void 0 : _a.length) ? this.config.excluded_headings.split(",").map((header) => header.trim()) : null;
      }
      /**
       * Analyzes the markdown content to extract metadata about each heading.
       * @param {string} content - The markdown content to analyze.
       * @returns {Array} An array of objects containing metadata about each heading.
       */
      // WIP
      get_headings_meta(content) {
        return content.split("\n").reduce((acc, line, line_i, lines) => {
          if (!this.is_heading(line))
            return acc;
          const chars_until_next_heading = lines.slice(line_i + 1).findIndex((line2) => this.is_heading(line2));
          const heading_level = line.split("#").length - 1;
          const heading_text = line.replace(/#/g, "").trim();
          acc.push = { line_i, heading_level, heading_text, chars_until_next_heading };
          return acc;
        }, []);
      }
      // v1
      // get block from path
      /**
       * Extracts a specific block of markdown based on a heading path.
       * @param {string} block_path - The path to the block, specified as a series of headings.
       * @param {string} markdown - The markdown content to parse.
       * @param {Object} opts - Options for block extraction, such as character limits per line.
       * @returns {string} The extracted block of markdown text.
       */
      get_block_from_path(block_path, markdown, opts = {}) {
        if (block_path.endsWith("#") && block_path.split("#").length === 2)
          return markdown.split("#")[0];
        if (!this.validate_block_path(block_path))
          return markdown;
        const {
          chars_per_line = null,
          max_chars = this.config.embed_input_max_chars,
          min_chars = this.config.embed_input_min_chars
        } = opts;
        const block = [];
        const block_headings = block_path.split("#").slice(1);
        let currentHeaders = [];
        let begin_line = 0;
        let is_code = false;
        let char_count = 0;
        let heading_occurrence = 0;
        let occurrence_count = 0;
        if (block_headings[block_headings.length - 1].indexOf("{") > -1) {
          heading_occurrence = parseInt(block_headings[block_headings.length - 1].split("{")[1].replace("}", ""));
          block_headings[block_headings.length - 1] = block_headings[block_headings.length - 1].split("{")[0];
        }
        const lines = markdown.split("\n");
        let block_heading_level = 0;
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];
          if (line.indexOf("```") === 0)
            is_code = !is_code;
          if (is_code)
            continue;
          if (["- ", "- [ ] "].indexOf(line) > -1)
            continue;
          if (!this.is_heading(line))
            continue;
          block_heading_level = this.heading_level(line);
          const heading_text = line.replace(/#/g, "").trim();
          const heading_index = block_headings.indexOf(heading_text);
          if (heading_index < 0)
            continue;
          if (currentHeaders.length !== heading_index)
            continue;
          currentHeaders.push(heading_text);
          if (currentHeaders.length === block_headings.length) {
            if (heading_occurrence === 0) {
              begin_line = i + 1;
              break;
            }
            if (occurrence_count === heading_occurrence) {
              begin_line = i + 1;
              break;
            }
            occurrence_count++;
            currentHeaders.pop();
            continue;
          }
        }
        if (begin_line === 0)
          return "";
        is_code = false;
        for (let i = begin_line; i < lines.length; i++) {
          let line = lines[i];
          if (this.is_heading(line) && this.heading_level(line) <= block_heading_level)
            break;
          if (chars_per_line && line.length > chars_per_line)
            line = line.slice(0, chars_per_line) + "...";
          if (line.startsWith("```"))
            is_code = !is_code;
          block.push(line);
          char_count += line.length;
          if (max_chars && char_count > max_chars) {
            const diff = char_count - max_chars;
            block[block.length - 1] = block[block.length - 1].slice(0, block[block.length - 1].length - diff) + "...";
            break;
          }
          if (max_chars && max_chars - char_count < 10)
            break;
        }
        if (is_code)
          block.push("```");
        return block.join("\n").trim();
      }
      /**
       * Parses the markdown content and organizes it into structured blocks based on headings.
       * @param {Object} params - Parameters containing content and optional file path.
       * @returns {Object} An object containing parsed blocks and other metadata.
       */
      parse({ content, file_path = "" }) {
        const file_breadcrumbs = this.file_path_to_breadcrumbs(file_path) + ": ";
        if (file_path.endsWith(".excalidraw.md")) {
          const excalidraw_block = this.get_block_from_path(file_path + "#Text Elements", content).replace("\n%%", "");
          return {
            blocks: [
              {
                text: excalidraw_block,
                path: file_path + "#Text Elements",
                length: excalidraw_block.length,
                heading: "Text Elements"
              }
            ],
            log: []
          };
        }
        const output = content.split("\n").reduce((acc, line, i, arr) => {
          if (this.is_heading(line) && (!acc.curr_level || !this.config.multi_heading_blocks || this.heading_level(line) <= acc.curr_level || acc.curr.length > this.config.embed_input_max_chars)) {
            this.output_block(acc);
            acc.curr_level = this.heading_level(line);
            acc.current_headers = acc.current_headers.filter((header) => header.level < acc.curr_level);
            acc.current_headers.push({ header: line.replace(/#/g, "").trim(), level: acc.curr_level });
            acc.start_line = i;
            acc.curr = file_breadcrumbs;
            acc.curr += acc.current_headers.map((header) => header.header).join(" > ");
            acc.block_headings = "#" + acc.current_headers.map((header) => header.header).join("#");
            this.handle_duplicate_headings(acc);
            acc.block_headings_list.push(acc.block_headings);
            acc.block_path = file_path + acc.block_headings;
            acc.curr_heading = line.replace(/#/g, "").trim();
            return acc;
          }
          if (this.is_content_line(line)) {
            if (acc.curr.indexOf("\n") === -1)
              acc.curr += ":";
            acc.curr += "\n" + line;
            acc.curr_line = i;
          }
          if (i === arr.length - 1)
            this.output_block(acc);
          return acc;
        }, { block_headings: "", block_headings_list: [], block_path: file_path + "#", curr: file_breadcrumbs, current_headers: [], blocks: [], log: [], start_line: 0, curr_line: 0, curr_heading: null });
        return {
          ...output,
          file_path,
          // remove properties that are exclusive to the reduce function
          block_headings: void 0,
          block_headings_list: void 0,
          block_path: void 0,
          curr: void 0,
          current_headers: void 0
        };
      }
      /**
       * Handles duplicate headings by appending a unique identifier to the heading path.
       * @param {Object} acc - The accumulator object used in reduce function.
       */
      // if block_headings is already in block_headings_list then add a number to the end
      handle_duplicate_headings(acc) {
        if (!acc.block_headings_list.includes(acc.block_headings))
          return;
        let count = 1;
        const uniqueHeadings = new Set(acc.block_headings_list);
        while (uniqueHeadings.has(`${acc.block_headings}{${count}}`)) {
          count++;
        }
        acc.block_headings = `${acc.block_headings}{${count}}`;
      }
      /**
       * Outputs the current block into the structured blocks array after validation.
       * @param {Object} acc - The accumulator object used in reduce function.
       */
      // push the current block to the blocks array
      output_block(acc) {
        const { embed_input_max_chars, embed_input_min_chars } = this.config;
        if (acc.curr.indexOf("\n") === -1)
          return acc.log.push(`Skipping empty block: ${acc.curr}`);
        if (!this.validate_heading(acc.block_headings))
          return acc.log.push(`Skipping excluded heading: ${acc.block_headings}`);
        if (acc.curr.length > embed_input_max_chars)
          acc.curr = acc.curr.substring(0, embed_input_max_chars);
        const breadcrumbs_length = acc.curr.indexOf("\n") + 1;
        const block_length = acc.curr.length - breadcrumbs_length;
        if (block_length < embed_input_min_chars)
          return acc.log.push(`Skipping block shorter than min length: ${acc.curr}`);
        if (this.config.skip_blocks_with_headings_only) {
          const block_lines = acc.curr.split("\n");
          const block_headings = block_lines.slice(1).filter((line) => this.is_heading(line));
          if (block_headings.length === block_lines.length - 1)
            return acc.log.push(`Skipping block with only headings: ${acc.curr}`);
        }
        acc.blocks.push({
          text: acc.curr.trim(),
          path: acc.block_path,
          length: block_length,
          heading: acc.curr_heading,
          lines: [acc.start_line, acc.curr_line]
        });
      }
      /**
       * Determines if a line of text should be considered as content.
       * @param {string} line - The line of text to evaluate.
       * @returns {boolean} True if the line is content, false otherwise.
       */
      is_content_line(line) {
        if (["- ", "- [ ] "].indexOf(line) > -1)
          return false;
        return true;
      }
      /**
       * Converts a file path to a breadcrumb string format.
       * @param {string} file_path - The file path to convert.
       * @returns {string} The breadcrumb string.
       */
      file_path_to_breadcrumbs(file_path) {
        return file_path.replace(".md", "").split("/").map((crumb) => crumb.trim()).filter((crumb) => crumb !== "").join(" > ");
      }
      // remove .md file extension and convert file_path to breadcrumb formatting
      /**
       * Determines the level of a heading based on the number of '#' characters.
       * @param {string} line - The heading line to evaluate.
       * @returns {number} The level of the heading.
       */
      heading_level(line) {
        return line.split("#").length - 1;
      }
      /**
       * Checks if a line is a heading.
       * @param {string} line - The line to check.
       * @returns {boolean} True if the line is a heading, false otherwise.
       * @param {string} line - The line to check.
       * @returns {boolean} True if the line is a heading, false otherwise.
      */
      is_heading(line) {
        return line.startsWith("#") && ["#", " "].indexOf(line[1]) > -1;
      }
      // check if line is a heading (starts with # and second character is space or # indicating not a tag)
      /**
       * Validates if the block path is correctly formatted to include at least one heading.
       * @param {string} block_path - The block path to validate.
       * @returns {boolean} True if the block path is valid, false otherwise.
       */
      validate_block_path(block_path) {
        return block_path.indexOf("#") > -1;
      }
      // validate block_path contains at least one "#"
      /**
       * Validates a heading against the list of excluded headings.
       * @param {string} headings - The heading to validate.
       * @returns {boolean} True if the heading is not excluded, false if it is.
       */
      validate_heading(headings) {
        var _a;
        return !!!((_a = this.excluded_headings) == null ? void 0 : _a.some((exclusion) => headings.indexOf(exclusion) > -1));
      }
      // validate heading against excluded headings
    };
    exports2.SmartMarkdown = SmartMarkdown;
  }
});

// node_modules/smart-chunks/smart-chunks.js
var require_smart_chunks = __commonJS({
  "node_modules/smart-chunks/smart-chunks.js"(exports2) {
    var { SmartMarkdown } = require_SmartMarkdown();
    exports2.SmartMarkdown = SmartMarkdown;
  }
});

// node_modules/smart-collections/helpers.js
var require_helpers = __commonJS({
  "node_modules/smart-collections/helpers.js"(exports2) {
    function create_uid(data) {
      const str = JSON.stringify(data);
      let hash = 0;
      if (str.length === 0)
        return hash;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = (hash << 5) - hash + char;
        hash = hash & hash;
        if (hash < 0)
          hash = hash * -1;
      }
      return hash.toString() + str.length;
    }
    exports2.create_uid = create_uid;
    function deep_merge(target, source) {
      for (const key in source) {
        if (source.hasOwnProperty(key)) {
          if (is_obj(source[key]) && is_obj(target[key]))
            deep_merge(target[key], source[key]);
          else
            target[key] = source[key];
        }
      }
      return target;
      function is_obj(item) {
        return item && typeof item === "object" && !Array.isArray(item);
      }
    }
    exports2.deep_merge = deep_merge;
    function collection_instance_name_from(class_name) {
      return class_name.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase().replace(/y$/, "ie") + "s";
    }
    exports2.collection_instance_name_from = collection_instance_name_from;
    function cos_sim(vector1, vector2) {
      const dotProduct = vector1.reduce((acc, val, i) => acc + val * vector2[i], 0);
      const normA = Math.sqrt(vector1.reduce((acc, val) => acc + val * val, 0));
      const normB = Math.sqrt(vector2.reduce((acc, val) => acc + val * val, 0));
      return normA === 0 || normB === 0 ? 0 : dotProduct / (normA * normB);
    }
    exports2.cos_sim = cos_sim;
    function top_acc(_acc, item, ct = 10) {
      if (_acc.items.size < ct) {
        _acc.items.add(item);
      } else if (item.sim > _acc.min) {
        _acc.items.add(item);
        _acc.items.delete(_acc.minItem);
        _acc.minItem = Array.from(_acc.items).reduce((min, curr) => curr.sim < min.sim ? curr : min);
        _acc.min = _acc.minItem.sim;
      }
    }
    exports2.top_acc = top_acc;
    function sleep(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }
    exports2.sleep = sleep;
  }
});

// node_modules/smart-collections/CollectionItem.js
var require_CollectionItem = __commonJS({
  "node_modules/smart-collections/CollectionItem.js"(exports2) {
    var helpers = require_helpers();
    var {
      create_uid,
      deep_merge,
      collection_instance_name_from
    } = helpers;
    var CollectionItem = class {
      /**
       * Default properties for an instance of CollectionItem.
       * @returns {Object} Default data configuration.
       */
      static get defaults() {
        return {
          data: {
            key: null
          }
        };
      }
      /**
       * Creates an instance of CollectionItem.
       * @param {Object} brain - The central storage or context.
       * @param {Object|null} data - Initial data for the item.
       */
      constructor(env, data = null) {
        var _a;
        this.env = env;
        this.brain = this.env;
        this.config = (_a = this.env) == null ? void 0 : _a.config;
        this.merge_defaults();
        if (data)
          this.data = data;
        if (!this.data.class_name)
          this.data.class_name = this.constructor.name;
      }
      /**
       * Merges default properties from all classes in the inheritance chain.
       */
      merge_defaults() {
        let current_class = this.constructor;
        while (current_class) {
          for (let key in current_class.defaults) {
            if (typeof current_class.defaults[key] === "object")
              this[key] = { ...current_class.defaults[key], ...this[key] };
            else
              this[key] = current_class.defaults[key];
          }
          current_class = Object.getPrototypeOf(current_class);
        }
      }
      /**
       * Generates or retrieves a unique key for the item. Can be overridden in child classes.
       * @returns {string} The unique key.
       */
      get_key() {
        console.log("called default get_key");
        return create_uid(this.data);
      }
      // update_data - for data in this.data
      /**
       * Updates the data of this item with new data.
       * @param {Object} data - The new data for the item.
       * @returns {boolean} True if data was successfully updated.
       */
      update_data(data) {
        data = JSON.parse(JSON.stringify(data, this.update_data_replacer));
        deep_merge(this.data, data);
        return true;
      }
      /**
       * Custom replacer function for JSON.stringify used in update_data to handle special object types.
       * @param {string} key - The key of the property being stringified.
       * @param {any} value - The value of the property being stringified.
       * @returns {any} The value to be used in the JSON string.
       */
      update_data_replacer(key, value) {
        if (value instanceof CollectionItem)
          return value.ref;
        if (Array.isArray(value))
          return value.map((val) => val instanceof CollectionItem ? val.ref : val);
        return value;
      }
      // init - for data not in this.data
      /**
       * Initializes the item with input_data, potentially asynchronously.
       * Handles interactions with other collection items.
       */
      init() {
        this.save();
      }
      // should always call this.save() in child class init() overrides
      /**
       * Saves the current state of the item to its collection.
       */
      save() {
        if (!this.validate_save()) {
          if (this.key)
            this.collection.delete(this.key);
          return console.error("Invalid save: ", { data: this.data, stack: new Error().stack });
        }
        this.collection.set(this);
        this.collection.save();
      }
      /**
       * Validates the item's data before saving.
       * @returns {boolean} True if the data is valid for saving.
       */
      validate_save() {
        if (!this.key)
          return false;
        if (this.key === "")
          return false;
        if (this.key === "undefined")
          return false;
        return true;
      }
      /**
       * Deletes the item from its collection.
       */
      delete() {
        this.collection.delete(this.key);
      }
      // functional filter (returns true or false) for filtering items in collection; called by collection class
      /**
       * Filters items in the collection based on provided options.
       * @param {Object} opts - Filtering options.
       * @returns {boolean} True if the item passes the filter.
       */
      filter(opts = {}) {
        const {
          exclude_key,
          exclude_keys = exclude_key ? [exclude_key] : [],
          exclude_key_starts_with,
          key_ends_with,
          key_starts_with,
          key_starts_with_any
        } = opts;
        if (exclude_keys == null ? void 0 : exclude_keys.includes(this.key))
          return false;
        if (exclude_key_starts_with && this.key.startsWith(exclude_key_starts_with))
          return false;
        if (key_ends_with && !this.key.endsWith(key_ends_with))
          return false;
        if (key_starts_with && !this.key.startsWith(key_starts_with))
          return false;
        if (key_starts_with_any && !key_starts_with_any.some((prefix) => this.key.startsWith(prefix)))
          return false;
        return true;
      }
      /**
       * Parses the item's data for any necessary processing or transformation. Placeholder for override in child classes.
       */
      parse() {
      }
      /**
       * Retrieves the collection name derived from the class name.
       * @returns {string} The collection name.
       */
      static get collection_name() {
        return collection_instance_name_from(this.name);
      }
      /**
       * Retrieves the collection name for the instance, either from data or the class method.
       * @returns {string} The collection name.
       */
      get collection_name() {
        return this.data.collection_name ? this.data.collection_name : collection_instance_name_from(this.data.class_name || this.constructor.name);
      }
      /**
       * Retrieves the collection this item belongs to.
       * @returns {Object} The collection object.
       */
      get collection() {
        return this.env[this.collection_name];
      }
      /**
       * Retrieves or generates the key for this item.
       * @returns {string} The item's key.
       */
      get key() {
        return this.data.key = this.data.key || this.get_key();
      }
      /**
       * Provides a reference object for this item, containing the collection name and key.
       * @returns {Object} The reference object.
       */
      get ref() {
        return { collection_name: this.collection_name, key: this.key };
      }
      /**
       * Retrieves the sequence key for this item, used for building sequence keys.
       * @returns {string} The sequence key.
       */
      get seq_key() {
        return this.key;
      }
      // used for building sequence keys
    };
    exports2.CollectionItem = CollectionItem;
  }
});

// node_modules/smart-collections/Collection.js
var require_Collection = __commonJS({
  "node_modules/smart-collections/Collection.js"(exports2) {
    var { CollectionItem } = require_CollectionItem();
    var AsyncFunction = Object.getPrototypeOf(async function() {
    }).constructor;
    var helpers = require_helpers();
    var { deep_merge } = helpers;
    var Collection = class {
      /**
       * Constructs a new Collection instance.
       * @param {Object} env - The environment context containing configurations and adapters.
       */
      constructor(env) {
        this.env = env;
        this.brain = this.env;
        this.config = this.env.config;
        this.items = {};
        this.LTM = this.env.ltm_adapter.wake_up(this, this.env.ltm_adapter);
      }
      /**
       * Loads a collection based on the environment and optional configuration.
       * @param {Object} env - The environment context.
       * @param {Object} [config={}] - Optional configuration for the collection.
       * @returns {Promise<Collection>|Collection} The loaded collection instance.
       */
      static load(env, config = {}) {
        const { custom_collection_name } = config;
        env[this.collection_name] = new this(env);
        if (custom_collection_name) {
          env[this.collection_name].collection_name = custom_collection_name;
          env.collections[custom_collection_name] = this.constructor;
        }
        env[this.collection_name].merge_defaults();
        if (env[this.collection_name].load instanceof AsyncFunction)
          return env[this.collection_name].load().then(() => env[this.collection_name]);
        else
          env[this.collection_name].load();
        return env[this.collection_name];
      }
      /**
       * Merges default configurations from all classes in the inheritance chain.
       */
      merge_defaults() {
        var _a, _b;
        let current_class = this.constructor;
        while (current_class) {
          const col_conf = (_b = (_a = this.config) == null ? void 0 : _a.collections) == null ? void 0 : _b[current_class.collection_name];
          Object.entries(typeof col_conf === "object" ? col_conf : {}).forEach(([key, value]) => this[key] = value);
          current_class = Object.getPrototypeOf(current_class);
        }
      }
      /**
       * Saves the current state of the collection.
       */
      save() {
        this.LTM.save();
      }
      /**
       * Loads the collection state.
       */
      load() {
        this.LTM.load();
      }
      /**
       * Revives items from a serialized state.
       * @param {string} key - The key of the item.
       * @param {*} value - The serialized item value.
       * @returns {CollectionItem|*} The revived item or the original value if not an object.
       */
      reviver(key, value) {
        if (typeof value !== "object" || value === null)
          return value;
        if (value.class_name)
          return new this.env.item_types[value.class_name](this.env, value);
        return value;
      }
      replacer(key, value) {
        if (value instanceof this.item_type)
          return value.data;
        if (value instanceof CollectionItem)
          return value.ref;
        return value;
      }
      /**
       * Creates or updates an item in the collection based on the provided data.
       * @param {Object} data - The data to create or update an item.
       * @returns {Promise<CollectionItem>|CollectionItem} The newly created or updated item.
       */
      create_or_update(data = {}) {
        const existing = this.find_by(data);
        const item = existing ? existing : new this.item_type(this.env);
        item.is_new = !!!existing;
        const changed = item.update_data(data);
        if (existing && !changed)
          return existing;
        if (item.validate_save())
          this.set(item);
        if (item.init instanceof AsyncFunction)
          return new Promise((resolve, reject) => {
            item.init(data).then(() => resolve(item));
          });
        item.init(data);
        return item;
      }
      /**
       * Finds an item in the collection that matches the given data.
       * @param {Object} data - The criteria used to find the item.
       * @returns {CollectionItem|null} The found item or null if not found.
       */
      find_by(data) {
        if (data.key)
          return this.get(data.key);
        const temp = new this.item_type(this.env);
        const temp_data = JSON.parse(JSON.stringify(data, temp.update_data_replacer));
        deep_merge(temp.data, temp_data);
        return temp.key ? this.get(temp.key) : null;
      }
      // READ
      /**
       * Filters the items in the collection based on the provided options.
       * @param {Object} opts - The options used to filter the items.
       * @return {CollectionItem[]} The filtered items.
       */
      filter(opts) {
        return Object.entries(this.items).filter(([key, item]) => item.filter(opts)).map(([key, item]) => item);
      }
      /**
       * Retrieves items from the collection based on the provided strategy and options.
       * @param {Function[]} strategy - The strategy used to retrieve the items.
       * @param {Object} opts - The options used to retrieve the items.
       * @return {CollectionItem[]} The retrieved items.
       * @throws {Error} Throws an error if any function in the strategy array is not actually a function or if an async function throws an error.
       */
      async retrieve(strategy = [], opts = {}) {
        return await sequential_async_processor(funcs, this.filter(opts), opts);
      }
      /**
       * Retrieves a single item from the collection based on the provided strategy and options.
       * @param {String} key - The key of the item to retrieve.
       * @return {CollectionItem} The retrieved item.
       */
      get(key) {
        return this.items[key];
      }
      /**
       * Retrieves multiple items from the collection based on the provided keys.
       * @param {String[]} keys - The keys of the items to retrieve.
       * @return {CollectionItem[]} The retrieved items.
       */
      get_many(keys = []) {
        if (Array.isArray(keys))
          return keys.map((key) => this.get(key));
        console.error("get_many called with non-array keys: ", keys);
      }
      /**
       * Retrieves a random item from the collection based on the provided options.
       * @param {Object} opts - The options used to retrieve the item.
       * @return {CollectionItem} The retrieved item.
       */
      get_rand(opts = null) {
        if (opts) {
          const filtered = this.filter(opts);
          return filtered[Math.floor(Math.random() * filtered.length)];
        }
        return this.items[this.keys[Math.floor(Math.random() * this.keys.length)]];
      }
      // UPDATE
      /**
       * Adds or updates an item in the collection.
       * @param {CollectionItem} item - The item to add or update.
       */
      set(item) {
        if (!item.key)
          throw new Error("Item must have key property");
        this.items[item.key] = item;
      }
      /**
       * Updates multiple items in the collection based on the provided keys and data.
       * @param {String[]} keys - The keys of the items to update.
       * @param {Object} data - The data to update the items with.
       */
      update_many(keys = [], data = {}) {
        this.get_many(keys).forEach((item) => item.update_data(data));
      }
      // DESTROY
      /**
       * Clears all items from the collection.
       */
      clear() {
        this.items = {};
      }
      /**
       * Deletes an item from the collection based on its key.
       * @param {String} key - The key of the item to delete.
       */
      delete(key) {
        delete this.items[key];
      }
      /**
       * Deletes multiple items from the collection based on their keys.
       * @param {String[]} keys - The keys of the items to delete.
       */
      delete_many(keys = []) {
        keys.forEach((key) => delete this.items[key]);
      }
      // CONVENIENCE METHODS (namespace getters)
      /**
       * Gets the collection name derived from the class name.
       * @return {String} The collection name.
       */
      static get collection_name() {
        return this.name.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
      }
      /**
       * Gets or sets the collection name. If a name is set, it overrides the default name.
       * @param {String} name - The new collection name.
       */
      get collection_name() {
        return this._collection_name ? this._collection_name : this.constructor.collection_name;
      }
      set collection_name(name) {
        this._collection_name = name;
      }
      /**
       * Gets the keys of the items in the collection.
       * @return {String[]} The keys of the items.
       */
      get keys() {
        return Object.keys(this.items);
      }
      /**
       * Gets the class name of the item type the collection manages.
       * @return {String} The item class name.
       */
      get item_class_name() {
        return this.constructor.name.slice(0, -1).replace(/(ie)$/g, "y");
      }
      // remove 's' from end of name & if name ends in 'ie', replace with 'y'
      /**
       * Gets the name of the item type the collection manages, derived from the class name.
       * @return {String} The item name.
       */
      get item_name() {
        return this.item_class_name.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
      }
      /**
       * Gets the constructor of the item type the collection manages.
       * @return {Function} The item type constructor.
       */
      get item_type() {
        return this.env.item_types[this.item_class_name];
      }
    };
    exports2.Collection = Collection;
    async function sequential_async_processor(funcs2, initial_value, opts = {}) {
      let value = initial_value;
      for (const func of funcs2) {
        if (typeof func !== "function") {
          throw new TypeError("All elements in async_functions array must be functions");
        }
        try {
          value = await func(value, opts);
        } catch (error) {
          throw error;
        }
      }
      return value;
    }
    exports2.sequential_async_processor = sequential_async_processor;
  }
});

// node_modules/smart-embed-model/adapters/adapter.js
var require_adapter = __commonJS({
  "node_modules/smart-embed-model/adapters/adapter.js"(exports2) {
    var Adapter = class {
      /**
       * Constructs an instance of Adapter.
       * @param {object} main - The main context object which should contain a configuration object.
       */
      constructor(main) {
        this.main = main;
        Object.assign(this, main.config);
      }
    };
    exports2.Adapter = Adapter;
  }
});

// node_modules/smart-embed-model/adapters/api.js
var require_api = __commonJS({
  "node_modules/smart-embed-model/adapters/api.js"(exports2) {
    var { Adapter } = require_adapter();
    var ApiAdapter = class extends Adapter {
      /**
       * Counts the number of tokens in the input.
       * Override in child classes to implement third-party token counters.
       * @param {string} input - The input to count tokens for.
       * @returns {Promise<number>} The number of tokens in the input.
       */
      async count_tokens(input) {
        return this.estimate_tokens(input);
      }
      /**
       * Estimates the number of tokens in the input.
       * @param {string|object} input - The input to estimate tokens for.
       * @returns {number} The estimated number of tokens.
       */
      estimate_tokens(input) {
        var _a;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.estimate_tokens) === "function")
          return this.adapter.estimate_tokens(input);
        if (typeof input === "object")
          input = JSON.stringify(input);
        return input.length / 3.7;
      }
      /**
       * Gets the maximum number of characters allowed in the input based on max_tokens.
       * @returns {number} The maximum number of characters.
       */
      get max_chars() {
        return this.max_tokens * 4 - 100;
      }
      /**
       * Embeds the input and returns the first embedding.
       * @param {string} input - The input to embed.
       * @returns {Promise<object>} The first embedding object.
       */
      async embed(input) {
        if (!(input == null ? void 0 : input.length))
          return console.log("input is empty");
        input = this.prepare_embed_input(input);
        const embeddings = await this.request_embedding(input);
        return embeddings[0];
      }
      /**
       * Embeds a batch of items and returns their embeddings.
       * @param {Array} items - The items to embed.
       * @returns {Promise<Array>} The embeddings of the items.
       */
      async embed_batch(items) {
        items = items.filter((item) => {
          var _a;
          return ((_a = item.embed_input) == null ? void 0 : _a.length) > 0;
        });
        if (items.length === 0)
          return console.log("empty batch (or all items have empty embed_input)");
        const embed_inputs = this.prepare_batch_input(items);
        let embeddings = await this.request_embedding(embed_inputs);
        if (!embeddings)
          return console.error(items);
        embeddings = embeddings.map((embedding, i) => this.parse_embedding_output(embed_inputs, embedding, i));
        return items.map((item, i) => {
          item.vec = embeddings[i].vec;
          item.tokens = embeddings[i].tokens;
          return item;
        });
      }
      /**
       * Parses the embedding output for each input.
       * @param {Array} embed_inputs - The inputs used for embedding.
       * @param {object} embedding - The embedding result.
       * @param {number} i - The index of the current embedding.
       * @returns {object} The parsed embedding output.
       */
      parse_embedding_output(embed_inputs, embedding, i) {
        const total_chars = this.count_embed_input_chars(embed_inputs);
        return {
          vec: embedding.vec,
          tokens: Math.round(embed_inputs[i].length / total_chars * embedding.tokens)
        };
      }
      /**
       * Counts the total number of characters in all embed inputs.
       * @param {Array} embed_inputs - The inputs used for embedding.
       * @returns {number} The total number of characters.
       */
      count_embed_input_chars(embed_inputs) {
        return embed_inputs.reduce((acc, curr) => acc + curr.length, 0);
      }
      /**
       * Prepares the batch input by processing each item's embed input.
       * @param {Array} items - The items to prepare.
       * @returns {Array} The prepared batch input.
       */
      prepare_batch_input(items) {
        return items.map((item) => this.prepare_embed_input(item.embed_input));
      }
      /**
       * Prepares the embed input by truncating it if necessary.
       * @param {string} embed_input - The input to prepare.
       * @returns {string} The prepared embed input.
       */
      prepare_embed_input(embed_input) {
        return embed_input.length > this.max_chars ? embed_input.slice(0, this.max_chars) : embed_input;
      }
      /**
       * Prepares the request body for embedding.
       * @param {string[]} embed_input - The input to embed.
       * @returns {object} The prepared request body.
       */
      prepare_request_body(embed_input) {
        const body = {
          model: this.model_name,
          input: embed_input
        };
        if (this.model_name.startsWith("text-embedding-3")) {
          body.dimensions = this.dims;
        }
        return body;
      }
      /**
       * Prepares the request headers for the API call.
       * @returns {object} The prepared request headers.
       */
      prepare_request_headers() {
        let headers = {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.api_key}`
        };
        if (this.headers)
          headers = { ...headers, ...this.headers };
        return headers;
      }
      /**
       * Requests the embedding from the API.
       * @param {string|string[]} embed_input - The input to embed. May be a string or an array of strings.
       * @returns {Promise<object[]>} The embedding objects {vec, tokens}.
       */
      async request_embedding(embed_input) {
        if (embed_input.length === 0) {
          console.log("embed_input is empty");
          return null;
        }
        const request2 = {
          url: this.endpoint,
          method: "POST",
          body: JSON.stringify(this.prepare_request_body(embed_input)),
          headers: this.prepare_request_headers()
        };
        const resp = await this.request(request2);
        return this.parse_response(resp);
      }
      /**
       * Parses the response from the API.
       * @param {object} resp - The response from the API.
       * @returns {Array} The parsed response data.
       */
      parse_response(resp) {
        return resp.data.map((item) => ({
          vec: item.embedding,
          tokens: resp.usage.total_tokens / resp.data.length
        }));
      }
      /**
       * Checks if the response JSON indicates an error.
       * @param {object} resp_json - The response JSON to check.
       * @returns {boolean} True if there is an error, false otherwise.
       */
      is_error(resp_json) {
        return !resp_json.data || !resp_json.usage;
      }
      /**
       * Retrieves the JSON from the response.
       * @param {Response} resp - The response object.
       * @returns {Promise<object>} The response JSON.
       */
      async get_resp_json(resp) {
        return typeof resp.json === "function" ? await resp.json() : await resp.json;
      }
      /**
       * Handles the request, including retries for specific errors.
       * @param {object} req - The request object.
       * @param {number} retries - The current retry count.
       * @returns {Promise<object|null>} The response JSON or null if an error occurs.
       */
      async request(req, retries = 0) {
        try {
          req.throw = false;
          const resp = this.request_adapter ? await this.request_adapter({ url: this.endpoint, ...req }) : await fetch(this.endpoint, req);
          const resp_json = await this.get_resp_json(resp);
          if (this.is_error(resp_json))
            return await this.handle_request_err(resp_json, req, retries);
          return resp_json;
        } catch (error) {
          return await this.handle_request_err(error, req, retries);
        }
      }
      /**
       * Handles errors during the request, including retrying the request.
       * @param {Error} error - The error encountered.
       * @param {object} req - The request object.
       * @param {number} retries - The current retry count.
       * @returns {Promise<object|null>} The response JSON or null if an error persists.
       */
      async handle_request_err(error, req, retries) {
        var _a;
        error = error.error;
        if ((_a = error.message) == null ? void 0 : _a.includes("maximum context length is")) {
          const max_len = parseInt(error.message.split("length is ")[1].split("tokens")[0].trim());
          const requested_len = parseInt(error.message.split("requested")[1].split("tokens")[0].trim());
          console.log(`max context length: ${max_len}, requested: ${requested_len}`);
          const body = JSON.parse(req.body);
          const longest_len = Math.max(...body.input.map((item) => item.length));
          const longest_i = body.input.findIndex((i) => i.length === longest_len);
          const reduce_factor = (requested_len - max_len) / requested_len;
          body.input[longest_i] = body.input[longest_i].slice(0, Math.floor(reduce_factor * longest_len) - 500 * retries);
          console.log(`truncated input: ${body.input[longest_i].length}`);
          req.body = JSON.stringify(body);
          return await this.request(req, retries + 1);
        }
        if (error.status === 429 && retries < 3) {
          const backoff = Math.pow(retries + 1, 2);
          console.log(`Retrying request (429) in ${backoff} seconds...`);
          await new Promise((r) => setTimeout(r, 1e3 * backoff));
          return await this.request(req, retries + 1);
        }
        console.error(error);
        return null;
      }
    };
    exports2.ApiAdapter = ApiAdapter;
  }
});

// node_modules/smart-embed-model/adapters/local_api.js
var require_local_api = __commonJS({
  "node_modules/smart-embed-model/adapters/local_api.js"(exports2) {
    var { ApiAdapter } = require_api();
    var LocalApiAdapter = class extends ApiAdapter {
      async embed(input) {
        const resp = await this.embed_batch([{
          embed_input: input
        }]);
        return resp == null ? void 0 : resp[0];
      }
      async init() {
        this.endpoint = this.local_endpoint;
      }
      prepare_batch_input(items) {
        return items.map((item) => {
          return {
            embed_input: this.prepare_embed_input(item.embed_input)
          };
        });
      }
      parse_embedding_output(embed_inputs, embedding, i) {
        return embedding;
      }
      prepare_request_body(input) {
        return {
          model_config: this.main.config,
          input
        };
      }
      prepare_request_headers() {
        return {
          "Content-Type": "application/json"
        };
      }
      is_error(resp) {
        return resp == null ? void 0 : resp.error;
      }
      parse_response(resp) {
        return resp;
      }
    };
    exports2.LocalApiAdapter = LocalApiAdapter;
  }
});

// node_modules/smart-embed-model/adapters/transformers.js
var require_transformers = __commonJS({
  "node_modules/smart-embed-model/adapters/transformers.js"(exports2) {
    var { Adapter } = require_adapter();
    var TransformersAdapter = class extends Adapter {
      async init() {
        const { env, pipeline, AutoTokenizer } = await import("@xenova/transformers");
        env.allowLocalModels = false;
        this.model = await pipeline("feature-extraction", this.model_name, { quantized: true, max_length: this.max_tokens });
        this.tokenizer = await AutoTokenizer.from_pretrained(this.model_name);
      }
      async embed_batch(items) {
        items = items.filter((item) => {
          var _a;
          return ((_a = item.embed_input) == null ? void 0 : _a.length) > 0;
        });
        if (!(items == null ? void 0 : items.length))
          return [];
        const tokens = await Promise.all(items.map((item) => this.count_tokens(item.embed_input)));
        const embed_input = await Promise.all(items.map(async (item, i) => {
          if (tokens[i] < this.max_tokens)
            return item.embed_input;
          let token_ct = tokens[i];
          let truncated_input = item.embed_input;
          while (token_ct > this.max_tokens) {
            const pct = this.max_tokens / token_ct;
            const max_chars = Math.floor(truncated_input.length * pct * 0.9);
            truncated_input = truncated_input.substring(0, max_chars) + "...";
            token_ct = await this.count_tokens(truncated_input);
          }
          tokens[i] = token_ct;
          return truncated_input;
        }));
        try {
          const resp2 = await this.model(embed_input, { pooling: "mean", normalize: true });
          return items.map((item, i) => {
            item.vec = Array.from(resp2[i].data);
            item.tokens = tokens[i];
            return item;
          });
        } catch (err) {
          console.log(err);
          console.log("Error embedding batch. Trying one at a time...");
        }
        const resp = await Promise.all(items.map(async (item) => {
          const { vec, tokens: tokens2, error } = await this.embed(item.embed_input);
          if (error) {
            console.log("Error embedding item: ", item.key);
            console.log(error);
            item.error = error;
            return item;
          }
          if (!vec) {
            console.log("Error embedding item: ", item.key);
            console.log("Vec: ", vec);
            console.log("Error: ", error);
            console.log("Tokens: ", tokens2);
            console.log("No vec returned");
            item.error = "No vec returned";
            return item;
          }
          item.vec = vec.map((val) => Math.round(val * 1e8) / 1e8);
          item.tokens = tokens2;
          return item;
        }));
        return resp;
      }
      async embed(input) {
        const output = { embed_input: input };
        if (!input)
          return { ...output, error: "No input text." };
        if (!this.model)
          await this.init();
        try {
          output.tokens = await this.count_tokens(input);
          if (output.tokens < 1)
            return { ...output, error: "Input too short." };
          if (output.tokens < this.max_tokens) {
            const embedding = await this.model(input, { pooling: "mean", normalize: true });
            output.vec = Array.from(embedding.data).map((val) => Math.round(val * 1e8) / 1e8);
          } else {
            const pct = this.max_tokens / output.tokens;
            const max_chars = Math.floor(input.length * pct * 0.95);
            input = input.substring(0, max_chars) + "...";
            output.truncated = true;
            console.log("Input too long. Truncating to ", input.length, " characters.");
            const { vec, tokens } = await this.embed(input);
            output.vec = vec;
            output.tokens = tokens;
          }
          return output;
        } catch (err) {
          console.log(err);
          return { ...output, error: err.message };
        }
      }
      async count_tokens(text) {
        if (!this.tokenizer)
          await this.init();
        const { input_ids } = await this.tokenizer(text);
        return input_ids.data.length;
      }
    };
    exports2.TransformersAdapter = TransformersAdapter;
  }
});

// node_modules/smart-embed-model/web_connector.json
var require_web_connector = __commonJS({
  "node_modules/smart-embed-model/web_connector.json"(exports2, module2) {
    module2.exports = {
      script: 'var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === "object" || typeof from === "function") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. "__esModule" has not been set), then set\n  // "default" to the CommonJS "module.exports" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,\n  mod\n));\n\n// adapters/adapter.js\nvar require_adapter = __commonJS({\n  "adapters/adapter.js"(exports) {\n    var Adapter = class {\n      /**\n       * Constructs an instance of Adapter.\n       * @param {object} main - The main context object which should contain a configuration object.\n       */\n      constructor(main) {\n        this.main = main;\n        Object.assign(this, main.config);\n      }\n    };\n    exports.Adapter = Adapter;\n  }\n});\n\n// adapters/transformers.js\nvar require_transformers = __commonJS({\n  "adapters/transformers.js"(exports) {\n    var { Adapter } = require_adapter();\n    var TransformersAdapter = class extends Adapter {\n      async init() {\n        const { env, pipeline, AutoTokenizer } = await import("@xenova/transformers");\n        env.allowLocalModels = false;\n        this.model = await pipeline("feature-extraction", this.model_name, { quantized: true, max_length: this.max_tokens });\n        this.tokenizer = await AutoTokenizer.from_pretrained(this.model_name);\n      }\n      async embed_batch(items) {\n        items = items.filter((item) => {\n          var _a;\n          return ((_a = item.embed_input) == null ? void 0 : _a.length) > 0;\n        });\n        if (!(items == null ? void 0 : items.length))\n          return [];\n        const tokens = await Promise.all(items.map((item) => this.count_tokens(item.embed_input)));\n        const embed_input = await Promise.all(items.map(async (item, i) => {\n          if (tokens[i] < this.max_tokens)\n            return item.embed_input;\n          let token_ct = tokens[i];\n          let truncated_input = item.embed_input;\n          while (token_ct > this.max_tokens) {\n            const pct = this.max_tokens / token_ct;\n            const max_chars = Math.floor(truncated_input.length * pct * 0.9);\n            truncated_input = truncated_input.substring(0, max_chars) + "...";\n            token_ct = await this.count_tokens(truncated_input);\n          }\n          tokens[i] = token_ct;\n          return truncated_input;\n        }));\n        try {\n          const resp2 = await this.model(embed_input, { pooling: "mean", normalize: true });\n          return items.map((item, i) => {\n            item.vec = Array.from(resp2[i].data);\n            item.tokens = tokens[i];\n            return item;\n          });\n        } catch (err) {\n          console.log(err);\n          console.log("Error embedding batch. Trying one at a time...");\n        }\n        const resp = await Promise.all(items.map(async (item) => {\n          const { vec, tokens: tokens2, error } = await this.embed(item.embed_input);\n          if (error) {\n            console.log("Error embedding item: ", item.key);\n            console.log(error);\n            item.error = error;\n            return item;\n          }\n          if (!vec) {\n            console.log("Error embedding item: ", item.key);\n            console.log("Vec: ", vec);\n            console.log("Error: ", error);\n            console.log("Tokens: ", tokens2);\n            console.log("No vec returned");\n            item.error = "No vec returned";\n            return item;\n          }\n          item.vec = vec.map((val) => Math.round(val * 1e8) / 1e8);\n          item.tokens = tokens2;\n          return item;\n        }));\n        return resp;\n      }\n      async embed(input) {\n        const output = { embed_input: input };\n        if (!input)\n          return { ...output, error: "No input text." };\n        if (!this.model)\n          await this.init();\n        try {\n          output.tokens = await this.count_tokens(input);\n          if (output.tokens < 1)\n            return { ...output, error: "Input too short." };\n          if (output.tokens < this.max_tokens) {\n            const embedding = await this.model(input, { pooling: "mean", normalize: true });\n            output.vec = Array.from(embedding.data).map((val) => Math.round(val * 1e8) / 1e8);\n          } else {\n            const pct = this.max_tokens / output.tokens;\n            const max_chars = Math.floor(input.length * pct * 0.95);\n            input = input.substring(0, max_chars) + "...";\n            output.truncated = true;\n            console.log("Input too long. Truncating to ", input.length, " characters.");\n            const { vec, tokens } = await this.embed(input);\n            output.vec = vec;\n            output.tokens = tokens;\n          }\n          return output;\n        } catch (err) {\n          console.log(err);\n          return { ...output, error: err.message };\n        }\n      }\n      async count_tokens(text) {\n        if (!this.tokenizer)\n          await this.init();\n        const { input_ids } = await this.tokenizer(text);\n        return input_ids.data.length;\n      }\n    };\n    exports.TransformersAdapter = TransformersAdapter;\n  }\n});\n\n// transformers_iframe.js\nvar require_transformers_iframe = __commonJS({\n  "transformers_iframe.js"(exports) {\n    var { TransformersAdapter } = require_transformers();\n    var TransformersIframeConnector = class _TransformersIframeConnector extends TransformersAdapter {\n      constructor(model_config, window2) {\n        super({ config: model_config });\n        this.model = null;\n        this.running_init = false;\n        this.window = window2;\n        this.embed_ct = 0;\n        this.timestamp = null;\n        this.tokens = 0;\n      }\n      static async create(model_config, window2) {\n        const connector = new _TransformersIframeConnector(model_config, window2);\n        await connector.init();\n        return connector;\n      }\n      async init() {\n        if (this.model)\n          return console.log("Smart Local Model already loaded");\n        if (this.running_init)\n          await new Promise((resolve) => setTimeout(resolve, 3e3));\n        if (!this.model && !this.running_init)\n          this.running_init = true;\n        console.log("Loading Smart Local Model");\n        const { pipeline, env, AutoTokenizer } = await import("https://cdn.jsdelivr.net/npm/@xenova/transformers@latest");\n        env.allowLocalModels = false;\n        this.model = await pipeline("feature-extraction", this.model_name, { quantized: true });\n        this.tokenizer = await AutoTokenizer.from_pretrained(this.model_name);\n        this.running_init = false;\n        this.window.tokenizer = this.tokenizer;\n        console.log(await this.embed("test"));\n        this.window.parent.postMessage({ type: "model_loaded", data: true }, "*");\n        this.window.addEventListener("message", this.handle_ipc.bind(this), false);\n      }\n      async handle_ipc(event) {\n        if (event.data.type == "smart_embed")\n          this.embed_handler(event.data);\n        if (event.data.type == "smart_embed_token_ct")\n          this.count_tokens_handler(event.data.embed_input);\n      }\n      async embed_handler(event_data) {\n        const { embed_input, handler_id } = event_data;\n        if (!this.timestamp)\n          this.timestamp = Date.now();\n        if (Array.isArray(embed_input)) {\n          const resp = await this.embed_batch(embed_input);\n          const send_data = {\n            type: "smart_embed_resp",\n            handler_id,\n            data: resp\n          };\n          this.window.postMessage(send_data, "*");\n          this.tokens += resp.reduce((acc, item) => acc + item.tokens, 0);\n          this.embed_ct += resp.length;\n        } else {\n          if (!this.timestamp)\n            this.timestamp = Date.now();\n          const send_data = await this.embed(embed_input);\n          send_data.type = "smart_embed_resp";\n          if (handler_id)\n            send_data.handler_id = handler_id;\n          this.window.postMessage(send_data, "*");\n          this.tokens += send_data.tokens;\n          this.embed_ct++;\n        }\n        if (Date.now() - this.timestamp > 1e4) {\n          console.log(`Embedded: ${this.embed_ct} inputs (${this.tokens} tokens, ${(this.tokens / ((Date.now() - this.timestamp) / 1e3)).toFixed(0)} tokens/sec)`);\n          this.timestamp = null;\n          this.tokens = 0;\n          this.embed_ct = 0;\n        }\n      }\n      async count_tokens_handler(input) {\n        const output = await this.count_tokens(input);\n        const send_data = {\n          type: "smart_embed_token_ct",\n          text: "count:" + input,\n          count: output\n        };\n        this.window.postMessage(send_data, "*");\n      }\n    };\n    exports.TransformersIframeConnector = TransformersIframeConnector;\n  }\n});\n\n// smart_embed_web.js\nwindow.addEventListener("message", init);\nasync function init(event) {\n  if (event.data.type === "init") {\n    window.removeEventListener("message", init);\n    const model_config = event.data.model_config;\n    console.log(model_config);\n    const { TransformersIframeConnector } = await Promise.resolve().then(() => __toESM(require_transformers_iframe()));\n    const model = await TransformersIframeConnector.create(model_config, window);\n    window.model = model;\n  }\n}\n//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiYWRhcHRlcnMvYWRhcHRlci5qcyIsICJhZGFwdGVycy90cmFuc2Zvcm1lcnMuanMiLCAidHJhbnNmb3JtZXJzX2lmcmFtZS5qcyIsICJzbWFydF9lbWJlZF93ZWIuanMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8qKlxuICogUmVwcmVzZW50cyBhIGdlbmVyaWMgYWRhcHRlciBjbGFzcyB0aGF0IGluaXRpYWxpemVzIHdpdGggYSBtYWluIGNvbnRleHQgYW5kIGNvcGllcyBpdHMgY29uZmlndXJhdGlvbi5cbiAqL1xuY2xhc3MgQWRhcHRlciB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGFuIGluc3RhbmNlIG9mIEFkYXB0ZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBtYWluIC0gVGhlIG1haW4gY29udGV4dCBvYmplY3Qgd2hpY2ggc2hvdWxkIGNvbnRhaW4gYSBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG1haW4pIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbWFpbiBjb250ZXh0IG9iamVjdCBmcm9tIHdoaWNoIGNvbmZpZ3VyYXRpb24gaXMgZGVyaXZlZC5cbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMubWFpbiA9IG1haW47XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgcHJvcGVydGllcyBmcm9tIHRoZSBtYWluIG9iamVjdCdzIGNvbmZpZyBwcm9wZXJ0eSB0byB0aGlzIGluc3RhbmNlLlxuICAgICAqL1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgbWFpbi5jb25maWcpOyAvLyBDb3B5IGNvbmZpZyB0byB0aGlzXG4gIH1cbn1cblxuLy8gRXhwb3J0IHRoZSBBZGFwdGVyIGNsYXNzIHRvIGJlIGF2YWlsYWJsZSBmb3Igb3RoZXIgbW9kdWxlcy5cbmV4cG9ydHMuQWRhcHRlciA9IEFkYXB0ZXI7XG4iLCAiY29uc3QgeyBBZGFwdGVyIH0gPSByZXF1aXJlKFwiLi9hZGFwdGVyXCIpO1xuXG5jbGFzcyBUcmFuc2Zvcm1lcnNBZGFwdGVyIGV4dGVuZHMgQWRhcHRlciB7XG4gIGFzeW5jIGluaXQoKSB7XG4gICAgY29uc3QgeyBlbnYsIHBpcGVsaW5lLCBBdXRvVG9rZW5pemVyIH0gPSBhd2FpdCBpbXBvcnQoJ0B4ZW5vdmEvdHJhbnNmb3JtZXJzJyk7XG4gICAgZW52LmFsbG93TG9jYWxNb2RlbHMgPSBmYWxzZTtcbiAgICB0aGlzLm1vZGVsID0gYXdhaXQgcGlwZWxpbmUoJ2ZlYXR1cmUtZXh0cmFjdGlvbicsIHRoaXMubW9kZWxfbmFtZSwgeyBxdWFudGl6ZWQ6IHRydWUsIG1heF9sZW5ndGg6IHRoaXMubWF4X3Rva2VucyB9KTtcbiAgICAvLyB0aGlzLm1vZGVsID0gYXdhaXQgcGlwZWxpbmUoJ2ZlYXR1cmUtZXh0cmFjdGlvbicsIHRoaXMubW9kZWxfbmFtZSwgeyBxdWFudGl6ZWQ6IGZhbHNlIH0pO1xuICAgIHRoaXMudG9rZW5pemVyID0gYXdhaXQgQXV0b1Rva2VuaXplci5mcm9tX3ByZXRyYWluZWQodGhpcy5tb2RlbF9uYW1lKTtcbiAgfVxuICBhc3luYyBlbWJlZF9iYXRjaChpdGVtcykge1xuICAgIGl0ZW1zID0gaXRlbXMuZmlsdGVyKGl0ZW0gPT4gaXRlbS5lbWJlZF9pbnB1dD8ubGVuZ3RoID4gMCk7IC8vIHJlbW92ZSBpdGVtcyB3aXRoIGVtcHR5IGVtYmVkX2lucHV0IChjYXVzZXMgLnNwbGl0KCkgZXJyb3IpXG4gICAgaWYoIWl0ZW1zPy5sZW5ndGgpIHJldHVybiBbXTtcbiAgICBjb25zdCB0b2tlbnMgPSBhd2FpdCBQcm9taXNlLmFsbChpdGVtcy5tYXAoaXRlbSA9PiB0aGlzLmNvdW50X3Rva2VucyhpdGVtLmVtYmVkX2lucHV0KSkpO1xuICAgIGNvbnN0IGVtYmVkX2lucHV0ID0gYXdhaXQgUHJvbWlzZS5hbGwoaXRlbXMubWFwKGFzeW5jIChpdGVtLCBpKSA9PiB7XG4gICAgICBpZiAodG9rZW5zW2ldIDwgdGhpcy5tYXhfdG9rZW5zKSByZXR1cm4gaXRlbS5lbWJlZF9pbnB1dDtcbiAgICAgIGxldCB0b2tlbl9jdCA9IHRva2Vuc1tpXTtcbiAgICAgIGxldCB0cnVuY2F0ZWRfaW5wdXQgPSBpdGVtLmVtYmVkX2lucHV0O1xuICAgICAgd2hpbGUgKHRva2VuX2N0ID4gdGhpcy5tYXhfdG9rZW5zKSB7XG4gICAgICAgIGNvbnN0IHBjdCA9IHRoaXMubWF4X3Rva2VucyAvIHRva2VuX2N0OyAvLyBnZXQgcGN0IG9mIGlucHV0IHRvIGtlZXBcbiAgICAgICAgY29uc3QgbWF4X2NoYXJzID0gTWF0aC5mbG9vcih0cnVuY2F0ZWRfaW5wdXQubGVuZ3RoICogcGN0ICogMC45MCk7IC8vIGdldCBudW1iZXIgb2YgY2hhcmFjdGVycyB0byBrZWVwIChtaW51cyAxMCUgZm9yIHNhZmV0eSlcbiAgICAgICAgdHJ1bmNhdGVkX2lucHV0ID0gdHJ1bmNhdGVkX2lucHV0LnN1YnN0cmluZygwLCBtYXhfY2hhcnMpICsgXCIuLi5cIjtcbiAgICAgICAgdG9rZW5fY3QgPSBhd2FpdCB0aGlzLmNvdW50X3Rva2Vucyh0cnVuY2F0ZWRfaW5wdXQpO1xuICAgICAgfVxuICAgICAgLy8gY29uc29sZS5sb2coXCJJbnB1dCB0b28gbG9uZy4gVHJ1bmNhdGluZyB0byBcIiwgdHJ1bmNhdGVkX2lucHV0Lmxlbmd0aCwgXCIgY2hhcmFjdGVycy5cIik7XG4gICAgICAvLyBjb25zb2xlLmxvZyhcIlRva2VuczogXCIsIHRva2Vuc1tpXSwgXCIgLT4gXCIsIHRva2VuX2N0KTtcbiAgICAgIHRva2Vuc1tpXSA9IHRva2VuX2N0O1xuICAgICAgcmV0dXJuIHRydW5jYXRlZF9pbnB1dDtcbiAgICB9KSk7XG5cbiAgICAvLyBjb25zb2xlLmxvZyhlbWJlZF9pbnB1dCk7XG4gICAgdHJ5e1xuICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IHRoaXMubW9kZWwoZW1iZWRfaW5wdXQsIHsgcG9vbGluZzogJ21lYW4nLCBub3JtYWxpemU6IHRydWUgfSk7XG4gICAgICAvLyBjb25zb2xlLmxvZyhyZXNwKTtcbiAgICAgIHJldHVybiBpdGVtcy5tYXAoKGl0ZW0sIGkpID0+IHtcbiAgICAgICAgaXRlbS52ZWMgPSBBcnJheS5mcm9tKHJlc3BbaV0uZGF0YSk7XG4gICAgICAgIGl0ZW0udG9rZW5zID0gdG9rZW5zW2ldO1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH0pO1xuICAgIH1jYXRjaChlcnIpe1xuICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiRXJyb3IgZW1iZWRkaW5nIGJhdGNoLiBUcnlpbmcgb25lIGF0IGEgdGltZS4uLlwiKTtcbiAgICB9XG4gICAgY29uc3QgcmVzcCA9IGF3YWl0IFByb21pc2UuYWxsKGl0ZW1zLm1hcChhc3luYyBpdGVtID0+IHtcbiAgICAgIGNvbnN0IHsgdmVjLCB0b2tlbnMsIGVycm9yIH0gPSBhd2FpdCB0aGlzLmVtYmVkKGl0ZW0uZW1iZWRfaW5wdXQpO1xuICAgICAgaWYoZXJyb3Ipe1xuICAgICAgICBjb25zb2xlLmxvZyhcIkVycm9yIGVtYmVkZGluZyBpdGVtOiBcIiwgaXRlbS5rZXkpO1xuICAgICAgICBjb25zb2xlLmxvZyhlcnJvcik7XG4gICAgICAgIGl0ZW0uZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9XG4gICAgICBpZighdmVjKXtcbiAgICAgICAgY29uc29sZS5sb2coXCJFcnJvciBlbWJlZGRpbmcgaXRlbTogXCIsIGl0ZW0ua2V5KTtcbiAgICAgICAgY29uc29sZS5sb2coXCJWZWM6IFwiLCB2ZWMpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIkVycm9yOiBcIiwgZXJyb3IpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIlRva2VuczogXCIsIHRva2Vucyk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiTm8gdmVjIHJldHVybmVkXCIpO1xuICAgICAgICBpdGVtLmVycm9yID0gXCJObyB2ZWMgcmV0dXJuZWRcIjtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9XG4gICAgICBpdGVtLnZlYyA9IHZlYy5tYXAodmFsID0+IE1hdGgucm91bmQodmFsICogMTAwMDAwMDAwKSAvIDEwMDAwMDAwMCk7IC8vIHJlZHVjZSBwcmVjaXNpb24gdG8gOCBkZWNpbWFsIHBsYWNlcyByZWY6IGh0dHBzOi8vd2ZoYnJpYW4uY29tL3ZlY3Rvci1kaW1lbnNpb24tcHJlY2lzaW9uLWVmZmVjdC1vbi1jb3NpbmUtc2ltaWxhcml0eS9cbiAgICAgIGl0ZW0udG9rZW5zID0gdG9rZW5zO1xuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfSkpO1xuICAgIHJldHVybiByZXNwO1xuICB9XG4gIGFzeW5jIGVtYmVkKGlucHV0KSB7XG4gICAgY29uc3Qgb3V0cHV0ID0geyBlbWJlZF9pbnB1dDogaW5wdXQgfTtcbiAgICBpZiAoIWlucHV0KSByZXR1cm4geyAuLi5vdXRwdXQsIGVycm9yOiBcIk5vIGlucHV0IHRleHQuXCIgfTtcbiAgICBpZiAoIXRoaXMubW9kZWwpIGF3YWl0IHRoaXMuaW5pdCgpO1xuICAgIHRyeSB7XG4gICAgICBvdXRwdXQudG9rZW5zID0gYXdhaXQgdGhpcy5jb3VudF90b2tlbnMoaW5wdXQpO1xuICAgICAgaWYgKG91dHB1dC50b2tlbnMgPCAxKSByZXR1cm4geyAuLi5vdXRwdXQsIGVycm9yOiBcIklucHV0IHRvbyBzaG9ydC5cIiB9O1xuICAgICAgaWYgKG91dHB1dC50b2tlbnMgPCB0aGlzLm1heF90b2tlbnMpIHtcbiAgICAgICAgY29uc3QgZW1iZWRkaW5nID0gYXdhaXQgdGhpcy5tb2RlbChpbnB1dCwgeyBwb29saW5nOiAnbWVhbicsIG5vcm1hbGl6ZTogdHJ1ZSB9KTtcbiAgICAgICAgb3V0cHV0LnZlYyA9IEFycmF5LmZyb20oZW1iZWRkaW5nLmRhdGEpLm1hcCh2YWwgPT4gTWF0aC5yb3VuZCh2YWwgKiAxMDAwMDAwMDApIC8gMTAwMDAwMDAwKTsgLy8gcmVkdWNlIHByZWNpc2lvbiB0byA4IGRlY2ltYWwgcGxhY2VzIHJlZjogaHR0cHM6Ly93Zmhicmlhbi5jb20vdmVjdG9yLWRpbWVuc2lvbi1wcmVjaXNpb24tZWZmZWN0LW9uLWNvc2luZS1zaW1pbGFyaXR5L1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcGN0ID0gdGhpcy5tYXhfdG9rZW5zIC8gb3V0cHV0LnRva2VuczsgLy8gZ2V0IHBjdCBvZiBpbnB1dCB0byBrZWVwXG4gICAgICAgIGNvbnN0IG1heF9jaGFycyA9IE1hdGguZmxvb3IoaW5wdXQubGVuZ3RoICogcGN0ICogMC45NSk7IC8vIGdldCBudW1iZXIgb2YgY2hhcmFjdGVycyB0byBrZWVwIChtaW51cyA1JSBmb3Igc2FmZXR5KVxuICAgICAgICBpbnB1dCA9IGlucHV0LnN1YnN0cmluZygwLCBtYXhfY2hhcnMpICsgXCIuLi5cIjtcbiAgICAgICAgb3V0cHV0LnRydW5jYXRlZCA9IHRydWU7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiSW5wdXQgdG9vIGxvbmcuIFRydW5jYXRpbmcgdG8gXCIsIGlucHV0Lmxlbmd0aCwgXCIgY2hhcmFjdGVycy5cIik7XG4gICAgICAgIGNvbnN0IHsgdmVjLCB0b2tlbnMgfSA9IGF3YWl0IHRoaXMuZW1iZWQoaW5wdXQpO1xuICAgICAgICBvdXRwdXQudmVjID0gdmVjO1xuICAgICAgICBvdXRwdXQudG9rZW5zID0gdG9rZW5zO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICByZXR1cm4geyAuLi5vdXRwdXQsIGVycm9yOiBlcnIubWVzc2FnZSB9O1xuICAgIH1cbiAgfVxuICBhc3luYyBjb3VudF90b2tlbnModGV4dCkge1xuICAgIGlmICghdGhpcy50b2tlbml6ZXIpIGF3YWl0IHRoaXMuaW5pdCgpO1xuICAgIGNvbnN0IHsgaW5wdXRfaWRzIH0gPSBhd2FpdCB0aGlzLnRva2VuaXplcih0ZXh0KTtcbiAgICByZXR1cm4gaW5wdXRfaWRzLmRhdGEubGVuZ3RoOyAvLyBSZXR1cm4gdGhlIG51bWJlciBvZiB0b2tlbnNcbiAgfVxufVxuXG5leHBvcnRzLlRyYW5zZm9ybWVyc0FkYXB0ZXIgPSBUcmFuc2Zvcm1lcnNBZGFwdGVyOyIsICJjb25zdCB7IFRyYW5zZm9ybWVyc0FkYXB0ZXIgfSA9IHJlcXVpcmUoJy4vYWRhcHRlcnMvdHJhbnNmb3JtZXJzJyk7XG5cbi8vIENPTk5FQ1RPUiBGT1IgT0JTSURJQU5cbmNsYXNzIFRyYW5zZm9ybWVyc0lmcmFtZUNvbm5lY3RvciBleHRlbmRzIFRyYW5zZm9ybWVyc0FkYXB0ZXIge1xuICBjb25zdHJ1Y3Rvcihtb2RlbF9jb25maWcsIHdpbmRvdykge1xuICAgIHN1cGVyKHtjb25maWc6IG1vZGVsX2NvbmZpZ30pOyAvLyBhc3NpZ25zIGNvbmZpZyB0byB0aGlzIGluIEFkYXB0ZXJcbiAgICB0aGlzLm1vZGVsID0gbnVsbDtcbiAgICB0aGlzLnJ1bm5pbmdfaW5pdCA9IGZhbHNlO1xuICAgIHRoaXMud2luZG93ID0gd2luZG93O1xuICAgIC8vIHN0YXRzXG4gICAgdGhpcy5lbWJlZF9jdCA9IDA7XG4gICAgdGhpcy50aW1lc3RhbXAgPSBudWxsO1xuICAgIHRoaXMudG9rZW5zID0gMDtcbiAgfVxuICBzdGF0aWMgYXN5bmMgY3JlYXRlKG1vZGVsX2NvbmZpZywgd2luZG93KSB7XG4gICAgY29uc3QgY29ubmVjdG9yID0gbmV3IFRyYW5zZm9ybWVyc0lmcmFtZUNvbm5lY3Rvcihtb2RlbF9jb25maWcsIHdpbmRvdyk7XG4gICAgYXdhaXQgY29ubmVjdG9yLmluaXQoKTtcbiAgICByZXR1cm4gY29ubmVjdG9yO1xuICB9XG4gIGFzeW5jIGluaXQoKSB7XG4gICAgaWYgKHRoaXMubW9kZWwpIHJldHVybiBjb25zb2xlLmxvZyhcIlNtYXJ0IExvY2FsIE1vZGVsIGFscmVhZHkgbG9hZGVkXCIpO1xuICAgIGlmICh0aGlzLnJ1bm5pbmdfaW5pdCkgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDMwMDApKTtcbiAgICBpZiAoIXRoaXMubW9kZWwgJiYgIXRoaXMucnVubmluZ19pbml0KSB0aGlzLnJ1bm5pbmdfaW5pdCA9IHRydWU7XG4gICAgY29uc29sZS5sb2coXCJMb2FkaW5nIFNtYXJ0IExvY2FsIE1vZGVsXCIpO1xuICAgIC8vIGNvbnN0IHsgcGlwZWxpbmUsIGVudiwgQXV0b1Rva2VuaXplciB9ID0gYXdhaXQgaW1wb3J0KCdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B4ZW5vdmEvdHJhbnNmb3JtZXJzQDIuMTMuMCcpO1xuICAgIGNvbnN0IHsgcGlwZWxpbmUsIGVudiwgQXV0b1Rva2VuaXplciB9ID0gYXdhaXQgaW1wb3J0KCdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B4ZW5vdmEvdHJhbnNmb3JtZXJzQGxhdGVzdCcpO1xuICAgIGVudi5hbGxvd0xvY2FsTW9kZWxzID0gZmFsc2U7XG4gICAgdGhpcy5tb2RlbCA9IGF3YWl0IHBpcGVsaW5lKCdmZWF0dXJlLWV4dHJhY3Rpb24nLCB0aGlzLm1vZGVsX25hbWUsIHsgcXVhbnRpemVkOiB0cnVlIH0pO1xuICAgIHRoaXMudG9rZW5pemVyID0gYXdhaXQgQXV0b1Rva2VuaXplci5mcm9tX3ByZXRyYWluZWQodGhpcy5tb2RlbF9uYW1lKTtcbiAgICB0aGlzLnJ1bm5pbmdfaW5pdCA9IGZhbHNlO1xuICAgIHRoaXMud2luZG93LnRva2VuaXplciA9IHRoaXMudG9rZW5pemVyO1xuICAgIGNvbnNvbGUubG9nKGF3YWl0IHRoaXMuZW1iZWQoXCJ0ZXN0XCIpKTtcbiAgICB0aGlzLndpbmRvdy5wYXJlbnQucG9zdE1lc3NhZ2UoeyB0eXBlOiBcIm1vZGVsX2xvYWRlZFwiLCBkYXRhOiB0cnVlIH0sIFwiKlwiKTsgLy8gcG9zdCBtZXNzYWdlIHRvIHBhcmVudCB0aGF0IG1vZGVsIGlzIGxvYWRlZFxuICAgIHRoaXMud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMuaGFuZGxlX2lwYy5iaW5kKHRoaXMpLCBmYWxzZSk7XG4gIH1cbiAgYXN5bmMgaGFuZGxlX2lwYyhldmVudCkge1xuICAgIGlmIChldmVudC5kYXRhLnR5cGUgPT0gXCJzbWFydF9lbWJlZFwiKSB0aGlzLmVtYmVkX2hhbmRsZXIoZXZlbnQuZGF0YSk7XG4gICAgLy8gaWYgKGV2ZW50LmRhdGEudHlwZSA9PSBcInNtYXJ0X2VtYmVkX2JhdGNoXCIpIHRoaXMuZW1iZWRfYmF0Y2hfaGFuZGxlcihldmVudC5kYXRhLmVtYmVkX2lucHV0KTtcbiAgICBpZiAoZXZlbnQuZGF0YS50eXBlID09IFwic21hcnRfZW1iZWRfdG9rZW5fY3RcIikgdGhpcy5jb3VudF90b2tlbnNfaGFuZGxlcihldmVudC5kYXRhLmVtYmVkX2lucHV0KTtcbiAgfVxuICBhc3luYyBlbWJlZF9oYW5kbGVyKGV2ZW50X2RhdGEpIHtcbiAgICBjb25zdCB7IGVtYmVkX2lucHV0LCBoYW5kbGVyX2lkIH0gPSBldmVudF9kYXRhO1xuICAgIC8vIGNvbnNvbGUubG9nKGVtYmVkX2lucHV0KTtcbiAgICBpZighdGhpcy50aW1lc3RhbXApIHRoaXMudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICBpZihBcnJheS5pc0FycmF5KGVtYmVkX2lucHV0KSkge1xuICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IHRoaXMuZW1iZWRfYmF0Y2goZW1iZWRfaW5wdXQpO1xuICAgICAgY29uc3Qgc2VuZF9kYXRhID0ge1xuICAgICAgICB0eXBlOiBcInNtYXJ0X2VtYmVkX3Jlc3BcIixcbiAgICAgICAgaGFuZGxlcl9pZCxcbiAgICAgICAgZGF0YTogcmVzcCxcbiAgICAgIH07XG4gICAgICB0aGlzLndpbmRvdy5wb3N0TWVzc2FnZShzZW5kX2RhdGEsIFwiKlwiKTtcbiAgICAgIHRoaXMudG9rZW5zICs9IHJlc3AucmVkdWNlKChhY2MsIGl0ZW0pID0+IGFjYyArIGl0ZW0udG9rZW5zLCAwKTtcbiAgICAgIHRoaXMuZW1iZWRfY3QgKz0gcmVzcC5sZW5ndGg7XG4gICAgfWVsc2V7XG4gICAgICBpZiAoIXRoaXMudGltZXN0YW1wKSB0aGlzLnRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICBjb25zdCBzZW5kX2RhdGEgPSBhd2FpdCB0aGlzLmVtYmVkKGVtYmVkX2lucHV0KTtcbiAgICAgIHNlbmRfZGF0YS50eXBlID0gXCJzbWFydF9lbWJlZF9yZXNwXCI7XG4gICAgICBpZiAoaGFuZGxlcl9pZCkgc2VuZF9kYXRhLmhhbmRsZXJfaWQgPSBoYW5kbGVyX2lkO1xuICAgICAgdGhpcy53aW5kb3cucG9zdE1lc3NhZ2Uoc2VuZF9kYXRhLCBcIipcIik7XG4gICAgICB0aGlzLnRva2VucyArPSBzZW5kX2RhdGEudG9rZW5zO1xuICAgICAgdGhpcy5lbWJlZF9jdCsrO1xuICAgIH1cbiAgICBpZiAoRGF0ZS5ub3coKSAtIHRoaXMudGltZXN0YW1wID4gMTAwMDApIHtcbiAgICAgIGNvbnNvbGUubG9nKGBFbWJlZGRlZDogJHt0aGlzLmVtYmVkX2N0fSBpbnB1dHMgKCR7dGhpcy50b2tlbnN9IHRva2VucywgJHsodGhpcy50b2tlbnMgLyAoKERhdGUubm93KCkgLSB0aGlzLnRpbWVzdGFtcCkgLyAxMDAwKSkudG9GaXhlZCgwKX0gdG9rZW5zL3NlYylgKTtcbiAgICAgIHRoaXMudGltZXN0YW1wID0gbnVsbDtcbiAgICAgIHRoaXMudG9rZW5zID0gMDtcbiAgICAgIHRoaXMuZW1iZWRfY3QgPSAwO1xuICAgIH1cbiAgfVxuICBhc3luYyBjb3VudF90b2tlbnNfaGFuZGxlcihpbnB1dCkge1xuICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IHRoaXMuY291bnRfdG9rZW5zKGlucHV0KTtcbiAgICBjb25zdCBzZW5kX2RhdGEgPSB7XG4gICAgICB0eXBlOiBcInNtYXJ0X2VtYmVkX3Rva2VuX2N0XCIsXG4gICAgICB0ZXh0OiBcImNvdW50OlwiICsgaW5wdXQsXG4gICAgICBjb3VudDogb3V0cHV0XG4gICAgfTtcbiAgICB0aGlzLndpbmRvdy5wb3N0TWVzc2FnZShzZW5kX2RhdGEsIFwiKlwiKTtcbiAgfVxufVxuZXhwb3J0cy5UcmFuc2Zvcm1lcnNJZnJhbWVDb25uZWN0b3IgPSBUcmFuc2Zvcm1lcnNJZnJhbWVDb25uZWN0b3I7XG5cbiIsICJ3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGluaXQpOyAvLyBsaXN0ZW4gZm9yIGluaXQgbWVzc2FnZVxuYXN5bmMgZnVuY3Rpb24gaW5pdChldmVudCkge1xuICBpZiAoZXZlbnQuZGF0YS50eXBlID09PSAnaW5pdCcpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGluaXQpOyAvLyByZW1vdmUgdGhpcyBldmVudCBsaXN0ZW5lclxuICAgIGNvbnN0IG1vZGVsX2NvbmZpZyA9IGV2ZW50LmRhdGEubW9kZWxfY29uZmlnO1xuICAgIGNvbnNvbGUubG9nKG1vZGVsX2NvbmZpZyk7XG4gICAgY29uc3QgeyBUcmFuc2Zvcm1lcnNJZnJhbWVDb25uZWN0b3IgfSA9IGF3YWl0IGltcG9ydCgnLi90cmFuc2Zvcm1lcnNfaWZyYW1lLmpzJyk7XG4gICAgY29uc3QgbW9kZWwgPSBhd2FpdCBUcmFuc2Zvcm1lcnNJZnJhbWVDb25uZWN0b3IuY3JlYXRlKG1vZGVsX2NvbmZpZywgd2luZG93KTtcbiAgICB3aW5kb3cubW9kZWwgPSBtb2RlbDtcbiAgfVxufSJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFHQSxRQUFNLFVBQU4sTUFBYztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLWixZQUFZLE1BQU07QUFLaEIsYUFBSyxPQUFPO0FBS1osZUFBTyxPQUFPLE1BQU0sS0FBSyxNQUFNO0FBQUEsTUFDakM7QUFBQSxJQUNGO0FBR0EsWUFBUSxVQUFVO0FBQUE7QUFBQTs7O0FDdkJsQjtBQUFBO0FBQUEsUUFBTSxFQUFFLFFBQVEsSUFBSTtBQUVwQixRQUFNLHNCQUFOLGNBQWtDLFFBQVE7QUFBQSxNQUN4QyxNQUFNLE9BQU87QUFDWCxjQUFNLEVBQUUsS0FBSyxV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\n'
    };
  }
});

// node_modules/smart-embed-model/adapters/iframe.js
var require_iframe = __commonJS({
  "node_modules/smart-embed-model/adapters/iframe.js"(exports2) {
    var { Adapter } = require_adapter();
    var web_connector = require_web_connector();
    var IframeAdapter = class extends Adapter {
      constructor(main) {
        super(main);
        this.frame = null;
        this.output = {};
        this.response_handlers = {};
        this.web_script = web_connector.script;
      }
      unload() {
        console.log("SmartEmbedTransformersWebAdapter Unloading");
        this.remove_frame();
        this.frame = null;
        this.output = {};
        this.response_handlers = {};
      }
      async init() {
        if (!this.frame) {
          this.frame = document.createElement("iframe");
          this.frame.style.display = "none";
          this.frame.style.width = "0";
          this.frame.style.height = "0";
          this.frame_loaded = new Promise((resolve) => this.frame.onload = resolve);
          const model_loaded = new Promise((resolve) => {
            window.addEventListener("message", (event) => {
              if (event.data.type === "model_loaded") {
                console.log("Model Loaded: " + this.model_name);
                resolve();
              }
            }, { once: true, capture: false });
          });
          this.frame.srcdoc = this.iframe_script;
          this.container.appendChild(this.frame);
          await this.frame_loaded;
          this.frame.contentWindow.postMessage({ type: "init", model_config: { ...this.main.config, container: null } }, "*");
          await model_loaded;
          this.frame.contentWindow.addEventListener("message", this.handle_iframe_messages.bind(this), false);
        }
        console.log("SmartEmbedTransformersWebAdapter Connected");
      }
      request_embedding(embed_input, retries = 0) {
        if (!(embed_input == null ? void 0 : embed_input.length))
          return console.log("embed_input is empty");
        const handler_id = typeof embed_input === "string" ? embed_input : create_uid(embed_input);
        this.frame.contentWindow.postMessage({ type: "smart_embed", embed_input, handler_id }, "*");
        return new Promise((resolve, reject) => {
          this.response_handlers[handler_id] = ({ error, data }) => {
            if (error) {
              console.log(error);
              reject(error);
            } else {
              resolve(data);
            }
          };
          setTimeout(() => {
            if (this.response_handlers[handler_id]) {
              reject(new Error("Timeout waiting for response"));
              delete this.response_handlers[handler_id];
            }
          }, 6e4);
        });
      }
      async embed_batch(items) {
        items = items.filter((item) => {
          var _a;
          return ((_a = item.embed_input) == null ? void 0 : _a.length) > 0;
        });
        if (!(items == null ? void 0 : items.length))
          return [];
        const resp = await this.request_embedding(items.map((item) => ({ embed_input: item.embed_input })));
        return items.map((item, i) => {
          const resp_item = resp.data[i];
          item.vec = resp_item.vec;
          item.tokens = resp_item.tokens;
          return item;
        });
      }
      embed(input) {
        return this.request_embedding(input);
      }
      count_tokens(input, timeout = 6e4) {
        this.frame.contentWindow.postMessage({ type: "smart_embed_token_ct", embed_input: input }, "*");
        return new Promise((resolve, reject) => {
          this.response_handlers["count:" + input] = ({ error, data }) => {
            if (error) {
              console.log(error);
              reject(error);
            } else {
              resolve(data);
            }
          };
          setTimeout(() => {
            if (this.response_handlers["count:" + input]) {
              reject(new Error("Timeout waiting for response"));
              delete this.response_handlers["count:" + input];
            }
          }, timeout);
        });
      }
      get iframe_script() {
        return `<script type="module">${this.web_script}</script>`;
      }
      get is_embedding() {
        return Object.keys(this.response_handlers).length > 0;
      }
      get queue_length() {
        return Object.keys(this.response_handlers).length;
      }
      get container_id() {
        return this.model_name.replace(/[^a-z0-9]/gi, "_").toLowerCase();
      }
      remove_frame() {
        if (this.frame)
          this.frame.remove();
        const frame_check = this.container.querySelector("#" + this.container_id);
        if (frame_check)
          frame_check.remove();
        console.log("SmartEmbedTransformersWebAdapter Disconnected");
      }
      handle_iframe_messages(event) {
        if (event.data.type === "smart_embed_resp" || event.data.type === "smart_embed_token_ct") {
          const handler = this.response_handlers[event.data.handler_id || event.data.text];
          if (handler) {
            handler({ error: null, data: event.data });
            delete this.response_handlers[event.data.handler_id || event.data.text];
          }
        }
      }
    };
    exports2.IframeAdapter = IframeAdapter;
    function create_uid(data) {
      const str = JSON.stringify(data);
      let hash = 0;
      if (str.length === 0)
        return hash;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = (hash << 5) - hash + char;
        hash = hash & hash;
        if (hash < 0)
          hash = hash * -1;
      }
      return hash.toString() + str.length;
    }
  }
});

// node_modules/smart-embed-model/adapters.js
var require_adapters = __commonJS({
  "node_modules/smart-embed-model/adapters.js"(exports2) {
    var { ApiAdapter } = require_api();
    exports2.api = ApiAdapter;
    var { LocalApiAdapter } = require_local_api();
    exports2.local_api = LocalApiAdapter;
    var { TransformersAdapter } = require_transformers();
    exports2.transformers = TransformersAdapter;
    var { IframeAdapter } = require_iframe();
    exports2.iframe = IframeAdapter;
  }
});

// node_modules/smart-embed-model/models.json
var require_models = __commonJS({
  "node_modules/smart-embed-model/models.json"(exports2, module2) {
    module2.exports = {
      "TaylorAI/bge-micro-v2": {
        model_name: "TaylorAI/bge-micro-v2",
        batch_size: 1,
        dims: 384,
        max_tokens: 512,
        name: "BGE-micro-v2",
        description: "Local, 512 tokens, 384 dim",
        type: "huggingface-transformers"
      },
      "andersonbcdefg/bge-small-4096": {
        model_name: "andersonbcdefg/bge-small-4096",
        batch_size: 1,
        dims: 384,
        max_tokens: 4096,
        name: "BGE-small-4K",
        description: "Local, 4,096 tokens, 384 dim",
        type: "huggingface-transformers"
      },
      "Xenova/jina-embeddings-v2-base-zh-8192": {
        model_name: "Xenova/jina-embeddings-v2-base-zh",
        batch_size: 1,
        dims: 512,
        max_tokens: 8192,
        name: "Jina-v2-base-zh-8K",
        description: "Local, 8,192 tokens, 512 dim, Chinese/English bilingual",
        type: "huggingface-transformers"
      },
      "text-embedding-3-small": {
        model_name: "text-embedding-3-small",
        batch_size: 10,
        dims: 1536,
        max_tokens: 8191,
        name: "OpenAI Text-3 Small",
        description: "API, 8,191 tokens, 1,536 dim",
        endpoint: "https://api.openai.com/v1/embeddings",
        type: "openai"
      },
      "text-embedding-3-large": {
        model_name: "text-embedding-3-large",
        batch_size: 10,
        dims: 3072,
        max_tokens: 8191,
        name: "OpenAI Text-3 Large",
        description: "API, 8,191 tokens, 3,072 dim",
        endpoint: "https://api.openai.com/v1/embeddings",
        type: "openai"
      },
      "text-embedding-3-small-512": {
        model_name: "text-embedding-3-small",
        batch_size: 50,
        dims: 512,
        max_tokens: 8191,
        name: "OpenAI Text-3 Small - 512",
        description: "API, 8,191 tokens, 512 dim",
        endpoint: "https://api.openai.com/v1/embeddings",
        type: "openai"
      },
      "text-embedding-3-large-256": {
        model_name: "text-embedding-3-large",
        batch_size: 10,
        dims: 256,
        max_tokens: 8191,
        name: "OpenAI Text-3 Large - 256",
        description: "API, 8,191 tokens, 256 dim",
        endpoint: "https://api.openai.com/v1/embeddings",
        type: "openai"
      },
      "text-embedding-ada-002": {
        model_name: "text-embedding-ada-002",
        batch_size: 10,
        dims: 1536,
        max_tokens: 8191,
        name: "OpenAI Ada",
        description: "API, 8,191 tokens, 1,536 dim",
        endpoint: "https://api.openai.com/v1/embeddings",
        type: "openai"
      },
      "Xenova/jina-embeddings-v2-small-en": {
        model_name: "Xenova/jina-embeddings-v2-small-en",
        batch_size: 1,
        dims: 512,
        max_tokens: 8192,
        name: "Jina-v2-small-en",
        description: "Local, 8,192 tokens, 512 dim",
        type: "huggingface-transformers"
      },
      "nomic-ai/nomic-embed-text-v1.5-256": {
        model_name: "nomic-ai/nomic-embed-text-v1.5",
        batch_size: 1,
        dims: 256,
        max_tokens: 8192,
        name: "Nomic-embed-text-v1.5",
        description: "Local, 8,192 tokens, 256 dim",
        type: "huggingface-transformers"
      },
      "Xenova/bge-small-en-v1.5": {
        model_name: "Xenova/bge-small-en-v1.5",
        batch_size: 1,
        dims: 384,
        max_tokens: 512,
        name: "BGE-small",
        description: "Local, 512 tokens, 384 dim",
        type: "huggingface-transformers"
      },
      "nomic-ai/nomic-embed-text-v1": {
        model_name: "nomic-ai/nomic-embed-text-v1",
        batch_size: 1,
        dims: 768,
        max_tokens: 2048,
        name: "Nomic-embed-text",
        description: "Local, 2,048 tokens, 768 dim",
        type: "huggingface-transformers"
      }
    };
  }
});

// node_modules/smart-embed-model/smart_embed_model.js
var require_smart_embed_model = __commonJS({
  "node_modules/smart-embed-model/smart_embed_model.js"(exports2) {
    var adapters = require_adapters();
    var embed_models2 = require_models();
    var SmartEmbedModel = class {
      /**
       * Create a SmartEmbed instance.
       * @param {string} env - The environment to use.
       * @param {string|object} config - The model configuration key or the model configuration object.
       * expects model to contain at least a model_key
       */
      constructor(env, config) {
        this.env = env;
        if (config.model_key)
          this.config = { ...embed_models2[config.model_key], ...config };
        else
          this.config = { ...config };
        this.embed_ct = 0;
        this.timestamp = null;
        this.tokens = 0;
        if (this.config.adapter)
          this.adapter = new adapters[this.config.adapter](this);
        else
          this.adapter = new adapters["api"](this);
      }
      /**
       * Factory method to create a new SmartEmbed instance and initialize it.
       * @param {string} env - The environment to use.
       * @param {string} model_config - Full model configuration object or at least a model_key, api_key, and adapter
       * @returns {Promise<SmartEmbed>} A promise that resolves with an initialized SmartEmbed instance.
       */
      static async create(env, model_config) {
        const model = new this(env, model_config);
        if (model.adapter && typeof model.adapter.init === "function")
          await model.adapter.init();
        return model;
      }
      /**
       * Count the number of tokens in the input string.
       * @param {string} input - The input string to process.
       * @returns {Promise<number>} A promise that resolves with the number of tokens.
       */
      async count_tokens(input) {
        if (this.adapter && typeof this.adapter.count_tokens === "function") {
          return await this.adapter.count_tokens(input);
        }
      }
      /**
       * Embed the input string into a numerical array.
       * @param {string} input - The input string to embed.
       * @returns {Promise<number[]>} A promise that resolves with the embedding array.
       */
      async embed(input) {
        if (this.adapter && typeof this.adapter.embed === "function") {
          return await this.adapter.embed(input);
        }
      }
      /**
       * Embed a batch of input strings into arrays of numerical arrays.
       * @param {string[]} input - The array of strings to embed.
       * @returns {Promise<number[][]>} A promise that resolves with the array of embedding arrays.
       */
      async embed_batch(input) {
        if (this.adapter && typeof this.adapter.embed_batch === "function") {
          return await this.adapter.embed_batch(input);
        }
      }
      /**
       * Get the configured batch size for embedding.
       * @returns {number} The batch size.
       */
      get batch_size() {
        return this.config.batch_size;
      }
      /**
       * Get the dimensions of the embedding.
       * @returns {number} The dimensions of the embedding.
       */
      get dims() {
        return this.config.dims;
      }
      /**
       * Get the maximum number of tokens that can be processed.
       * @returns {number} The maximum number of tokens.
       */
      get max_tokens() {
        return this.config.max_tokens;
      }
      /**
       * Get the name of the model used for embedding.
       * @returns {string} The model name.
       */
      get model_name() {
        return this.config.model_name;
      }
    };
    exports2.SmartEmbedModel = SmartEmbedModel;
  }
});

// node_modules/smart-entities/smart_entities.js
var require_smart_entities = __commonJS({
  "node_modules/smart-entities/smart_entities.js"(exports2) {
    var { Collection } = require_Collection();
    var { CollectionItem } = require_CollectionItem();
    var { SmartEmbedModel } = require_smart_embed_model();
    var SmartEntities = class extends Collection {
      constructor(env) {
        super(env);
        this.env = env;
        this._pause_embeddings = false;
      }
      async _save() {
        await this.LTM._save();
      }
      // async b/c Obsidian API is async
      replacer(key, value) {
        if (value instanceof this.item_type) {
          if (!value.validate_save()) {
            console.log("Invalid block, skipping save: ", value.data);
            return void 0;
          }
          if (value.data.embedding.vec && value.data.text)
            value.data.text = void 0;
          return value.data;
        }
        return super.replacer(key, value);
      }
      unload() {
        var _a;
        if (typeof ((_a = this.smart_embed) == null ? void 0 : _a.unload) === "function") {
          this.smart_embed.unload();
          delete this.smart_embed;
        }
        if (this.smart_embed_container) {
          const iframe = this.smart_embed_container.querySelector("iframe");
          if (!iframe)
            return;
          iframe.srcdoc = "";
          iframe.parentNode.removeChild(iframe);
          this.smart_embed_container.remove();
        }
      }
      async load() {
        await this.LTM.load();
        console.log(this);
        console.log(this.env);
        await this.load_smart_embed();
      }
      async load_smart_embed() {
        var _a, _b;
        if (this.smart_embed_model === "None")
          return;
        if (this.env.smart_embed_active_models[this.smart_embed_model] instanceof SmartEmbedModel) {
          this.smart_embed = this.env.smart_embed_active_models[this.smart_embed_model];
          console.log("SmartEmbed already loaded for " + this.collection_name + ": Model: " + this.smart_embed_model);
        } else {
          const model = { model_key: this.smart_embed_model };
          if (this.smart_embed_model.includes("/")) {
            console.log(this.env.local_model_type);
            this.model_key = this.smart_embed_model;
            const local_max = this.env.config.local_embedding_max_tokens;
            if (local_max < model.max_tokens)
              model.max_tokens = local_max;
            console.log("Checking for local Smart Connect server...");
            try {
              const request_adapter = ((_a = this.env.main.obsidian) == null ? void 0 : _a.requestUrl) || null;
              const sc_local = !request_adapter ? await fetch("http://localhost:37421/") : await request_adapter({ url: "http://localhost:37421/", method: "GET" });
              if (sc_local.status === 200) {
                console.log("Local Smart Connect server found");
                this.smart_embed = await SmartEmbedModel.create(this.env, { ...model, request_adapter, adapter: "local_api", local_endpoint: "http://localhost:37421/embed_batch" });
                return;
              }
            } catch (err) {
              console.log("Could not connect to local Smart Connect server");
            }
            if (this.env.local_model_type === "Web") {
              this.model_key += "_web";
              if (this.smart_embed)
                console.log(`Existing WebAdapter for ${this.collection_name} model: ${this.smart_embed_model}`);
              else
                this.smart_embed = await SmartEmbedModel.create(this.env, { ...model, adapter: "iframe", container: this.smart_embed_container });
            } else {
              this.model_key += "_node";
              if (this.smart_embed)
                console.log(`Existing NodeAdapter for ${this.collection_name} model: ${this.smart_embed_model}`);
              else
                this.smart_embed = await SmartEmbedModel.create(this.env, { ...model, adapter: "transformers" });
            }
          } else {
            this.model_key += "_api";
            if (this.smart_embed)
              console.log(`Existing ApiAdapter for ${this.collection_name} model: ${this.smart_embed_model}`);
            else
              this.smart_embed = await SmartEmbedModel.create(this.env, { ...model, request_adapter: (_b = this.env.main.obsidian) == null ? void 0 : _b.requestUrl, api_key: this.config.api_key });
          }
        }
      }
      get smart_embed_container() {
        if (!this.model_key)
          return console.log("model_key not set");
        const id = this.model_key.replace(/[^a-zA-Z0-9]/g, "_");
        if (!window.document)
          return console.log("window.document not available");
        if (window.document.querySelector(`#${id}`))
          return window.document.querySelector(`#${id}`);
        const container = window.document.createElement("div");
        container.id = id;
        window.document.body.appendChild(container);
        return container;
      }
      get smart_embed() {
        var _a;
        return (_a = this.env.active_embed_models) == null ? void 0 : _a[this.model_key];
      }
      set smart_embed(val) {
        if (!this.model_key)
          this.model_key = val.model_name + "_" + val.constructor.name;
        if (!this.env.active_embed_models)
          this.env.active_embed_models = {};
        this.env.active_embed_models[this.model_key] = val;
      }
      pause_embedding() {
        this._pause_embeddings = true;
        this.env.main.notices.remove("embedding progress");
      }
      async ensure_embeddings(show_notice = null) {
        var _a, _b;
        console.log("ensure_embeddings");
        if (!this.smart_embed)
          return console.log("SmartEmbed not loaded for " + this.collection_name);
        const unembedded_items = this.unembedded_items;
        if (unembedded_items.length === 0)
          return true;
        console.log("unembedded_items: ", unembedded_items);
        const performance_notice_msg = "(This is a resource intensive operation)";
        if (show_notice !== false && unembedded_items.length > 30) {
          const start_btn = { text: "Start embedding", callback: () => this.ensure_embeddings(false) };
          this.env.main.notices.show("start embedding", [`Are you ready to begin embedding ${unembedded_items.length} ${this.collection_name}?`, performance_notice_msg], { timeout: 0, confirm: start_btn });
          return false;
        }
        if (this.is_embedding)
          return console.log("already embedding");
        this.is_embedding = true;
        const batch_size = this.smart_embed.batch_size;
        this.env.main.notices.remove("start embedding");
        let total_tokens = 0;
        let time_start = Date.now();
        let time_elapsed = 0;
        let tokens_per_sec = 0;
        for (let i = 0; i < unembedded_items.length; i += batch_size) {
          if (this._pause_embeddings) {
            this._pause_embeddings = false;
            const restart_btn = { text: "Restart", callback: () => this.ensure_embeddings() };
            this.env.main.notices.show("restart embedding", [`Embedding ${this.collection_name}...`, `Paused at ${i} / ${unembedded_items.length} ${this.collection_name}`, performance_notice_msg], { timeout: 0, button: restart_btn });
            this.LTM._save(true);
            this.is_embedding = false;
            return;
          }
          if (i % 10 === 0) {
            const pause_btn = { text: "Pause", callback: () => this.pause_embedding(), stay_open: true };
            this.env.main.notices.show("embedding progress", [`Embedding ${this.collection_name}...`, `Progress: ${i} / ${unembedded_items.length} ${this.collection_name}`, `${tokens_per_sec} tokens/sec`, performance_notice_msg], { timeout: 0, button: pause_btn, immutable: true });
          }
          const items = unembedded_items.slice(i, i + batch_size);
          await Promise.all(items.map(async (item) => await item.get_embed_input()));
          const resp = await this.smart_embed.embed_batch(items);
          items.forEach((item) => {
            item._embed_input = null;
            item.changed = true;
          });
          total_tokens += resp.reduce((acc, item) => acc + item.tokens, 0);
          time_elapsed = Date.now() - time_start;
          tokens_per_sec = Math.round(total_tokens / (time_elapsed / 1e3));
          if (i && i % 500 === 0) {
            await this.LTM._save();
          }
        }
        if ((_b = (_a = this.env.main._notice) == null ? void 0 : _a.noticeEl) == null ? void 0 : _b.parentElement)
          this.env.main._notice.hide();
        const embedded_ct = unembedded_items.filter((i) => i.vec).length;
        this.env.main.notices.remove("embedding progress");
        this.env.main.notices.show("done embedding", [`Embedding ${this.collection_name}...`, `Done creating ${embedded_ct} embeddings.`], { timeout: 1e4 });
        if (unembedded_items.length)
          this.LTM._save();
        this.is_embedding = false;
        return true;
      }
      get embedded_items() {
        return this.smart_embed ? Object.values(this.items).filter((i) => i.vec) : Object.values(this.items);
      }
      get unembedded_items() {
        return this.smart_embed ? Object.values(this.items).filter((item) => !item.vec) : [];
      }
      nearest(vec, filter = {}) {
        if (!vec)
          return console.log("no vec");
        const {
          // results_count = 20,
          results_count = 50
        } = filter;
        const nearest = this.filter(filter).reduce((acc, item) => {
          var _a;
          if (!((_a = item.data.embedding) == null ? void 0 : _a.vec))
            return acc;
          item.sim = cos_sim(vec, item.data.embedding.vec);
          top_acc(acc, item, results_count);
          return acc;
        }, { min: 0, items: /* @__PURE__ */ new Set() });
        return Array.from(nearest.items);
      }
      get file_name() {
        return this.collection_name + "-" + this.smart_embed_model.split("/").pop();
      }
      get smart_embed_model() {
        return this.config[this.collection_name + "_embed_model"];
      }
    };
    var SmartEntity = class extends CollectionItem {
      static get defaults() {
        return {
          data: {
            path: null,
            embedding: {}
          }
        };
      }
      get_key() {
        return this.data.path;
      }
      // DO: clarified/improved logic
      save() {
        this.collection.set(this);
        this.env.save();
      }
      get_nearest(filter = {}) {
      }
      async get_as_context(params = {}) {
        return `---BEGIN NOTE${params.i ? " " + params.i : ""} [[${this.path}]]---
${await this.get_content()}
---END NOTE${params.i ? " " + params.i : ""}---`;
      }
      async get_content() {
      }
      // override in child class
      async get_embed_input() {
      }
      // override in child class
      // getters
      get ajson() {
        return `${JSON.stringify(this.key)}: ${JSON.stringify(this.data)}`;
      }
      get embed_link() {
        return `![[${this.data.path}]]`;
      }
      get multi_ajson_file_name() {
        return this.path.split("#").shift().replace(/[^a-zA-Z0-9]/g, "_").replace(".md", "");
      }
      get name() {
        return (!this.env.main.settings.show_full_path ? this.path.split("/").pop() : this.path.split("/").join(" > ")).split("#").join(" > ").replace(".md", "");
      }
      get path() {
        return this.data.path;
      }
      get tokens() {
        return this.data.embedding.tokens;
      }
      get vec() {
        return this.data.embedding.vec;
      }
      // setters
      set error(error) {
        this.data.embedding.error = error;
      }
      set tokens(tokens) {
        this.data.embedding.tokens = tokens;
      }
      set vec(vec) {
        this.data.embedding.vec = vec;
      }
    };
    function cos_sim(vector1, vector2) {
      const dotProduct = vector1.reduce((acc, val, i) => acc + val * vector2[i], 0);
      const normA = Math.sqrt(vector1.reduce((acc, val) => acc + val * val, 0));
      const normB = Math.sqrt(vector2.reduce((acc, val) => acc + val * val, 0));
      return normA === 0 || normB === 0 ? 0 : dotProduct / (normA * normB);
    }
    function top_acc(_acc, item, ct = 10) {
      if (_acc.items.size < ct) {
        _acc.items.add(item);
      } else if (item.sim > _acc.min) {
        _acc.items.add(item);
        _acc.items.delete(_acc.minItem);
        _acc.minItem = Array.from(_acc.items).reduce((min, curr) => curr.sim < min.sim ? curr : min);
        _acc.min = _acc.minItem.sim;
      }
    }
    exports2.SmartEntity = SmartEntity;
    exports2.SmartEntities = SmartEntities;
    exports2.cos_sim = cos_sim;
    var SmartNotes = class extends SmartEntities {
      async import(files, opts = {}) {
        try {
          let batch = [];
          for (let i = 0; i < files.length; i++) {
            if (batch.length % 10 === 0) {
              this.env.main.notices.show("initial scan progress", [`Making Smart Connections...`, `Progress: ${i} / ${files.length} files`], { timeout: 0 });
              await Promise.all(batch);
              batch = [];
            }
            const note = this.get(files[i].path);
            if (!note)
              batch.push(this.create_or_update({ path: files[i].path }));
            if (note && note.meta_changed) {
              note.data.embedding = {};
              batch.push(this.create_or_update({ path: files[i].path }));
            }
          }
          await Promise.all(batch);
          this.env.main.notices.remove("initial scan progress");
          this.env.main.notices.show("done initial scan", [`Making Smart Connections...`, `Done importing Smart Notes.`], { timeout: 3e3 });
          this.ensure_embeddings();
        } catch (e) {
          console.log("error importing blocks");
          console.log(e);
        }
      }
      async ensure_embeddings(show_notice = false) {
        var _a;
        await super.ensure_embeddings(show_notice);
        await this.prune(true);
        if ((_a = this.env.smart_blocks) == null ? void 0 : _a.smart_embed) {
          await this.env.smart_blocks.ensure_embeddings({ show_notice });
          await this.env.smart_blocks.prune(true);
        }
      }
      async prune(override = false) {
        var _a;
        const remove = [];
        const items_w_vec = Object.entries(this.items).filter(([key, note]) => note.vec);
        const total_items_w_vec = items_w_vec.length;
        const available_notes = this.env.files.reduce((acc, file) => {
          acc[file.path] = true;
          return acc;
        }, {});
        if (!total_items_w_vec) {
          this.clear();
          return;
        }
        for (const [key, note] of items_w_vec) {
          if (!available_notes[note.data.path]) {
            remove.push(key);
            continue;
          }
          if (note.is_gone) {
            remove.push(key);
            continue;
          }
          if (note.meta_changed) {
            const content = await note.get_content();
            const hash = await create_hash(content);
            if (hash !== ((_a = note.last_history) == null ? void 0 : _a.hash)) {
              remove.push(key);
              continue;
            }
          }
        }
        console.log(remove);
        const remove_ratio = remove.length / total_items_w_vec;
        if (override && remove_ratio < 0.5 || confirm(`Are you sure you want to delete ${remove.length} (${Math.floor(remove_ratio * 100)}%) Note-level Embeddings?`)) {
          this.delete_many(remove);
          this.LTM._save(true);
          console.log(`Pruned ${remove.length} Smart Notes`);
        }
      }
      get current_note() {
        return this.get(this.env.main.app.workspace.getActiveFile().path);
      }
      get blocks() {
        this.env.smart_blocks.get_many(this.last_history.blocks);
      }
    };
    var SmartNote = class extends SmartEntity {
      static get defaults() {
        return {
          data: {
            history: []
            // array of { mtime, hash, length, blocks[] }
          },
          _embed_input: null
          // stored temporarily
        };
      }
      async init() {
        var _a;
        const content = await this.get_content();
        const hash = await create_hash(content);
        if (hash !== ((_a = this.last_history) == null ? void 0 : _a.hash)) {
          this.data.history.push({ blocks: {}, mtime: this.t_file.stat.mtime, size: this.t_file.stat.size, hash });
          this.data.embedding = {};
        } else {
          this.last_history.mtime = this.t_file.stat.mtime;
          this.last_history.size = this.t_file.stat.size;
        }
        this.env.smart_blocks.import(this, { show_notice: false });
      }
      async get_embed_input() {
        if (typeof this._embed_input === "string" && this._embed_input.length)
          return this._embed_input;
        const content = await this.get_content();
        const breadcrumbs = this.data.path.split("/").join(" > ").replace(".md", "");
        this._embed_input = `${breadcrumbs}:
${content}`;
        return this._embed_input;
      }
      find_connections() {
        let results = [];
        if (!this.vec && !this.median_block_vec) {
          const start_embedding_btn = {
            text: "Start embedding",
            callback: () => {
              this.collection.import().then(() => this.env.main.view.render_nearest(this));
            }
          };
          this.env.main.notices.show("no embedding found", `No embeddings found for ${this.name}.`, { confirm: start_embedding_btn });
          return results;
        }
        if (this.vec && this.median_block_vec && this.env.smart_blocks.smart_embed && this.collection.smart_embed) {
          const nearest_blocks = this.env.smart_blocks.nearest(this.median_block_vec, { exclude_key_starts_with: this.key });
          const nearest_notes = this.env.smart_notes.nearest(this.vec, { exclude_key_starts_with: this.key });
          results = nearest_blocks.map((block) => {
            const note = nearest_notes.find((note2) => note2.key === block.note_key);
            if (!note)
              block.score = block.sim;
            else
              block.score = (block.sim + note.sim) / 2;
            return block;
          }).sort((a, b) => {
            if (a.score === b.score)
              return 0;
            return a.score > b.score ? -1 : 1;
          });
        } else if (this.median_block_vec && this.env.smart_blocks.smart_embed) {
          const nearest_blocks = this.env.smart_blocks.nearest(this.median_block_vec, { exclude_key_starts_with: this.key });
          results = nearest_blocks.map((block) => {
            var _a;
            if (!((_a = block.note) == null ? void 0 : _a.median_block_vec.length)) {
              block.score = block.sim;
              return block;
            }
            block.score = (block.sim + cos_sim(this.median_block_vec, block.note.median_block_vec)) / 2;
            return block;
          }).sort((a, b) => {
            if (a.score === b.score)
              return 0;
            return a.score > b.score ? -1 : 1;
          });
        } else if (this.vec && this.collection.smart_embed) {
          const nearest_notes = this.env.smart_notes.nearest(this.vec, { exclude_key_starts_with: this.key });
          results = nearest_notes.map((note) => {
            note.score = note.sim;
            return note;
          }).sort((a, b) => {
            if (a.score === b.score)
              return 0;
            return a.score > b.score ? -1 : 1;
          });
        }
        return results;
      }
      open() {
        this.env.main.open_note(this.data.path);
      }
      get_block_by_line(line) {
        return this.blocks.find((block) => block.data.lines[0] <= line && block.data.lines[1] >= line);
      }
      get block_vecs() {
        return this.blocks.map((block) => block.data.embedding.vec).filter((vec) => vec);
      }
      // filter out blocks without vec
      get blocks() {
        return Object.keys(this.last_history.blocks).map((block_key) => this.env.smart_blocks.get(block_key)).filter((block) => block);
      }
      // filter out blocks that don't exist
      get embed_input() {
        return this._embed_input ? this._embed_input : this.get_embed_input();
      }
      get meta_changed() {
        if (!this.last_history)
          return true;
        return this.last_history.mtime !== this.t_file.stat.mtime && this.last_history.size !== this.t_file.stat.size;
      }
      get is_canvas() {
        return this.data.path.endsWith("canvas");
      }
      get is_excalidraw() {
        return this.data.path.endsWith("excalidraw.md");
      }
      get is_gone() {
        return this.t_file === null;
      }
      get last_history() {
        return this.data.history.length ? this.data.history[this.data.history.length - 1] : null;
      }
      get mean_block_vec() {
        return this._mean_block_vec ? this._mean_block_vec : this._mean_block_vec = this.block_vecs.reduce((acc, vec) => acc.map((val, i) => val + vec[i]), Array(384).fill(0)).map((val) => val / this.block_vecs.length);
      }
      get median_block_vec() {
        var _a;
        return this._median_block_vec ? this._median_block_vec : this._median_block_vec = (_a = this.block_vecs[0]) == null ? void 0 : _a.map((val, i) => this.block_vecs.map((vec) => vec[i]).sort()[Math.floor(this.block_vecs.length / 2)]);
      }
      get note_name() {
        return this.path.split("/").pop().replace(".md", "");
      }
      get t_file() {
        return this.env.get_tfile(this.data.path);
      }
    };
    var SmartBlocks = class extends SmartEntities {
      async import(note) {
        try {
          const note_path = note.data.path;
          const note_content = await note.get_content();
          const { blocks } = this.env.smart_markdown.parse({ content: note_content, file_path: note_path });
          blocks.forEach((block) => {
            const item = this.create_or_update(block);
            note.last_history.blocks[item.key] = true;
          });
        } catch (e) {
          console.log("error parsing blocks for note: ", note.key);
          console.log(e);
        }
      }
      async prune(override = false) {
        const remove = [];
        const total_items_w_vec = this.embedded_items.length;
        if (!total_items_w_vec) {
          return;
        }
        for (const [key, block] of Object.entries(this.items)) {
          if (block.is_gone)
            remove.push(key);
        }
        const remove_ratio = remove.length / total_items_w_vec;
        if (override && remove_ratio < 0.5 || confirm(`Are you sure you want to delete ${remove.length} (${Math.floor(remove_ratio * 100)}%) Block-level embeddings?`)) {
          this.delete_many(remove);
          if (!override)
            this.LTM._save(true);
        }
        console.log(`Pruned ${remove.length} SmartBlocks.`);
      }
    };
    var SmartBlock = class extends SmartEntity {
      static get defaults() {
        return {
          data: {
            text: null,
            // hash: null,
            length: 0
          },
          _embed_input: ""
          // stored temporarily
        };
      }
      // SmartChunk: text, length, path
      update_data(data) {
        var _a;
        if (!this.is_new) {
          if (this.data.length !== data.length)
            this.data.embedding = {};
        }
        if (!((_a = this.data.embedding) == null ? void 0 : _a.vec))
          this._embed_input += data.text;
        delete data.text;
        super.update_data(data);
        return true;
      }
      init() {
        if (!this.note)
          return console.log({ "no note for block": this.data });
        if (Array.isArray(this.note.last_history.blocks))
          this.note.last_history.blocks = {};
        this.note.last_history.blocks[this.key] = true;
      }
      async get_content() {
        var _a;
        const note_content = await ((_a = this.note) == null ? void 0 : _a.get_content());
        if (!note_content)
          return null;
        const block_content = this.env.smart_markdown.get_block_from_path(this.data.path, note_content);
        return block_content;
      }
      async get_embed_input() {
        if (typeof this._embed_input === "string" && this._embed_input.length)
          return this._embed_input;
        this._embed_input = this.breadcrumbs + "\n" + await this.get_content();
        return this._embed_input;
      }
      async get_next_k_shot(i) {
        if (!this.next_block)
          return null;
        const current = await this.get_content();
        const next = await this.next_block.get_content();
        return `---BEGIN CURRENT ${i}---
${current}
---END CURRENT ${i}---
---BEGIN NEXT ${i}---
${next}
---END NEXT ${i}---
`;
      }
      find_connections() {
        if (!this.vec)
          return [];
        return this.env.smart_blocks.nearest(this.vec, { exclude_key_starts_with: this.note.key });
      }
      get breadcrumbs() {
        return this.data.path.split("/").join(" > ").split("#").join(" > ").replace(".md", "");
      }
      get embed_input() {
        return this._embed_input ? this._embed_input : this.get_embed_input();
      }
      get lines() {
        return { start: this.data.lines[0], end: this.data.lines[1] };
      }
      get folder() {
        return this.data.path.split("/").slice(0, -1).join("/");
      }
      get is_block() {
        this.data.path.includes("#");
      }
      get is_gone() {
        if (this.env.smart_notes.unembedded_items.length)
          return false;
        if (!this.note)
          return true;
        if (this.note.is_gone)
          return true;
        if (!this.note.last_history.blocks[this.key])
          return true;
        return false;
      }
      // use text length to detect changes
      get name() {
        return (!this.env.main.settings.show_full_path ? this.data.path.split("/").pop() : this.data.path.split("/").join(" > ")).split("#").join(" > ").replace(".md", "");
      }
      // uses data.lines to get next block
      get next_block() {
        var _a;
        if (!this.data.lines)
          return null;
        const next_line = this.data.lines[1] + 1;
        return (_a = this.note.blocks) == null ? void 0 : _a.find((block) => {
          var _a2, _b;
          return next_line === ((_b = (_a2 = block.data) == null ? void 0 : _a2.lines) == null ? void 0 : _b[0]);
        });
      }
      get note() {
        return this.env.smart_notes.get(this.note_key);
      }
      get note_key() {
        return this.data.path.split("#")[0];
      }
      get note_name() {
        return this.note_key.split("/").pop().replace(".md", "");
      }
      // backwards compatibility (DEPRECATED)
      get link() {
        return this.data.path;
      }
    };
    async function create_hash(text) {
      const msgUint8 = new TextEncoder().encode(text.trim());
      const hashBuffer = await crypto.subtle.digest("SHA-256", msgUint8);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      const hashHex = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
      return hashHex;
    }
    exports2.SmartBlock = SmartBlock;
    exports2.SmartBlocks = SmartBlocks;
    exports2.SmartNote = SmartNote;
    exports2.SmartNotes = SmartNotes;
  }
});

// src/render_dataview_codeblocks.js
var require_render_dataview_codeblocks = __commonJS({
  "src/render_dataview_codeblocks.js"(exports2) {
    async function render_dataview_codeblocks(file_content, note_path, opts = {}) {
      opts = {
        char_limit: null,
        ...opts
      };
      const dataview_api = window == null ? void 0 : window["DataviewAPI"];
      if (!dataview_api)
        return file_content;
      if (!file_content)
        return file_content;
      const dataview_code_blocks = file_content.match(/```dataview(.*?)```/gs);
      if (!dataview_code_blocks)
        return file_content;
      for (let i = 0; i < dataview_code_blocks.length; i++) {
        if (opts.char_limit && opts.char_limit < file_content.indexOf(dataview_code_blocks[i]))
          break;
        const dataview_code_block = dataview_code_blocks[i];
        const dataview_code_block_content = dataview_code_block.replace("```dataview", "").replace("```", "");
        const dataview_query_result = await dataview_api.queryMarkdown(dataview_code_block_content, note_path, null);
        if (dataview_query_result.successful) {
          file_content = file_content.replace(dataview_code_block, dataview_query_result.value);
        }
      }
      return file_content;
    }
    exports2.render_dataview_codeblocks = render_dataview_codeblocks;
  }
});

// src/sc_entities.js
var require_sc_entities = __commonJS({
  "src/sc_entities.js"(exports2) {
    var {
      SmartBlock: BaseSmartBlock,
      SmartBlocks,
      SmartNote: BaseSmartNote,
      SmartNotes
    } = require_smart_entities();
    var { render_dataview_codeblocks } = require_render_dataview_codeblocks();
    var SmartNote = class extends BaseSmartNote {
      async get_content() {
        return await this.brain.cached_read(this.data.path);
      }
      async get_as_context(params = {}) {
        const content = await render_dataview_codeblocks(await this.get_content(), this.data.path);
        return `---BEGIN NOTE${params.i ? " " + params.i : ""} [[${this.path}]]---
${content}
---END NOTE${params.i ? " " + params.i : ""}---`;
      }
    };
    var SmartBlock = class extends BaseSmartBlock {
      async get_as_context(params = {}) {
        const content = await render_dataview_codeblocks(await this.get_content(), this.data.path);
        return `---BEGIN NOTE${params.i ? " " + params.i : ""} [[${this.path}]]---
${content}
---END NOTE${params.i ? " " + params.i : ""}---`;
      }
    };
    exports2.SmartNotes = SmartNotes;
    exports2.SmartNote = SmartNote;
    exports2.SmartBlocks = SmartBlocks;
    exports2.SmartBlock = SmartBlock;
  }
});

// src/smart_socket.js
var require_smart_socket = __commonJS({
  "src/smart_socket.js"(exports2) {
    var SmartSocket = class {
      /**
       * Creates an instance of SmartSocket.
       * @param {number} port The port number to connect to.
       */
      constructor(port) {
        this.port = port;
        this.ws_retries = 0;
        this.ws = null;
        this.retry = false;
      }
      /**
       * Initiates the connection process, with optional retry logic.
       * @param {boolean} [retry=false] Whether to attempt a reconnection.
       */
      async connect(retry = false) {
        this.retry = retry;
        if (!this.can_attempt_connection(retry))
          return;
        if (retry)
          await this.calculate_backoff(retry);
        if (typeof this.is_server_running === "function") {
          const is_running = await this.is_server_running();
          if (!is_running) {
            console.log("Smart Connect is not running, will try to connect again later");
            this.connect(true);
            return;
          }
        }
        try {
          await this.initialize_websocket();
        } catch (err) {
          if (retry && (this.ws_retries < 10 || typeof this.is_server_running === "function")) {
            await this.handle_connection_error(true, err);
          } else {
            this.on_fail_to_reconnect();
          }
        }
      }
      /**
       * Checks if a new connection attempt can be made.
       * @param {boolean} retry Indicates if this is a retry attempt.
       * @returns {boolean} True if a connection attempt can be made, false otherwise.
       */
      can_attempt_connection(retry) {
        retry = retry || this.retry;
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
          console.log("WebSocket is already connected. Aborting new connection attempt.");
          return false;
        }
        if (retry && this.ws_retries >= 10) {
          console.error("Failed to reconnect after 10 attempts");
          this.on_fail_to_reconnect();
          return false;
        }
        return true;
      }
      /**
       * Calculates and applies a backoff delay for reconnection attempts.
       * @param {boolean} retry Indicates if this is a retry attempt.
       * @returns {Promise<void>} A promise that resolves after the backoff delay.
       */
      calculate_backoff(retry) {
        if (retry || this.retry) {
          this.ws_retries += 1;
          const backoff_time = Math.min(1e3 * Math.pow(2, this.ws_retries), 6e4);
          console.log(`Attempting to reconnect in ${backoff_time / 1e3} seconds...`);
          return new Promise((resolve) => setTimeout(resolve, backoff_time));
        }
        return Promise.resolve();
      }
      /**
       * Initializes the WebSocket connection.
       * @returns {Promise<void>} A promise that resolves when the WebSocket is successfully opened.
       */
      async initialize_websocket() {
        this.cleanup_websocket();
        await new Promise((resolve, reject) => {
          const timeout_id = setTimeout(() => {
            var _a;
            if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
              (_a = this.ws) == null ? void 0 : _a.close();
              reject(new Error("WebSocket failed to connect"));
            }
          }, 1e4);
          this.ws = new WebSocket(`ws://localhost:${this.port}`);
          this.ws.onopen = () => {
            clearTimeout(timeout_id);
            this.on_open();
            this.ws_retries = 0;
            this.retry = true;
            resolve();
          };
          this.ws.onclose = (event) => {
            this.cleanup_websocket();
            reject(new Error("WebSocket closed"));
            this.on_close();
          };
          this.ws.onerror = (err) => {
            this.cleanup_websocket();
            reject(err);
            this.on_error(err);
          };
          this.ws.onmessage = this.handle_message.bind(this);
        });
      }
      cleanup_websocket() {
        if (this.ws) {
          this.ws.onopen = null;
          this.ws.onclose = null;
          this.ws.onerror = null;
          this.ws.onmessage = null;
          if (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING) {
            this.ws.close();
          }
          this.ws = null;
        }
      }
      /**
       * Handles connection errors and decides whether to retry.
       * @param {boolean} retry Indicates if this is a retry attempt.
       * @param {Error} err The error that occurred during connection.
       */
      async handle_connection_error(retry, err) {
        console.log("Handling WebSocket connection error on port " + this.port);
        if (retry && this.ws_retries < 10) {
          await this.connect(true);
        } else if (!retry || this.ws_retries >= 10) {
          console.error("Failed to connect to WebSocket after retries:");
          console.log(err);
          this.on_fail_to_reconnect();
        }
      }
      /**
       * Placeholder for error handling logic.
       * @param {Error} err The error encountered.
       */
      on_error(err) {
      }
      /**
       * Handles WebSocket closure and attempts reconnection.
       */
      on_close() {
        console.log("Disconnected from WebSocket");
        if (this.retry && this.should_attempt_reconnect) {
          this.connect(true);
        } else {
          console.log("Reconnection not attempted due to policy (intentional disconnection or retry limit reached).");
        }
      }
      get should_attempt_reconnect() {
        return this.ws_retries < 10;
      }
      /**
       * Logs successful WebSocket connection.
       */
      on_open() {
        console.log(`Connected to WebSocket on port ${this.port}`);
      }
      /**
       * Handles incoming WebSocket messages.
       * @param {MessageEvent} event The message event.
       */
      handle_message(event) {
        console.log("Message from server", event.data);
      }
      /**
       * Handles failure to reconnect after multiple attempts.
       */
      on_fail_to_reconnect() {
        console.error("Failed to reconnect, will not retry...");
      }
      /**
       * Closes the WebSocket connection.
       */
      unload() {
        this.cleanup_websocket();
      }
    };
    exports2.SmartSocket = SmartSocket;
  }
});

// src/dataview_socket.js
var require_dataview_socket = __commonJS({
  "src/dataview_socket.js"(exports2) {
    var { SmartSocket } = require_smart_socket();
    var DataviewSocket = class extends SmartSocket {
      constructor(env, port) {
        super(port);
        this.env = env;
        this.brain = this.env;
        this.dataview_api = null;
      }
      static async create(env, port) {
        const smart_socket = new DataviewSocket(env, port);
        env.dv_ws = smart_socket;
        await smart_socket.init();
        return smart_socket;
      }
      async init() {
        await this.get_dataview_api();
        await this.connect();
      }
      async is_server_running() {
        var _a;
        try {
          const sc_local = await ((_a = this.env.main.obsidian) == null ? void 0 : _a.requestUrl({ url: "http://localhost:37421/", method: "GET" }));
          console.log(sc_local);
          return (sc_local == null ? void 0 : sc_local.status) === 200;
        } catch (err) {
          return false;
        }
      }
      async get_dataview_api(retries = 0) {
        this.dataview_api = window["DataviewAPI"];
        if (!this.dataview_api) {
          if (retries < 10) {
            await new Promise((resolve) => setTimeout(resolve, retries * 1e3));
            return this.get_dataview_api(retries + 1);
          } else {
            this.brain.main.show_notice("Dataview API not found");
          }
        }
      }
      async handle_message(event) {
        console.log("Message from server ", event.data);
        console.log(typeof event.data);
        const data = JSON.parse(event.data);
        try {
          const resp = await this.dataview_api.queryMarkdown(data.query, data.rel_path, null);
          console.log(resp);
          this.ws.send(JSON.stringify(resp));
        } catch (err) {
          console.error(err);
          this.ws.send(JSON.stringify({ status: "error", message: err }));
        }
      }
    };
    exports2.DataviewSocket = DataviewSocket;
  }
});

// build/views.json
var require_views = __commonJS({
  "build/views.json"(exports2, module2) {
    module2.exports = {
      attribution: '<div class="sc-brand">\n  <svg viewBox="0 0 100 100" class="svg-icon smart-connections">\n    <path d="M50,20 L80,40 L80,60 L50,100" stroke="currentColor" stroke-width="4" fill="none"></path>\n    <path d="M30,50 L55,70" stroke="currentColor" stroke-width="5" fill="none"></path>\n    <circle cx="50" cy="20" r="9" fill="currentColor"></circle>\n    <circle cx="80" cy="40" r="9" fill="currentColor"></circle>\n    <circle cx="80" cy="70" r="9" fill="currentColor"></circle>\n    <circle cx="50" cy="100" r="9" fill="currentColor"></circle>\n    <circle cx="30" cy="50" r="9" fill="currentColor"></circle>\n  </svg>\n  <p><a style="font-weight: 700;" href="https://smartconnections.app/">Smart Connections</a></p>\n</div>',
      sc_change: '<div class="sc-change">\n  <div class="actions">\n    <button>Accept</button>\n    <button>Reject</button>\n    <button>Show Old</button>\n    <button style="display: none;">Hide Old</button>\n    <div>Time saved: <%= time_saved %></div>\n    <%- this.attribution %>\n  </div>\n  <div class="old-content" style="display: none;"></div>\n  <div class="new-content"></div>\n</div>\n\n',
      smart_chat: `<div class="workspace-leaf-content" data-type="smart-connections-chat-view">
  <div class="sc-chat-container">
    <div class="sc-top-bar-container">
      <input class="sc-chat-name-input" type="text" value="<%= name %>" placeholder="Chat Name">
      <button title="Open Conversation Note"><%- this.get_icon('external-link') %></button>
      <button title="Chat History"><%- this.get_icon('history') %></button>
      <button title="Settings"><%- this.get_icon('gear') %></button>
      <button title="New Chat"><%- this.get_icon('plus') %></button>
    </div>
    <div class="sc-chat-box">
      <div class="sc-message-container">
        <div class="sc-message assistant">
          <div class="sc-message-content">
            <span>
              Hi there, welcome to the Smart Chat.&nbsp;Ask me a question about your notes and I'll try to answer it.
            </span>
          </div>
        </div>
        <%- messages %>
      </div>
    </div>
    <div class="sc-chat-form"><textarea class="sc-chat-input"
        placeholder="Try &quot;Based on my notes&quot; or &quot;Summarize [[this note]]&quot; or &quot;Important tasks in /folder/&quot;"></textarea>
      <div class="sc-button-container">
        <span id="sc-abort-button" style="display: none;"><%- this.get_icon('square') %></span>
        <button class="send-button" id="sc-send-button">Send</button>
      </div>
    </div>
    <div id="settings"></div>
  </div>
  <%- this.attribution %>
</div>`,
      smart_chat_msg: `<div class="sc-message <%= role %>">
  <div class="sc-message-content" data-content="<%= content %>">
    <span><%= content %></span>
    <span class="sc-msg-button" title="Copy message to clipboard"><%- this.get_icon('copy') %></span>
    <!-- TODO: Copy context to clipboard (icon: eye) -->
    <!-- TODO: Copy prompt to clipboard (icon: files) -->
  </div>
</div>`,
      smart_chat_settings: '<div class="setting-component"\n  data-name="Model Platform"\n  data-setting="chat_model_platform_key"\n  data-type="dropdown"\n  data-description="Select a model platform to use with Smart Chat."\n  <%- chat_platforms.map((platform, i) => `data-option-${i + 1}="${platform.key}|${platform.description}"`).join(\'\\n\') %>\n  data-callback="changed_smart_chat_model"\n></div>\n<% if(chat_platform?.fetch_models) { %>\n  <% if(settings[settings.chat_model_platform_key]?.api_key) { %>\n    <div class="setting-component"\n      data-name="Model Name"\n      data-type="dropdown"\n      data-setting="<%= settings.chat_model_platform_key %>.model_name"\n      data-callback="changed_smart_chat_model"\n      <%- platform_chat_models.map((model, i) => `data-option-${i}="${model.key}|${model.model_name} (${model.description})"`).join(\'\\n\') %>\n    ></div>\n  <% } %>\n  <% if(!platform_chat_models.length) { %>\n    <div class="setting-component"\n      data-name="Refresh Models List"\n      data-type="button"\n      data-callback="changed_smart_chat_model"\n    ></div>\n  <% } %>\n  <div class="setting-component"\n    data-name="<%= chat_platform.description %> API Key"\n    data-type="text"\n    data-setting="<%= settings.chat_model_platform_key %>.api_key"\n    <% if(chat_platform.signup_url) { %>\n      data-description="<a href=\'<%= chat_platform.signup_url %>\'>Get API Key</a> for <%= chat_platform.description %>."\n    <% } else { %>\n      data-description="API Key for <%= chat_platform.description %>."\n    <% } %>\n    data-placeholder="Enter an API Key"\n    data-button="Save"\n    data-callback="test_chat_api_key"\n  ></div>\n<% } %>\n<% if (settings.chat_model_platform_key.startsWith(\'custom_local\')) { %>\n  <h3>Custom Local Model</h3>\n  <div class="setting-component"\n    data-name="Model Name"\n    data-type="text"\n    data-setting="custom_local.model_name"\n    data-description="Name of the custom model."\n    data-placeholder="Enter a model name"\n    data-callback="changed_smart_chat_model"\n  ></div>\n  <div class="setting-component"\n    data-name="protocol"\n    data-type="text"\n    data-setting="custom_local.protocol"\n    data-description="Protocol for chat server (http or https)."\n    data-placeholder="Enter a protocol"\n    data-callback="changed_smart_chat_model"\n  ></div>\n  <div class="setting-component"\n    data-name="hostname"\n    data-type="text"\n    data-setting="custom_local.hostname"\n    data-description="Host for local chat server."\n    data-placeholder="Enter a host"\n    data-callback="changed_smart_chat_model"\n  ></div>\n  <div class="setting-component"\n    data-name="port"\n    data-type="number"\n    data-setting="custom_local.port"\n    data-description="Port for local chat server."\n    data-placeholder="Enter a port number"\n    data-callback="changed_smart_chat_model"\n  ></div>\n  <div class="setting-component"\n    data-name="path"\n    data-type="text"\n    data-setting="custom_local.path"\n    data-description="Path for local chat server."\n    data-placeholder="Enter a path"\n    data-callback="changed_smart_chat_model"\n  ></div>\n  <div class="setting-component"\n    data-name="streaming"\n    data-type="toggle"\n    data-setting="custom_local.streaming"\n    data-description="Enable streaming for local chat server. Disable if you are getting CORS errors."\n    data-callback="changed_smart_chat_model"\n  ></div>\n  <div class="setting-component"\n    data-name="Max input tokens"\n    data-description="Maximum number of tokens for input to the model."\n    data-type="number"\n    data-setting="custom_local.max_input_tokens"\n    data-placeholder="Enter a number"\n    data-callback="changed_smart_chat_model"\n  ></div>\n<% } else if(settings.chat_model_platform_key.startsWith(\'custom_api\')) { %>\n  <h3>Custom Server</h3>\n  <div class="setting-component"\n    data-name="Model Name"\n    data-type="text"\n    data-setting="custom_api.model_name"\n    data-description="Name of the custom model."\n    data-placeholder="Enter a model name"\n    data-callback="changed_smart_chat_model"\n  ></div>\n  <div class="setting-component"\n    data-name="protocol"\n    data-type="text"\n    data-setting="custom_api.protocol"\n    data-description="Protocol for chat server (http or https)."\n    data-placeholder="Enter a protocol"\n    data-callback="changed_smart_chat_model"\n  ></div>\n  <div class="setting-component"\n    data-name="hostname"\n    data-type="text"\n    data-setting="custom_api.hostname"\n    data-description="Host for chat server."\n    data-placeholder="Enter a host"\n    data-callback="changed_smart_chat_model"\n  ></div>\n  <div class="setting-component"\n    data-name="path"\n    data-type="text"\n    data-setting="custom_api.path"\n    data-description="Path for chat server."\n    data-placeholder="Enter a path"\n    data-callback="changed_smart_chat_model"\n  ></div>\n  <div class="setting-component"\n    data-name="streaming"\n    data-type="toggle"\n    data-setting="custom_api.streaming"\n    data-description="Enable streaming for chat server. Disable if you are getting CORS errors."\n    data-callback="changed_smart_chat_model"\n  ></div>\n  <div class="setting-component"\n    data-name="Max input tokens"\n    data-description="Maximum number of tokens for input to the model."\n    data-type="number"\n    data-setting="custom_api.max_input_tokens"\n    data-placeholder="Enter a number"\n    data-callback="changed_smart_chat_model"\n  ></div>\n  <div class="setting-component"\n    data-name="API Key"\n    data-type="text"\n    data-setting="custom_api.api_key"\n    data-description="API Key for the custom server sent as a header (bearer token)."\n    data-placeholder="Enter an API Key"\n    data-button="Save"\n    data-callback="test_chat_api_key"\n  ></div>\n<% } %>',
      smart_chat_system_msg: '<div class="sc-<%= role %>">\n  <div class="" data-content="<%= content %>">\n    <span><%= content %></span>\n  </div>\n</div>',
      smart_connections: `<div class="sc-top-bar">
  <p class="sc-context">
    <%- current_path %>
    <%- this.notes %> (<%- this.blocks %>)
  </p>
  <button class="sc-fold-all"><%- this.get_icon('fold-vertical') %></button>
  <button class="sc-unfold-all"><%- this.get_icon('unfold-vertical') %></button>
  <button class="sc-search-button" style="display: none;"><%- this.get_icon('search') %></button>
  <button title="Settings"><%- this.get_icon('gear') %></button>
</div>
<div class="sc-list">
  <% for (let result of results) { %>
  <div class="search-result<%- !this.settings.expanded_view ? ' sc-collapsed' : '' %>" data-path="<%- result.path %>">
    <span class="header">
      <%- this.get_icon('right-triangle') %>
      <a class="search-result-file-title" title="<%- result.path %>" draggable="true">
        <small><%- [result.score?.toFixed(2), result.name].join(' | ') %></small>
      </a>
    </span>
    <ul draggable="true">
      <li class="search-result-file-title" title="<%- result.path %>" data-collection="<%= result.collection_name %>"></li>
    </ul>
  </div>
  <% } %>
</div>
<div id="settings"></div>
<%- this.attribution %>`,
      smart_embed_settings: `<div class="setting-component"
  data-name="Notes Embedding Model"
  data-setting="smart_notes_embed_model"
  data-type="dropdown"
  data-description="Select a model to use for embedding your notes."
  <%- embedding_models.map((model, i) => \`data-option-\${i + 1}="\${model.key}|\${model.name} (\${model.description})"\`).join('\\n') %>
  data-callback="restart_plugin"
></div>
<div class="setting-component"
  data-name="Blocks Embedding Model"
  data-setting="smart_blocks_embed_model"
  data-type="dropdown"
  data-description="Select a model to use for embedding your blocks."
  data-option-0="None|None"
  <%- embedding_models.map((model, i) => \`data-option-\${i + 1}="\${model.key}|\${model.name} (\${model.description})"\`).join('\\n') %>
  data-callback="restart_plugin"
></div>
<div class="setting-component"
  data-name="Minimum Embedding Length"
  data-description="Minimum length of note to embed."
  data-type="number"
  data-setting="embed_input_min_chars"
  data-placeholder="Enter a number"
  data-callback="reload_env"
></div>
<% if(!settings.smart_notes_embed_model.includes('/') || !settings.smart_blocks_embed_model.includes('/')) { %>
<div class="setting-component"
  data-name="OpenAI API Key for embeddings"
  data-type="text"
  data-setting="api_key"
  data-placeholder="Enter your OpenAI API Key"
  data-button="Save"
  data-callback="test_api_key_openai_embeddings"
></div>
<% } %>
<% if(settings.smart_notes_embed_model.includes('/') || settings.smart_blocks_embed_model.includes('/')) { %>
<div class="setting-component"
  data-name="Local Embedding Max Tokens"
  data-description="Reduce max tokens depending on available resources (CPU, RAM)." 
  data-type="dropdown"
  data-setting="local_embedding_max_tokens"
  data-option-1="512"
  data-option-2="1024"
  data-option-3="2048|2048 (default)"
  data-option-4="4096"
  data-option-5="8192"
  data-callback="reload_env"
></div>

<div class="setting-component"
  data-name="Connect to Smart Connect"
  data-description="<a href='https://github.com/brianpetro/smart-connect'>Smart Connect</a> is free to use for faster local embeddings."
  data-type="button"
  data-callback="connect_to_smart_connect"
></div>
<% } %>
<div class="setting-component"
  data-name="Show Full Path"
  data-description="Show full path in view."
  data-type="toggle"
  data-setting="show_full_path"
  data-callback="refresh_smart_view"
></div>`,
      smart_settings: `<h1>Smart Connections</h1>
<% if(this.env.plugin.EARLY_ACCESS && this.env.plugin.obsidian.Platform.isMobile && !this.env.plugin.settings.enable_mobile) { %>
<div data-callout-metadata="" data-callout-fold="" data-callout="warning" class="callout"><div class="callout-title"><div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-alert-triangle"><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"></path><path d="M12 9v4"></path><path d="M12 17h.01"></path></svg></div><div class="callout-title-inner">Mobile is DISABLED.</div></div><div class="callout-content">
<p>Toggle "Enable mobile" setting to activate mobile.</p>
</div></div>
<% } %>
<div data-callout-metadata="" data-callout-fold="" data-callout="info" class="callout">
  <div class="callout-title">
    <div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
        class="svg-icon lucide-info">
        <circle cx="12" cy="12" r="10"></circle>
        <path d="M12 16v-4"></path>
        <path d="M12 8h.01"></path>
      </svg></div>
    <div class="callout-title-inner">
      <blockquote>
        <p><b>User Agreement:</b> By using Smart Connections you agree to share how it helps you with at least one other person
          \u{1F60A}\u{1F334}</p>
      </blockquote>
    </div>
  </div>
</div>
<div class="sc-supporters">
  <h1>Supporter Community</h1>
  <% if(!this.env.plugin.EARLY_ACCESS){ %>
  <p>The success of Smart Connections is a direct result of our community of supporters who generously fund and evaluate new features. Their unwavering commitment to our privacy-focused, open-source software benefits all. Together, we can continue to innovate and make a positive impact on the world.</p>
  <p><b>Supporter benefits include:</b></p>
  <ul>
    <li>Early access to new &amp; experimental features:
      <ul>
        <li>Early access to new versions enables supporters to help ensure new features are ready for the broader community.</li>
        <li><i>Available in v2.2 (Early Release):</i><ul>
          <li>\u{1F5BC}\uFE0F Multimodal Smart Chat (images)</li>
          <li>\u{1F4F2} Mobile compatibility</li>
        </ul></li>
        <li><i>Coming soon:</i><ul>
          <li>Re-ranking in the Smart View</li>
          <li>Actions in the Smart Chat</li>
          <li>Advanced filters in the Smart View</li>
        </ul></li>
      </ul>
    </li>
    <li>Access to the supporter-only <a href="https://chat.smartconnections.app">private chat</a>:
      <ul>
        <li><i>Community:</i>
          <ul>
            <li>Ask questions and share insights with other supporters.</li>
          </ul>
        </li>
        <li><i>Help &amp; Support (priority):</i>
          <ul>
            <li>Swift, top-priority support in the <a href="https://chat.smartconnections.app">Supporter Chat</a>.</li>
          </ul>
        </li>
        <li><i>Feature Requests (priority):</i>
          <ul>
            <li>Influence the future of Smart Connections with priority feature requests in the <a href="https://chat.smartconnections.app">Supporter Chat</a>.</li>
          </ul>
        </li>
        <li><i>Insider Updates:</i>
          <ul>
            <li>Learn about the latest features &amp; improvements before they are announced.</li>
          </ul>
        </li>
      </ul>
    </li>
    <li><b>For a very limited time:</b> Early access to Smart Connect: Use ChatGPT with your notes <i>without</i> uploading your notes to the cloud using <a href="https://chat.openai.com/g/g-9Xb1mRJYl-smart-connect-obsidian">Smart Connect - Obsidian</a> GPT.</li>
  </ul>
  <% } %>
  <div class="setting-component"
    data-name="Supporter License Key"
    data-type="text"
    data-setting="license_key"
    data-description="Note: this is not required to use Smart Connections."
    data-placeholder="Enter your license_key"
  ></div>
  <div class="setting-component"
    data-name="Smart Connect - Obsidian GPT"
    data-btn-text="Open GPT"
    data-description='Chat with your notes in ChatGPT without uploading your notes to the cloud!'
    data-type="button"
    data-href="https://chat.openai.com/g/g-9Xb1mRJYl-smart-connections-2"
  ></div>
  <div class="setting-component"
    data-name="Enable Mobile (EXPERIMENTAL)"
    data-description="Enable mobile support for Smart Connections."
    data-type="toggle"
    <%- this.env.plugin.EARLY_ACCESS ? '' : 'data-disabled=true' %>
    data-setting="enable_mobile"
    data-callback="toggle_mobile"
  ></div>
  <div class="setting-component"
    data-name="Open Supporter Community Chat"
    data-btn-text="Open Chat"
    data-description='Join the supporter community chat.'
    data-type="button"
    data-href="https://chat.smartconnections.app"
  ></div>
  <% if(!this.env.plugin.EARLY_ACCESS){ %>
  <div class="setting-component"
    data-name="Upgrade to Early Access Version (v2.2)"
    data-description="Upgrade to v2.2 (Early Access) to access new features and improvements."
    data-type="button"
    data-btn-text="Upgrade to v2.2"
    data-callback="upgrade_to_early_access"
  ></div>
  <div class="setting-component"
    data-name="Become a Supporter"
    data-description="Become a Supporter"
    data-type="button"
    data-href="https://buy.stripe.com/9AQ7sWemT48u1LGcN4"
  ></div>
  <% } %>
</div>
<h1>Smart View & Embeddings</h1>
<p>Notes about embedding models:</p>
<ul>
  <li>Local model compatibility depends on available CPU and RAM. Try reducing the max tokens (context) if a local model if failing.</li>
  <li>API models are not dependent on local compute, but they require an API key and send your notes to third-party servers for processing.</li>
</ul>
<%- smart_embed_settings %>
<h1>Smart Chat</h1>
<%- smart_chat_settings %>
<h3>System Prompts</h3>
<div class="setting-component"
  data-name="System Prompts Folder"
  data-description="Folder to store system prompts. Available in chat by typing '@'"
  data-type="text"
  data-setting="system_prompts_folder"
  data-placeholder="Enter a folder name"
  data-callback="update_system_prompts_folder"
  data-button="Save"
></div>
<div class="setting-component"
  data-name="Default Language"
  data-setting="language"
  data-type="dropdown"
  data-description="Default language to use for Smart Chat. Changes which self-referential pronouns will trigger lookup of your notes."
  data-option-1="en|English"
  data-option-2="es|Spanish"
  data-option-3="fr|French"
  data-option-4="de|German"
  data-option-5="it|Italian"
  data-callback="update_language"
></div>
<span id="self-referential-pronouns">Current: my, I, me, mine, our, ours, us, we</span>
<h1>Exclusions</h1>
<p id="file-counts">Included files: <%= included_files %> / Total files: <%= total_files %></p>
<div class="setting-component"
  data-name="File Exclusions"
  data-description="'Excluded file' matchers separated by a comma."
  data-type="text"
  data-setting="file_exclusions"
  data-placeholder="drawings,prompts/logs"
  data-callback="update_exclusions"
></div>
<div class="setting-component"
  data-name="Folder Exclusions"
  data-description="'Excluded folder' matchers separated by a comma."
  data-type="text"
  data-setting="folder_exclusions"
  data-placeholder="drawings,prompts/logs"
  data-callback="update_exclusions"
></div>
<div class="setting-component"
  data-name="Exclude all top-level folders"
  data-description="Set folder exclusions to exclude all top-level folders."
  data-type="button"
  data-callback="exclude_all_top_level_folders"
></div>
<div class="setting-component"
  data-name="Heading Exclusions"
  data-description="'Excluded header' matchers separated by a comma. Works for 'blocks' only."
  data-type="text"
  data-setting="excluded_headings"
  data-placeholder="drawings,prompts/logs"
></div>
<h3>Data Management</h3>
<div class="setting-component"
  data-name="Refresh Notes"
  data-description="Clear notes data and reprocess."
  data-type="button"
  data-callback="refresh_notes"
></div>
<div class="setting-component"
  data-name="Smart Connections Folder"
  data-description="Folder to store Smart Connections data."
  data-type="text"
  data-setting="smart_connections_folder"
  data-placeholder="Enter a folder name"
  data-callback="update_smart_connections_folder"
  data-button="rename"
></div>
<div class="setting-component"
  data-name="Smart Chat History Folder"
  data-description="Folder to store Smart Chat history."
  data-type="text"
  data-setting="smart_chat_folder"
  data-placeholder="Enter a folder name"
  data-callback="update_smart_chat_folder"
  data-button="rename"
></div>
<div class="setting-component"
  data-name="Embedding file per note (EXPERIMENTAL)"
  data-description="Save embedding data in a separate file per note."
  data-type="toggle"
  data-setting="embedding_file_per_note"
  data-callback="restart_plugin"
></div>
<h1>Force Refresh</h1>
<div class="setting-component"
  data-name="force_refresh"
  data-description="WARNING: DO NOT use unless you know what you are doing! This will delete all of your current embeddings from OpenAI and trigger reprocessing of your entire vault!"
  data-confirm="Are you sure you want to Force Refresh? By clicking yes you confirm that you understand the consequences of this action."
  data-type="button"
  data-callback="force_refresh"
></div>
<h1>Muted Notices</h1>
<% if(muted_notices && Object.keys(muted_notices).length) { %>
  <% for(const notice in muted_notices) { %>
    <div class="setting-component"
      data-name="<%= notice %>"
      data-setting="muted_notices.<%= notice %>"
      data-type="button"
      data-btn-text="Unmute"
      data-callback="unmute_notice"
    ></div>
  <% } %>
<% } else { %>
  <p>No muted notices.</p>
<% } %>
<hr>
<h5 name="og-gpt" id="og-gpt">The Original Smart Connections GPT</h5>
<div data-callout-metadata="" data-callout-fold="" data-callout="warning" class="callout">
  <div class="callout-title">
    <div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
        class="svg-icon lucide-alert-triangle">
        <path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"></path>
        <path d="M12 9v4"></path>
        <path d="M12 17h.01"></path>
      </svg></div>
    <div class="callout-title-inner"><p><i>This will be removed in a future version.</i> Please use the <a href="https://chat.openai.com/g/g-9Xb1mRJYl-smart-connect-obsidian">Smart Connect - Obsidian</a> GPT for more advanced features like creating notes and embedding search.</p></div>
  </div>
</div>
<p>This GPT can browser folders and read notes. It requires manually synchronization for your notes to be accessible by ChatGPT.</p>
<div class="setting-component"
  data-name="ChatGPT Integration (supporter-only)"
  data-btn-text="Sync Notes"
  data-description="Sync your notes for use with the Smart Connections GPT and ChatGPT Plugin. Respects your file and folder exclusion settings. Required to use the Smart Connections GPT."
  data-type="button"
  data-callback="sync_for_chatgpt"
></div>
<div class="setting-component"
  data-name="Open Smart Connections GPT"
  data-btn-text="Open"
  data-description='Chat with your notes in ChatGPT. Requires a ChatGPT Plus account.'
  data-type="button"
  data-href="https://chat.openai.com/g/g-SlDDp07bm-smart-connections-for-obsidian"
></div>
<hr>
<% if(this.env.plugin.EARLY_ACCESS){ %>
<div class="setting-component"
  data-name="Revert to Stable Release"
  data-btn-text="Revert"
  data-description='Revert to the stable release of Smart Connections. Requires "Check for Updates" and then "Update Plugin" to complete the process.'
  data-type="button"
  data-callback="revert_to_stable_release"
></div>
<% } %>
`
    };
  }
});

// ejs.min.js
var require_ejs_min = __commonJS({
  "ejs.min.js"(exports2, module2) {
    (function(f) {
      if (typeof exports2 === "object" && typeof module2 !== "undefined") {
        module2.exports = f();
      } else if (typeof define === "function" && define.amd) {
        define([], f);
      } else {
        var g;
        if (typeof window !== "undefined") {
          g = window;
        } else if (typeof global !== "undefined") {
          g = global;
        } else if (typeof self !== "undefined") {
          g = self;
        } else {
          g = this;
        }
        g.ejs = f();
      }
    })(function() {
      var define2, module3, exports3;
      return function() {
        function r(e, n, t) {
          function o(i2, f) {
            if (!n[i2]) {
              if (!e[i2]) {
                var c = "function" == typeof require && require;
                if (!f && c)
                  return c(i2, true);
                if (u)
                  return u(i2, true);
                var a = new Error("Cannot find module '" + i2 + "'");
                throw a.code = "MODULE_NOT_FOUND", a;
              }
              var p = n[i2] = { exports: {} };
              e[i2][0].call(p.exports, function(r2) {
                var n2 = e[i2][1][r2];
                return o(n2 || r2);
              }, p, p.exports, r, e, n, t);
            }
            return n[i2].exports;
          }
          for (var u = "function" == typeof require && require, i = 0; i < t.length; i++)
            o(t[i]);
          return o;
        }
        return r;
      }()({ 1: [function(require2, module4, exports4) {
        "use strict";
        var fs = require2("fs");
        var path = require2("path");
        var utils = require2("./utils");
        var scopeOptionWarned = false;
        var _VERSION_STRING = require2("../package.json").version;
        var _DEFAULT_OPEN_DELIMITER = "<";
        var _DEFAULT_CLOSE_DELIMITER = ">";
        var _DEFAULT_DELIMITER = "%";
        var _DEFAULT_LOCALS_NAME = "locals";
        var _NAME = "ejs";
        var _REGEX_STRING = "(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)";
        var _OPTS_PASSABLE_WITH_DATA = ["delimiter", "scope", "context", "debug", "compileDebug", "client", "_with", "rmWhitespace", "strict", "filename", "async"];
        var _OPTS_PASSABLE_WITH_DATA_EXPRESS = _OPTS_PASSABLE_WITH_DATA.concat("cache");
        var _BOM = /^\uFEFF/;
        var _JS_IDENTIFIER = /^[a-zA-Z_$][0-9a-zA-Z_$]*$/;
        exports4.cache = utils.cache;
        exports4.fileLoader = fs.readFileSync;
        exports4.localsName = _DEFAULT_LOCALS_NAME;
        exports4.promiseImpl = new Function("return this;")().Promise;
        exports4.resolveInclude = function(name, filename, isDir) {
          var dirname = path.dirname;
          var extname = path.extname;
          var resolve = path.resolve;
          var includePath = resolve(isDir ? filename : dirname(filename), name);
          var ext = extname(name);
          if (!ext) {
            includePath += ".ejs";
          }
          return includePath;
        };
        function resolvePaths(name, paths) {
          var filePath;
          if (paths.some(function(v) {
            filePath = exports4.resolveInclude(name, v, true);
            return fs.existsSync(filePath);
          })) {
            return filePath;
          }
        }
        function getIncludePath(path2, options) {
          var includePath;
          var filePath;
          var views = options.views;
          var match = /^[A-Za-z]+:\\|^\//.exec(path2);
          if (match && match.length) {
            path2 = path2.replace(/^\/*/, "");
            if (Array.isArray(options.root)) {
              includePath = resolvePaths(path2, options.root);
            } else {
              includePath = exports4.resolveInclude(path2, options.root || "/", true);
            }
          } else {
            if (options.filename) {
              filePath = exports4.resolveInclude(path2, options.filename);
              if (fs.existsSync(filePath)) {
                includePath = filePath;
              }
            }
            if (!includePath && Array.isArray(views)) {
              includePath = resolvePaths(path2, views);
            }
            if (!includePath && typeof options.includer !== "function") {
              throw new Error('Could not find the include file "' + options.escapeFunction(path2) + '"');
            }
          }
          return includePath;
        }
        function handleCache(options, template) {
          var func;
          var filename = options.filename;
          var hasTemplate = arguments.length > 1;
          if (options.cache) {
            if (!filename) {
              throw new Error("cache option requires a filename");
            }
            func = exports4.cache.get(filename);
            if (func) {
              return func;
            }
            if (!hasTemplate) {
              template = fileLoader(filename).toString().replace(_BOM, "");
            }
          } else if (!hasTemplate) {
            if (!filename) {
              throw new Error("Internal EJS error: no file name or template provided");
            }
            template = fileLoader(filename).toString().replace(_BOM, "");
          }
          func = exports4.compile(template, options);
          if (options.cache) {
            exports4.cache.set(filename, func);
          }
          return func;
        }
        function tryHandleCache(options, data, cb) {
          var result;
          if (!cb) {
            if (typeof exports4.promiseImpl == "function") {
              return new exports4.promiseImpl(function(resolve, reject) {
                try {
                  result = handleCache(options)(data);
                  resolve(result);
                } catch (err) {
                  reject(err);
                }
              });
            } else {
              throw new Error("Please provide a callback function");
            }
          } else {
            try {
              result = handleCache(options)(data);
            } catch (err) {
              return cb(err);
            }
            cb(null, result);
          }
        }
        function fileLoader(filePath) {
          return exports4.fileLoader(filePath);
        }
        function includeFile(path2, options) {
          var opts = utils.shallowCopy(utils.createNullProtoObjWherePossible(), options);
          opts.filename = getIncludePath(path2, opts);
          if (typeof options.includer === "function") {
            var includerResult = options.includer(path2, opts.filename);
            if (includerResult) {
              if (includerResult.filename) {
                opts.filename = includerResult.filename;
              }
              if (includerResult.template) {
                return handleCache(opts, includerResult.template);
              }
            }
          }
          return handleCache(opts);
        }
        function rethrow(err, str, flnm, lineno, esc) {
          var lines = str.split("\n");
          var start = Math.max(lineno - 3, 0);
          var end = Math.min(lines.length, lineno + 3);
          var filename = esc(flnm);
          var context = lines.slice(start, end).map(function(line, i) {
            var curr = i + start + 1;
            return (curr == lineno ? " >> " : "    ") + curr + "| " + line;
          }).join("\n");
          err.path = filename;
          err.message = (filename || "ejs") + ":" + lineno + "\n" + context + "\n\n" + err.message;
          throw err;
        }
        function stripSemi(str) {
          return str.replace(/;(\s*$)/, "$1");
        }
        exports4.compile = function compile(template, opts) {
          var templ;
          if (opts && opts.scope) {
            if (!scopeOptionWarned) {
              console.warn("`scope` option is deprecated and will be removed in EJS 3");
              scopeOptionWarned = true;
            }
            if (!opts.context) {
              opts.context = opts.scope;
            }
            delete opts.scope;
          }
          templ = new Template(template, opts);
          return templ.compile();
        };
        exports4.render = function(template, d, o) {
          var data = d || utils.createNullProtoObjWherePossible();
          var opts = o || utils.createNullProtoObjWherePossible();
          if (arguments.length == 2) {
            utils.shallowCopyFromList(opts, data, _OPTS_PASSABLE_WITH_DATA);
          }
          return handleCache(opts, template)(data);
        };
        exports4.renderFile = function() {
          var args = Array.prototype.slice.call(arguments);
          var filename = args.shift();
          var cb;
          var opts = { filename };
          var data;
          var viewOpts;
          if (typeof arguments[arguments.length - 1] == "function") {
            cb = args.pop();
          }
          if (args.length) {
            data = args.shift();
            if (args.length) {
              utils.shallowCopy(opts, args.pop());
            } else {
              if (data.settings) {
                if (data.settings.views) {
                  opts.views = data.settings.views;
                }
                if (data.settings["view cache"]) {
                  opts.cache = true;
                }
                viewOpts = data.settings["view options"];
                if (viewOpts) {
                  utils.shallowCopy(opts, viewOpts);
                }
              }
              utils.shallowCopyFromList(opts, data, _OPTS_PASSABLE_WITH_DATA_EXPRESS);
            }
            opts.filename = filename;
          } else {
            data = utils.createNullProtoObjWherePossible();
          }
          return tryHandleCache(opts, data, cb);
        };
        exports4.Template = Template;
        exports4.clearCache = function() {
          exports4.cache.reset();
        };
        function Template(text, opts) {
          opts = opts || utils.createNullProtoObjWherePossible();
          var options = utils.createNullProtoObjWherePossible();
          this.templateText = text;
          this.mode = null;
          this.truncate = false;
          this.currentLine = 1;
          this.source = "";
          options.client = opts.client || false;
          options.escapeFunction = opts.escape || opts.escapeFunction || utils.escapeXML;
          options.compileDebug = opts.compileDebug !== false;
          options.debug = !!opts.debug;
          options.filename = opts.filename;
          options.openDelimiter = opts.openDelimiter || exports4.openDelimiter || _DEFAULT_OPEN_DELIMITER;
          options.closeDelimiter = opts.closeDelimiter || exports4.closeDelimiter || _DEFAULT_CLOSE_DELIMITER;
          options.delimiter = opts.delimiter || exports4.delimiter || _DEFAULT_DELIMITER;
          options.strict = opts.strict || false;
          options.context = opts.context;
          options.cache = opts.cache || false;
          options.rmWhitespace = opts.rmWhitespace;
          options.root = opts.root;
          options.includer = opts.includer;
          options.outputFunctionName = opts.outputFunctionName;
          options.localsName = opts.localsName || exports4.localsName || _DEFAULT_LOCALS_NAME;
          options.views = opts.views;
          options.async = opts.async;
          options.destructuredLocals = opts.destructuredLocals;
          options.legacyInclude = typeof opts.legacyInclude != "undefined" ? !!opts.legacyInclude : true;
          if (options.strict) {
            options._with = false;
          } else {
            options._with = typeof opts._with != "undefined" ? opts._with : true;
          }
          this.opts = options;
          this.regex = this.createRegex();
        }
        Template.modes = { EVAL: "eval", ESCAPED: "escaped", RAW: "raw", COMMENT: "comment", LITERAL: "literal" };
        Template.prototype = { createRegex: function() {
          var str = _REGEX_STRING;
          var delim = utils.escapeRegExpChars(this.opts.delimiter);
          var open = utils.escapeRegExpChars(this.opts.openDelimiter);
          var close = utils.escapeRegExpChars(this.opts.closeDelimiter);
          str = str.replace(/%/g, delim).replace(/</g, open).replace(/>/g, close);
          return new RegExp(str);
        }, compile: function() {
          var src;
          var fn;
          var opts = this.opts;
          var prepended = "";
          var appended = "";
          var escapeFn = opts.escapeFunction;
          var ctor;
          var sanitizedFilename = opts.filename ? JSON.stringify(opts.filename) : "undefined";
          if (!this.source) {
            this.generateSource();
            prepended += '  var __output = "";\n  function __append(s) { if (s !== undefined && s !== null) __output += s }\n';
            if (opts.outputFunctionName) {
              if (!_JS_IDENTIFIER.test(opts.outputFunctionName)) {
                throw new Error("outputFunctionName is not a valid JS identifier.");
              }
              prepended += "  var " + opts.outputFunctionName + " = __append;\n";
            }
            if (opts.localsName && !_JS_IDENTIFIER.test(opts.localsName)) {
              throw new Error("localsName is not a valid JS identifier.");
            }
            if (opts.destructuredLocals && opts.destructuredLocals.length) {
              var destructuring = "  var __locals = (" + opts.localsName + " || {}),\n";
              for (var i = 0; i < opts.destructuredLocals.length; i++) {
                var name = opts.destructuredLocals[i];
                if (!_JS_IDENTIFIER.test(name)) {
                  throw new Error("destructuredLocals[" + i + "] is not a valid JS identifier.");
                }
                if (i > 0) {
                  destructuring += ",\n  ";
                }
                destructuring += name + " = __locals." + name;
              }
              prepended += destructuring + ";\n";
            }
            if (opts._with !== false) {
              prepended += "  with (" + opts.localsName + " || {}) {\n";
              appended += "  }\n";
            }
            appended += "  return __output;\n";
            this.source = prepended + this.source + appended;
          }
          if (opts.compileDebug) {
            src = "var __line = 1\n  , __lines = " + JSON.stringify(this.templateText) + "\n  , __filename = " + sanitizedFilename + ";\ntry {\n" + this.source + "} catch (e) {\n  rethrow(e, __lines, __filename, __line, escapeFn);\n}\n";
          } else {
            src = this.source;
          }
          if (opts.client) {
            src = "escapeFn = escapeFn || " + escapeFn.toString() + ";\n" + src;
            if (opts.compileDebug) {
              src = "rethrow = rethrow || " + rethrow.toString() + ";\n" + src;
            }
          }
          if (opts.strict) {
            src = '"use strict";\n' + src;
          }
          if (opts.debug) {
            console.log(src);
          }
          if (opts.compileDebug && opts.filename) {
            src = src + "\n//# sourceURL=" + sanitizedFilename + "\n";
          }
          try {
            if (opts.async) {
              try {
                ctor = new Function("return (async function(){}).constructor;")();
              } catch (e) {
                if (e instanceof SyntaxError) {
                  throw new Error("This environment does not support async/await");
                } else {
                  throw e;
                }
              }
            } else {
              ctor = Function;
            }
            fn = new ctor(opts.localsName + ", escapeFn, include, rethrow", src);
          } catch (e) {
            if (e instanceof SyntaxError) {
              if (opts.filename) {
                e.message += " in " + opts.filename;
              }
              e.message += " while compiling ejs\n\n";
              e.message += "If the above error is not helpful, you may want to try EJS-Lint:\n";
              e.message += "https://github.com/RyanZim/EJS-Lint";
              if (!opts.async) {
                e.message += "\n";
                e.message += "Or, if you meant to create an async function, pass `async: true` as an option.";
              }
            }
            throw e;
          }
          var returnedFn = opts.client ? fn : function anonymous(data) {
            var include = function(path2, includeData) {
              var d = utils.shallowCopy(utils.createNullProtoObjWherePossible(), data);
              if (includeData) {
                d = utils.shallowCopy(d, includeData);
              }
              return includeFile(path2, opts)(d);
            };
            return fn.apply(opts.context, [data || utils.createNullProtoObjWherePossible(), escapeFn, include, rethrow]);
          };
          if (opts.filename && typeof Object.defineProperty === "function") {
            var filename = opts.filename;
            var basename = path.basename(filename, path.extname(filename));
            try {
              Object.defineProperty(returnedFn, "name", { value: basename, writable: false, enumerable: false, configurable: true });
            } catch (e) {
            }
          }
          return returnedFn;
        }, generateSource: function() {
          var opts = this.opts;
          if (opts.rmWhitespace) {
            this.templateText = this.templateText.replace(/[\r\n]+/g, "\n").replace(/^\s+|\s+$/gm, "");
          }
          this.templateText = this.templateText.replace(/[ \t]*<%_/gm, "<%_").replace(/_%>[ \t]*/gm, "_%>");
          var self2 = this;
          var matches = this.parseTemplateText();
          var d = this.opts.delimiter;
          var o = this.opts.openDelimiter;
          var c = this.opts.closeDelimiter;
          if (matches && matches.length) {
            matches.forEach(function(line, index) {
              var closing;
              if (line.indexOf(o + d) === 0 && line.indexOf(o + d + d) !== 0) {
                closing = matches[index + 2];
                if (!(closing == d + c || closing == "-" + d + c || closing == "_" + d + c)) {
                  throw new Error('Could not find matching close tag for "' + line + '".');
                }
              }
              self2.scanLine(line);
            });
          }
        }, parseTemplateText: function() {
          var str = this.templateText;
          var pat = this.regex;
          var result = pat.exec(str);
          var arr = [];
          var firstPos;
          while (result) {
            firstPos = result.index;
            if (firstPos !== 0) {
              arr.push(str.substring(0, firstPos));
              str = str.slice(firstPos);
            }
            arr.push(result[0]);
            str = str.slice(result[0].length);
            result = pat.exec(str);
          }
          if (str) {
            arr.push(str);
          }
          return arr;
        }, _addOutput: function(line) {
          if (this.truncate) {
            line = line.replace(/^(?:\r\n|\r|\n)/, "");
            this.truncate = false;
          }
          if (!line) {
            return line;
          }
          line = line.replace(/\\/g, "\\\\");
          line = line.replace(/\n/g, "\\n");
          line = line.replace(/\r/g, "\\r");
          line = line.replace(/"/g, '\\"');
          this.source += '    ; __append("' + line + '")\n';
        }, scanLine: function(line) {
          var self2 = this;
          var d = this.opts.delimiter;
          var o = this.opts.openDelimiter;
          var c = this.opts.closeDelimiter;
          var newLineCount = 0;
          newLineCount = line.split("\n").length - 1;
          switch (line) {
            case o + d:
            case o + d + "_":
              this.mode = Template.modes.EVAL;
              break;
            case o + d + "=":
              this.mode = Template.modes.ESCAPED;
              break;
            case o + d + "-":
              this.mode = Template.modes.RAW;
              break;
            case o + d + "#":
              this.mode = Template.modes.COMMENT;
              break;
            case o + d + d:
              this.mode = Template.modes.LITERAL;
              this.source += '    ; __append("' + line.replace(o + d + d, o + d) + '")\n';
              break;
            case d + d + c:
              this.mode = Template.modes.LITERAL;
              this.source += '    ; __append("' + line.replace(d + d + c, d + c) + '")\n';
              break;
            case d + c:
            case "-" + d + c:
            case "_" + d + c:
              if (this.mode == Template.modes.LITERAL) {
                this._addOutput(line);
              }
              this.mode = null;
              this.truncate = line.indexOf("-") === 0 || line.indexOf("_") === 0;
              break;
            default:
              if (this.mode) {
                switch (this.mode) {
                  case Template.modes.EVAL:
                  case Template.modes.ESCAPED:
                  case Template.modes.RAW:
                    if (line.lastIndexOf("//") > line.lastIndexOf("\n")) {
                      line += "\n";
                    }
                }
                switch (this.mode) {
                  case Template.modes.EVAL:
                    this.source += "    ; " + line + "\n";
                    break;
                  case Template.modes.ESCAPED:
                    this.source += "    ; __append(escapeFn(" + stripSemi(line) + "))\n";
                    break;
                  case Template.modes.RAW:
                    this.source += "    ; __append(" + stripSemi(line) + ")\n";
                    break;
                  case Template.modes.COMMENT:
                    break;
                  case Template.modes.LITERAL:
                    this._addOutput(line);
                    break;
                }
              } else {
                this._addOutput(line);
              }
          }
          if (self2.opts.compileDebug && newLineCount) {
            this.currentLine += newLineCount;
            this.source += "    ; __line = " + this.currentLine + "\n";
          }
        } };
        exports4.escapeXML = utils.escapeXML;
        exports4.__express = exports4.renderFile;
        exports4.VERSION = _VERSION_STRING;
        exports4.name = _NAME;
        if (typeof window != "undefined") {
          window.ejs = exports4;
        }
      }, { "../package.json": 6, "./utils": 2, fs: 3, path: 4 }], 2: [function(require2, module4, exports4) {
        "use strict";
        var regExpChars = /[|\\{}()[\]^$+*?.]/g;
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var hasOwn = function(obj, key) {
          return hasOwnProperty.apply(obj, [key]);
        };
        exports4.escapeRegExpChars = function(string) {
          if (!string) {
            return "";
          }
          return String(string).replace(regExpChars, "\\$&");
        };
        var _ENCODE_HTML_RULES = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&#34;", "'": "&#39;" };
        var _MATCH_HTML = /[&<>'"]/g;
        function encode_char(c) {
          return _ENCODE_HTML_RULES[c] || c;
        }
        var escapeFuncStr = `var _ENCODE_HTML_RULES = {
      "&": "&amp;"
    , "<": "&lt;"
    , ">": "&gt;"
    , '"': "&#34;"
    , "'": "&#39;"
    }
  , _MATCH_HTML = /[&<>'"]/g;
function encode_char(c) {
  return _ENCODE_HTML_RULES[c] || c;
};
`;
        exports4.escapeXML = function(markup) {
          return markup == void 0 ? "" : String(markup).replace(_MATCH_HTML, encode_char);
        };
        function escapeXMLToString() {
          return Function.prototype.toString.call(this) + ";\n" + escapeFuncStr;
        }
        try {
          if (typeof Object.defineProperty === "function") {
            Object.defineProperty(exports4.escapeXML, "toString", { value: escapeXMLToString });
          } else {
            exports4.escapeXML.toString = escapeXMLToString;
          }
        } catch (err) {
          console.warn("Unable to set escapeXML.toString (is the Function prototype frozen?)");
        }
        exports4.shallowCopy = function(to, from) {
          from = from || {};
          if (to !== null && to !== void 0) {
            for (var p in from) {
              if (!hasOwn(from, p)) {
                continue;
              }
              if (p === "__proto__" || p === "constructor") {
                continue;
              }
              to[p] = from[p];
            }
          }
          return to;
        };
        exports4.shallowCopyFromList = function(to, from, list) {
          list = list || [];
          from = from || {};
          if (to !== null && to !== void 0) {
            for (var i = 0; i < list.length; i++) {
              var p = list[i];
              if (typeof from[p] != "undefined") {
                if (!hasOwn(from, p)) {
                  continue;
                }
                if (p === "__proto__" || p === "constructor") {
                  continue;
                }
                to[p] = from[p];
              }
            }
          }
          return to;
        };
        exports4.cache = { _data: {}, set: function(key, val) {
          this._data[key] = val;
        }, get: function(key) {
          return this._data[key];
        }, remove: function(key) {
          delete this._data[key];
        }, reset: function() {
          this._data = {};
        } };
        exports4.hyphenToCamel = function(str) {
          return str.replace(/-[a-z]/g, function(match) {
            return match[1].toUpperCase();
          });
        };
        exports4.createNullProtoObjWherePossible = function() {
          if (typeof Object.create == "function") {
            return function() {
              return /* @__PURE__ */ Object.create(null);
            };
          }
          if (!({ __proto__: null } instanceof Object)) {
            return function() {
              return { __proto__: null };
            };
          }
          return function() {
            return {};
          };
        }();
      }, {}], 3: [function(require2, module4, exports4) {
      }, {}], 4: [function(require2, module4, exports4) {
        (function(process2) {
          function normalizeArray(parts, allowAboveRoot) {
            var up = 0;
            for (var i = parts.length - 1; i >= 0; i--) {
              var last = parts[i];
              if (last === ".") {
                parts.splice(i, 1);
              } else if (last === "..") {
                parts.splice(i, 1);
                up++;
              } else if (up) {
                parts.splice(i, 1);
                up--;
              }
            }
            if (allowAboveRoot) {
              for (; up--; up) {
                parts.unshift("..");
              }
            }
            return parts;
          }
          exports4.resolve = function() {
            var resolvedPath = "", resolvedAbsolute = false;
            for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
              var path = i >= 0 ? arguments[i] : process2.cwd();
              if (typeof path !== "string") {
                throw new TypeError("Arguments to path.resolve must be strings");
              } else if (!path) {
                continue;
              }
              resolvedPath = path + "/" + resolvedPath;
              resolvedAbsolute = path.charAt(0) === "/";
            }
            resolvedPath = normalizeArray(filter(resolvedPath.split("/"), function(p) {
              return !!p;
            }), !resolvedAbsolute).join("/");
            return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
          };
          exports4.normalize = function(path) {
            var isAbsolute = exports4.isAbsolute(path), trailingSlash = substr(path, -1) === "/";
            path = normalizeArray(filter(path.split("/"), function(p) {
              return !!p;
            }), !isAbsolute).join("/");
            if (!path && !isAbsolute) {
              path = ".";
            }
            if (path && trailingSlash) {
              path += "/";
            }
            return (isAbsolute ? "/" : "") + path;
          };
          exports4.isAbsolute = function(path) {
            return path.charAt(0) === "/";
          };
          exports4.join = function() {
            var paths = Array.prototype.slice.call(arguments, 0);
            return exports4.normalize(filter(paths, function(p, index) {
              if (typeof p !== "string") {
                throw new TypeError("Arguments to path.join must be strings");
              }
              return p;
            }).join("/"));
          };
          exports4.relative = function(from, to) {
            from = exports4.resolve(from).substr(1);
            to = exports4.resolve(to).substr(1);
            function trim(arr) {
              var start = 0;
              for (; start < arr.length; start++) {
                if (arr[start] !== "")
                  break;
              }
              var end = arr.length - 1;
              for (; end >= 0; end--) {
                if (arr[end] !== "")
                  break;
              }
              if (start > end)
                return [];
              return arr.slice(start, end - start + 1);
            }
            var fromParts = trim(from.split("/"));
            var toParts = trim(to.split("/"));
            var length = Math.min(fromParts.length, toParts.length);
            var samePartsLength = length;
            for (var i = 0; i < length; i++) {
              if (fromParts[i] !== toParts[i]) {
                samePartsLength = i;
                break;
              }
            }
            var outputParts = [];
            for (var i = samePartsLength; i < fromParts.length; i++) {
              outputParts.push("..");
            }
            outputParts = outputParts.concat(toParts.slice(samePartsLength));
            return outputParts.join("/");
          };
          exports4.sep = "/";
          exports4.delimiter = ":";
          exports4.dirname = function(path) {
            if (typeof path !== "string")
              path = path + "";
            if (path.length === 0)
              return ".";
            var code = path.charCodeAt(0);
            var hasRoot = code === 47;
            var end = -1;
            var matchedSlash = true;
            for (var i = path.length - 1; i >= 1; --i) {
              code = path.charCodeAt(i);
              if (code === 47) {
                if (!matchedSlash) {
                  end = i;
                  break;
                }
              } else {
                matchedSlash = false;
              }
            }
            if (end === -1)
              return hasRoot ? "/" : ".";
            if (hasRoot && end === 1) {
              return "/";
            }
            return path.slice(0, end);
          };
          function basename(path) {
            if (typeof path !== "string")
              path = path + "";
            var start = 0;
            var end = -1;
            var matchedSlash = true;
            var i;
            for (i = path.length - 1; i >= 0; --i) {
              if (path.charCodeAt(i) === 47) {
                if (!matchedSlash) {
                  start = i + 1;
                  break;
                }
              } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
              }
            }
            if (end === -1)
              return "";
            return path.slice(start, end);
          }
          exports4.basename = function(path, ext) {
            var f = basename(path);
            if (ext && f.substr(-1 * ext.length) === ext) {
              f = f.substr(0, f.length - ext.length);
            }
            return f;
          };
          exports4.extname = function(path) {
            if (typeof path !== "string")
              path = path + "";
            var startDot = -1;
            var startPart = 0;
            var end = -1;
            var matchedSlash = true;
            var preDotState = 0;
            for (var i = path.length - 1; i >= 0; --i) {
              var code = path.charCodeAt(i);
              if (code === 47) {
                if (!matchedSlash) {
                  startPart = i + 1;
                  break;
                }
                continue;
              }
              if (end === -1) {
                matchedSlash = false;
                end = i + 1;
              }
              if (code === 46) {
                if (startDot === -1)
                  startDot = i;
                else if (preDotState !== 1)
                  preDotState = 1;
              } else if (startDot !== -1) {
                preDotState = -1;
              }
            }
            if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
              return "";
            }
            return path.slice(startDot, end);
          };
          function filter(xs, f) {
            if (xs.filter)
              return xs.filter(f);
            var res = [];
            for (var i = 0; i < xs.length; i++) {
              if (f(xs[i], i, xs))
                res.push(xs[i]);
            }
            return res;
          }
          var substr = "ab".substr(-1) === "b" ? function(str, start, len) {
            return str.substr(start, len);
          } : function(str, start, len) {
            if (start < 0)
              start = str.length + start;
            return str.substr(start, len);
          };
        }).call(this, require2("_process"));
      }, { _process: 5 }], 5: [function(require2, module4, exports4) {
        var process2 = module4.exports = {};
        var cachedSetTimeout;
        var cachedClearTimeout;
        function defaultSetTimout() {
          throw new Error("setTimeout has not been defined");
        }
        function defaultClearTimeout() {
          throw new Error("clearTimeout has not been defined");
        }
        (function() {
          try {
            if (typeof setTimeout === "function") {
              cachedSetTimeout = setTimeout;
            } else {
              cachedSetTimeout = defaultSetTimout;
            }
          } catch (e) {
            cachedSetTimeout = defaultSetTimout;
          }
          try {
            if (typeof clearTimeout === "function") {
              cachedClearTimeout = clearTimeout;
            } else {
              cachedClearTimeout = defaultClearTimeout;
            }
          } catch (e) {
            cachedClearTimeout = defaultClearTimeout;
          }
        })();
        function runTimeout(fun) {
          if (cachedSetTimeout === setTimeout) {
            return setTimeout(fun, 0);
          }
          if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
          }
          try {
            return cachedSetTimeout(fun, 0);
          } catch (e) {
            try {
              return cachedSetTimeout.call(null, fun, 0);
            } catch (e2) {
              return cachedSetTimeout.call(this, fun, 0);
            }
          }
        }
        function runClearTimeout(marker) {
          if (cachedClearTimeout === clearTimeout) {
            return clearTimeout(marker);
          }
          if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
          }
          try {
            return cachedClearTimeout(marker);
          } catch (e) {
            try {
              return cachedClearTimeout.call(null, marker);
            } catch (e2) {
              return cachedClearTimeout.call(this, marker);
            }
          }
        }
        var queue = [];
        var draining = false;
        var currentQueue;
        var queueIndex = -1;
        function cleanUpNextTick() {
          if (!draining || !currentQueue) {
            return;
          }
          draining = false;
          if (currentQueue.length) {
            queue = currentQueue.concat(queue);
          } else {
            queueIndex = -1;
          }
          if (queue.length) {
            drainQueue();
          }
        }
        function drainQueue() {
          if (draining) {
            return;
          }
          var timeout = runTimeout(cleanUpNextTick);
          draining = true;
          var len = queue.length;
          while (len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
              if (currentQueue) {
                currentQueue[queueIndex].run();
              }
            }
            queueIndex = -1;
            len = queue.length;
          }
          currentQueue = null;
          draining = false;
          runClearTimeout(timeout);
        }
        process2.nextTick = function(fun) {
          var args = new Array(arguments.length - 1);
          if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
            }
          }
          queue.push(new Item(fun, args));
          if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
          }
        };
        function Item(fun, array) {
          this.fun = fun;
          this.array = array;
        }
        Item.prototype.run = function() {
          this.fun.apply(null, this.array);
        };
        process2.title = "browser";
        process2.browser = true;
        process2.env = {};
        process2.argv = [];
        process2.version = "";
        process2.versions = {};
        function noop() {
        }
        process2.on = noop;
        process2.addListener = noop;
        process2.once = noop;
        process2.off = noop;
        process2.removeListener = noop;
        process2.removeAllListeners = noop;
        process2.emit = noop;
        process2.prependListener = noop;
        process2.prependOnceListener = noop;
        process2.listeners = function(name) {
          return [];
        };
        process2.binding = function(name) {
          throw new Error("process.binding is not supported");
        };
        process2.cwd = function() {
          return "/";
        };
        process2.chdir = function(dir) {
          throw new Error("process.chdir is not supported");
        };
        process2.umask = function() {
          return 0;
        };
      }, {}], 6: [function(require2, module4, exports4) {
        module4.exports = { name: "ejs", description: "Embedded JavaScript templates", keywords: ["template", "engine", "ejs"], version: "3.1.9", author: "Matthew Eernisse <mde@fleegix.org> (http://fleegix.org)", license: "Apache-2.0", bin: { ejs: "./bin/cli.js" }, main: "./lib/ejs.js", jsdelivr: "ejs.min.js", unpkg: "ejs.min.js", repository: { type: "git", url: "git://github.com/mde/ejs.git" }, bugs: "https://github.com/mde/ejs/issues", homepage: "https://github.com/mde/ejs", dependencies: { jake: "^10.8.5" }, devDependencies: { browserify: "^16.5.1", eslint: "^6.8.0", "git-directory-deploy": "^1.5.1", jsdoc: "^4.0.2", "lru-cache": "^4.0.1", mocha: "^10.2.0", "uglify-js": "^3.3.16" }, engines: { node: ">=0.10.0" }, scripts: { test: "mocha -u tdd" } };
      }, {}] }, {}, [1])(1);
    });
  }
});

// src/ScTranslations.json
var require_ScTranslations = __commonJS({
  "src/ScTranslations.json"(exports2, module2) {
    module2.exports = {
      en: {
        pronouns: ["my", "I", "me", "mine", "our", "ours", "us", "we"],
        prompt: "Based on your notes",
        initial_message: "Hi, I'm ChatGPT with access to your notes via Smart Connections. Ask me a question about your notes and I'll try to answer it."
      },
      es: {
        pronouns: ["mi", "yo", "m\xED", "t\xFA"],
        prompt: "Bas\xE1ndose en sus notas",
        initial_message: "Hola, soy ChatGPT con acceso a tus apuntes a trav\xE9s de Smart Connections. Hazme una pregunta sobre tus apuntes e intentar\xE9 responderte."
      },
      fr: {
        pronouns: ["me", "mon", "ma", "mes", "moi", "nous", "notre", "nos", "je", "j'", "m'"],
        prompt: "D'apr\xE8s vos notes",
        initial_message: "Bonjour, je suis ChatGPT et j'ai acc\xE8s \xE0 vos notes via Smart Connections. Posez-moi une question sur vos notes et j'essaierai d'y r\xE9pondre."
      },
      de: {
        pronouns: ["mein", "meine", "meinen", "meiner", "meines", "mir", "uns", "unser", "unseren", "unserer", "unseres"],
        prompt: "Basierend auf Ihren Notizen",
        initial_message: "Hallo, ich bin ChatGPT und habe \xFCber Smart Connections Zugang zu Ihren Notizen. Stellen Sie mir eine Frage zu Ihren Notizen und ich werde versuchen, sie zu beantworten."
      },
      it: {
        pronouns: ["mio", "mia", "miei", "mie", "noi", "nostro", "nostri", "nostra", "nostre"],
        prompt: "Sulla base degli appunti",
        initial_message: "Ciao, sono ChatGPT e ho accesso ai tuoi appunti tramite Smart Connections. Fatemi una domanda sui vostri appunti e cercher\xF2 di rispondervi."
      }
    };
  }
});

// node_modules/smart-chat-model/adapters/anthropic.js
var require_anthropic = __commonJS({
  "node_modules/smart-chat-model/adapters/anthropic.js"(exports2) {
    var AnthropicAdapter = class {
      /**
       * Prepares the request body for the Anthropic API by converting ChatML format to a format compatible with Anthropic.
       * @param {Object} opts - The options object containing messages and other parameters in ChatML format.
       * @returns {Object} The request body formatted for the Anthropic API.
       */
      prepare_request_body(opts) {
        return chatml_to_anthropic(opts);
      }
      /**
       * Counts the tokens in the input by estimating them, as the Anthropic model does not provide a direct method.
       * @param {string|Object} input - The input text or object to count tokens in.
       * @returns {Promise<number>} The estimated number of tokens in the input.
       */
      async count_tokens(input) {
        return this.estimate_tokens(input);
      }
      /**
       * Estimates the number of tokens in the input based on a rough average token size.
       * @param {string|Object} input - The input text or object to estimate tokens in.
       * @returns {number} The estimated number of tokens.
       */
      estimate_tokens(input) {
        if (typeof input === "object")
          input = JSON.stringify(input);
        return Math.ceil(input.length / 6);
      }
      /**
       * Extracts the first tool call from the JSON response content.
       * @param {Object} json - The JSON response from which to extract the tool call.
       * @returns {Object|null} The first tool call found, or null if none exist.
       */
      get_tool_call(json) {
        return json.content.find((msg) => msg.type === "tool_use");
      }
      /**
       * Retrieves the input content of a tool call.
       * @param {Object} tool_call - The tool call object from which to extract the input.
       * @returns {Object} The input of the tool call.
       */
      get_tool_call_content(tool_call) {
        return tool_call.input;
      }
      /**
       * Retrieves the name of the tool from a tool call object.
       * @param {Object} tool_call - The tool call object from which to extract the name.
       * @returns {string} The name of the tool.
       */
      get_tool_name(tool_call) {
        return tool_call.name;
      }
      /**
       * Extracts the first message from the JSON response content.
       * @param {Object} json - The JSON response from which to extract the message.
       * @returns {Object|null} The first message found, or null if none exist.
       */
      get_message(json) {
        var _a;
        return (_a = json.content) == null ? void 0 : _a[0];
      }
      /**
       * Retrieves the content of the first message from the JSON response.
       * @param {Object} json - The JSON response from which to extract the message content.
       * @returns {string|null} The content of the first message, or null if no message is found.
       */
      get_message_content(json) {
        var _a, _b;
        return (_b = this.get_message(json)) == null ? void 0 : _b[(_a = this.get_message(json)) == null ? void 0 : _a.type];
      }
    };
    exports2.AnthropicAdapter = AnthropicAdapter;
    function chatml_to_anthropic(opts) {
      const messages = opts.messages.filter((msg) => msg.role !== "system").map((m) => {
        if (typeof m.content === "string")
          return { role: m.role, content: m.content };
        if (Array.isArray(m.content)) {
          const content = m.content.map((c) => {
            if (c.type === "text")
              return { type: "text", text: c.text };
            if (c.type === "image_url") {
              const image_url = c.image_url.url;
              let media_type = image_url.split(":")[1].split(";")[0];
              if (media_type === "image/jpg")
                media_type = "image/jpeg";
              return { type: "image", source: { type: "base64", media_type, data: image_url.split(",")[1] } };
            }
          });
          return { role: m.role, content };
        }
        return m;
      });
      const { model, max_tokens, temperature, tools } = opts;
      const last_system_idx = opts.messages.findLastIndex((msg) => msg.role === "system" && msg.content.includes("---BEGIN"));
      if (last_system_idx > -1) {
        const system_prompt = "<context>\n" + opts.messages[last_system_idx].content + "\n</context>\n";
        messages[messages.length - 1].content = system_prompt + messages[messages.length - 1].content;
      }
      console.log(messages);
      const out = {
        messages,
        model,
        max_tokens,
        temperature
      };
      if (tools) {
        out.tools = tools.map((tool) => ({
          name: tool.function.name,
          description: tool.function.description,
          input_schema: tool.function.parameters
        }));
        const tool_prompt = `Use the "${out.tools[0].name}" tool!`;
        const last_user_idx = out.messages.findLastIndex((msg) => msg.role === "user");
        out.messages[last_user_idx].content += "\n" + tool_prompt;
        out.system = `Required: use the "${out.tools[0].name}" tool!`;
      }
      const last_non_context_system_idx = opts.messages.findLastIndex((msg) => msg.role === "system" && !msg.content.includes("---BEGIN"));
      if (last_non_context_system_idx > -1)
        out.system = opts.messages[last_non_context_system_idx].content;
      return out;
    }
    exports2.chatml_to_anthropic = chatml_to_anthropic;
  }
});

// node_modules/smart-chat-model/adapters/cohere.js
var require_cohere = __commonJS({
  "node_modules/smart-chat-model/adapters/cohere.js"(exports2) {
    var CohereAdapter = class {
      /**
       * Converts a ChatML object to a format suitable for a request to the Cohere API.
       * @param {Object} chatml - The ChatML object containing the chat history and other parameters.
       * @returns {Object} The request body formatted for the Cohere API.
       */
      prepare_request_body(chatml) {
        return chatml_to_cohere(chatml);
      }
      /**
       * Extracts the message content from a JSON response from the Cohere API.
       * @param {Object} json - The JSON response object from which to extract the text content.
       * @returns {string} The extracted text content from the response.
       */
      get_message_content(json) {
        return json.text;
      }
      /**
       * Processes streaming data received from the Cohere API and extracts text chunks.
       * This method handles the accumulation of text data over multiple events and manages the state of the stream.
       * @param {Object} event - The event object containing streaming data.
       * @returns {string} The accumulated text chunk extracted from the stream.
       */
      get_text_chunk_from_stream(event) {
        if (!this.last_line_index)
          this.last_line_index = 0;
        clearTimeout(this.last_line_timeout);
        this.last_line_timeout = setTimeout(() => {
          this.last_line_index = 0;
        }, 1e4);
        const data = event.source.xhr.responseText;
        const lines = data.split("\n").slice(this.last_line_index);
        console.log(lines);
        this.last_line_index += lines.length;
        const text_chunk = lines.filter((line) => line.trim() !== "").map((line) => {
          console.log(line);
          const json = JSON.parse(line);
          if (json.event_type === "stream-end") {
            console.log("stream-end");
            this.end_of_stream = true;
            setTimeout(() => {
              this.end_of_stream = false;
            }, 3e3);
            return "";
          }
          return json.text;
        }).join("");
        console.log(text_chunk);
        return text_chunk;
      }
      /**
       * Determines if the end of the stream has been reached based on the event data.
       * @param {Object} event - The event object that may indicate the end of the stream.
       * @returns {boolean} True if the end of the stream is indicated, false otherwise.
       */
      is_end_of_stream(event) {
        return this.end_of_stream;
      }
    };
    exports2.CohereAdapter = CohereAdapter;
    function chatml_to_cohere(chatml) {
      const cohere = {
        model: chatml.model,
        // skip last user message
        chat_history: chatml.messages.slice(0, -1).map((message) => ({
          role: message.role,
          message: parse_message_content_to_string(message)
        })),
        message: parse_message_content_to_string(chatml.messages[chatml.messages.length - 1]),
        temperature: chatml.temperature
        // stream: chatml.stream // currently not supported
      };
      return cohere;
    }
    exports2.chatml_to_cohere = chatml_to_cohere;
    function parse_message_content_to_string(message) {
      return Array.isArray(message.content) ? message.content.filter((c) => c.type === "text").map((c) => c.text).join("\n") : message.content;
    }
  }
});

// node_modules/smart-chat-model/adapters/gemini.js
var require_gemini = __commonJS({
  "node_modules/smart-chat-model/adapters/gemini.js"(exports2) {
    var GeminiAdapter = class {
      /**
       * Constructs a GeminiAdapter instance with a specified model configuration.
       * @param {Object} model - The model configuration object.
       */
      constructor(model) {
        this.model = model;
      }
      /**
       * Prepares the request body for the Gemini API by converting ChatML format to a format compatible with Gemini.
       * @param {Object} body - The options object containing messages and other parameters in ChatML format.
       * @returns {Object} The request body formatted for the Gemini API.
       */
      prepare_request_body(body) {
        return chatml_to_gemini(body);
      }
      /**
       * Extracts the first tool call from the JSON response content.
       * @param {Object} json - The JSON response from which to extract the tool call.
       * @returns {Object|null} The first tool call found, or null if none exist.
       */
      get_tool_call(json) {
        var _a, _b, _c, _d, _e;
        return (_e = (_d = (_c = (_b = (_a = json.candidates) == null ? void 0 : _a[0]) == null ? void 0 : _b.content) == null ? void 0 : _c.parts) == null ? void 0 : _d[0]) == null ? void 0 : _e.functionCall;
      }
      /**
       * Retrieves the name of the tool from a tool call object.
       * @param {Object} tool_call - The tool call object from which to extract the name.
       * @returns {string|null} The name of the tool, or null if not available.
       */
      get_tool_name(tool_call) {
        return tool_call == null ? void 0 : tool_call.name;
      }
      /**
       * Retrieves the input content of a tool call.
       * @param {Object} tool_call - The tool call object from which to extract the input.
       * @returns {Object|null} The input of the tool call, or null if not available.
       */
      get_tool_call_content(tool_call) {
        return tool_call == null ? void 0 : tool_call.args;
      }
      /**
       * Extracts the first message from the JSON response content.
       * @param {Object} json - The JSON response from which to extract the message.
       * @returns {Object|null} The first message found, or null if none exist.
       */
      get_message(json) {
        var _a;
        return (_a = json.candidates) == null ? void 0 : _a[0];
      }
      /**
       * Retrieves the content of the first message from the JSON response.
       * @param {Object} json - The JSON response from which to extract the message content.
       * @returns {string|null} The content of the first message, or null if no message is found.
       */
      get_message_content(json) {
        var _a, _b;
        return (_b = (_a = this.get_message(json)) == null ? void 0 : _a.content) == null ? void 0 : _b.parts.map((part) => part.text).join("");
      }
      /**
       * Handles escaped newlines in a streaming text chunk.
       * @param {Object} event - The streaming event containing the data.
       * @returns {string} The text chunk with escaped newlines replaced.
       */
      get_text_chunk_from_stream(event) {
        return event.data.replace(/\\n/g, "\n");
      }
      /**
       * Determines if the streaming response has ended based on the readyState of the XMLHttpRequest.
       * @param {Object} event - The streaming event.
       * @returns {boolean} True if the stream has ended, false otherwise.
       */
      is_end_of_stream(event) {
        return event.source.xhr.readyState === 4;
      }
      /**
       * Counts the tokens in the input by making an API request to the Gemini token counting endpoint.
       * @param {string|Object} input - The input text or object to count tokens in.
       * @returns {Promise<number>} The total number of tokens in the input.
       */
      async count_tokens(input) {
        var _a;
        const req = {
          url: `https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:countTokens?key=${this.model.api_key}`,
          method: "POST",
          headers: { "Content-Type": "application/json" }
        };
        let body;
        if (typeof input === "string")
          body = chatml_to_gemini({ messages: [{ role: "user", content: input }] });
        else if (Array.isArray(input))
          body = chatml_to_gemini({ messages: input });
        else if (typeof input === "object")
          body = chatml_to_gemini(input);
        else
          return console.error("Invalid input for count_tokens", input);
        delete body.generationConfig;
        delete body.safetySettings;
        req.body = JSON.stringify(body);
        const resp = await this.model.request_adapter(req);
        return (_a = resp == null ? void 0 : resp.json) == null ? void 0 : _a.totalTokens;
      }
      /**
       * Getter for the standard API endpoint with the API key appended.
       * @returns {string} The formatted endpoint URL for non-streaming requests.
       */
      get endpoint() {
        return this.model.config.endpoint.replace("MODEL_NAME", this.model.model_name) + "?key=" + this.model.api_key;
      }
      /**
       * Getter for the streaming API endpoint with the API key appended.
       * @returns {string} The formatted endpoint URL for streaming requests.
       */
      get endpoint_streaming() {
        return this.model.config.endpoint_streaming.replace("MODEL_NAME", this.model.model_name) + "?key=" + this.model.api_key;
      }
    };
    exports2.GeminiAdapter = GeminiAdapter;
    function chatml_to_gemini(opts) {
      const messages = opts.messages.filter((msg) => msg.role !== "system");
      const last_system_idx = opts.messages.findLastIndex((msg) => msg.role === "system" && msg.content.includes("---BEGIN"));
      if (last_system_idx > -1) {
        const system_prompt = "---BEGIN IMPORTANT CONTEXT---\n" + opts.messages[last_system_idx].content + "\n---END IMPORTANT CONTEXT---\n\n";
        messages[messages.length - 1].content = system_prompt + messages[messages.length - 1].content;
      }
      const body = {
        contents: messages.filter((msg) => msg.role !== "system").map((msg) => {
          const content = {};
          content.role = msg.role === "assistant" ? "model" : msg.role;
          content.parts = !Array.isArray(msg.content) ? [{ text: msg.content }] : msg.content.map((c) => {
            if (c.type === "text") {
              return { text: c.text };
            }
            if (c.type === "image_url") {
              const image_url = c.image_url.url;
              let mime_type = image_url.split(":")[1].split(";")[0];
              if (mime_type === "image/jpg")
                mime_type = "image/jpeg";
              return { inline_data: { mime_type, data: image_url.split(",")[1] } };
            }
          });
          return content;
          ({
            role: msg.role === "assistant" ? "model" : msg.role,
            parts: Array.isArray(msg.content) ? [{ text: msg.content.filter((c) => c.type === "text").map((c) => c.text).join("\n") }] : [{ text: msg.content }]
          });
        }),
        generationConfig: {
          temperature: opts.temperature || 0.9,
          topK: opts.topK || 1,
          topP: opts.topP || 1,
          maxOutputTokens: opts.max_tokens || 2048,
          stopSequences: opts.stopSequences || [],
          candidate_count: opts.n || 1
        },
        safetySettings: [
          {
            category: "HARM_CATEGORY_HARASSMENT",
            threshold: "BLOCK_NONE"
          },
          {
            category: "HARM_CATEGORY_HATE_SPEECH",
            threshold: "BLOCK_NONE"
          },
          {
            category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
            threshold: "BLOCK_NONE"
          },
          {
            category: "HARM_CATEGORY_DANGEROUS_CONTENT",
            threshold: "BLOCK_NONE"
          }
        ]
      };
      const system_instructions = opts.messages.filter((msg) => msg.role === "system" && !msg.content.includes("---BEGIN"));
      if (system_instructions.length > 0)
        body.systemInstruction = { parts: system_instructions.map((msg) => ({ text: msg.content })) };
      if (opts.tools) {
        body.tools = [{
          function_declarations: opts.tools.map((tool) => ({
            name: tool.function.name,
            description: tool.function.description,
            parameters: tool.function.parameters
          }))
        }];
        body.tool_config = {
          function_calling_config: {
            mode: "ANY"
          }
        };
        const tool_prompt = `Use the "${body.tools[0].function_declarations[0].name}" tool!`;
        const last_user_idx = body.contents.findLastIndex((msg) => msg.role === "user");
        body.contents[last_user_idx].parts[0].text += "\n" + tool_prompt;
      }
      return body;
    }
    exports2.chatml_to_gemini = chatml_to_gemini;
  }
});

// node_modules/smart-chat-model/adapters.js
var require_adapters2 = __commonJS({
  "node_modules/smart-chat-model/adapters.js"(exports2) {
    var { AnthropicAdapter } = require_anthropic();
    var { CohereAdapter } = require_cohere();
    var { GeminiAdapter } = require_gemini();
    exports2.Anthropic = AnthropicAdapter;
    exports2.Cohere = CohereAdapter;
    exports2.Gemini = GeminiAdapter;
  }
});

// node_modules/smart-chat-model/platforms.json
var require_platforms = __commonJS({
  "node_modules/smart-chat-model/platforms.json"(exports2, module2) {
    module2.exports = {
      openai: {
        description: "OpenAI",
        type: "API",
        endpoint: "https://api.openai.com/v1/chat/completions",
        streaming: true,
        actions: true,
        fetch_models: true,
        default_model: "gpt-3.5-turbo",
        signup_url: "https://platform.openai.com/api-keys"
      },
      google_gemini: {
        description: "Google Gemini",
        type: "API",
        api_key_header: "none",
        endpoint: "https://generativelanguage.googleapis.com/v1beta/models/MODEL_NAME:generateContent",
        endpoint_streaming: "https://generativelanguage.googleapis.com/v1beta/models/MODEL_NAME:streamGenerateContent",
        streaming: true,
        actions: true,
        adapter: "Gemini",
        fetch_models: true,
        default_model: "gemini-1.0-pro",
        signup_url: "https://ai.google.dev/"
      },
      open_router: {
        description: "Open Router",
        type: "API",
        endpoint: "https://openrouter.ai/api/v1/chat/completions",
        streaming: true,
        fetch_models: true,
        default_model: "mistralai/mistral-7b-instruct:free",
        signup_url: "https://accounts.openrouter.ai/sign-up?redirect_url=https%3A%2F%2Fopenrouter.ai%2Fkeys"
      },
      cohere: {
        description: "Cohere Command-R",
        type: "API",
        endpoint: "https://api.cohere.ai/v1/chat",
        streaming: false,
        adapter: "Cohere",
        fetch_models: true,
        default_model: "command-r",
        signup_url: "https://dashboard.cohere.com/welcome/register?redirect_uri=%2Fapi-keys"
      },
      anthropic: {
        description: "Anthropic Claude",
        type: "API",
        endpoint: "https://api.anthropic.com/v1/messages",
        streaming: false,
        api_key_header: "x-api-key",
        headers: {
          "anthropic-version": "2023-06-01",
          "anthropic-beta": "tools-2024-04-04"
        },
        adapter: "Anthropic",
        actions: true,
        fetch_models: true,
        default_model: "claude-3-sonnet-20240229",
        signup_url: "https://console.anthropic.com/login?returnTo=%2Fsettings%2Fkeys"
      },
      custom_local: {
        model_name: "custom_local",
        description: "Custom Local (OpenAI format)",
        type: "API"
      },
      custom_api: {
        model_name: "custom_api",
        description: "Custom API (OpenAI format)",
        type: "API"
      }
    };
  }
});

// node_modules/smart-chat-model/utils/is_valid_tool_call.js
var require_is_valid_tool_call = __commonJS({
  "node_modules/smart-chat-model/utils/is_valid_tool_call.js"(exports2) {
    function is_valid_tool_call(tool, tool_call_content) {
      var _a;
      const props = tool.function.parameters.properties;
      if (Object.keys(tool_call_content).length === 0)
        throw new Error(`Invalid tool call: object is empty`);
      Object.entries(tool_call_content).forEach(([key, value]) => {
        if (!props[key])
          throw new Error(`Invalid tool call: missing key ${key} in tool spec`, props);
        if (Array.isArray(value) && props[key].type === "array") {
          const itemType = typeof value[0];
          if (!value.every((item) => typeof item === itemType))
            throw new Error(`Invalid tool call: array items are not of the same type`);
          if (props[key].items.type !== itemType)
            throw new Error(`Invalid tool call: array items are not of the same type as the spec`);
        } else if (props[key].type !== typeof value) {
          if (props[key].type === "number" && typeof value === "string") {
            if (isNaN(Number(value)))
              throw new Error(`Invalid tool call: value ${value} is not a valid number`);
            tool_call_content[key] = Number(value);
          } else
            throw new Error(`Invalid tool call: value ${value} is not of type ${props[key].type}`);
        }
        if (props[key].enum && !props[key].enum.includes(value))
          throw new Error(`Invalid tool call: value ${value} is not in enum ${props[key].enum}`);
      });
      (_a = tool.function.parameters.required) == null ? void 0 : _a.forEach((key) => {
        if (!tool_call_content[key])
          throw new Error(`Invalid tool call: missing required key ${key}`);
      });
      return true;
    }
    exports2.is_valid_tool_call = is_valid_tool_call;
  }
});

// node_modules/smart-chat-model/streamer.js
var require_streamer = __commonJS({
  "node_modules/smart-chat-model/streamer.js"(exports2) {
    var _setReadyState, setReadyState_fn, _onStreamFailure, onStreamFailure_fn, _onStreamAbort, onStreamAbort_fn, _onStreamProgress, onStreamProgress_fn, _onStreamLoaded, onStreamLoaded_fn, _parseEventChunk, parseEventChunk_fn, _checkStreamClosed, checkStreamClosed_fn;
    var SmartStreamer = class {
      constructor(url, options = {}) {
        // private methods
        __privateAdd(this, _setReadyState);
        __privateAdd(this, _onStreamFailure);
        __privateAdd(this, _onStreamAbort);
        __privateAdd(this, _onStreamProgress);
        __privateAdd(this, _onStreamLoaded);
        __privateAdd(this, _parseEventChunk);
        __privateAdd(this, _checkStreamClosed);
        const {
          method = "GET",
          headers = {},
          body = null,
          withCredentials = false
        } = options;
        this.url = url;
        this.method = method;
        this.headers = headers;
        this.body = body;
        this.withCredentials = withCredentials;
        this.listeners = {};
        this.readyState = this.CONNECTING;
        this.progress = 0;
        this.chunk = "";
        this.last_event_id = "";
        this.xhr = null;
        this.FIELD_SEPARATOR = ":";
        this.INITIALIZING = -1;
        this.CONNECTING = 0;
        this.OPEN = 1;
        this.CLOSED = 2;
      }
      /**
       * Adds an event listener for the specified event type.
       *
       * @param {string} type - The type of the event.
       * @param {Function} listener - The listener function to be called when the event is triggered.
       */
      addEventListener(type, listener) {
        if (!this.listeners[type])
          this.listeners[type] = [];
        if (!this.listeners[type].includes(listener))
          this.listeners[type].push(listener);
      }
      /**
       * Removes an event listener from the SmartStreamer instance.
       *
       * @param {string} type - The type of event to remove the listener from.
       * @param {Function} listener - The listener function to remove.
       */
      removeEventListener(type, listener) {
        if (!this.listeners[type])
          return;
        this.listeners[type] = this.listeners[type].filter((callback) => callback !== listener);
        if (this.listeners[type].length === 0)
          delete this.listeners[type];
      }
      /**
       * Dispatches an event to the appropriate event handlers.
       *
       * @param {Event} event - The event to be dispatched.
       * @returns {boolean} - Returns true if the event was successfully dispatched, false otherwise.
       */
      dispatchEvent(event) {
        if (!event)
          return true;
        event.source = this;
        const onHandler = "on" + event.type;
        if (Object.prototype.hasOwnProperty.call(this, onHandler)) {
          this[onHandler].call(this, event);
          if (event.defaultPrevented)
            return false;
        }
        if (this.listeners[event.type]) {
          this.listeners[event.type].forEach((callback) => {
            callback(event);
            return !event.defaultPrevented;
          });
        }
        return true;
      }
      /**
       * Initiates the streaming process.
       */
      stream() {
        __privateMethod(this, _setReadyState, setReadyState_fn).call(this, this.CONNECTING);
        this.xhr = new XMLHttpRequest();
        this.xhr.addEventListener("progress", __privateMethod(this, _onStreamProgress, onStreamProgress_fn).bind(this));
        this.xhr.addEventListener("load", __privateMethod(this, _onStreamLoaded, onStreamLoaded_fn).bind(this));
        this.xhr.addEventListener("readystatechange", __privateMethod(this, _checkStreamClosed, checkStreamClosed_fn).bind(this));
        this.xhr.addEventListener("error", __privateMethod(this, _onStreamFailure, onStreamFailure_fn).bind(this));
        this.xhr.addEventListener("abort", __privateMethod(this, _onStreamAbort, onStreamAbort_fn).bind(this));
        this.xhr.open(this.method, this.url);
        for (const header in this.headers) {
          this.xhr.setRequestHeader(header, this.headers[header]);
        }
        if (this.last_event_id)
          this.xhr.setRequestHeader("Last-Event-ID", this.last_event_id);
        this.xhr.withCredentials = this.withCredentials;
        this.xhr.send(this.body);
      }
      /**
       * Ends the streamer connection.
       * Aborts the current XHR request and sets the ready state to CLOSED.
       */
      end() {
        if (this.readyState === this.CLOSED)
          return;
        this.xhr.abort();
        this.xhr = null;
        __privateMethod(this, _setReadyState, setReadyState_fn).call(this, this.CLOSED);
      }
    };
    _setReadyState = new WeakSet();
    setReadyState_fn = function(state) {
      const event = new CustomEvent("readyStateChange");
      event.readyState = state;
      this.readyState = state;
      this.dispatchEvent(event);
    };
    _onStreamFailure = new WeakSet();
    onStreamFailure_fn = function(e) {
      const event = new CustomEvent("error");
      event.data = e.currentTarget.response;
      this.dispatchEvent(event);
      this.end();
    };
    _onStreamAbort = new WeakSet();
    onStreamAbort_fn = function(e) {
      const event = new CustomEvent("abort");
      this.end();
    };
    _onStreamProgress = new WeakSet();
    onStreamProgress_fn = function(e) {
      if (!this.xhr)
        return;
      if (this.xhr.status !== 200) {
        __privateMethod(this, _onStreamFailure, onStreamFailure_fn).call(this, e);
        return;
      }
      if (this.readyState === this.CONNECTING) {
        this.dispatchEvent(new CustomEvent("open"));
        __privateMethod(this, _setReadyState, setReadyState_fn).call(this, this.OPEN);
      }
      const data = this.xhr.responseText.substring(this.progress);
      this.progress += data.length;
      data.split(/(\r\n|\r|\n)/g).forEach((part) => {
        if (part.trim().length === 0) {
          this.dispatchEvent(__privateMethod(this, _parseEventChunk, parseEventChunk_fn).call(this, this.chunk.trim()));
          this.chunk = "";
        } else {
          this.chunk += part;
        }
      });
    };
    _onStreamLoaded = new WeakSet();
    onStreamLoaded_fn = function(e) {
      __privateMethod(this, _onStreamProgress, onStreamProgress_fn).call(this, e);
      this.dispatchEvent(__privateMethod(this, _parseEventChunk, parseEventChunk_fn).call(this, this.chunk));
      this.chunk = "";
    };
    _parseEventChunk = new WeakSet();
    parseEventChunk_fn = function(chunk) {
      if (!chunk || chunk.length === 0)
        return null;
      const e = { id: null, retry: null, data: "", event: "message", text: "" };
      chunk.split(/(\r\n|\r|\n)/).forEach((line) => {
        line = line.trim();
        const index = line.indexOf(this.FIELD_SEPARATOR);
        if (index <= 0)
          return;
        const field = line.substring(0, index).replace(/^"|"$/g, "");
        if (!["id", "retry", "data", "event", "text"].includes(field))
          return;
        const value = line.substring(index + 1).trim().replace(/^"|"$/g, "");
        e.data += value;
      });
      if (e.id)
        this.last_event_id = e.id;
      const event = new CustomEvent(e.event || "message");
      event.id = e.id;
      event.data = e.data || "";
      event.last_event_id = this.last_event_id;
      return event;
    };
    _checkStreamClosed = new WeakSet();
    checkStreamClosed_fn = function() {
      if (!this.xhr)
        return;
      if (this.xhr.readyState === XMLHttpRequest.DONE)
        __privateMethod(this, _setReadyState, setReadyState_fn).call(this, this.CLOSED);
    };
    exports2.SmartStreamer = SmartStreamer;
  }
});

// node_modules/smart-chat-model/models/open_router.js
var require_open_router = __commonJS({
  "node_modules/smart-chat-model/models/open_router.js"(exports2) {
    async function fetch_open_router_models() {
      try {
        const response = await fetch("https://openrouter.ai/api/v1/models");
        if (!response.ok) {
          throw new Error("Network response was not ok");
        }
        const data = await response.json();
        console.log("Model data retrieved:", data);
        return data.data.map((model) => ({
          model_name: model.id,
          key: model.id,
          max_input_tokens: model.context_length,
          description: model.name,
          actions: model.description.includes("tool use") || model.description.includes("function call"),
          multimodal: model.architecture.modality === "multimodal",
          raw: model
        }));
      } catch (error) {
        console.error("Failed to fetch model data:", error);
        return [];
      }
    }
    exports2.fetch_open_router_models = fetch_open_router_models;
  }
});

// node_modules/smart-chat-model/models/openai.js
var require_openai = __commonJS({
  "node_modules/smart-chat-model/models/openai.js"(exports2) {
    var model_context = {
      "gpt-3.5-turbo": {
        "context": 16385,
        "max_out": 4096
      },
      "gpt-3.5-turbo-0125": {
        "context": 16385,
        "max_out": 4096
      },
      "gpt-3.5-turbo-0301": {
        "context": 4097,
        "max_out": 4097
      },
      "gpt-3.5-turbo-0613": {
        "context": 4097,
        "max_out": 4097
      },
      "gpt-3.5-turbo-1106": {
        "context": 16385,
        "max_out": 4096
      },
      "gpt-3.5-turbo-16k": {
        "context": 16385,
        "max_out": 16385
      },
      "gpt-3.5-turbo-16k-0613": {
        "context": 16385,
        "max_out": 16385
      },
      "gpt-4": {
        "context": 8192,
        "max_out": 8192
      },
      "gpt-4-0125-preview": {
        "context": 128e3,
        "max_out": 4096
      },
      "gpt-4-0314": {
        "context": 8192,
        "max_out": 8192
      },
      "gpt-4-0613": {
        "context": 8192,
        "max_out": 8192
      },
      "gpt-4-1106-preview": {
        "context": 128e3,
        "max_out": 4096
      },
      "gpt-4-1106-vision-preview": {
        "context": 128e3,
        "max_out": 4096
      },
      "gpt-4-32k": {
        "context": 32768,
        "max_out": 32768
      },
      "gpt-4-32k-0314": {
        "context": 32768,
        "max_out": 32768
      },
      "gpt-4-32k-0613": {
        "context": 32768,
        "max_out": 32768
      },
      "gpt-4-turbo": {
        "context": 128e3,
        "max_out": 4096
      },
      "gpt-4-turbo-2024-04-09": {
        "context": 128e3,
        "max_out": 4096
      },
      "gpt-4-turbo-preview": {
        "context": 128e3,
        "max_out": 4096
      },
      "gpt-4-vision-preview": {
        "context": 128e3,
        "max_out": 4096
      }
    };
    async function fetch_openai_models(api_key) {
      if (!api_key) {
        console.error("No API key provided");
        return [];
      }
      try {
        const response = await fetch("https://api.openai.com/v1/models", {
          headers: {
            "Authorization": `Bearer ${api_key}`
          }
        });
        if (!response.ok) {
          throw new Error("Network response was not ok");
        }
        const data = await response.json();
        console.log("Model data retrieved:", data);
        return data.data.filter((model) => model.id.startsWith("gpt-") && !model.id.includes("-instruct")).map((model) => {
          const out = {
            model_name: model.id,
            key: model.id,
            multimodal: model.id.includes("vision") || model.id.includes("gpt-4-turbo")
          };
          if (model_context[model.id]) {
            out.max_input_tokens = model_context[model.id].context;
            out.description = `context: ${model_context[model.id].context}, output: ${model_context[model.id].max_out}`;
          }
          return out;
        });
      } catch (error) {
        console.error("Failed to fetch model data:", error);
        return [];
      }
    }
    exports2.fetch_openai_models = fetch_openai_models;
  }
});

// node_modules/smart-chat-model/models/google_gemini.js
var require_google_gemini = __commonJS({
  "node_modules/smart-chat-model/models/google_gemini.js"(exports2) {
    async function fetch_google_gemini_models(api_key) {
      if (!api_key) {
        console.error("No API key provided");
        return [];
      }
      try {
        const response = await fetch("https://generativelanguage.googleapis.com/v1beta/models?key=" + api_key);
        if (!response.ok) {
          throw new Error("Network response was not ok");
        }
        const data = await response.json();
        console.log("Model data retrieved:", data);
        return data.models.filter((model) => model.name.startsWith("models/gemini")).map((model) => {
          const out = {
            model_name: model.name.split("/").pop(),
            key: model.name.split("/").pop(),
            max_input_tokens: model.inputTokenLimit,
            max_output_tokens: model.maxOutputTokens,
            description: model.description,
            multimodal: model.name.includes("vision") || model.description.includes("multimodal"),
            raw: model
          };
          return out;
        });
      } catch (error) {
        console.error("Failed to fetch model data:", error);
        return [];
      }
    }
    exports2.fetch_google_gemini_models = fetch_google_gemini_models;
  }
});

// node_modules/smart-chat-model/models/cohere.js
var require_cohere2 = __commonJS({
  "node_modules/smart-chat-model/models/cohere.js"(exports2) {
    async function fetch_cohere_models(api_key) {
      if (!api_key) {
        console.error("No API key provided");
        return [];
      }
      try {
        const response = await fetch("https://api.cohere.ai/v1/models", {
          headers: {
            "Authorization": `Bearer ${api_key}`
          }
        });
        if (!response.ok) {
          throw new Error("Network response was not ok");
        }
        const data = await response.json();
        console.log("Model data retrieved:", data);
        return data.models.filter((model) => model.name.startsWith("command-")).map((model) => {
          const out = {
            model_name: model.name,
            key: model.name,
            max_input_tokens: model.context_length,
            tokenizer_url: model.tokenizer_url,
            finetuned: model.finetuned,
            description: `Max input tokens: ${model.context_length}, Finetuned: ${model.finetuned}`
          };
          return out;
        });
      } catch (error) {
        console.error("Failed to fetch model data:", error);
        return [];
      }
    }
    exports2.fetch_cohere_models = fetch_cohere_models;
  }
});

// node_modules/smart-chat-model/models/anthropic.js
var require_anthropic2 = __commonJS({
  "node_modules/smart-chat-model/models/anthropic.js"(exports2) {
    async function fetch_anthropic_models() {
      return [
        {
          "key": "claude-3-opus-20240229",
          "model_name": "claude-3-opus-20240229",
          "description": "Anthropic's Claude Opus",
          "max_input_tokens": 2e5,
          "max_output_tokens": 4e3,
          "multimodal": true
        },
        {
          key: "claude-3-sonnet-20240229",
          "model_name": "claude-3-sonnet-20240229",
          "description": "Anthropic's Claude Sonnet",
          "max_input_tokens": 2e5,
          "max_output_tokens": 4e3,
          "multimodal": true
        },
        {
          key: "claude-3-haiku-20240307",
          "model_name": "claude-3-haiku-20240307",
          "description": "Anthropic's Claude Haiku",
          "max_input_tokens": 2e5,
          "max_output_tokens": 4e3,
          "multimodal": true
        }
      ];
    }
    exports2.fetch_anthropic_models = fetch_anthropic_models;
  }
});

// node_modules/smart-chat-model/models/fetch.js
var require_fetch = __commonJS({
  "node_modules/smart-chat-model/models/fetch.js"(exports2) {
    var { fetch_open_router_models } = require_open_router();
    var { fetch_openai_models } = require_openai();
    var { fetch_google_gemini_models } = require_google_gemini();
    var { fetch_cohere_models } = require_cohere2();
    var { fetch_anthropic_models } = require_anthropic2();
    exports2.open_router = fetch_open_router_models;
    exports2.openai = fetch_openai_models;
    exports2.google_gemini = fetch_google_gemini_models;
    exports2.cohere = fetch_cohere_models;
    exports2.anthropic = fetch_anthropic_models;
  }
});

// node_modules/smart-chat-model/smart_chat_model.js
var require_smart_chat_model = __commonJS({
  "node_modules/smart-chat-model/smart_chat_model.js"(exports2) {
    var adapters = require_adapters2();
    var platforms = require_platforms();
    var { is_valid_tool_call } = require_is_valid_tool_call();
    var { SmartStreamer } = require_streamer();
    var fetch_models = require_fetch();
    var SmartChatModel = class {
      /**
       * Constructs an instance of SmartChatModel with specified environment, model key, and options.
       * @param {Object} main - The main environment context, typically containing configurations and state.
       * @param {string} platform_key - Key to select the specific model configuration from models.json.
       * @param {Object} model_config - Optional parameters to override model configurations.
       */
      constructor(main, platform_key, model_config = {}) {
        this.env = main;
        this.main = this.env;
        this.config = {
          ...platforms[platform_key] || {},
          ...model_config
          // override default platform config
        };
        this.platform_key = platform_key;
        this.active_stream = null;
        this._request_adapter = null;
        this.platforms = platforms;
        if (this.config.adapter)
          this.adapter = new adapters[this.config.adapter](this);
        console.log(this.adapter);
      }
      static get models() {
        return platforms;
      }
      get default_opts() {
        return {
          temperature: 0.3,
          top_p: 1,
          presence_penalty: 0,
          frequency_penalty: 0,
          n: 1,
          model: this.model_name,
          max_tokens: this.max_output_tokens
        };
      }
      async request_middlewares(opts) {
        return opts;
      }
      /**
       * Completes the chat interaction by processing the provided options, making an API request, and handling the response.
       * This method supports both streaming and non-streaming responses, and can handle tool calls if specified in the response.
       *
       * @param {Object} opts - The options for the chat completion which may include settings like temperature, max tokens, etc.
       * @param {boolean} render - Flag to determine if the response should be rendered in the UI.
       * @returns {Promise<string|void>} - Returns the chat response content or handles tool outputs recursively. In case of errors, it may return an error message.
       */
      async complete(opts = {}, render = true) {
        var _a, _b, _c, _d;
        if (!this.base_model_config) {
          this.base_model_config = await this.get_base_model_config();
          this.config = {
            ...this.base_model_config,
            ...this.config
          };
        }
        opts = {
          ...this.default_opts,
          messages: ((_b = await ((_a = this.current) == null ? void 0 : _a.get_chat_ml())) == null ? void 0 : _b.messages) || [],
          ...opts
        };
        if (opts.stream !== false && this.config.streaming && !this.current.tool_choice)
          opts.stream = true;
        else
          opts.stream = false;
        opts = await this.request_middlewares(JSON.parse(JSON.stringify(opts)));
        const req = {
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${this.api_key}`
          },
          method: "POST"
        };
        if (this.config.headers)
          req.headers = { ...req.headers, ...this.config.headers };
        if (this.config.api_key_header) {
          if (this.config.api_key_header !== "none")
            req.headers[this.config.api_key_header] = this.api_key;
          delete req.headers.Authorization;
        }
        const body = typeof ((_c = this.env.actions) == null ? void 0 : _c.prepare_request_body) === "function" ? this.env.actions.prepare_request_body(opts) : { ...opts };
        req.body = JSON.stringify(typeof ((_d = this.adapter) == null ? void 0 : _d.prepare_request_body) === "function" ? this.adapter.prepare_request_body(body) : body);
        console.log(req);
        try {
          if (opts.stream)
            return await this.stream(req);
          const resp_json = await this.request(req);
          if (resp_json.error) {
            console.error(resp_json.error);
            if (render)
              this.done_handler("*API Error. See console logs for details.*");
            return;
          }
          const tool_call = this.get_tool_call(resp_json);
          if (tool_call) {
            this.env.chats.current.tool_choice = null;
            const tool_name = this.get_tool_name(tool_call);
            const tool_call_content = this.get_tool_call_content(tool_call);
            const tool = body.tools.find((t) => t.function.name === tool_name);
            if (is_valid_tool_call(tool, tool_call_content)) {
              await this.current.add_message({ role: "assistant", tool_calls: [{
                function: {
                  name: tool_name,
                  arguments: JSON.stringify(tool_call_content)
                }
              }] });
              const tool_handler = this.get_tool_handler(tool_name);
              if (!tool_handler)
                return console.error(`Tool ${tool_name} not found`);
              const tool_output = await tool_handler(this.env, tool_call_content);
              if (tool_output) {
                await this.current.add_tool_output(tool_name, tool_output);
                return this.complete({});
              }
            } else {
              console.error(`Invalid tool call: ${tool_call}`);
              if (render)
                this.done_handler("*Invalid tool call. See console logs for details.*");
              return "*Invalid tool call. See console logs for details.*";
            }
          }
          if (render)
            this.done_handler(this.get_message_content(resp_json));
          return this.get_message_content(resp_json);
        } catch (err) {
          console.error(err);
        }
      }
      // HANDLE TOOLS
      /**
       * Retrieves the tool handler function based on the tool name from the environment's actions.
       * This method can be overridden to use custom logic for handling tools.
       * 
       * @param {string} tool_name - The name of the tool for which the handler is to be retrieved.
       * @returns {Function} The handler function for the specified tool.
       */
      get_tool_handler(tool_name) {
        return this.env.actions.actions[tool_name].handler;
      }
      /**
       * Extracts the tool call information from a JSON response. This method supports adapter-specific logic.
       * If no adapter method is provided, it defaults to the expected OpenAI JSON format.
       * 
       * @param {Object} json - The JSON response from which to extract the tool call.
       * @returns {Object} The first tool call found in the response.
       */
      get_tool_call(json) {
        var _a, _b, _c;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.get_tool_call) === "function")
          return this.adapter.get_tool_call(json);
        return (_c = (_b = json.choices) == null ? void 0 : _b[0].message.tool_calls) == null ? void 0 : _c[0];
      }
      /**
       * Determines the tool name from a tool call object. Supports adapter-specific implementations.
       * Defaults to extracting the name directly from the tool call structure.
       * 
       * @param {Object} tool_call - The tool call object from which to extract the tool name.
       * @returns {string} The name of the tool.
       */
      get_tool_name(tool_call) {
        var _a;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.get_tool_name) === "function")
          return this.adapter.get_tool_name(tool_call);
        return tool_call.function.name;
      }
      /**
       * Extracts the tool call content from a tool call object. Supports adapter-specific logic.
       * Defaults to parsing the 'arguments' field of the tool call function as JSON.
       * 
       * @param {Object} tool_call - The tool call object from which to extract the content.
       * @returns {Object} The parsed arguments of the tool call.
       */
      get_tool_call_content(tool_call) {
        var _a;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.get_tool_call_content) === "function")
          return this.adapter.get_tool_call_content(tool_call);
        return JSON.parse(tool_call.function.arguments);
      }
      // HANDLE MESSAGES
      /**
       * Retrieves the message object from a JSON response. Supports adapter-specific implementations.
       * Defaults to handling both OpenAI and Ollama formats by checking for message structures in 'choices'.
       * 
       * @param {Object} json - The JSON response from which to extract the message.
       * @returns {Object} The message object extracted from the response.
       */
      get_message(json) {
        var _a, _b;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.get_message) === "function")
          return this.adapter.get_message(json);
        return ((_b = json.choices) == null ? void 0 : _b[0].message) || json.message;
      }
      /**
       * Extracts the content of a message from a JSON response. Supports adapter-specific implementations.
       * This method relies on `get_message` to first retrieve the message object.
       * 
       * @param {Object} json - The JSON response from which to extract the message content.
       * @returns {string} The content of the message.
       */
      get_message_content(json) {
        var _a;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.get_message_content) === "function")
          return this.adapter.get_message_content(json);
        return this.get_message(json).content;
      }
      async request(req) {
        req.url = this.endpoint;
        req.throw = false;
        const resp = this._request_adapter ? await this._request_adapter(req) : await fetch(this.endpoint, req);
        console.log(resp);
        const resp_json = await this.get_resp_json(resp);
        console.log(resp_json);
        return resp_json;
      }
      async get_resp_json(resp) {
        return typeof resp.json === "function" ? await resp.json() : await resp.json;
      }
      get request_adapter() {
        return this._request_adapter;
      }
      async stream(req) {
        console.log("Streaming Request: ");
        console.log(req);
        const full_text = await new Promise((resolve, reject) => {
          try {
            this.active_stream = new SmartStreamer(this.endpoint_streaming, req);
            let curr_text = "";
            this.active_stream.addEventListener("message", (e) => {
              if (this.is_end_of_stream(e)) {
                this.stop_stream();
                return resolve(curr_text);
              }
              let text_chunk = this.get_text_chunk_from_stream(e);
              if (!text_chunk)
                return;
              curr_text += text_chunk;
              this.chunk_handler(text_chunk);
            });
            this.active_stream.addEventListener("readystatechange", (e) => {
              if (e.readyState >= 2)
                console.log("ReadyState: " + e.readyState);
            });
            this.active_stream.addEventListener("error", (e) => {
              console.error(e);
              this.done_handler("*API Error. See console logs for details.*");
              this.stop_stream();
              reject(e);
            });
            this.active_stream.stream();
          } catch (err) {
            console.error(err);
            this.stop_stream();
            reject(err);
          }
        });
        this.done_handler(full_text);
        return full_text;
      }
      get_text_chunk_from_stream(event) {
        var _a;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.get_text_chunk_from_stream) === "function")
          return this.adapter.get_text_chunk_from_stream(event);
        let resp = null;
        let text_chunk = "";
        try {
          resp = JSON.parse(event.data);
          text_chunk = resp.choices[0].delta.content;
        } catch (err) {
          console.log(err);
          console.log(event.data);
          if (event.data.indexOf("}{") > -1)
            event.data = event.data.replace(/}{/g, "},{");
          resp = JSON.parse(`[${event.data}]`);
          resp.forEach((r) => {
            if (r.choices)
              text_chunk += r.choices[0].delta.content;
          });
        }
        return text_chunk;
      }
      is_end_of_stream(event) {
        var _a;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.is_end_of_stream) === "function")
          return this.adapter.is_end_of_stream(event);
        return event.data === "[DONE]";
      }
      stop_stream() {
        if (this.active_stream) {
          this.active_stream.end();
          this.active_stream = null;
        }
      }
      done_handler(full_str) {
        if (typeof this.main.done_handler === "function")
          this.main.done_handler(full_str);
      }
      chunk_handler(text_chunk) {
        if (typeof this.main.chunk_handler === "function")
          this.main.chunk_handler(text_chunk);
      }
      async count_tokens(input) {
        var _a;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.count_tokens) === "function")
          return await this.adapter.count_tokens(input);
        return this.estimate_tokens(input);
      }
      estimate_tokens(input) {
        var _a;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.estimate_tokens) === "function")
          return this.adapter.estimate_tokens(input);
        if (typeof input === "object")
          input = JSON.stringify(input);
        return input.length / 4;
      }
      async test_api_key() {
        console.log(this.api_key);
        try {
          const request2 = {
            messages: [
              { role: "user", content: "Hello" }
            ],
            temperature: 0,
            max_tokens: 100,
            stream: false,
            n: 1
          };
          if (this.config.fetch_models) {
            request2.model = this.config.default_model;
          }
          const resp = await this.complete(request2, false);
          console.log(resp);
          if (!resp)
            return false;
          return true;
        } catch (err) {
          console.error(err);
          return false;
        }
      }
      async get_models() {
        var _a;
        if (((_a = this.platforms[this.platform_key]) == null ? void 0 : _a.fetch_models) && typeof fetch_models[this.platform_key] === "function") {
          const models = await fetch_models[this.platform_key](this.api_key);
          if (models) {
            models.sort((a, b) => a.model_name.localeCompare(b.model_name));
            return models;
          } else
            console.error(`No models found for ${this.platform_key}`, models);
        }
        return [];
      }
      async get_base_model_config() {
        const models = await this.get_models();
        return models.find((m) => m.key === this.model_name);
      }
      // getters
      get api_key() {
        return this.config.api_key;
      }
      get current() {
        var _a;
        return (_a = this.env.chats) == null ? void 0 : _a.current;
      }
      // use endpoint of combine protocol, hostname, port, and path
      get endpoint() {
        var _a;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.endpoint) !== "undefined")
          return this.adapter.endpoint.replace("MODEL_NAME", this.model_name);
        return this.config.endpoint || this.config.protocol + "://" + this.config.hostname + (this.config.port ? ":" + this.config.port : "") + this.endpoint_path;
      }
      get endpoint_streaming() {
        var _a;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.endpoint_streaming) !== "undefined")
          return this.adapter.endpoint_streaming.replace("MODEL_NAME", this.model_name);
        return this.config.endpoint_streaming || this.endpoint;
      }
      get endpoint_path() {
        return this.config.path.startsWith("/") ? this.config.path : "/" + this.config.path;
      }
      get max_input_tokens() {
        return this.config.max_input_tokens;
      }
      get max_output_tokens() {
        return this.config.max_output_tokens;
      }
      get model_name() {
        return this.config.model_name || this.config.default_model;
      }
      get multimodal() {
        var _a;
        return typeof ((_a = this.adapter) == null ? void 0 : _a.multimodal) !== "undefined" ? this.adapter.multimodal : this.config.multimodal;
      }
    };
    exports2.SmartChatModel = SmartChatModel;
  }
});

// src/sc_chat_model.js
var require_sc_chat_model = __commonJS({
  "src/sc_chat_model.js"(exports2) {
    var ScTranslations = require_ScTranslations();
    var { SmartChatModel } = require_smart_chat_model();
    var ScChatModel = class extends SmartChatModel {
      async done_handler(full_str) {
        await this.env.chat_ui.new_message(full_str, "assistant");
        this.env.chats.current.add_message({ role: "assistant", content: full_str });
        this.env.chat_ui.clear_streaming_ux();
      }
      async chunk_handler(text_chunk) {
        await this.env.chat_ui.new_message(text_chunk, "assistant", true);
      }
      async request_middlewares(opts) {
        await Promise.all(opts.messages.map(async (msg, i) => {
          const context_start = "```sc-context";
          if (msg.role === "tool" && msg.tool_call_id === "lookup") {
            msg.role = "system";
            msg.content = context_start + "\n" + JSON.parse(msg.content).map((c) => c.path).join("\n") + "\n```";
          }
          if (msg.role === "system" && msg.content.includes(context_start)) {
            const context_start_i = msg.content.indexOf(context_start) + context_start.length;
            const context_end_i = msg.content.substring(context_start_i).indexOf("```");
            const raw_contents = msg.content.substring(context_start_i, context_start_i + context_end_i);
            const entities = this.env.plugin.get_entities_from_context_codeblock(raw_contents);
            let context = [];
            let tokens = [];
            await Promise.all(entities.map(async (entity, i2) => {
              if (!(entity == null ? void 0 : entity.get_as_context))
                return console.log(entity);
              context[i2] = await entity.get_as_context({ i: i2 });
              tokens[i2] = await this.count_tokens(context[i2]);
            }));
            let total_tokens = 0;
            let ct = 0;
            context = context.reduce((acc, c, i2) => {
              if (!c)
                return acc;
              if (total_tokens + tokens[i2] > this.max_input_tokens)
                return acc;
              total_tokens += tokens[i2];
              ct++;
              if (acc)
                acc += "\n";
              return acc + c;
            }, "");
            msg.content = this.get_prompt_context_prefix({ ct }) + "\n" + context;
          }
          const sys_start = "```sc-system";
          if (msg.role === "system" && msg.content.includes(sys_start)) {
            const sys_start_i = msg.content.indexOf(sys_start) + sys_start.length;
            const sys_end_i = msg.content.substring(sys_start_i).indexOf("```");
            const sys_prompts = msg.content.substring(sys_start_i, sys_start_i + sys_end_i).split("\n").filter((ln) => ln.trim());
            console.log(sys_prompts);
            msg.content = "";
            for (const sys_prompt of sys_prompts) {
              const tfile = this.env.system_prompts.find((file) => file.basename === sys_prompt);
              const note_content = await this.env.plugin.brain.cached_read(tfile);
              if (msg.content)
                msg.content += "\n";
              msg.content += note_content;
            }
          }
          return msg;
        }));
        opts.messages = opts.messages.filter((msg) => msg.role !== "assistant" || msg.content);
        console.log(opts.messages);
        return opts;
      }
      get_prompt_context_prefix(params = {}) {
        return `Anticipate the type of answer desired by the user. Imagine the following${params.ct ? " " + params.ct : ""} notes were written by the user and contain all the necessary information to answer the user's question. Begin responses with "${ScTranslations[this.env.plugin.settings.language].prompt}..."`;
      }
    };
    exports2.ScChatModel = ScChatModel;
  }
});

// node_modules/smart-chats/utils/message_content_array_to_markdown.js
var require_message_content_array_to_markdown = __commonJS({
  "node_modules/smart-chats/utils/message_content_array_to_markdown.js"(exports2) {
    function message_content_array_to_markdown(content) {
      let markdown = "";
      content.forEach((c, i) => {
        var _a;
        if (c.type === "text") {
          if (c.text.startsWith("Image caption: ")) {
            if (((_a = content[i - 1]) == null ? void 0 : _a.type) === "image_url") {
              markdown = markdown.split("\n").slice(0, -2).join("\n");
              markdown += `
![${c.text.split(":")[1].trim()}](${content[i - 1].image_url.url})`;
            } else {
              markdown += `${c.text}`;
            }
          } else {
            markdown += `${c.text}`;
          }
        } else if (c.type === "image_url")
          markdown += `![](${c.image_url.url})`;
        markdown += "\n";
      });
      return markdown.trim();
    }
    exports2.message_content_array_to_markdown = message_content_array_to_markdown;
  }
});

// node_modules/smart-chats/smart_chats_ui.js
var require_smart_chats_ui = __commonJS({
  "node_modules/smart-chats/smart_chats_ui.js"(exports2) {
    var { message_content_array_to_markdown } = require_message_content_array_to_markdown();
    var SmartChatsUI = class {
      /**
       * Creates an instance of SmartChatsUI.
       * @param {Object} env - The environment object containing configurations and utilities.
       * @param {HTMLElement} container - The HTML container element for the chat UI.
       */
      constructor(env, container) {
        this.env = env;
        this.main = this.env;
        this.container = container;
        this.templates = this.env.templates;
      }
      /**
       * Provides a context for the view rendering. Should be overridden in subclasses.
       * @returns {Object} The context object for the view.
       */
      get view_context() {
        return {
          /* override */
        };
      }
      /**
       * Renders templates using the environment's rendering engine.
       * @param {...any} args - Arguments including template and data to render.
       * @returns {Promise<string>} The rendered HTML string.
       */
      async render(...args) {
        return await this.env.ejs.render(...args);
      }
      /**
       * Displays a notice message in the console.
       * @param {string} message - The message to display.
       */
      show_notice(message) {
        console.log(message);
      }
      /**
       * Initializes the chat UI by clearing the container and rendering the initial chat template.
       */
      async init() {
        console.log("init SmartChatRenderer");
        console.log(this.container);
        this.container.innerHTML = "";
        console.log(this.env.chats.current);
        const data = await this.get_view_data();
        this.container.innerHTML = await this.render(this.templates.smart_chat, data, { context: this.view_context, rmWhitespace: true });
        this.post_process();
      }
      /**
       * Handles new user messages, updates the UI, and triggers rendering of typing indicator.
       * @param {string} user_input - The user's input message.
       */
      async new_user_message(user_input) {
        await this.new_message(user_input, "user");
        this.set_streaming_ux();
        await this.render_dotdotdot();
      }
      /**
       * Post-initialization processing, such as adding listeners and processing messages.
       */
      async post_process() {
        this.add_listeners();
        this.messages.forEach(this.message_post_process.bind(this));
      }
      /**
       * Placeholder for adding listeners. Should be overridden in subclasses.
       */
      add_listeners() {
      }
      /**
       * Placeholder for message post-processing. Should be overridden in subclasses.
       * @param {HTMLElement} msg_elm - The message element to process.
       */
      message_post_process(msg_elm) {
      }
      /**
       * Retrieves view data for rendering the chat interface.
       * @returns {Promise<Object>} An object containing data for the view.
       */
      add_message_listeners(msg_elm) {
      }
      // OVERRIDE
      async get_view_data() {
        var _a;
        const data = {
          name: ((_a = this.env.chats.current) == null ? void 0 : _a.name) || "UNTITLED CHAT",
          messages: await this.env.chats.current.get_messages_html()
        };
        return data;
      }
      /**
       * Adds input listeners to the chat form for handling special keys and sending messages.
       */
      add_chat_input_listeners() {
        const chat_input = this.container.querySelector(".sc-chat-form");
        const textarea = chat_input.querySelector("textarea");
        chat_input.addEventListener("keydown", (e) => {
          if (e.key === "Enter" && e.shiftKey) {
            e.preventDefault();
            if (this.prevent_input) {
              this.show_notice("Wait until current response is finished.");
              return;
            }
            let user_input = textarea.value;
            textarea.value = "";
            this.env.chats.current.new_user_message(user_input);
          }
          textarea.style.height = "auto";
          textarea.style.height = textarea.scrollHeight + "px";
        });
        const abort_button = this.container.querySelector("#sc-abort-button");
        abort_button.addEventListener("click", () => {
          this.env.chat_model.stop_stream();
          this.clear_streaming_ux();
        });
        const button = this.container.querySelector("#sc-send-button");
        button.addEventListener("click", () => {
          if (this.prevent_input) {
            this.show_notice("Wait until current response is finished.");
            return;
          }
          let user_input = textarea.value;
          textarea.value = "";
          this.env.chats.current.new_user_message(user_input);
        });
      }
      // render message
      async new_message(content, role = "assistant", append_last = false) {
        if (this.dotdotdot_interval) {
          if (!this.last_msg)
            this.message_container.insertAdjacentHTML("beforeend", await this.get_message_html(role, content));
          clearInterval(this.dotdotdot_interval);
          this.dotdotdot_interval = null;
          this.last_msg_content.innerHTML = "";
          this.last_msg.dataset.content = "";
        }
        if (this.last_msg && !this.last_msg.dataset.content)
          this.last_msg.dataset.content = "";
        if (append_last) {
          this.last_msg_content.innerHTML += content;
          this.last_msg.dataset.content += content;
          if (content.indexOf("\n") > -1)
            this.render_md_as_html(this.last_msg);
        } else {
          if (this.last_from !== role) {
            const html = await this.get_message_html(role, content);
            this.message_container.insertAdjacentHTML("beforeend", html);
            this.last_from = role;
            this.last_msg.dataset.content = content;
          } else {
            this.last_msg_content.innerHTML = content;
            this.last_msg.dataset.content = content;
          }
          this.message_post_process(this.last_msg);
        }
        this.message_container.scrollTop = this.message_container.scrollHeight;
      }
      /**
       * Generates HTML for a message based on the role and content.
       * @param {string} role - The role of the message sender.
       * @param {string} content - The content of the message.
       * @returns {Promise<string>} The HTML string for the message.
       */
      async get_message_html(role, content) {
        if (Array.isArray(content))
          content = message_content_array_to_markdown(content);
        return await this.render(this.templates.smart_chat_msg, { role, content }, { context: this.view_context, rmWhitespace: true });
      }
      async get_system_message_html(msg) {
        let { content, role } = msg;
        if (content.includes("```sc-system")) {
          content = content.replace(/```sc-system|```/g, "").trim();
          content = "system prompts: " + content.split("\n").filter((ln) => ln.trim()).join(", ");
        }
        if (content.includes("```sc-context")) {
          content = content.replace(/```sc-context|```/g, "").trim();
          content = "context: " + content.split("\n").filter((ln) => ln.trim()).join(", ");
          if (content.length > 100)
            content = content.substring(0, 100) + "...";
        }
        return await this.render(this.templates.smart_chat_system_msg, { content, role }, { context: this.view_context, rmWhitespace: true });
      }
      /**
       * Inserts selected text from a suggestion modal into the chat input.
       * @param {string} insert_text - The text to insert.
       */
      insert_selection(insert_text) {
        const textarea = this.container.querySelector(".sc-chat-form textarea");
        let caret_pos = textarea.selectionStart;
        let text_before = textarea.value.substring(0, caret_pos);
        let text_after = textarea.value.substring(caret_pos, textarea.value.length);
        textarea.value = text_before + insert_text + text_after;
        textarea.selectionStart = caret_pos + insert_text.length;
        textarea.selectionEnd = caret_pos + insert_text.length;
        textarea.focus();
      }
      /**
       * Renders a typing indicator ("...") and sets an interval to animate it.
       */
      async render_dotdotdot() {
        if (this.dotdotdot_interval)
          clearInterval(this.dotdotdot_interval);
        await this.new_message("...", "assistant");
        let dots = 0;
        const curr_msg = this.last_msg_content;
        curr_msg.innerHTML = "...";
        this.dotdotdot_interval = setInterval(() => {
          dots++;
          if (dots > 3)
            dots = 1;
          curr_msg.innerHTML = ".".repeat(dots);
        }, 500);
      }
      /**
       * Returns the message container element.
       * @returns {HTMLElement} The message container.
       */
      get message_container() {
        return this.container.querySelector(".sc-message-container");
      }
      /**
       * Returns the last message content element.
       * @returns {HTMLElement} The last message content element.
       */
      get last_msg() {
        return this.container.querySelector(".sc-message-container").lastElementChild.querySelector(".sc-message-content");
      }
      /**
       * Returns the last message content span element.
       * @returns {HTMLElement} The last message content span element.
       */
      get last_msg_content() {
        return this.last_msg.querySelector("span:not(.sc-msg-button)");
      }
      /**
       * Returns all message content elements.
       * @returns {NodeListOf<HTMLElement>} A NodeList of message content elements.
       */
      get messages() {
        return this.container.querySelectorAll(".sc-message-container .sc-message-content");
      }
      /**
       * Sets the user interface to a "streaming" mode, disabling input and showing an abort button.
       */
      set_streaming_ux() {
        this.prevent_input = true;
        if (this.container.querySelector("#sc-send-button"))
          this.container.querySelector("#sc-send-button").style.display = "none";
        if (this.container.querySelector("#sc-abort-button"))
          this.container.querySelector("#sc-abort-button").style.display = "block";
      }
      /**
       * Resets the user interface from "streaming" mode to normal.
       */
      unset_streaming_ux() {
        this.prevent_input = false;
        if (this.container.querySelector("#sc-send-button"))
          this.container.querySelector("#sc-send-button").style.display = "";
        if (this.container.querySelector("#sc-abort-button"))
          this.container.querySelector("#sc-abort-button").style.display = "none";
      }
      /**
       * Clears any streaming user interface effects, such as intervals and temporary elements.
       */
      clear_streaming_ux() {
        this.unset_streaming_ux();
        if (this.dotdotdot_interval) {
          clearInterval(this.dotdotdot_interval);
          this.dotdotdot_interval = null;
          this.active_elm.parentElement.remove();
          this.active_elm = null;
        }
      }
      /**
       * Update/set text in chat_input
       */
      set_chat_input_text(text) {
        const textarea = this.container.querySelector(".sc-chat-form textarea");
        textarea.value = text;
      }
    };
    exports2.SmartChatsUI = SmartChatsUI;
  }
});

// src/smart_obsidian_view.js
var require_smart_obsidian_view = __commonJS({
  "src/smart_obsidian_view.js"(exports2) {
    var { ItemView } = require("obsidian");
    var views = require_views();
    var ejs = require_ejs_min();
    var SmartObsidianView = class extends ItemView {
      constructor(leaf, plugin) {
        super(leaf);
        this.app = plugin.app;
        this.plugin = plugin;
        this.settings = plugin.settings;
        this.templates = views;
        this.ejs = ejs;
      }
      render_template(template_name, data) {
        if (!this.templates[template_name])
          throw new Error(`Template '${template_name}' not found.`);
        return ejs.render(this.templates[template_name], data, { context: this.view_context });
      }
      get view_context() {
        return {
          // app: this.plugin.app,
          attribution: this.templates.attribution,
          get_icon: this.get_icon.bind(this),
          settings: this.plugin.settings
        };
      }
      get_icon(name) {
        return this.plugin.obsidian.getIcon(name).outerHTML;
      }
      static get view_type() {
      }
      static get_leaf(workspace) {
        var _a;
        return (_a = workspace.getLeavesOfType(this.view_type)) == null ? void 0 : _a.find((leaf) => leaf.view instanceof this);
      }
      static get_view(workspace) {
        var _a;
        return (_a = this.get_leaf(workspace)) == null ? void 0 : _a.view;
      }
      static open(workspace, active = true) {
        if (this.get_leaf(workspace))
          this.get_leaf(workspace).setViewState({ type: this.view_type, active });
        else
          workspace.getRightLeaf(false).setViewState({ type: this.view_type, active });
        if (workspace.rightSplit.collapsed)
          workspace.rightSplit.toggle();
      }
      static is_open(workspace) {
        var _a;
        return ((_a = this.get_leaf(workspace)) == null ? void 0 : _a.view) instanceof this;
      }
    };
    exports2.SmartObsidianView = SmartObsidianView;
  }
});

// src/sc_chat_view.js
var require_sc_chat_view = __commonJS({
  "src/sc_chat_view.js"(exports2) {
    var { SmartObsidianView } = require_smart_obsidian_view();
    var ScChatView2 = class extends SmartObsidianView {
      constructor(leaf, plugin) {
        super(leaf, plugin);
        this.plugin = plugin;
        this.env = this.plugin.env;
        this.config = this.plugin.settings;
      }
      static get view_type() {
        return "smart-connections-chat-view";
      }
      getDisplayText() {
        return "Smart Connections Chat";
      }
      getIcon() {
        return "message-square";
      }
      getViewType() {
        return ScChatView2.view_type;
      }
      async onOpen() {
        this.app.workspace.onLayoutReady(this.initialize.bind(this));
      }
      async initialize() {
        if (!this.env.entities_loaded) {
          this.containerEl.innerHTML = "Loading Smart Connections...";
          while (!this.env.entities_loaded)
            await new Promise((r) => setTimeout(r, 2e3));
        }
        if (this.env.chat_ui)
          this.env.chat_ui.container = this.containerEl;
        while (!this.env.chats)
          await new Promise((r) => setTimeout(r, 300));
        await this.env.chats.new();
        this.app.workspace.registerHoverLinkSource(ScChatView2.view_type, {
          display: "Smart Chat Links",
          defaultMod: true
        });
      }
      onClose() {
        this.app.workspace.unregisterHoverLinkSource(ScChatView2.view_type);
      }
    };
    exports2.ScChatView = ScChatView2;
  }
});

// src/smart_settings.js
var require_smart_settings = __commonJS({
  "src/smart_settings.js"(exports2) {
    var { Setting } = require("obsidian");
    var SmartSettings = class {
      constructor(env, container, template_name = "smart_settings") {
        this.env = env;
        this.plugin = this.env.plugin;
        this.settings = this.plugin.settings;
        this.container = container;
        this.template_name = template_name;
        this.ejs = this.env.ejs;
        this.templates = this.env.templates;
      }
      async render() {
        const view_data = typeof this.get_view_data === "function" ? await this.get_view_data() : this.view_data;
        this.render_template(view_data);
        this.render_components();
      }
      render_template(view_data = null) {
        if (!this.template)
          throw new Error(`Settings template not found.`);
        this.container.empty();
        this.container.innerHTML = this.ejs.render(this.template, view_data || this.view_data, { context: this });
      }
      async update(setting, value) {
        console.log("saving setting: " + setting);
        if (setting.includes(".")) {
          let parts = setting.split(".");
          let obj = this.plugin.settings;
          for (let i = 0; i < parts.length - 1; i++) {
            if (!obj[parts[i]])
              obj[parts[i]] = {};
            obj = obj[parts[i]];
          }
          obj[parts[parts.length - 1]] = typeof value === "string" ? value.trim() : value;
        } else {
          this.plugin.settings[setting] = typeof value === "string" ? value.trim() : value;
        }
        await this.plugin.save_settings(true);
        console.log("saved settings");
        console.log(this.plugin.settings);
      }
      render_components() {
        this.container.querySelectorAll(".setting-component").forEach((elm) => {
          const setting_elm = new Setting(elm);
          if (elm.dataset.name)
            setting_elm.setName(elm.dataset.name);
          if (elm.dataset.description)
            setting_elm.descEl.innerHTML = elm.dataset.description;
          const setting = elm.dataset.setting;
          if (elm.dataset.type === "text") {
            setting_elm.addText((text) => {
              text.setPlaceholder(elm.dataset.placeholder || "");
              text.setValue(this.get_setting(setting));
              let debounceTimer;
              if (elm.dataset.button) {
                setting_elm.addButton((button) => {
                  button.setButtonText(elm.dataset.button);
                  button.onClick(async () => this.handle_on_change(setting, text.getValue(), elm));
                });
              } else {
                text.onChange(async (value) => {
                  clearTimeout(debounceTimer);
                  debounceTimer = setTimeout(() => this.handle_on_change(setting, value, elm), 2e3);
                });
              }
            });
          } else if (elm.dataset.type === "number") {
            setting_elm.addText((number) => {
              number.inputEl.type = "number";
              number.setPlaceholder(elm.dataset.placeholder || "");
              number.inputEl.value = parseInt(this.get_setting(setting));
              number.inputEl.min = elm.dataset.min || 0;
              if (elm.dataset.max)
                number.inputEl.max = elm.dataset.max;
              let debounceTimer;
              number.onChange(async (value) => {
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(() => this.handle_on_change(setting, parseInt(value), elm), 2e3);
              });
            });
          } else if (elm.dataset.type === "dropdown") {
            setting_elm.addDropdown((dropdown) => {
              Object.entries(elm.dataset).filter(([k, v]) => k.startsWith("option")).forEach(([k, v]) => {
                const [value, name] = v.split("|");
                dropdown.addOption(value, name || value);
              });
              dropdown.onChange(async (value) => this.handle_on_change(setting, value, elm));
              dropdown.setValue(this.get_setting(setting));
            });
          } else if (elm.dataset.type === "button") {
            setting_elm.addButton((button) => {
              button.setButtonText(elm.dataset.btnText || elm.dataset.name);
              button.onClick(async () => {
                if (elm.dataset.confirm) {
                  const confirmation_message = elm.dataset.confirm;
                  if (!confirm(confirmation_message))
                    return;
                }
                if (elm.dataset.href)
                  window.open(elm.dataset.href);
                if (elm.dataset.callback)
                  this[elm.dataset.callback](setting);
              });
            });
          } else if (elm.dataset.type === "toggle") {
            setting_elm.addToggle((toggle) => {
              toggle.setValue(this.get_setting(setting));
              toggle.onChange(async (value) => this.handle_on_change(setting, value, elm));
            });
          }
          if (elm.dataset.disabled)
            setting_elm.setDisabled(true);
        });
      }
      async handle_on_change(setting, value, elm) {
        await this.update(setting, value);
        if (elm.dataset.callback)
          this[elm.dataset.callback](setting, value, elm);
      }
      get_setting(setting) {
        if (setting.includes(".")) {
          let parts = setting.split(".");
          let obj = this.plugin.settings;
          for (let part of parts.slice(0, -1)) {
            if (obj[part] === void 0)
              return this.plugin.constructor.defaults[setting];
            obj = obj[part];
          }
          return obj[parts[parts.length - 1]] || this.plugin.constructor.defaults[setting];
        } else {
          return this.plugin.settings[setting] || this.plugin.constructor.defaults[setting];
        }
      }
      // override in subclass (required)
      get template() {
        return "";
      }
      // ejs template string
      get view_data() {
        return {};
      }
      // object properties available in template
    };
    exports2.SmartSettings = SmartSettings;
  }
});

// src/smart_chat_settings.js
var require_smart_chat_settings = __commonJS({
  "src/smart_chat_settings.js"(exports2) {
    var ScTranslations = require_ScTranslations();
    var { SmartSettings } = require_smart_settings();
    var SmartChatSettings = class extends SmartSettings {
      update_smart_chat_folder() {
        this.plugin.update_smart_chat_folder();
      }
      async changed_smart_chat_model(render = true) {
        console.log(this.plugin.settings.chat_model_platform_key);
        const platform_config = this.plugin.env.chat_model.platforms[this.plugin.settings.chat_model_platform_key];
        let smart_chat_model_config = this.plugin.settings[this.plugin.settings.chat_model_platform_key];
        if (smart_chat_model_config.model_name) {
          const platform_models = await this.plugin.env.chat_model.get_models();
          const model_config = platform_models.find((m) => m.model_name === smart_chat_model_config.model_name);
          smart_chat_model_config = {
            ...smart_chat_model_config || {},
            ...platform_config || {},
            ...model_config || {}
          };
          this.plugin.settings[this.plugin.settings.chat_model_platform_key] = smart_chat_model_config;
        }
        await this.plugin.save_settings(true);
        this.plugin.env.chat_model = null;
        this.plugin.env.init_chat_model(this.plugin.settings.chat_model_platform_key);
        if (render)
          this.render();
      }
      async test_chat_api_key() {
        await this.changed_smart_chat_model();
        const resp = await this.plugin.env.chat_model.test_api_key();
        if (resp)
          return this.plugin.notices.show("api key test pass", "Success! API key is valid");
        this.plugin.notices.show("api key test fail", "Error: API key is invalid!");
      }
      get self_ref_list() {
        return "Current: " + ScTranslations[this.config.language].pronouns.join(", ");
      }
      get template() {
        return this.templates["smart_chat_settings"];
      }
      async get_view_data() {
        var _a, _b, _c;
        const view_data = {
          settings: this.plugin.settings,
          chat_platform: (_a = this.env.chat_model) == null ? void 0 : _a.platforms[this.plugin.settings.chat_model_platform_key],
          chat_platforms: ((_b = this.env.chat_model) == null ? void 0 : _b.platforms) ? Object.keys(this.env.chat_model.platforms).map((platform_key) => {
            var _a2;
            return { key: platform_key, ...((_a2 = this.env.chat_model) == null ? void 0 : _a2.platforms[platform_key]) || {} };
          }) : []
        };
        view_data.platform_chat_models = await ((_c = this.plugin.env.chat_model) == null ? void 0 : _c.get_models());
        view_data.smart_chat_settings = this.ejs.render(this.template, view_data);
        return view_data;
      }
    };
    exports2.SmartChatSettings = SmartChatSettings;
  }
});

// src/sc_chats_ui.js
var require_sc_chats_ui = __commonJS({
  "src/sc_chats_ui.js"(exports2) {
    var { SmartChatsUI } = require_smart_chats_ui();
    var { ScChatView: ScChatView2 } = require_sc_chat_view();
    var { FuzzySuggestModal } = require("obsidian");
    var { SmartChatSettings } = require_smart_chat_settings();
    var ScChatsUI = class extends SmartChatsUI {
      get view_context() {
        return {
          attribution: this.templates.attribution,
          get_icon: this.env.plugin.chat_view.get_icon.bind(this.env.plugin.chat_view)
        };
      }
      get obsidian() {
        return this.env.plugin.obsidian;
      }
      show_notice(message) {
        this.env.plugin.show_notice(message);
      }
      add_listeners() {
        const chat_name_input = this.container.querySelector(".sc-chat-name-input");
        chat_name_input.addEventListener("change", (event) => {
          this.env.chats.current.rename(event.target.value);
        });
        const open_in_note_btn = this.container.querySelector("button[title='Open Conversation Note']");
        open_in_note_btn.addEventListener("click", () => {
          const link_tfile = this.env.plugin.app.metadataCache.getFirstLinkpathDest(this.env.chats.current.name, "/");
          let leaf = this.env.plugin.app.workspace.getLeaf(true);
          leaf.openFile(link_tfile);
        });
        const settings_btn = this.container.querySelector("button[title='Settings']");
        settings_btn.addEventListener("click", async () => {
          const settings_container = this.container.querySelector("#settings");
          if (settings_container.innerHTML)
            return settings_container.innerHTML = "";
          if (!this.chat_settings)
            this.chat_settings = new SmartChatSettings(this.env, settings_container);
          else
            this.chat_settings.container = settings_container;
          this.chat_settings.render();
          settings_container.style.transition = "background-color 0.5s ease-in-out";
          settings_container.style.backgroundColor = "var(--bold-color)";
          setTimeout(() => {
            settings_container.style.backgroundColor = "";
          }, 500);
        });
        const history_btn = this.container.querySelector("button[title='Chat History']");
        history_btn.addEventListener("click", () => {
          this.env.chats.open_modal();
        });
        const new_chat_btn = this.container.querySelector("button[title='New Chat']");
        new_chat_btn.addEventListener("click", () => {
          this.env.chats.new();
        });
        this.add_chat_input_listeners();
      }
      async message_post_process(msg_elm) {
        await this.render_md_as_html(msg_elm);
        this.handle_links_in_message(msg_elm);
        this.add_message_listeners(msg_elm);
      }
      async render_md_as_html(msg_elm) {
        const text_elm = msg_elm.querySelector("span:not(.sc-msg-button)");
        const text = msg_elm.getAttribute("data-content") || text_elm.textContent;
        text_elm.innerHTML = "";
        await this.obsidian.MarkdownRenderer.render(this.env.plugin.app, text, text_elm, "?no-dataview", new this.obsidian.Component());
      }
      handle_links_in_message(msg_elm) {
        const links = msg_elm.querySelectorAll("a");
        if (links.length > 0) {
          for (let i = 0; i < links.length; i++) {
            const link = links[i];
            const link_text = link.getAttribute("data-href");
            link.addEventListener("mouseover", (event) => {
              this.env.plugin.app.workspace.trigger("hover-link", {
                event,
                source: ScChatView2.view_type,
                hoverParent: link.parentElement,
                targetEl: link,
                // extract link text from a.data-href
                linktext: link_text
              });
            });
            link.addEventListener("click", (event) => {
              const link_tfile = this.env.plugin.app.metadataCache.getFirstLinkpathDest(link_text, "/");
              const mod = this.obsidian.Keymap.isModEvent(event);
              let leaf = this.env.plugin.app.workspace.getLeaf(mod);
              leaf.openFile(link_tfile);
            });
          }
        }
      }
      add_message_listeners(msg_elm) {
        const copy_button = msg_elm.querySelector("span.sc-msg-button[title='Copy message to clipboard']");
        copy_button == null ? void 0 : copy_button.addEventListener("click", (e) => {
          console.log("copy message to clipboard");
          const msg_content_elm = e.target.closest(".sc-message-content");
          console.log(msg_content_elm);
          const msg_content = msg_content_elm.getAttribute("data-content") || msg_content_elm.querySelector("span:not(.sc-msg-button)").textContent;
          console.log(msg_content);
          navigator.clipboard.writeText(msg_content);
          this.env.plugin.show_notice("Message copied to clipboard");
        });
      }
      // open file suggestion modal
      open_file_suggestion_modal() {
        if (!this.file_selector)
          this.file_selector = new ScFileSelectModal(this.env.plugin.app, this.env);
        this.file_selector.open();
      }
      // open folder suggestion modal
      async open_folder_suggestion_modal() {
        if (!this.folder_selector) {
          const folders = await this.env.plugin.get_folders();
          this.folder_selector = new ScFolderSelectModal(this.env.plugin.app, this.env, folders);
        }
        this.folder_selector.open();
      }
      async open_system_prompt_modal() {
        if (!this.system_prompt_selector)
          this.system_prompt_selector = new ScSystemPromptSelectModal(this.env.plugin.app, this.env);
        this.system_prompt_selector.open();
      }
      add_chat_input_listeners() {
        super.add_chat_input_listeners();
        const chat_input = this.container.querySelector(".sc-chat-form");
        this.brackets_ct = 0;
        this.prevent_input = false;
        chat_input.addEventListener("keyup", this.key_up_handler.bind(this));
      }
      key_up_handler(e) {
        const textarea = this.container.querySelector(".sc-chat-form textarea");
        if (!["/", "@", "["].includes(e.key))
          return;
        const caret_pos = textarea.selectionStart;
        if (e.key === "[") {
          if (textarea.value[caret_pos - 2] === "[") {
            this.open_file_suggestion_modal();
            return;
          }
        } else {
          this.brackets_ct = 0;
        }
        if (e.key === "/") {
          if (textarea.value.length === 1 || textarea.value[caret_pos - 2] === " ") {
            this.open_folder_suggestion_modal();
            return;
          }
        }
        if (e.key === "@") {
          if (textarea.value.length === 1 || textarea.value[caret_pos - 2] === " ") {
            this.open_system_prompt_modal();
            return;
          }
        }
      }
    };
    exports2.ScChatsUI = ScChatsUI;
    var ScFileSelectModal = class extends FuzzySuggestModal {
      constructor(app, env) {
        super(app);
        this.app = app;
        this.env = env;
        this.setPlaceholder("Type the name of a file...");
      }
      // get all markdown files
      getItems() {
        return this.app.vault.getMarkdownFiles().sort((a, b) => a.basename.localeCompare(b.basename));
      }
      getItemText(item) {
        return item.basename;
      }
      onChooseItem(file) {
        this.env.chat_ui.insert_selection(file.basename + "]] ");
      }
    };
    var ScFolderSelectModal = class extends FuzzySuggestModal {
      constructor(app, env, folders) {
        super(app);
        this.app = app;
        this.env = env;
        this.folders = folders;
        this.setPlaceholder("Type the name of a folder...");
      }
      getItems() {
        return this.folders;
      }
      getItemText(item) {
        return item;
      }
      onChooseItem(folder) {
        this.env.chat_ui.insert_selection(folder + "/ ");
      }
    };
    var ScSystemPromptSelectModal = class extends FuzzySuggestModal {
      constructor(app, env) {
        super(app);
        this.app = app;
        this.env = env;
        this.setPlaceholder("Type the name of a system prompt...");
      }
      // getItems() { return this.env.system_prompts; }
      getItems() {
        return this.env.system_prompts;
      }
      getItemText(item) {
        return item.basename;
      }
      onChooseItem(prompt) {
        this.env.chat_ui.insert_selection('"' + prompt.basename + '"');
      }
    };
  }
});

// node_modules/smart-chats/smart_chat.js
var require_smart_chat = __commonJS({
  "node_modules/smart-chats/smart_chat.js"(exports2) {
    var SmartChat = class {
      constructor(env, key, data = "") {
        this.env = env;
        this.chats = this.env.chats;
        this.key = key;
        this.data = data;
        this.scope = {};
        if (this.chats)
          this.chats.items[this.key] = this;
      }
      /**
       * Factory method to create a new SmartChat instance with a unique key or a default one.
       * 
       * @static
       * @param {SmartEnv} env - The SmartChat environment object.
       * @param {string} [key=null] - Optional key for the chat session. If not provided, a default is generated.
       * @param {string} [data=''] - Initial data for the chat session.
       * @returns {SmartChat} A new instance of SmartChat.
       */
      static create(env, key = null, data = "") {
        if (!key)
          key = "UNTITLED CHAT " + get_file_date_string();
        const chat = new this(env, key, data);
        return chat;
      }
      /**
       * Computes the file path for the current chat session based on its key and file type.
       * 
       * @returns {string} The file path for the chat session.
       */
      get file_path() {
        return `${this.chats.folder}/${this.key}.${this.file_type}`;
      }
      /**
       * Returns the name (key) of the chat session.
       * 
       * @returns {string} The key of the chat session.
       */
      get name() {
        return this.key;
      }
      /**
       * Renames the current chat session and updates the storage references.
       * 
       * @param {string} new_id - The new identifier for the chat session.
       * @returns {Promise<void>}
       */
      async rename(new_id) {
        if (this.key === new_id)
          return;
        if (await this.exists())
          await this.delete();
        delete this.chats.items[this.key];
        this.key = new_id;
        this.chats.items[this.key] = this;
        await this.save();
      }
      /**
       * Retrieves all messages from the chat session and converts them to HTML format.
       * 
       * @returns {Promise<string>} A string containing all messages in HTML format.
       */
      async get_messages_html() {
        const messages = await this.get_messages();
        const html = await Promise.all(messages.map(async (msg) => {
          if (!msg.content)
            return "";
          if (msg.role === "system")
            return await this.env.chat_ui.get_system_message_html(msg);
          return await this.env.chat_ui.get_message_html(msg.role, msg.content);
        }));
        return html.join("");
      }
      /**
       * Adds a new message to the chat session.
       * 
       * @param {Object} [msg={}] - The message object to add.
       * @returns {Promise<void>}
       */
      async add_message(msg = {}) {
        const chat_ml = await this.get_chat_ml();
        chat_ml.messages.push(msg);
        await this.update(chat_ml);
      }
      /**
       * Adds output from a tool to the chat session as a message.
       * 
       * @param {string} tool_name - The name of the tool.
       * @param {*} tool_output - The output from the tool.
       * @returns {Promise<void>}
       */
      async add_tool_output(tool_name, tool_output) {
        if (typeof this.env.actions.parse_tool_output === "function") {
          const message = await this.env.actions.parse_tool_output(tool_name, tool_output);
          if (message)
            return await this.add_message(message);
        }
        await this.add_message({ role: "tool", tool_call_id: tool_name, content: JSON.stringify(tool_output) });
      }
      // file-type specific parsing and formatting overrides
      /**
       * Updates the chat session data with the provided ChatML object and saves it.
       * 
       * @param {Object} chat_ml - The ChatML object to update the session with.
       * @returns {Promise<void>}
       */
      async update(chat_ml) {
        this.data = this.from_chatml(chat_ml);
        await this.save();
      }
      /**
       * Saves the current chat session data to the file system.
       * 
       * @returns {Promise<void>}
       */
      async save() {
        return await this.chats.save(this.file_path, this.data);
      }
      /**
       * Deletes the chat session file from the file system.
       * 
       * @returns {Promise<void>}
       */
      async delete() {
        return await this.chats.delete(this.file_path);
      }
      /**
       * Checks if the chat session file exists in the file system.
       * 
       * @returns {Promise<boolean>} True if the file exists, false otherwise.
       */
      async exists() {
        return await this.chats.exists(this.file_path);
      }
      /**
       * Loads the chat session data from the file system.
       * 
       * @returns {Promise<string>} The loaded data.
       */
      async load() {
        if (!await this.exists())
          return this.data = "";
        return this.data = await this.chats.read(this.file_path);
      }
      /**
       * Retrieves the ChatML object from the current session data.
       * 
       * @returns {Promise<Object>} The ChatML object.
       */
      async get_chat_ml() {
        await this.load();
        const chat_ml = this.to_chatml(this.data);
        return chat_ml;
      }
      /**
       * Retrieves all messages from the ChatML object of the current session.
       * 
       * @returns {Promise<Array>} An array of message objects.
       */
      async get_messages() {
        return (await this.get_chat_ml()).messages;
      }
      /**
       * Processes a new user message, updates UI/UX, and adds it to the chat session.
       * 
       * @param {string} content - The content of the user message.
       * @returns {Promise<void>}
       */
      async new_user_message(content) {
        var _a, _b, _c, _d, _e;
        const og_content = content;
        content = await this.parse_user_message(content);
        if (typeof ((_b = (_a = this.env) == null ? void 0 : _a.chat_ui) == null ? void 0 : _b.new_user_message) === "function")
          await this.env.chat_ui.new_user_message(og_content);
        if (typeof ((_d = (_c = this.env) == null ? void 0 : _c.actions) == null ? void 0 : _d.new_user_message) === "function")
          await this.env.actions.new_user_message(content);
        if (typeof ((_e = this.chats) == null ? void 0 : _e.new_user_message) === "function")
          await this.chats.new_user_message(content);
        await this.add_message({ role: "user", content });
        await this.env.chat_model.complete({});
      }
      // Override these for file-type specific parsing and formatting in subclasses
      /**
       * Returns the file type for the chat session, used in file operations.
       * 
       * @returns {string} The file type, default is 'json'.
       */
      get file_type() {
        return "json";
      }
      /**
       * Converts the provided data into a ChatML object. This method should be overridden in subclasses.
       * 
       * @param {string} data - The data to convert.
       * @returns {Object} The ChatML object.
       */
      to_chatml(data) {
        return data;
      }
      /**
       * Converts a ChatML object back into a string or suitable format for storage. This method should be overridden in subclasses.
       * 
       * @param {Object} data - The ChatML object to convert.
       * @returns {string} The string or formatted data.
       */
      from_chatml(data) {
        return data;
      }
      /**
       * Parses the user message content before adding it to the chat. This method can be overridden to include custom parsing logic.
       * 
       * @param {string} content - The content to parse.
       * @returns {Promise<string>} The parsed content.
       */
      async parse_user_message(content) {
        return content;
      }
    };
    function get_file_date_string() {
      return (/* @__PURE__ */ new Date()).toISOString().replace(/(T|:|\..*)/g, " ").trim();
    }
    exports2.SmartChat = SmartChat;
  }
});

// node_modules/smart-chats/utils/chat_ml_to_markdown.js
var require_chat_ml_to_markdown = __commonJS({
  "node_modules/smart-chats/utils/chat_ml_to_markdown.js"(exports2) {
    var { message_content_array_to_markdown } = require_message_content_array_to_markdown();
    function chat_ml_to_markdown(chat_ml) {
      console.log("chat_ml");
      console.log(chat_ml);
      let markdown = "";
      let has_md = false;
      chat_ml.messages.forEach((msg) => {
        if (msg.role && msg.content) {
          if (markdown.length > 0)
            markdown += "\n\n";
          markdown += `##### ${msg.role}
`;
          if (msg.role === "tool") {
            console.log(msg);
            markdown += "```";
            if (msg.tool_call_id)
              markdown += `${msg.tool_call_id}
`;
            if (msg.content)
              markdown += `${msg.content}
`;
            markdown += "```";
          } else if (Array.isArray(msg.content)) {
            markdown += message_content_array_to_markdown(msg.content);
          } else if (msg.content.indexOf("---BEGIN NOTE") > -1) {
            markdown += "```sc-context";
            const lines = msg.content.split("\n").filter((line) => line.trim().length && line.startsWith("---BEGIN NOTE") && line.indexOf("[[") > -1);
            lines.forEach((line, i) => {
              const link = line.substring(line.indexOf("[[") + 2, line.indexOf("]]"));
              if (i > 0)
                markdown += "\n";
              if (link)
                markdown += `${link}`;
            });
            markdown += "\n```";
          } else if (msg.content.indexOf("#") === 0 || msg.content.indexOf("\n#") > -1) {
            markdown += "```md";
            const content = msg.content.replace(/\n[`]{3}/g, "\n\\```");
            markdown += `
${content}`;
            markdown += "\n```";
          } else
            markdown += `${msg.content}`;
        }
        if (msg.tool_calls) {
          msg.tool_calls.forEach((tool_call) => {
            var _a, _b, _c;
            if (markdown.length > 0)
              markdown += "\n\n";
            markdown += `##### assistant
`;
            markdown += `\`\`\`${(_a = tool_call == null ? void 0 : tool_call.function) == null ? void 0 : _a.name}`;
            try {
              markdown += `
${JSON.stringify(JSON.parse((_b = tool_call == null ? void 0 : tool_call.function) == null ? void 0 : _b.arguments))}`;
            } catch (err) {
              markdown += `
${(_c = tool_call == null ? void 0 : tool_call.function) == null ? void 0 : _c.arguments}`;
            }
            markdown += "\n```";
          });
        }
      });
      return markdown.trim();
    }
    exports2.chat_ml_to_markdown = chat_ml_to_markdown;
  }
});

// node_modules/smart-chats/utils/add_content_to_message.js
var require_add_content_to_message = __commonJS({
  "node_modules/smart-chats/utils/add_content_to_message.js"(exports2) {
    function add_content_to_message(curr_msg, content) {
      if (typeof content === "string")
        content = content.trim();
      else
        content = content.map((c) => c.type === "text" ? { type: "text", text: c.text.trim() } : c);
      if (Array.isArray(content)) {
        if (typeof curr_msg.content === "string")
          curr_msg.content = [{ type: "text", text: curr_msg.content }];
        else if (typeof curr_msg.content === "undefined")
          curr_msg.content = [];
        curr_msg.content.push(...content);
      } else {
        if (Array.isArray(curr_msg.content)) {
          if (curr_msg.content[curr_msg.content.length - 1].type === "text")
            curr_msg.content[curr_msg.content.length - 1].text += "\n" + content;
          else
            curr_msg.content.push({ type: "text", text: content });
        } else {
          if (!curr_msg.content)
            curr_msg.content = "";
          else
            curr_msg.content += "\n";
          if (content.startsWith("\\```"))
            content = content.substring(1);
          curr_msg.content += content;
        }
      }
    }
    exports2.add_content_to_message = add_content_to_message;
  }
});

// node_modules/smart-chats/utils/markdown_to_chat_ml.js
var require_markdown_to_chat_ml = __commonJS({
  "node_modules/smart-chats/utils/markdown_to_chat_ml.js"(exports2) {
    var { add_content_to_message } = require_add_content_to_message();
    function markdown_to_chat_ml(markdown) {
      const lines = markdown.split("\n");
      const chat_ml = { messages: [] };
      let current_role = "";
      let tool_name = null;
      let curr_msg = null;
      let is_code_block = false;
      lines.forEach((line) => {
        if (tool_name && curr_msg.role === "tool")
          curr_msg.tool_call_id = tool_name;
        if (line.startsWith("##### ") && !is_code_block) {
          tool_name = null;
          if (curr_msg)
            chat_ml.messages.push({ ...curr_msg });
          current_role = line.substring(6).trim();
          curr_msg = {
            role: current_role
          };
        } else if (line.startsWith("```")) {
          is_code_block = !is_code_block;
          if (line.trim().length > 5 && line.trim().indexOf(" ") < 0) {
            tool_name = line.substring(3).trim();
            if (tool_name === "md")
              return;
            if (["js", "javascript", "dataview"].includes(tool_name))
              return add_content_to_message(curr_msg, line);
            if (["sc-context", "sc-system"].includes(tool_name))
              return add_content_to_message(curr_msg, line);
            if (curr_msg.role === "tool")
              return;
            if (!curr_msg.tool_calls)
              curr_msg.tool_calls = [];
            curr_msg.tool_calls.push({
              id: tool_name,
              type: "function",
              function: {
                name: tool_name,
                arguments: ""
              }
            });
          } else if (["sc-context", "sc-system", "md", "javascript", "js", "dataview"].includes(tool_name)) {
            add_content_to_message(curr_msg, line);
          }
        } else if (line.trim() !== "" && curr_msg) {
          if (tool_name && curr_msg.tool_calls)
            curr_msg.tool_calls[curr_msg.tool_calls.length - 1].function.arguments += line;
          else if (line.match(/!\[.*?\]\((.*?)\)/)) {
            const image_matches = line.matchAll(/^!\[(?<caption>[^\]]*?)\]\((?<imageUrl>[^\)]*?)\)/g);
            const content = [];
            for (const match of image_matches) {
              const caption = match.groups.caption || match.groups.obsidianCaption;
              const imageUrl = match.groups.imageUrl || match.groups.obsidianLink;
              content.push({ type: "image_url", image_url: { url: imageUrl } });
              if (caption)
                content.push({ type: "text", text: `Image caption: ${caption}` });
            }
            add_content_to_message(curr_msg, content);
          } else
            add_content_to_message(curr_msg, line);
        }
      });
      if (curr_msg)
        chat_ml.messages.push({ ...curr_msg });
      return chat_ml;
    }
    exports2.markdown_to_chat_ml = markdown_to_chat_ml;
  }
});

// node_modules/smart-chats/smart_chat_md.js
var require_smart_chat_md = __commonJS({
  "node_modules/smart-chats/smart_chat_md.js"(exports2) {
    var { SmartChat } = require_smart_chat();
    var { chat_ml_to_markdown } = require_chat_ml_to_markdown();
    var { markdown_to_chat_ml } = require_markdown_to_chat_ml();
    var SmartChatMD = class extends SmartChat {
      /**
       * Returns the file type associated with this class.
       * @returns {string} The file type, which is 'md' for markdown.
       */
      get file_type() {
        return "md";
      }
      /**
       * Updates the internal data with the provided ChatML and saves it.
       * @param {Object} chat_ml - The ChatML object to update the data with.
       */
      async update(chat_ml) {
        this.data = this.from_chatml(chat_ml);
        await this.save();
      }
      // file-type specific parsing and formatting overrides
      /**
       * Retrieves the ChatML representation of the current data.
       * @returns {Promise<Object>} The ChatML object.
       */
      async get_chat_ml() {
        await this.load();
        const chat_ml = this.to_chatml(this.data);
        return chat_ml;
      }
      /**
       * Converts markdown text to a ChatML object.
       * @param {string} markdown - The markdown string to convert.
       * @returns {Object} The converted ChatML object.
       */
      to_chatml(markdown) {
        return markdown_to_chat_ml(markdown);
      }
      /**
       * Converts a ChatML object to markdown text.
       * @param {Object} chatml - The ChatML object to convert.
       * @returns {string} The converted markdown string.
       */
      from_chatml(chatml) {
        return chat_ml_to_markdown(chatml);
      }
    };
    exports2.SmartChatMD = SmartChatMD;
    exports2.chat_ml_to_markdown = chat_ml_to_markdown;
    exports2.markdown_to_chat_ml = markdown_to_chat_ml;
  }
});

// node_modules/smart-chats/smart_chats.js
var require_smart_chats = __commonJS({
  "node_modules/smart-chats/smart_chats.js"(exports2) {
    var { SmartChatMD } = require_smart_chat_md();
    var { SmartChat } = require_smart_chat();
    var SmartChats = class {
      /**
       * Creates an instance of SmartChats.
       * @param {Object} env - The environment context, used across the chat system.
       * @param {Object} [opts={}] - Optional parameters to configure the SmartChats instance.
       */
      constructor(env, opts = {}) {
        this.env = env;
        this.folder = "smart-chats";
        this.items = {};
        this.formats = {
          md: SmartChatMD,
          json: SmartChat
        };
        this.default_file_type = "md";
        Object.assign(this, opts);
      }
      /**
       * Creates a new chat instance and initializes the chat UI.
       */
      async new() {
        if (this.current) {
          await this.current.save();
          this.current = null;
        }
        this.current = this.file_format.create(this.env);
        console.log(this.current);
        await this.env.chat_ui.init();
      }
      /**
       * Loads all conversations from the filesystem and initializes them.
       */
      async load_all() {
        if (!await this.exists(this.folder))
          await this.create_folder(this.folder);
        const convos = await this.get_conversation_ids_and_file_types();
        convos.forEach(([conversation_id, file_type]) => {
          if (!this.formats[file_type])
            console.log("Unsupported file type", [conversation_id, file_type]);
          this.items[conversation_id] = this.formats[file_type].create(this.env, conversation_id);
        });
      }
      /**
       * Saves a chat conversation by its key.
       * If the chat does not exist, it creates a new one.
       * @param {string} key - The key identifier for the chat.
       * @param {string} chat_ml - The chat content in markup language.
       */
      async save(key, chat_ml) {
        let chat = this.items[key];
        if (!chat) {
          console.log("Creating new conversation");
          chat = this.file_format.create(this.env, key, chat_ml);
        }
        await chat.save(chat_ml);
      }
      /**
       * Getter for the file format based on the default file type.
       * @returns {Object} The chat format class.
       */
      get file_format() {
        return this.formats[this.default_file_type];
      }
      /**
       * Retrieves conversation IDs and their corresponding file types from the filesystem.
       * @returns {Promise<Array<Array<string>>>} An array of conversation IDs and file types.
       */
      async get_conversation_ids_and_file_types() {
        console.log("get_conversation_ids_and_file_types");
        const folder = await this.list(this.folder);
        console.log(folder);
        const files = folder.files.map((file) => {
          const file_type = file.split(".").pop();
          const conversation_id = file.replace(this.folder + "/", "").replace("." + file_type, "");
          return [conversation_id, file_type];
        });
        return files;
      }
      // Platform-specific methods to be overridden in subclasses or instances
      async open(conversation_id) {
      }
      async load(path) {
      }
      async save(path, file_content) {
      }
      async delete(path) {
      }
      async exists(path) {
      }
      async create_folder(path) {
      }
      async list(path) {
      }
    };
    exports2.SmartChats = SmartChats;
    exports2.SmartChat = SmartChat;
    exports2.SmartChatMD = SmartChatMD;
  }
});

// src/extract_folder_references.js
var require_extract_folder_references = __commonJS({
  "src/extract_folder_references.js"(exports2) {
    function extract_folder_references(folders, user_input) {
      folders = folders.slice();
      const matches = folders.sort((a, b) => b.length - a.length).map((folder) => {
        if (user_input.indexOf(folder) !== -1) {
          user_input = user_input.replace(folder, "");
          return folder;
        }
        return false;
      }).filter((folder) => folder);
      console.log(matches);
      if (matches)
        return matches;
      return false;
    }
    exports2.extract_folder_references = extract_folder_references;
  }
});

// src/contains_internal_link.js
var require_contains_internal_link = __commonJS({
  "src/contains_internal_link.js"(exports2) {
    function contains_internal_link(user_input) {
      if (user_input.indexOf("[[") === -1)
        return false;
      if (user_input.indexOf("]]") === -1)
        return false;
      return true;
    }
    exports2.contains_internal_link = contains_internal_link;
  }
});

// src/contains_folder_reference.js
var require_contains_folder_reference = __commonJS({
  "src/contains_folder_reference.js"(exports2) {
    function contains_folder_reference(user_input) {
      const first_slash = user_input.indexOf("/");
      if (first_slash === -1)
        return false;
      const last_slash = user_input.lastIndexOf("/");
      if (last_slash - first_slash <= 1)
        return false;
      const first_open_parentheses = user_input.indexOf("(");
      const first_close_parentheses = user_input.indexOf(")");
      if (first_open_parentheses > first_slash && first_close_parentheses < last_slash)
        return true;
      if (first_open_parentheses !== -1 && first_close_parentheses !== -1) {
        const start = user_input.indexOf("(");
        const end = user_input.indexOf(")");
        const without_content_in_parentheses = user_input.slice(0, start) + user_input.slice(end + 1);
        if (without_content_in_parentheses.indexOf("/") !== -1)
          return false;
        if (without_content_in_parentheses.indexOf("/") === without_content_in_parentheses.lastIndexOf("/"))
          return false;
      }
      return true;
    }
    exports2.contains_folder_reference = contains_folder_reference;
  }
});

// src/sc_chat_md.js
var require_sc_chat_md = __commonJS({
  "src/sc_chat_md.js"(exports2) {
    var { SmartChatMD } = require_smart_chat_md();
    var { extract_folder_references } = require_extract_folder_references();
    var { contains_internal_link } = require_contains_internal_link();
    var { contains_folder_reference } = require_contains_folder_reference();
    var ScChatMD = class extends SmartChatMD {
      async new_user_message(content) {
        const og_content = content;
        try {
          await super.new_user_message(content);
        } catch (e) {
          this.env.plugin.notices.show(e.message, e.message);
          console.warn(e);
          this.env.chat_ui.set_chat_input_text(og_content);
        }
      }
      /**
       * Parses a user message to handle special syntax like mentions and converts them into system messages.
       * @param {string} content - The user message content.
       * @returns {Promise<string>} The processed content with mentions handled.
       */
      async parse_user_message(content) {
        this.env.chats.current.scope = {};
        if (content.includes('@"')) {
          const mention_pattern = /@\"([^"]+)\"/;
          const mention = content.match(mention_pattern)[1];
          const sys_msg = {
            role: "system",
            content: "```sc-system\n" + mention + "\n```"
          };
          await this.add_message(sys_msg);
          const sys_msg_html = await this.env.chat_ui.get_system_message_html(sys_msg);
          await this.env.chat_ui.message_container.insertAdjacentHTML("beforeend", sys_msg_html);
          content = content.replace(mention_pattern, "").trim();
        }
        if (contains_internal_link(content)) {
          const notes = extract_internal_links(this.env, content);
          console.log(notes);
          if (notes.length) {
            const context = "```sc-context\n" + notes.map((n) => `${n.path}`).join("\n") + "\n```";
            const context_msg = { role: "system", content: context };
            await this.add_message(context_msg);
            const context_msg_html = await this.env.chat_ui.get_system_message_html(context_msg);
            await this.env.chat_ui.message_container.insertAdjacentHTML("beforeend", context_msg_html);
          }
        }
        if (contains_folder_reference(content)) {
          const folders = await this.env.plugin.get_folders();
          const folder_refs = extract_folder_references(folders, content);
          console.log(folder_refs);
          if (folder_refs)
            this.env.chats.current.scope.key_starts_with_any = folder_refs;
          console.log(this.env.chats.current.scope);
        }
        return content;
      }
      async add_tool_output(tool_name, tool_output) {
        await super.add_tool_output(tool_name, tool_output);
        await this.env.chat_ui.init();
        await this.env.chat_ui.render_dotdotdot();
      }
    };
    exports2.ScChatMD = ScChatMD;
    function extract_internal_links(env, user_input) {
      const matches = user_input.match(/\[\[(.*?)\]\]/g);
      console.log(matches);
      if (matches)
        return matches.map((match) => {
          const tfile = env.plugin.app.metadataCache.getFirstLinkpathDest(match.replace("[[", "").replace("]]", ""), "/");
          return tfile;
        });
      return [];
    }
    exports2.extract_internal_links = extract_internal_links;
  }
});

// src/sc_chats.js
var require_sc_chats = __commonJS({
  "src/sc_chats.js"(exports2) {
    var { SmartChats } = require_smart_chats();
    var { ScChatMD } = require_sc_chat_md();
    var { FuzzySuggestModal } = require("obsidian");
    var ScChats = class extends SmartChats {
      constructor(env, opts = {}) {
        super(env, opts);
        this.plugin = this.env.plugin;
        this.folder = this.env.config.smart_chat_folder || this.folder;
        this.formats.md = ScChatMD;
      }
      async new_user_message(message) {
        var _a;
        if (this.env.config.chat_model_platform_key === "open_router" && !((_a = this.env.config.open_router) == null ? void 0 : _a.api_key)) {
          this.env.config.free_chat_uses = this.env.config.free_chat_uses || 0;
          this.env.config.free_chat_uses++;
          if (this.env.config.free_chat_uses > 2) {
            this.env.plugin.notices.show("shared usage", "Your chats are currently using a community account with very limited usage. Please add your own API key in the Smart Chat settings to enable unlimited personal usage and prevent exhausting the shared account limit.", { immutable: true, timeout: 2e4 });
          }
          return;
        }
        return message;
      }
      // platform specific overrides
      open(key) {
        this.current = this.items[key];
        this.env.chat_ui.init();
      }
      async read(path) {
        return await this.plugin.app.vault.adapter.read(path);
      }
      normalize_path(path) {
        return this.plugin.obsidian.normalizePath(path);
      }
      async save(path, file_content) {
        await this.plugin.app.vault.adapter.write(this.normalize_path(path), file_content);
      }
      async delete(path) {
        await this.plugin.app.vault.adapter.remove(path);
      }
      async exists(path) {
        return await this.plugin.app.vault.adapter.exists(path);
      }
      async create_folder(path) {
        return await this.plugin.app.vault.adapter.mkdir(path);
      }
      async list(path) {
        return await this.plugin.app.vault.adapter.list(path);
      }
      // CUSTOM
      open_modal() {
        if (!this.modal)
          this.modal = new ScChatHistoryModal(this.plugin.app, this.env);
        this.modal.open();
      }
      // // backwords compatibility
      // async import_v1_chats() {
      //   const files = await this.list('.smart-connections/chats');
      //   console.log(files);
      //   for (let i = 0; i < files.files.length; i++) {
      //     const file = files.files[i];
      //     const chat_id = file.replace('.smart-connections/chats/', '').replace('.json', '');
      //     const messages = [];
      //     JSON.parse(await this.read(file))
      //       .map(msg => msg[0])
      //       .forEach(msg => {
      //         if (msg.role === "user") return messages.push({
      //           role: "user",
      //           content: msg.content,
      //         });
      //         if (msg.hyd) messages.push({
      //           role: "assistant",
      //           content: null,
      //           tool_calls: [{
      //             function: {
      //               name: "find_notes",
      //               args: JSON.stringify({ hypotheticals: [msg.hyd] })
      //             }
      //           }]
      //         });
      //         if (msg.context) {
      //           // const context_links = [];
      //           // msg.context.split('\n').forEach((line, i, arr) => {
      //           //   if(line.startsWith('---BEGIN') && arr[i+1]){
      //           //     const breadcrumbs = arr[i+1].replace(': ', '#').split(' > '); // remove last char (:) and split by ' > '
      //           //     const link_path = breadcrumbs.map(breadcrumb => breadcrumb.trim()).join('/');
      //           //     context_links.push(link_path);
      //           //   }
      //           // });
      //           // messages.push({
      //           //   role: "system",
      //           //   content: 'BEGIN NOTES AS CONTEXT:\n[['+context_links.join(']]\n[[')+']]'
      //           // });
      //           messages.push({
      //             role: "system",
      //             content: "```smart-connections\n" + msg.hyd + "\n```"
      //           });
      //           // // get last user message from messages and add again
      //           // const last_user_msg = messages[messages.findLastIndex(m => m.role === "user")];
      //           // messages.push(last_user_msg);
      //         }
      //         if (msg.role === "assistant") return messages.push({
      //           role: "assistant",
      //           content: msg.content,
      //         });
      //       });
      //     console.log(messages);
      //     const convo = this.conversation_format.create(this, chat_id, chat_ml_to_markdown({ messages }));
      //     await convo.save();
      //   }
      // }
    };
    exports2.ScChats = ScChats;
    var ScChatHistoryModal = class extends FuzzySuggestModal {
      constructor(app, env) {
        super(app);
        this.app = app;
        this.env = env;
        this.setPlaceholder("Type the name of a chat session...");
      }
      // getItems() { return (this.view.files) ? this.view.files : []; }
      getItems() {
        return Object.keys(this.env.chats.items);
      }
      // if not UNTITLED, remove date after last em dash
      getItemText(item) {
        return item.indexOf("UNTITLED") === -1 ? item.replace(/[^]*$/, "") : item;
      }
      // onChooseItem(session) { this.view.open_chat(session); }
      onChooseItem(conversation_id) {
        this.env.chats.open(conversation_id);
      }
    };
  }
});

// build/actions_openapi.json
var require_actions_openapi = __commonJS({
  "build/actions_openapi.json"(exports2, module2) {
    module2.exports = {
      openapi: "3.0.0",
      paths: {
        "/lookup": {
          post: {
            operationId: "lookup",
            summary: "Semantic search",
            description: "Performs a semantic search of the user's data. Required: hypothetical_1 and hypothetical_2. Optional: hypothetical_3.",
            requestBody: {
              content: {
                "application/json": {
                  schema: {
                    type: "object",
                    properties: {
                      hypothetical_1: {
                        type: "string",
                        description: "Short hypothetical notes predicted to be semantically similar to the notes necessary to fulfill the user's request. At least three hypotheticals per request. The hypothetical notes may contain paragraphs, lists, or checklists in markdown format. Hypothetical notes always begin with breadcrumbs containing the anticipated folder(s), file name, and relevant headings separated by ' > ' (no slashes). Example: PARENT FOLDER NAME > CHILD FOLDER NAME > FILE NAME > HEADING 1 > HEADING 2 > HEADING 3: HYPOTHETICAL NOTE CONTENTS."
                      },
                      hypothetical_2: {
                        type: "string",
                        description: "Must be distinct from and not share any breadcrumbs with hypothetical_1."
                      },
                      hypothetical_3: {
                        type: "string",
                        description: "Must be distinct from hypothetical_1 and hypothetical_2."
                      }
                    },
                    required: [
                      "hypothetical_1",
                      "hypothetical_2"
                    ]
                  }
                }
              }
            }
          }
        }
      },
      components: {},
      tags: []
    };
  }
});

// src/actions/lookup.js
var require_lookup = __commonJS({
  "src/actions/lookup.js"(exports2) {
    async function lookup(env, params = {}) {
      var _a, _b, _c, _d, _e;
      console.log("lookup", params);
      const { hypotheticals = [], hypothetical_1, hypothetical_2, hypothetical_3 } = params;
      if (hypothetical_1)
        hypotheticals.push(hypothetical_1);
      if (hypothetical_2)
        hypotheticals.push(hypothetical_2);
      if (hypothetical_3)
        hypotheticals.push(hypothetical_3);
      if (!hypotheticals)
        return { error: "hypotheticals is required" };
      const collection = ((_a = env.smart_blocks) == null ? void 0 : _a.smart_embed) ? env.smart_blocks : env.smart_notes;
      console.log(collection);
      if (!collection || !collection.smart_embed)
        return { error: "Embedding search is not enabled." };
      const embeddings = await collection.smart_embed.embed_batch(hypotheticals.map((h) => ({ embed_input: h })));
      console.log(embeddings);
      console.log({ scope: (_c = (_b = env.chats) == null ? void 0 : _b.current) == null ? void 0 : _c.scope });
      const filter = {
        ...((_e = (_d = env.chats) == null ? void 0 : _d.current) == null ? void 0 : _e.scope) || {},
        ...params.filter || {}
      };
      console.log({ filter });
      const results = embeddings.flatMap((embedding, i) => {
        return collection.nearest(embedding.vec, filter);
      });
      results.sort((a, b) => {
        if (a.sim === b.sim)
          return 0;
        return a.sim > b.sim ? -1 : 1;
      });
      const k = params.k || env.config.lookup_k || 10;
      let top_k = await Promise.all(
        results.slice(0, k).filter((r, i, a) => a.findIndex((t) => t.data.path === r.data.path) === i).map(async (r) => {
          return {
            score: r.sim,
            path: r.data.path
          };
        })
      );
      console.log(top_k);
      console.log(`Found and returned ${top_k.length} ${collection.collection_name}.`);
      return top_k;
    }
    exports2.lookup = lookup;
    function cos_sim(vector1, vector2) {
      const dotProduct = vector1.reduce((acc, val, i) => acc + val * vector2[i], 0);
      const normA = Math.sqrt(vector1.reduce((acc, val) => acc + val * val, 0));
      const normB = Math.sqrt(vector2.reduce((acc, val) => acc + val * val, 0));
      return normA === 0 || normB === 0 ? 0 : dotProduct / (normA * normB);
    }
    function top_acc(_acc, item, ct = 10) {
      if (_acc.items.size < ct) {
        _acc.items.add(item);
      } else if (item.sim > _acc.min) {
        _acc.items.add(item);
        _acc.items.delete(_acc.minItem);
        _acc.minItem = Array.from(_acc.items).reduce((min, curr) => curr.sim < min.sim ? curr : min);
        _acc.min = _acc.minItem.sim;
      }
    }
    exports2.top_acc = top_acc;
    function get_nearest_until_next_dev_exceeds_std_dev(nearest) {
      if (nearest.length === 0)
        return [];
      const sims = nearest.map((n) => n.sim);
      const mean = sims.reduce((a, b) => a + b) / sims.length;
      let std_dev = Math.sqrt(sims.map((x) => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / sims.length);
      let slice_i = 0;
      while (slice_i < nearest.length) {
        const next = nearest[slice_i + 1];
        if (next) {
          const next_dev = Math.abs(next.sim - nearest[slice_i].sim);
          if (next_dev > std_dev) {
            if (slice_i < 3)
              std_dev = std_dev * 1.5;
            else
              break;
          }
        }
        slice_i++;
      }
      nearest = nearest.slice(0, slice_i + 1);
      return nearest;
    }
    exports2.get_nearest_until_next_dev_exceeds_std_dev = get_nearest_until_next_dev_exceeds_std_dev;
    function sort_by_len_adjusted_similarity(nearest) {
      nearest = nearest.sort((a, b) => {
        const a_score = a.sim / a.tokens;
        const b_score = b.sim / b.tokens;
        if (a_score > b_score)
          return -1;
        if (a_score < b_score)
          return 1;
        return 0;
      });
      return nearest;
    }
    exports2.sort_by_len_adjusted_similarity = sort_by_len_adjusted_similarity;
    function get_top_k_by_sim(results, opts) {
      return Array.from(results.reduce((acc, item) => {
        var _a;
        if (!((_a = item.data.embedding) == null ? void 0 : _a.vec))
          return acc;
        item.sim = cos_sim(opts.vec, item.data.embedding.vec);
        top_acc(acc, item, opts.k);
        return acc;
      }, { min: 0, items: /* @__PURE__ */ new Set() }).items);
    }
    exports2.get_top_k_by_sim = get_top_k_by_sim;
  }
});

// src/actions/_actions.js
var require_actions = __commonJS({
  "src/actions/_actions.js"(exports2) {
    var { lookup } = require_lookup();
    exports2.lookup = lookup;
  }
});

// src/sc_actions.js
var require_sc_actions = __commonJS({
  "src/sc_actions.js"(exports2) {
    var ScTranslations = require_ScTranslations();
    var openapi_spec = require_actions_openapi();
    var handlers = require_actions();
    var { lookup } = require_lookup();
    var ScActions = class {
      constructor(env, opts = {}) {
        this.env = env;
        this.plugin = this.env.plugin;
        this.app = this.plugin.app;
        this.config = this.plugin.settings;
        this.actions = {};
      }
      init() {
        const actions = Object.entries(openapi_spec.paths).flatMap(
          ([path, methods]) => Object.entries(methods).map(([method, { operationId, requestBody, description }]) => {
            var _a, _b;
            return {
              type: "function",
              function: {
                name: operationId,
                description,
                parameters: {
                  type: "object",
                  properties: (_b = (_a = requestBody == null ? void 0 : requestBody.content["application/json"]) == null ? void 0 : _a.schema) == null ? void 0 : _b.properties
                }
              }
            };
          })
        );
        actions.forEach((action) => {
          this.actions[action.function.name] = {
            json: action,
            handler: handlers[action.function.name]
          };
        });
      }
      prepare_request_body(body) {
        var _a, _b;
        if ((_a = this.env.chats) == null ? void 0 : _a.current.tool_choice) {
          const tool_choice = this.env.chats.current.tool_choice;
          if (body.tool_choice !== "auto") {
            const tool_json = (_b = this.actions[tool_choice]) == null ? void 0 : _b.json;
            if (tool_json) {
              body.tool_choice = {
                type: "function",
                function: { name: tool_choice }
              };
              body.tools = [tool_json];
            }
          } else {
            body.tool_choice = "auto";
            body.tools = this.env.actions.actions.map((t) => t.json);
          }
        }
        console.log(body);
        return body;
      }
      // v2.1
      // DO: decided: rename to parse_user_message?
      async new_user_message(user_input) {
        if (Array.isArray(user_input)) {
          for (let i = 0; i < user_input.length; i++) {
            if (user_input[i].type === "text") {
              await this.new_user_message(user_input[i].text);
            }
          }
          return;
        }
        if (this.should_trigger_retrieval(user_input)) {
          console.log("should trigger retrieval");
          if (this.actions.lookup && this.env.chat_model.config.actions) {
            this.env.chats.current.tool_choice = "lookup";
          } else {
            await this.get_context_hyde(user_input);
          }
        }
      }
      should_trigger_retrieval(user_input) {
        if (this.contains_self_referential_keywords(user_input))
          return true;
        if (this.env.chats.current.scope.key_starts_with_any)
          return true;
        return false;
      }
      // check if includes keywords referring to one's own notes
      contains_self_referential_keywords(user_input) {
        if (user_input.match(new RegExp(`\\b(${ScTranslations[this.config.language].pronouns.join("|")})\\b`, "gi")))
          return true;
        return false;
      }
      // BACKWARD COMPATIBILITY for non-function-calling models (DEPRECATED)
      async get_context_hyde(user_input) {
        console.log("get_context_hyde");
        const hyd_input = `Anticipate what the user is seeking. Respond in the form of a hypothetical note written by the user. The note may contain statements as paragraphs, lists, or checklists in markdown format with no headings. Please respond with one hypothetical note and abstain from any other commentary. Use the format: PARENT FOLDER NAME > CHILD FOLDER NAME > FILE NAME > HEADING 1 > HEADING 2 > HEADING 3: HYPOTHETICAL NOTE CONTENTS.`;
        const chatml = [
          { role: "system", content: hyd_input },
          { role: "user", content: user_input }
        ];
        const hyd = await this.env.chat_model.complete(
          {
            messages: chatml,
            stream: false,
            temperature: 0,
            max_tokens: 420
            // n: 3, // DO: multiple completions (unavailable in Anthropic Claude)
          },
          false
          // skip render
        );
        this.env.chats.current.add_message({
          role: "assistant",
          tool_calls: [{
            function: {
              name: "lookup",
              arguments: JSON.stringify({ hypotheticals: [hyd] })
            }
          }]
        });
        const results = await lookup(this.env, { hypotheticals: [hyd] });
        await this.env.chats.current.add_tool_output("lookup", results);
        return;
      }
      parse_tool_output(tool_name, tool_output) {
        if (tool_name === "lookup")
          return parse_lookup_tool_output(tool_output);
      }
    };
    exports2.ScActions = ScActions;
    function parse_lookup_tool_output(tool_output) {
      let content = "```sc-context\n";
      tool_output.forEach((note, i) => {
        content += `${note.path}
`;
      });
      content += "```";
      return { role: "system", content };
    }
  }
});

// src/sc_env.js
var require_sc_env = __commonJS({
  "src/sc_env.js"(exports2) {
    var { Brain } = require_Brain();
    var { SmartMarkdown } = require_smart_chunks();
    var {
      SmartNotes,
      SmartBlocks,
      SmartNote,
      SmartBlock
    } = require_sc_entities();
    var { DataviewSocket } = require_dataview_socket();
    var templates = require_views();
    var ejs = require_ejs_min();
    var { ScChatModel } = require_sc_chat_model();
    var { ScChatsUI } = require_sc_chats_ui();
    var { ScChats } = require_sc_chats();
    var { ScActions } = require_sc_actions();
    var ScEnv2 = class extends Brain {
      constructor(plugin, ltm_adapter) {
        super(ltm_adapter);
        this.plugin = plugin;
        this.main = this.plugin;
        this.config = this.plugin.settings;
        this.data_path = this.config.smart_connections_folder;
        this.collections = {
          smart_notes: SmartNotes,
          smart_blocks: SmartBlocks
        };
        this.item_types = {
          SmartNote,
          SmartBlock
        };
        this.save_timeout = null;
        this.smart_embed_active_models = {};
        this.local_model_type = "Web";
        this.dv_ws = null;
        this.chat = null;
        this.ejs = ejs;
        this.templates = templates;
      }
      async reload() {
        this.unload();
        this.config = this.plugin.settings;
        await this.init();
      }
      unload() {
        this.unload_entities();
        this.smart_embed_active_models = {};
        if (this.dv_ws)
          this.dv_ws.unload();
      }
      unload_entities() {
        this.entities_loaded = false;
        if (this.smart_notes)
          this.smart_notes.unload();
        this.smart_notes = null;
        if (this.smart_blocks)
          this.smart_blocks.unload();
        this.smart_blocks = null;
      }
      async reload_entities() {
        this.unload_entities();
        if (this.plugin.is_initializing_entities)
          this.plugin.is_initializing_entities = false;
        await this.init_entities();
      }
      async init() {
        this.init_chat_model();
        DataviewSocket.create(this, 37042);
        this.smart_markdown = new SmartMarkdown({ ...this.config, skip_blocks_with_headings_only: true });
        await this.init_entities();
        await this.init_import();
        await this.init_chat();
      }
      // load one at a time to re-use embed models
      async init_entities() {
        if (this.plugin.is_initializing_entities)
          return console.log("already init entities");
        this.plugin.is_initializing_entities = true;
        if (this.config.embedding_file_per_note) {
          this.smart_notes = new SmartNotes(this);
          this.smart_blocks = new SmartBlocks(this);
          this.smart_notes.merge_defaults();
          this.smart_blocks.merge_defaults();
          await this.smart_blocks.load_smart_embed();
          await this.smart_notes.load();
        } else {
          await Promise.all(Object.values(this.collections).map(async (static_collection) => await static_collection.load(this)));
        }
        this.plugin.is_initializing_entities = false;
        this.entities_loaded = true;
      }
      // initiate import of smart notes, shows notice before starting embedding
      async init_import() {
        if (this.smart_notes.smart_embed || this.smart_blocks.smart_embed)
          this.smart_notes.import(this.files, { reset: true, show_notice: true });
      }
      init_chat_model(chat_model_platform_key = null) {
        var _a, _b;
        let chat_model_config = {};
        chat_model_platform_key = chat_model_platform_key != null ? chat_model_platform_key : this.config.chat_model_platform_key;
        if (chat_model_platform_key === "open_router" && !((_a = this.config[chat_model_platform_key]) == null ? void 0 : _a.api_key))
          chat_model_config.api_key = "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";
        else
          chat_model_config = (_b = this.config[chat_model_platform_key]) != null ? _b : {};
        this.chat_model = new ScChatModel(this, chat_model_platform_key, { ...chat_model_config });
        this.chat_model._request_adapter = this.plugin.obsidian.requestUrl;
      }
      async init_chat() {
        var _a;
        this.actions = new ScActions(this);
        this.actions.init();
        while (!((_a = this.plugin.chat_view) == null ? void 0 : _a.containerEl))
          await new Promise((r) => setTimeout(r, 300));
        this.chat_ui = new ScChatsUI(this, this.plugin.chat_view.containerEl);
        this.chats = new ScChats(this);
        await this.chats.load_all();
      }
      get_tfile(file_path) {
        return this.plugin.app.vault.getAbstractFileByPath(file_path);
      }
      async cached_read(file) {
        const t_file = typeof file === "string" ? this.get_tfile(file) : file;
        if (!(t_file instanceof this.plugin.obsidian.TFile))
          return null;
        return await this.plugin.app.vault.cachedRead(t_file);
      }
      async force_refresh() {
        this.smart_blocks.clear();
        this.smart_notes.clear();
        this.smart_notes.import(this.files);
      }
      // prevent saving too often (large files can cause lag)
      save() {
        if (this.save_timeout)
          clearTimeout(this.save_timeout);
        this.save_timeout = setTimeout(async () => {
          if (this.plugin.last_user_activity && Date.now() - this.plugin.last_user_activity < 6e4)
            return this.save();
          await this._save();
          this.save_timeout = null;
        }, 2e4);
      }
      async _save() {
        await Promise.all(Object.keys(this.collections).map(async (collection_name) => await this[collection_name]._save()));
      }
      // getters
      get all_files() {
        return this.plugin.app.vault.getFiles().filter((file) => file instanceof this.plugin.obsidian.TFile && (file.extension === "md" || file.extension === "canvas"));
      }
      // no exclusions
      get files() {
        return this.plugin.app.vault.getFiles().filter((file) => file instanceof this.plugin.obsidian.TFile && (file.extension === "md" || file.extension === "canvas") && this.is_included(file.path));
      }
      is_included(file_path) {
        return !this.file_exclusions.some((exclusion) => file_path.includes(exclusion));
      }
      get file_exclusions() {
        var _a;
        if (this._file_exclusions)
          return this._file_exclusions;
        this._file_exclusions = ((_a = this.plugin.settings.file_exclusions) == null ? void 0 : _a.length) ? this.plugin.settings.file_exclusions.split(",").map((file) => file.trim()) : [];
        return this._file_exclusions = this._file_exclusions.concat(this.folder_exclusions);
      }
      get folder_exclusions() {
        var _a;
        if (this._folder_exclusions)
          return this._folder_exclusions;
        return this._folder_exclusions = ((_a = this.plugin.settings.folder_exclusions) == null ? void 0 : _a.length) ? this.plugin.settings.folder_exclusions.split(",").map((folder) => {
          folder = folder.trim();
          if (folder.slice(-1) !== "/")
            return folder + "/";
          return folder;
        }) : [];
      }
      get excluded_headings() {
        var _a;
        if (this._excluded_headings)
          return this._excluded_headings;
        return this._excluded_headings = ((_a = this.plugin.settings.excluded_headings) == null ? void 0 : _a.length) ? this.plugin.settings.excluded_headings.split(",").map((heading) => heading.trim()) : [];
      }
      get system_prompts() {
        return this.plugin.app.vault.getMarkdownFiles().filter((file) => file.path.includes(this.config.system_prompts_folder) || file.path.includes(".prompt") || file.path.includes(".sp"));
      }
    };
    exports2.ScEnv = ScEnv2;
  }
});

// src/default_settings.js
var require_default_settings = __commonJS({
  "src/default_settings.js"(exports2) {
    function default_settings2() {
      return {
        settings: {
          new_user: true,
          chat_folder: "smart chat",
          smart_notes_embed_model: "TaylorAI/bge-micro-v2",
          smart_blocks_embed_model: "None",
          smart_connections_folder: ".smart-connections",
          smart_connections_folder_last: ".smart-connections",
          system_prompts_folder: "smart prompts",
          smart_chat_folder: "smart-chats",
          smart_chat_folder_last: "smart-chats",
          local_embedding_max_tokens: 2048,
          embedding_file_per_note: false,
          chat_model_platform_key: "open_router",
          open_router: {},
          // Smart Blocks Settings (chunking)
          embed_input_min_chars: 50,
          multi_heading_blocks: true,
          // v2.2
          enable_mobile: true,
          // V1
          api_key: "",
          excluded_headings: "",
          file_exclusions: "Untitled",
          folder_exclusions: "smart-chats",
          show_full_path: false,
          expanded_view: true,
          language: "en",
          log_render: false,
          log_render_files: false,
          recently_sent_retry_notice: false,
          version: ""
          // smart_chat_model: "gpt-3.5-turbo-0125",
          // skip_sections: false, // DEPRECATED
          // group_nearest_by_file: false, // DEPRECATED
          // path_only: "", // DEPRECATED
          // header_exclusions: "", // DEPRECATED use excluded_headings instead
        },
        api: null,
        embeddings_loaded: false,
        folders: [],
        has_new_embeddings: false,
        nearest_cache: {},
        render_log: {
          deleted_embeddings: 0,
          exclusions_logs: {},
          failed_embeddings: [],
          files: [],
          new_embeddings: 0,
          skipped_low_delta: {},
          token_usage: 0,
          tokens_saved_by_cache: 0
        },
        retry_notice_timeout: null,
        save_timeout: null,
        sc_branding: {},
        update_available: false
      };
    }
    exports2.default_settings = default_settings2;
  }
});

// src/smart_embed_settings.js
var require_smart_embed_settings = __commonJS({
  "src/smart_embed_settings.js"(exports2) {
    var { SmartSettings } = require_smart_settings();
    var smart_embed_models = require_models();
    var SmartEmbedSettings = class extends SmartSettings {
      refresh_smart_view() {
        this.plugin.smart_connections_view.render_nearest();
      }
      async connect_to_smart_connect() {
        var _a, _b;
        if ((_b = (_a = this.plugin.env.smart_notes) == null ? void 0 : _a.smart_embed) == null ? void 0 : _b.is_smart_connect) {
          this.plugin.notices.show("smart connect already connected", "Already connected to local Smart Connect for embedding.");
          return;
        }
        try {
          await this.plugin.obsidian.requestUrl({ url: "http://localhost:37421/", method: "GET" });
          this.plugin.notices.show("smart connect found", "Local Smart Connect server found. Connecting...");
          this.plugin.restart_plugin();
        } catch (err) {
          this.plugin.notices.show("smart connect not found", "Could not connect to local Smart Connect server");
        }
      }
      async test_api_key_openai_embeddings() {
        var _a, _b, _c, _d;
        const req = {
          url: `https://api.openai.com/v1/embeddings`,
          method: "POST",
          body: JSON.stringify({ model: "text-embedding-ada-002", input: "test" }),
          headers: { "Content-Type": "application/json", "Authorization": `Bearer ${this.plugin.settings.api_key}` }
        };
        try {
          const resp = await this.plugin.obsidian.requestUrl(req);
          if ((_d = (_c = (_b = (_a = resp == null ? void 0 : resp.json) == null ? void 0 : _a.data) == null ? void 0 : _b[0]) == null ? void 0 : _c.embedding) == null ? void 0 : _d.length) {
            return this.plugin.notices.show("api key test pass", "Success! OpenAI API key is valid");
          }
          this.plugin.notices.show("api key test fail", "Error: OpenAI API key is invalid!");
        } catch (err) {
          this.plugin.notices.show("api key test fail", "Error: OpenAI API key is invalid!");
          console.error("Smart Connections: Error testing OpenAI API key", err);
        }
      }
      reload_env() {
        this.env.reload();
      }
      // DEPRECATED
      restart_plugin() {
        this.plugin.restart_plugin();
      }
      get template() {
        return this.templates["smart_embed_settings"];
      }
      async get_view_data() {
        const view_data = {
          settings: this.plugin.settings,
          embedding_models: Object.keys(smart_embed_models).map((model_key) => ({ key: model_key, ...smart_embed_models[model_key] }))
        };
        view_data.smart_embed_settings = this.ejs.render(this.template, view_data);
        return view_data;
      }
    };
    exports2.SmartEmbedSettings = SmartEmbedSettings;
  }
});

// src/sc_smart_view.js
var require_sc_smart_view = __commonJS({
  "src/sc_smart_view.js"(exports2) {
    var { SmartObsidianView } = require_smart_obsidian_view();
    var { SmartEmbedSettings } = require_smart_embed_settings();
    var SUPPORTED_FILE_TYPES = ["md", "canvas"];
    var ScSmartView2 = class extends SmartObsidianView {
      static get view_type() {
        return "smart-connections-view";
      }
      // Obsidian
      getViewType() {
        return this.constructor.view_type;
      }
      getDisplayText() {
        return "Smart Connections Files";
      }
      getIcon() {
        return "smart-connections";
      }
      async onOpen() {
        this.app.workspace.onLayoutReady(this.initialize.bind(this));
      }
      async initialize() {
        var _a;
        this.env = this.plugin.brain;
        this.brain = this.env;
        this.last_parent_id = (_a = this.constructor.get_leaf(this.app.workspace)) == null ? void 0 : _a.parent.id;
        this.container = this.containerEl.children[1];
        this.container.empty();
        this.nearest_cache = {};
        this.plugin.smart_connections_view = this;
        this.register_plugin_events();
        this.app.workspace.registerHoverLinkSource(this.constructor.view_type, { display: "Smart Connections Files", defaultMod: true });
        this.container.innerHTML = this.render_template("smart_connections", { current_path: "", results: [] });
        this.add_top_bar_listeners();
      }
      async onClose() {
        console.log("closing smart connections view");
        this.app.workspace.unregisterHoverLinkSource(this.constructor.view_type);
      }
      onResize() {
        if (this.constructor.get_leaf(this.app.workspace).parent.id !== this.last_parent_id) {
          console.log("Parent changed, reloading");
          this.initialize();
        }
      }
      // getters
      // DEPRECATED
      // get path_only() { return (this.settings.path_only?.length) ? this.settings.path_only.split(",").map((path) => path.trim()) : []; }
      // Smart Connections
      register_plugin_events() {
        this.plugin.registerEvent(this.app.workspace.on("file-open", (file) => {
          this.update_last_user_activity_timestamp();
          if (!file)
            return;
          if (this.container.checkVisibility() === false)
            return console.log("View inactive, skipping render nearest");
          this.render_nearest(file);
        }));
        this.plugin.registerEvent(this.app.workspace.on("active-leaf-change", (leaf) => {
          var _a;
          this.update_last_user_activity_timestamp();
          if (leaf.view instanceof this.constructor) {
            if (leaf.view.container.querySelectorAll(".search-result").length && leaf.view.last_note === ((_a = this.app.workspace.getActiveFile()) == null ? void 0 : _a.path))
              return;
            return this.render_nearest();
          }
        }));
        this.plugin.registerEvent(this.app.workspace.on("editor-change", (editor) => {
          this.update_last_user_activity_timestamp();
        }));
        this.plugin.registerEvent(this.app.workspace.on("quit", async () => {
          if (this.env.save_timeout) {
            clearTimeout(this.env.save_timeout);
            await this.env._save();
            console.log("Smart Connections saved");
          }
        }));
      }
      // used in brain.save timeout to reset if recent activity (prevent saving blocking UX during user activity)
      update_last_user_activity_timestamp() {
        this.last_user_activity = Date.now();
      }
      // Smart Connections Views
      get view_context() {
        var _a, _b;
        return {
          ...super.view_context,
          blocks: (_a = this.env.smart_blocks) == null ? void 0 : _a.keys.length,
          notes: (_b = this.env.smart_notes) == null ? void 0 : _b.keys.length
        };
      }
      async render_nearest(context, container = this.container) {
        var _a;
        if (!this.env.entities_loaded) {
          container.innerHTML = "Loading Smart Connections...";
          while (!this.env.entities_loaded)
            await new Promise((r) => setTimeout(r, 2e3));
        }
        let results;
        if (typeof context === "string")
          results = await this.plugin.api.search(context);
        if (typeof context === "undefined")
          context = this.app.workspace.getActiveFile();
        if (context instanceof this.plugin.obsidian.TFile) {
          if (SUPPORTED_FILE_TYPES.indexOf(context.extension) === -1)
            return this.plugin.notices.show("unsupported file type", [
              "File: " + context.name,
              "Unsupported file type (Supported: " + SUPPORTED_FILE_TYPES.join(", ") + ")"
            ]);
          if (!this.env.smart_notes.get(context.path)) {
            if (this.env.is_included(context.path)) {
              await this.env.smart_notes.import(this.env.files);
            } else {
              return this.plugin.notices.show("excluded file", "File is excluded: " + context.path, { timeout: 3e3 });
            }
          }
          results = (_a = this.env.smart_notes.get(context.path)) == null ? void 0 : _a.find_connections();
        }
        if (context instanceof this.env.item_types.SmartBlock)
          results = context.find_connections();
        if (context instanceof this.env.item_types.SmartNote)
          results = context.find_connections();
        if (!results)
          return this.plugin.notices.show("no smart connections found", "No Smart Connections found.");
        if (typeof context === "object")
          context = context.key || context.path;
        this.last_note = this.app.workspace.getActiveFile().path;
        container.innerHTML = this.render_template("smart_connections", { current_path: context, results });
        this.add_top_bar_listeners(container);
        container.querySelectorAll(".search-result").forEach((elm, i) => this.add_link_listeners(elm, results[i]));
        container.querySelectorAll(".search-result:not(.sc-collapsed) ul li").forEach(this.render_result.bind(this));
      }
      async render_result(elm, i = 0) {
        var _a;
        if (elm.innerHTML)
          return console.log("already rendered");
        await new Promise((r) => setTimeout(r, 20 * i));
        if (!isElementVisible(elm)) {
          const parent = elm.closest(".search-result");
          if (parent.classList.contains("sc-collapsed"))
            return;
          if (!isElementVisible(parent)) {
            const observer = new IntersectionObserver((entries, observer2) => {
              if (entries[0].isIntersecting) {
                this.render_result(elm);
                observer2.unobserve(parent);
              }
            }, { threshold: 0.5 });
            observer.observe(parent);
            return;
          }
        }
        console.log("rendering result");
        const entity_key = elm.title;
        const collection_name = elm.dataset.collection;
        const entity = this.brain[collection_name].get(entity_key);
        if (should_render_embed())
          return this.plugin.obsidian.MarkdownRenderer.render(this.app, entity.embed_link, elm, entity_key, new this.plugin.obsidian.Component());
        const content = (_a = await (entity == null ? void 0 : entity.get_content())) == null ? void 0 : _a.replace(/```dataview/g, "```\\dataview");
        if (!entity || !content) {
          elm.createEl("p", { text: "Block not found: " + entity_key });
          const refresh_button = elm.createEl("button", { text: "Refresh embeddings" });
          refresh_button.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();
            this.env.smart_notes.import(this.env.files, { reset: true });
          });
        }
        this.plugin.obsidian.MarkdownRenderer.render(this.app, content, elm, entity_key, new this.plugin.obsidian.Component());
        function isElementVisible(elem) {
          const rect = elem.getBoundingClientRect();
          return rect.top >= 0 && rect.left >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && rect.right <= (window.innerWidth || document.documentElement.clientWidth);
        }
        function should_render_embed() {
          var _a2, _b;
          if (!entity)
            return false;
          if (entity.is_canvas)
            return true;
          if (entity.is_excalidraw)
            return true;
          if ((_a2 = entity.note) == null ? void 0 : _a2.is_canvas)
            return true;
          if ((_b = entity.note) == null ? void 0 : _b.is_excalidraw)
            return true;
          return false;
        }
      }
      add_link_listeners(elm, item) {
        elm.addEventListener("click", this.handle_search_result_click.bind(this));
        elm.setAttr("draggable", "true");
        elm.addEventListener("dragstart", (event) => {
          const dragManager = this.app.dragManager;
          const file_path = item.path.split("#")[0];
          const file = this.app.metadataCache.getFirstLinkpathDest(file_path, "");
          const dragData = dragManager.dragFile(event, file);
          dragManager.onDragStart(event, dragData);
        });
        if (item.path.indexOf("{") > -1)
          return;
        elm.addEventListener("mouseover", (event) => {
          this.app.workspace.trigger("hover-link", {
            event,
            source: this.constructor.view_type,
            hoverParent: elm.parentElement,
            targetEl: elm,
            linktext: item.path
          });
        });
      }
      handle_search_result_click(event) {
        event.preventDefault();
        event.stopPropagation();
        const search_result = event.target.classList.contains(".search-result") ? event.target : event.target.closest(".search-result");
        if (event.target instanceof SVGElement)
          return this.toggle_search_result_visibility(search_result);
        if (search_result.classList.contains("sc-collapsed")) {
          if (this.plugin.obsidian.Keymap.isModEvent(event))
            this.plugin.open_note(search_result.dataset.path, event);
          else
            this.toggle_search_result_visibility(search_result);
        } else
          this.plugin.open_note(search_result.dataset.path, event);
      }
      toggle_search_result_visibility(search_result_elm) {
        search_result_elm.classList.toggle("sc-collapsed");
        this.render_result(search_result_elm.querySelector("li"));
      }
      add_top_bar_listeners(container = this.container) {
        const top_bar = container.querySelector(".sc-top-bar");
        const search_button = container.querySelector(".sc-search-button");
        search_button.addEventListener("click", () => {
          const og_top_bar = top_bar.innerHTML;
          top_bar.empty();
          const search_container = top_bar.createEl("div", { cls: "search-input-container" });
          const input = search_container.createEl("input", {
            cls: "sc-search-input",
            type: "search",
            placeholder: "Type to start search..."
          });
          input.focus();
          input.addEventListener("keydown", (event) => {
            if (event.key === "Escape") {
              if (this.search_timeout)
                clearTimeout(this.search_timeout);
              top_bar.innerHTML = og_top_bar;
              this.add_top_bar_listeners(container);
            }
          });
          input.addEventListener("keyup", (event) => {
            if (this.search_timeout)
              clearTimeout(this.search_timeout);
            const search_term = input.value;
            if (event.key === "Enter" && search_term !== "")
              this.render_nearest(search_term);
            else if (search_term !== "") {
              if (this.search_timeout)
                clearTimeout(this.search_timeout);
              this.search_timeout = setTimeout(() => this.render_nearest(search_term), 700);
            }
          });
        });
        const fold_all_button = container.querySelector(".sc-fold-all");
        fold_all_button.addEventListener("click", (e) => {
          container.querySelectorAll(".search-result").forEach((elm) => elm.classList.add("sc-collapsed"));
          this.plugin.settings.expanded_view = false;
          this.plugin.save_settings();
        });
        const unfold_all_button = container.querySelector(".sc-unfold-all");
        unfold_all_button.addEventListener("click", () => {
          container.querySelectorAll(".search-result").forEach((elm) => {
            elm.classList.remove("sc-collapsed");
            this.render_result(elm.querySelector("li"));
          });
          this.plugin.settings.expanded_view = true;
          this.plugin.save_settings();
        });
        const settings_btn = this.container.querySelector("button[title='Settings']");
        settings_btn.addEventListener("click", async () => {
          const settings_container = this.container.querySelector("#settings");
          if (settings_container.innerHTML)
            return settings_container.innerHTML = "";
          if (!this.embed_settings)
            this.embed_settings = new SmartEmbedSettings(this.env, settings_container);
          else
            this.embed_settings.container = settings_container;
          this.embed_settings.render();
          settings_container.style.transition = "background-color 0.5s ease-in-out";
          settings_container.style.backgroundColor = "var(--bold-color)";
          setTimeout(() => {
            settings_container.style.backgroundColor = "";
          }, 500);
        });
      }
    };
    exports2.ScSmartView = ScSmartView2;
  }
});

// src/smart_search.js
var require_smart_search = __commonJS({
  "src/smart_search.js"(exports2) {
    var SmartSearch2 = class {
      constructor(plugin) {
        this.main = plugin;
        this.plugin = plugin;
      }
      async search(search_text, filter = {}) {
        var _a, _b, _c, _d, _e, _f;
        try {
          if (!((_b = (_a = this.plugin.env) == null ? void 0 : _a.smart_blocks) == null ? void 0 : _b.smart_embed) && !((_d = (_c = this.plugin.env) == null ? void 0 : _c.smart_notes) == null ? void 0 : _d.smart_embed)) {
            this.plugin.notices.show("embed model not loaded", "Embed model not loaded. Please wait for the model to load and try again.");
            return [];
          }
          const collection = ((_f = (_e = this.plugin.env) == null ? void 0 : _e.smart_blocks) == null ? void 0 : _f.smart_embed) ? this.plugin.env.smart_blocks : this.plugin.env.smart_notes;
          const embedding = await collection.smart_embed.embed(search_text);
          if (!(embedding == null ? void 0 : embedding.vec)) {
            this.main.notices.show("embed search text failed", "Failed to embed search text.");
            return [];
          }
          return collection.nearest(embedding.vec, filter).sort((a, b) => {
            if (a.sim > b.sim)
              return -1;
            if (a.sim < b.sim)
              return 1;
            return 0;
          });
        } catch (e) {
          this.main.notices.show("error in embedding search", "Error in embedding search. See console for details.", { timeout: 0 });
          console.error(e);
          return [];
        }
      }
    };
    exports2.SmartSearch = SmartSearch2;
  }
});

// src/smart_notices.js
var require_smart_notices = __commonJS({
  "src/smart_notices.js"(exports2) {
    var { setIcon } = require("obsidian");
    var SmartNotices2 = class {
      constructor(main) {
        this.main = main;
        this.active = {};
      }
      show(id, message, opts = {}) {
        var _a, _b;
        if (typeof opts.timeout === "undefined")
          opts.timeout = 5e3;
        if ((_a = this.main.settings.muted_notices) == null ? void 0 : _a[id]) {
          if (opts.confirm && typeof opts.confirm.callback === "function")
            opts.confirm.callback.call();
          return;
        }
        const content = this.build(id, message, opts);
        if (this.active[id] && ((_b = this.active[id].noticeEl) == null ? void 0 : _b.parentElement)) {
          return this.active[id].setMessage(content, opts.timeout);
        }
        return this.render(id, content, opts);
      }
      render(id, content, opts) {
        this.active[id] = new this.main.obsidian.Notice(content, opts.timeout);
        return this.active[id];
      }
      build(id, message, opts = {}) {
        const frag = document.createDocumentFragment();
        const head = frag.createEl("p", { cls: "sc-notice-head", text: "[Smart Connections]" });
        const content = frag.createEl("p", { cls: "sc-notice-content" });
        const actions = frag.createEl("div", { cls: "sc-notice-actions" });
        if (typeof message === "string")
          content.innerText = message;
        else if (Array.isArray(message))
          content.innerHTML = message.join("<br>");
        if (!opts.immutable)
          this.add_mute_btn(id, actions);
        if (opts.confirm)
          this.add_btn(opts.confirm, actions);
        if (opts.button)
          this.add_btn(opts.button, actions);
        return frag;
      }
      add_btn(button, container) {
        const btn = document.createElement("button");
        btn.innerHTML = button.text;
        btn.addEventListener("click", (e) => {
          if (button.stay_open) {
            e.preventDefault();
            e.stopPropagation();
          }
          button.callback();
        });
        container.appendChild(btn);
      }
      add_mute_btn(id, container) {
        const btn = document.createElement("button");
        setIcon(btn, "bell-off");
        btn.addEventListener("click", () => {
          if (!this.main.settings.muted_notices)
            this.main.settings.muted_notices = {};
          this.main.settings.muted_notices[id] = true;
          this.main.save_settings();
          this.show("Notice muted", "Notice muted", { timeout: 2e3 });
        });
        container.appendChild(btn);
      }
      unload() {
        for (let id in this.active) {
          this.remove(id);
        }
      }
      remove(id) {
        var _a;
        (_a = this.active[id]) == null ? void 0 : _a.hide();
        delete this.active[id];
      }
      // begin plugin specific methods
      show_requires_smart_view() {
        const btn = { text: "Open Smart View", callback: () => {
          this.main.open_view(false);
        } };
        const msg = 'Smart View must be open to utilize all Smart Chat features. For example, asking things like "Based on my notes..." requires Smart View to be open.';
        this.show("requires smart view", msg, { button: btn, timeout: 0 });
      }
    };
    exports2.SmartNotices = SmartNotices2;
  }
});

// src/sc_settings.js
var require_sc_settings = __commonJS({
  "src/sc_settings.js"(exports2) {
    var { SmartSettings } = require_smart_settings();
    var smart_embed_models = require_models();
    var { SmartChatSettings } = require_smart_chat_settings();
    var { SmartEmbedSettings } = require_smart_embed_settings();
    var ScSettings2 = class extends SmartSettings {
      constructor(env, container, template_name = "smart_settings") {
        super(env, container, template_name);
        this.chat_settings = new SmartChatSettings(env, container, template_name);
        this.embed_settings = new SmartEmbedSettings(env, container, template_name);
      }
      update_smart_chat_folder() {
        this.chat_settings.update_smart_chat_folder();
      }
      async changed_smart_chat_model() {
        await this.chat_settings.changed_smart_chat_model(false);
        this.render();
      }
      async test_chat_api_key() {
        await this.chat_settings.test_chat_api_key();
      }
      get self_ref_list() {
        return this.chat_settings.self_ref_list;
      }
      async refresh_notes() {
        this.env.smart_notes.import(this.env.files, { reset: true });
      }
      reload_env() {
        this.env.reload();
      }
      // DEPRECATED
      restart_plugin() {
        this.plugin.restart_plugin();
      }
      force_refresh() {
        this.env.force_refresh();
      }
      sync_for_chatgpt() {
        this.plugin.sync_notes();
      }
      update_smart_connections_folder() {
        this.plugin.update_smart_connections_folder();
      }
      refresh_smart_view() {
        this.embed_settings.refresh_smart_view();
      }
      async connect_to_smart_connect() {
        await this.embed_settings.connect_to_smart_connect();
      }
      // test API key
      async test_api_key_openai_embeddings() {
        await this.embed_settings.test_api_key_openai_embeddings();
      }
      async exclude_all_top_level_folders() {
        const folders = (await this.app.vault.adapter.list("/")).folders;
        const input = this.container.querySelector("div[data-setting='folder_exclusions'] input");
        input.value = folders.join(", ");
        input.dispatchEvent(new Event("input"));
        this.update_exclusions();
      }
      async update_language(setting, value, elm) {
        await this.update("language", value);
        const self_ref_pronouns_list = this.container.querySelector("#self-referential-pronouns");
        self_ref_pronouns_list.setText(this.self_ref_list);
      }
      async update_exclusions() {
        this.plugin.env._file_exclusions = null;
        this.plugin.env._folder_exclusions = null;
        console.log("render_file_counts");
        const elm = this.container.querySelector("#file-counts");
        console.log("elm", elm);
        const total_files = this.plugin.env.all_files.length;
        const included_files = this.plugin.env.files.length;
        elm.setText(`Included files: ${included_files} / Total files: ${total_files}`);
      }
      get template() {
        return this.templates["smart_settings"];
      }
      async get_view_data() {
        const view_data = {
          settings: this.plugin.settings,
          embedding_models: Object.keys(smart_embed_models).map((model_key) => ({ key: model_key, ...smart_embed_models[model_key] })),
          included_files: this.plugin.env.files.length,
          total_files: this.plugin.env.all_files.length,
          muted_notices: this.plugin.settings.muted_notices || false,
          ...await this.chat_settings.get_view_data() || {},
          ...await this.embed_settings.get_view_data() || {}
        };
        return view_data;
      }
      unmute_notice(setting) {
        const id = setting.split(".")[1];
        console.log("unmute_notice", id);
        delete this.plugin.settings.muted_notices[id];
        this.update("muted_notices", this.plugin.settings.muted_notices);
        this.render();
      }
      // upgrade to early access
      async upgrade_to_early_access() {
        await this.plugin.update_early_access();
      }
    };
    exports2.ScSettings = ScSettings2;
  }
});

// src/sc_settings_tab.js
var require_sc_settings_tab = __commonJS({
  "src/sc_settings_tab.js"(exports2) {
    var { PluginSettingTab } = require("obsidian");
    var ScSettingsTab2 = class extends PluginSettingTab {
      constructor(app, plugin) {
        super(app, plugin);
        this.plugin = plugin;
        this.config = plugin.settings;
      }
      display() {
        this.smart_settings = new this.plugin.ScSettings(this.plugin.env, this.containerEl);
        return this.smart_settings.render();
      }
    };
    exports2.ScSettingsTab = ScSettingsTab2;
  }
});

// src/sc_actions_ux.js
var require_sc_actions_ux = __commonJS({
  "src/sc_actions_ux.js"(exports2) {
    var ejs = require_ejs_min();
    var views = require_views();
    var ScActionsUx2 = class {
      constructor(plugin, container) {
        this.plugin = plugin;
        this.container = container;
      }
      change_code_block(code) {
        const active_file = this.plugin.app.workspace.getActiveFile();
        const note_path = active_file.path;
        const old_content = code.substring(code.indexOf("<<<<<<< ORIGINAL\n") + "<<<<<<< ORIGINAL\n".length, code.indexOf("======="));
        const new_content = code.substring(code.indexOf("=======\n") + "=======\n".length, code.indexOf(">>>>>>>"));
        const time_saved = (Math.round(new_content.split(" ").length / 50) || 1) + " min";
        this.container.innerHTML = this.render_template("sc_change", { new_content, old_content, time_saved });
        console.log(this.container);
        const new_content_container = this.container.querySelector(".new-content");
        const old_content_container = this.container.querySelector(".old-content");
        this.plugin.obsidian.MarkdownRenderer.renderMarkdown(new_content, new_content_container, note_path, new this.plugin.obsidian.Component());
        this.plugin.obsidian.MarkdownRenderer.renderMarkdown(old_content, old_content_container, note_path, new this.plugin.obsidian.Component());
        const show_old_button = this.get_button_by_text("Show Old");
        const hide_old_button = this.get_button_by_text("Hide Old");
        show_old_button.onclick = () => {
          old_content_container.style.display = "block";
          show_old_button.style.display = "none";
          hide_old_button.style.display = "inline-block";
        };
        hide_old_button.onclick = () => {
          old_content_container.style.display = "none";
          show_old_button.style.display = "inline-block";
          hide_old_button.style.display = "none";
        };
        const approve_button = this.get_button_by_text("Accept");
        approve_button.onclick = async () => {
          const content = await this.plugin.app.vault.cachedRead(active_file);
          const updated_content = content.replace("```sc-change\n" + code + "\n```", new_content.trim());
          await this.plugin.app.vault.modify(active_file, updated_content);
          await this.append_accepted_changes({ note_path, old_content, new_content, time_saved });
        };
        const reject_button = this.get_button_by_text("Reject");
        reject_button.onclick = async () => {
          const content = await this.plugin.app.vault.cachedRead(active_file);
          const updated_content = content.replace("```sc-change\n" + code + "\n```", old_content.trim());
          await this.plugin.app.vault.modify(active_file, updated_content);
        };
      }
      async append_accepted_changes(change) {
        const file_path = this.plugin.settings.smart_connections_folder + "/accepted_changes.ndjson";
        if (!await this.plugin.app.vault.exists(file_path)) {
          console.log("File does not exist, creating it");
          await this.plugin.app.vault.create(file_path, "");
        }
        await this.plugin.app.vault.adapter.append(file_path, JSON.stringify(change) + "\n");
      }
      render_template(template_name, data) {
        if (!views[template_name])
          throw new Error(`Template '${template_name}' not found.`);
        return ejs.render(views[template_name], data, { context: this });
      }
      get_button_by_text(text) {
        return get_button_by_text(this.container, text);
      }
      get_icon(name) {
        return this.plugin.obsidian.getIcon(name).outerHTML;
      }
      get attribution() {
        return views.attribution;
      }
    };
    function get_button_by_text(container, text) {
      return Array.from(container.querySelectorAll("button")).find((button) => button.textContent === text);
    }
    exports2.ScActionsUx = ScActionsUx2;
  }
});

// src/open_note.js
var require_open_note = __commonJS({
  "src/open_note.js"(exports2) {
    async function open_note2(plugin, target_path, event = null) {
      let targetFile;
      let heading;
      if (target_path[target_path.length - 1] === "#")
        target_path = target_path.slice(0, -1);
      if (target_path.indexOf("#") > -1) {
        targetFile = plugin.app.metadataCache.getFirstLinkpathDest(target_path.split("#")[0], "");
        const target_file_cache = plugin.app.metadataCache.getFileCache(targetFile);
        let heading_text = target_path.split("#").pop();
        let occurence = 0;
        if (heading_text.indexOf("{") > -1) {
          occurence = parseInt(heading_text.split("{")[1].split("}")[0]);
          heading_text = heading_text.split("{")[0];
        }
        const headings = target_file_cache.headings;
        for (let i = 0; i < headings.length; i++) {
          if (headings[i].heading === heading_text) {
            if (occurence === 0) {
              heading = headings[i];
              break;
            }
            occurence--;
          }
        }
      } else {
        targetFile = plugin.app.metadataCache.getFirstLinkpathDest(target_path, "");
      }
      let leaf;
      if (event) {
        const mod = plugin.obsidian.Keymap.isModEvent(event);
        leaf = plugin.app.workspace.getLeaf(mod);
      } else {
        leaf = plugin.app.workspace.getMostRecentLeaf();
      }
      await leaf.openFile(targetFile);
      if (heading) {
        let { editor } = leaf.view;
        const pos = { line: heading.position.start.line, ch: 0 };
        editor.setCursor(pos);
        editor.scrollIntoView({ to: pos, from: pos }, true);
      }
    }
    exports2.open_note = open_note2;
  }
});

// src/index.js
var {
  addIcon,
  Keymap,
  MarkdownRenderer,
  Notice,
  Plugin,
  request,
  requestUrl,
  TAbstractFile,
  TFile
} = require("obsidian");
var { ObsAJSON } = require_ObsAJSON();
var { ObsMultiAJSON } = require_ObsMultiAJSON();
var { ScEnv } = require_sc_env();
var { default_settings } = require_default_settings();
var { ScSmartView } = require_sc_smart_view();
var { SmartSearch } = require_smart_search();
var { SmartNotices } = require_smart_notices();
var { ScChatView } = require_sc_chat_view();
var { ScSettings } = require_sc_settings();
var { ScSettingsTab } = require_sc_settings_tab();
var embed_models = require_models();
var { ScActionsUx } = require_sc_actions_ux();
var { open_note } = require_open_note();
var SmartConnectionsPlugin = class extends Plugin {
  static get defaults() {
    return default_settings();
  }
  get item_views() {
    return {
      ScSmartView,
      ScChatView
    };
  }
  get ScSettings() {
    return ScSettings;
  }
  async open_note(target_path, event = null) {
    await open_note(this, target_path, event);
  }
  async load_settings() {
    Object.assign(this, this.constructor.defaults);
    Object.assign(this.settings, await this.loadData());
    this.handle_deprecated_settings();
  }
  async onload() {
    this.app.workspace.onLayoutReady(this.initialize.bind(this));
  }
  // initialize when layout is ready
  onunload() {
    var _a, _b;
    console.log("unloading plugin");
    (_a = this.env) == null ? void 0 : _a.unload();
    this.env = null;
    this.brain = null;
    (_b = this.notices) == null ? void 0 : _b.unload();
  }
  async initialize() {
    console.log("Loading Smart Connections v2...");
    await this.load_settings();
    this.smart_connections_view = null;
    this.add_commands();
    this.register_views();
    this.addSettingTab(new ScSettingsTab(this.app, this, "smart_settings_21"));
    this.check_for_updates();
    this.add_to_gitignore("\n\n# Ignore Smart Connections folder\n.smart-connections");
    this.api = new SmartSearch(this);
    (window["SmartSearch"] = this.api) && this.register(() => delete window["SmartSearch"]);
    addIcon("smart-connections", `<path d="M50,20 L80,40 L80,60 L50,100" stroke="currentColor" stroke-width="4" fill="none"/>
    <path d="M30,50 L55,70" stroke="currentColor" stroke-width="5" fill="none"/>
    <circle cx="50" cy="20" r="9" fill="currentColor"/>
    <circle cx="80" cy="40" r="9" fill="currentColor"/>
    <circle cx="80" cy="70" r="9" fill="currentColor"/>
    <circle cx="50" cy="100" r="9" fill="currentColor"/>
    <circle cx="30" cy="50" r="9" fill="currentColor"/>`);
    this.addRibbonIcon("smart-connections", "Open: View Smart Connections", () => {
      this.open_view();
    });
    this.addRibbonIcon("message-square", "Open: Smart Chat Conversation", () => {
      this.open_chat();
    });
    this.registerMarkdownCodeBlockProcessor("smart-connections", this.render_code_block.bind(this));
    this.registerMarkdownCodeBlockProcessor("sc-context", this.render_code_block_context.bind(this));
    this.registerMarkdownCodeBlockProcessor("sc-change", this.change_code_block.bind(this));
    this.notices = new SmartNotices(this);
    this.obsidian = require("obsidian");
    this.new_user();
    await this.load_env();
    console.log("Smart Connections v2 loaded");
  }
  async load_env() {
    this.env = new ScEnv(this, this.settings.embedding_file_per_note ? ObsMultiAJSON : ObsAJSON);
    this.brain = this.env;
    await this.env.init();
  }
  new_user() {
    if (!this.settings.new_user)
      return;
    this.settings.new_user = false;
    this.settings.version = this.manifest.version;
    this.open_view();
    this.open_chat();
    if (this.app.workspace.rightSplit.collapsed)
      this.app.workspace.rightSplit.toggle();
    this.save_settings();
  }
  register_views() {
    Object.values(this.item_views).forEach((View) => {
      this.registerView(View.view_type, (leaf) => new View(leaf, this));
    });
  }
  async check_for_updates() {
    if (this.settings.version !== this.manifest.version) {
      this.settings.version = this.manifest.version;
      await this.save_settings();
    }
    setTimeout(this.check_for_update.bind(this), 3e3);
    setInterval(this.check_for_update.bind(this), 108e5);
  }
  // check for update
  async check_for_update() {
    try {
      const { json: response } = await requestUrl({
        url: "https://api.github.com/repos/brianpetro/obsidian-smart-connections/releases/latest",
        method: "GET",
        headers: {
          "Content-Type": "application/json"
        },
        contentType: "application/json"
      });
      const latest_release = response.tag_name;
      if (latest_release !== this.manifest.version) {
        new Notice(`[Smart Connections] A new version is available! (v${latest_release})`);
        this.update_available = true;
      }
    } catch (error) {
      console.log(error);
    }
  }
  async restart_plugin() {
    await this.saveData(this.settings);
    await new Promise((r) => setTimeout(r, 3e3));
    window.restart_plugin = async (id) => {
      console.log("restarting plugin", id);
      await window.app.plugins.disablePlugin(id);
      await window.app.plugins.enablePlugin(id);
      console.log("plugin restarted", id);
    };
    await window.restart_plugin(this.manifest.id);
  }
  add_commands() {
    this.addCommand({
      id: "sc-find-notes",
      name: "Find: Make Smart Connections",
      icon: "pencil_icon",
      hotkeys: [],
      editorCallback: (editor) => {
        var _a;
        if (editor.somethingSelected())
          this.view.render_nearest(editor.getSelection());
        else if ((_a = editor.getCursor()) == null ? void 0 : _a.line) {
          const line = editor.getCursor().line;
          const block = this.brain.smart_notes.current_note.get_block_by_line(line);
          console.log(block);
          console.log(line);
          this.view.render_nearest(block);
        } else
          this.view.render_nearest();
      }
    });
    this.addCommand({
      id: "sc-refresh-connections",
      name: "Refresh & Make Connections",
      icon: "pencil_icon",
      hotkeys: [],
      editorCallback: async (editor) => {
        var _a;
        const curr_file = this.app.workspace.getActiveFile();
        (_a = this.view) == null ? true : delete _a.nearest_cache[curr_file.path];
        this.env.smart_notes.delete(curr_file.path);
        await this.env.smart_notes.import([curr_file]);
        setTimeout(() => {
          this.view.render_nearest();
        }, 1e3);
      }
    });
    this.addCommand({
      id: "smart-connections-view",
      name: "Open: View Smart Connections",
      callback: () => {
        this.open_view();
      }
    });
    this.addCommand({
      id: "smart-connections-chat",
      name: "Open: Smart Chat Conversation",
      callback: () => {
        this.open_chat();
      }
    });
    this.addCommand({
      id: "smart-connections-random",
      name: "Open: Random Note from Smart Connections",
      callback: () => {
        var _a;
        const curr_file = this.app.workspace.getActiveFile();
        const curr_note = (_a = this.brain) == null ? void 0 : _a.smart_notes.get(curr_file.path);
        const nearest = curr_note.find_connections();
        const rand = Math.floor(Math.random() * nearest.length / 2);
        const rand_entity = nearest[rand];
        this.open_note(rand_entity.path);
      }
    });
  }
  async make_connections(selected_text = null) {
    if (!this.view)
      await this.open_view();
    await this.view.render_nearest(selected_text);
  }
  async save_settings(rerender = false) {
    await this.saveData(this.settings);
    await this.load_settings();
    if (rerender) {
      this.nearest_cache = {};
      console.log("rerendering view");
      await this.make_connections();
    }
  }
  // utils
  async add_to_gitignore(ignore, message = null) {
    if (!await this.app.vault.adapter.exists(".gitignore"))
      return;
    let gitignore_file = await this.app.vault.adapter.read(".gitignore");
    if (gitignore_file.indexOf(ignore) < 0) {
      await this.app.vault.adapter.append(".gitignore", `

${message ? "# " + message + "\n" : ""}${ignore}`);
      console.log("Added to .gitignore: " + ignore);
    }
  }
  show_notice(message, opts = {}) {
    console.log("old showing notice");
    const notice_id = typeof message === "string" ? message : message[0];
    return this.notices.show(notice_id, message, opts);
  }
  open_view(active = true) {
    ScSmartView.open(this.app.workspace, active);
  }
  open_chat() {
    ScChatView.open(this.app.workspace);
  }
  get view() {
    return ScSmartView.get_view(this.app.workspace);
  }
  get chat_view() {
    return ScChatView.get_view(this.app.workspace);
  }
  // get folders, traverse non-hidden sub-folders
  async get_folders(path = "/") {
    try {
      const folders = (await this.app.vault.adapter.list(path)).folders;
      let folder_list = [];
      for (let i = 0; i < folders.length; i++) {
        if (folders[i].startsWith("."))
          continue;
        folder_list.push(folders[i]);
        folder_list = folder_list.concat(await this.get_folders(folders[i] + "/"));
      }
      return folder_list;
    } catch (error) {
      console.warn("Error getting folders", error);
      return [];
    }
  }
  // SUPPORTERS
  async sync_notes() {
    if (!this.settings.license_key) {
      new Notice("Smart Connections: Supporter license key is required to sync notes to the ChatGPT Plugin server.");
      return;
    }
    console.log("syncing notes");
    const files = this.brain.files;
    const notes = await this.build_notes_object(files);
    const response = await requestUrl({
      url: "https://sync.smartconnections.app/sync",
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      contentType: "application/json",
      body: JSON.stringify({
        license_key: this.settings.license_key,
        notes
      })
    });
    console.log(response);
  }
  async build_notes_object(files) {
    let output = {};
    for (let i = 0; i < files.length; i++) {
      let file = files[i];
      let parts = file.path.split("/");
      let current = output;
      for (let ii = 0; ii < parts.length; ii++) {
        let part = parts[ii];
        if (ii === parts.length - 1) {
          current[part] = await this.app.vault.cachedRead(file);
        } else {
          if (!current[part]) {
            current[part] = {};
          }
          current = current[part];
        }
      }
    }
    return output;
  }
  async render_code_block(contents, container, ctx) {
    console.log(container);
    return this.view.render_nearest(contents.trim().length ? contents : ctx.sourcePath, container);
  }
  async render_code_block_context(results, container, ctx) {
    results = this.get_entities_from_context_codeblock(results);
    console.log(results);
    container.innerHTML = this.view.render_template("smart_connections", { current_path: "context", results });
    container.querySelectorAll(".search-result").forEach((elm, i) => this.view.add_link_listeners(elm, results[i]));
    container.querySelectorAll(".search-result:not(.sc-collapsed) ul li").forEach(this.view.render_result.bind(this.view));
  }
  get_entities_from_context_codeblock(results) {
    return results.split("\n").map((key) => {
      const entity = key.includes("#") ? this.brain.smart_blocks.get(key) : this.brain.smart_notes.get(key);
      return entity ? entity : { name: "Not found: " + key };
    });
  }
  // change code block
  async change_code_block(source, el, ctx) {
    console.log(source);
    const renderer = new ScActionsUx(this, el);
    renderer.change_code_block(source);
  }
  // update smart connections folder
  async update_smart_connections_folder() {
    if (this.settings.smart_connections_folder === this.settings.smart_connections_folder_last)
      return;
    if (!confirm("Are you sure you want to update the Smart Connections folder? This will move all Smart Connections files to the new folder and restart the plugin.")) {
      this.settings.smart_connections_folder = this.settings.smart_connections_folder_last;
      return;
    }
    await this.app.vault.adapter.rename(this.settings.smart_connections_folder_last, this.settings.smart_connections_folder);
    this.settings.smart_connections_folder_last = this.settings.smart_connections_folder;
    await this.save_settings();
    this.restart_plugin();
  }
  // update smart chat folder
  async update_smart_chat_folder() {
    if (this.settings.smart_chat_folder === this.settings.smart_chat_folder_last)
      return;
    if (!confirm("Are you sure you want to update the Smart Chats folder? This will move all Smart Chat files to the new folder.")) {
      this.settings.smart_chat_folder = this.settings.smart_chat_folder_last;
      return;
    }
    await this.app.vault.adapter.rename(this.settings.smart_chat_folder_last, this.settings.smart_chat_folder);
    this.settings.smart_chat_folder_last = this.settings.smart_chat_folder;
    await this.save_settings();
    this.env.chats.folder = this.settings.smart_chat_folder;
  }
  async update_early_access() {
    if (!this.settings.license_key)
      return this.show_notice("Supporter license key required for early access update");
    const v2 = await this.obsidian.requestUrl({
      url: "https://sync.smartconnections.app/download_v2",
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        license_key: this.settings.license_key
      })
    });
    if (v2.status !== 200)
      return console.error("Error downloading early access update", v2);
    console.log(v2.json);
    await this.app.vault.adapter.write(".obsidian/plugins/smart-connections/main.js", v2.json.main);
    await this.app.vault.adapter.write(".obsidian/plugins/smart-connections/manifest.json", v2.json.manifest);
    await this.app.vault.adapter.write(".obsidian/plugins/smart-connections/styles.css", v2.json.styles);
    await window.app.plugins.loadManifests();
    await this.restart_plugin();
  }
  // BEGIN BACKWARD COMPATIBILITY (DEPRECATED: remove before 2.2 stable release)
  async handle_deprecated_settings() {
    Object.entries(this.settings).forEach(([key, value]) => {
      var _a;
      if (key.includes("-")) {
        const new_key = key.replace(/-/g, "_");
        this.settings[new_key] = value;
        delete this.settings[key];
        this.save_settings();
      }
      if (key.startsWith("api_key_")) {
        const platform = key.replace(/^api_key_/, "");
        if (!this.settings[platform])
          this.settings[platform] = {};
        if (!this.settings[platform].api_key)
          this.settings[platform].api_key = value;
        if ((_a = this.settings.smart_chat_model) == null ? void 0 : _a.startsWith(platform)) {
          const model_name = this.settings.smart_chat_model.replace(platform + "-", "");
          if (!this.settings[platform].model_name)
            this.settings[platform].model_name = model_name;
          delete this.settings.smart_chat_model;
        }
        delete this.settings[key];
        this.save_settings();
      }
    });
    if (!this.settings.file_exclusions.includes("Untitled")) {
      if (this.settings.file_exclusions.length)
        this.settings.file_exclusions += ",";
      this.settings.file_exclusions += "Untitled";
      this.save_settings();
    }
    if (this.settings.smart_notes_embed_model === "None") {
      this.settings.smart_notes_embed_model = "TaylorAI/bge-micro-v2";
      this.save_settings();
    }
    if (!embed_models[this.settings.smart_notes_embed_model]) {
      this.settings.smart_notes_embed_model = this.constructor.defaults.smart_notes_embed_model;
      this.save_settings();
    }
    if (!embed_models[this.settings.smart_blocks_embed_model] && this.settings.smart_blocks_embed_model !== "None") {
      this.settings.smart_blocks_embed_model = this.constructor.defaults.smart_blocks_embed_model;
      this.save_settings();
    }
    if (this.settings.header_exclusions) {
      this.settings.excluded_headings = this.settings.header_exclusions;
      delete this.settings.header_exclusions;
    }
  }
};
module.exports = SmartConnectionsPlugin;
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWNvbGxlY3Rpb25zL2xvbmdfdGVybV9tZW1vcnkuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWNvbGxlY3Rpb25zL09ic0FKU09OLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zbWFydC1jb2xsZWN0aW9ucy9PYnNNdWx0aUFKU09OLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zbWFydC1jb2xsZWN0aW9ucy9lbnYuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWNvbGxlY3Rpb25zL0JyYWluLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zbWFydC1jaHVua3MvU21hcnRNYXJrZG93bi5qcyIsICIuLi9ub2RlX21vZHVsZXMvc21hcnQtY2h1bmtzL3NtYXJ0LWNodW5rcy5qcyIsICIuLi9ub2RlX21vZHVsZXMvc21hcnQtY29sbGVjdGlvbnMvaGVscGVycy5qcyIsICIuLi9ub2RlX21vZHVsZXMvc21hcnQtY29sbGVjdGlvbnMvQ29sbGVjdGlvbkl0ZW0uanMiLCAiLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWNvbGxlY3Rpb25zL0NvbGxlY3Rpb24uanMiLCAiLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWVtYmVkLW1vZGVsL2FkYXB0ZXJzL2FkYXB0ZXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWVtYmVkLW1vZGVsL2FkYXB0ZXJzL2FwaS5qcyIsICIuLi9ub2RlX21vZHVsZXMvc21hcnQtZW1iZWQtbW9kZWwvYWRhcHRlcnMvbG9jYWxfYXBpLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zbWFydC1lbWJlZC1tb2RlbC9hZGFwdGVycy90cmFuc2Zvcm1lcnMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWVtYmVkLW1vZGVsL3dlYl9jb25uZWN0b3IuanNvbiIsICIuLi9ub2RlX21vZHVsZXMvc21hcnQtZW1iZWQtbW9kZWwvYWRhcHRlcnMvaWZyYW1lLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zbWFydC1lbWJlZC1tb2RlbC9hZGFwdGVycy5qcyIsICIuLi9ub2RlX21vZHVsZXMvc21hcnQtZW1iZWQtbW9kZWwvbW9kZWxzLmpzb24iLCAiLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWVtYmVkLW1vZGVsL3NtYXJ0X2VtYmVkX21vZGVsLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zbWFydC1lbnRpdGllcy9zbWFydF9lbnRpdGllcy5qcyIsICIuLi9zcmMvcmVuZGVyX2RhdGF2aWV3X2NvZGVibG9ja3MuanMiLCAiLi4vc3JjL3NjX2VudGl0aWVzLmpzIiwgIi4uL3NyYy9zbWFydF9zb2NrZXQuanMiLCAiLi4vc3JjL2RhdGF2aWV3X3NvY2tldC5qcyIsICIuLi9idWlsZC92aWV3cy5qc29uIiwgIi4uL2Vqcy5taW4uanMiLCAiLi4vc3JjL1NjVHJhbnNsYXRpb25zLmpzb24iLCAiLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWNoYXQtbW9kZWwvYWRhcHRlcnMvYW50aHJvcGljLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zbWFydC1jaGF0LW1vZGVsL2FkYXB0ZXJzL2NvaGVyZS5qcyIsICIuLi9ub2RlX21vZHVsZXMvc21hcnQtY2hhdC1tb2RlbC9hZGFwdGVycy9nZW1pbmkuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWNoYXQtbW9kZWwvYWRhcHRlcnMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWNoYXQtbW9kZWwvcGxhdGZvcm1zLmpzb24iLCAiLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWNoYXQtbW9kZWwvdXRpbHMvaXNfdmFsaWRfdG9vbF9jYWxsLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zbWFydC1jaGF0LW1vZGVsL3N0cmVhbWVyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zbWFydC1jaGF0LW1vZGVsL21vZGVscy9vcGVuX3JvdXRlci5qcyIsICIuLi9ub2RlX21vZHVsZXMvc21hcnQtY2hhdC1tb2RlbC9tb2RlbHMvb3BlbmFpLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zbWFydC1jaGF0LW1vZGVsL21vZGVscy9nb29nbGVfZ2VtaW5pLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zbWFydC1jaGF0LW1vZGVsL21vZGVscy9jb2hlcmUuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWNoYXQtbW9kZWwvbW9kZWxzL2FudGhyb3BpYy5qcyIsICIuLi9ub2RlX21vZHVsZXMvc21hcnQtY2hhdC1tb2RlbC9tb2RlbHMvZmV0Y2guanMiLCAiLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWNoYXQtbW9kZWwvc21hcnRfY2hhdF9tb2RlbC5qcyIsICIuLi9zcmMvc2NfY2hhdF9tb2RlbC5qcyIsICIuLi9ub2RlX21vZHVsZXMvc21hcnQtY2hhdHMvdXRpbHMvbWVzc2FnZV9jb250ZW50X2FycmF5X3RvX21hcmtkb3duLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zbWFydC1jaGF0cy9zbWFydF9jaGF0c191aS5qcyIsICIuLi9zcmMvc21hcnRfb2JzaWRpYW5fdmlldy5qcyIsICIuLi9zcmMvc2NfY2hhdF92aWV3LmpzIiwgIi4uL3NyYy9zbWFydF9zZXR0aW5ncy5qcyIsICIuLi9zcmMvc21hcnRfY2hhdF9zZXR0aW5ncy5qcyIsICIuLi9zcmMvc2NfY2hhdHNfdWkuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWNoYXRzL3NtYXJ0X2NoYXQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWNoYXRzL3V0aWxzL2NoYXRfbWxfdG9fbWFya2Rvd24uanMiLCAiLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWNoYXRzL3V0aWxzL2FkZF9jb250ZW50X3RvX21lc3NhZ2UuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWNoYXRzL3V0aWxzL21hcmtkb3duX3RvX2NoYXRfbWwuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWNoYXRzL3NtYXJ0X2NoYXRfbWQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWNoYXRzL3NtYXJ0X2NoYXRzLmpzIiwgIi4uL3NyYy9leHRyYWN0X2ZvbGRlcl9yZWZlcmVuY2VzLmpzIiwgIi4uL3NyYy9jb250YWluc19pbnRlcm5hbF9saW5rLmpzIiwgIi4uL3NyYy9jb250YWluc19mb2xkZXJfcmVmZXJlbmNlLmpzIiwgIi4uL3NyYy9zY19jaGF0X21kLmpzIiwgIi4uL3NyYy9zY19jaGF0cy5qcyIsICIuLi9idWlsZC9hY3Rpb25zX29wZW5hcGkuanNvbiIsICIuLi9zcmMvYWN0aW9ucy9sb29rdXAuanMiLCAiLi4vc3JjL2FjdGlvbnMvX2FjdGlvbnMuanMiLCAiLi4vc3JjL3NjX2FjdGlvbnMuanMiLCAiLi4vc3JjL3NjX2Vudi5qcyIsICIuLi9zcmMvZGVmYXVsdF9zZXR0aW5ncy5qcyIsICIuLi9zcmMvc21hcnRfZW1iZWRfc2V0dGluZ3MuanMiLCAiLi4vc3JjL3NjX3NtYXJ0X3ZpZXcuanMiLCAiLi4vc3JjL3NtYXJ0X3NlYXJjaC5qcyIsICIuLi9zcmMvc21hcnRfbm90aWNlcy5qcyIsICIuLi9zcmMvc2Nfc2V0dGluZ3MuanMiLCAiLi4vc3JjL3NjX3NldHRpbmdzX3RhYi5qcyIsICIuLi9zcmMvc2NfYWN0aW9uc191eC5qcyIsICIuLi9zcmMvb3Blbl9ub3RlLmpzIiwgIi4uL3NyYy9pbmRleC5qcyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBsb25nLXRlcm0gbWVtb3J5IHN0b3JhZ2UgZm9yIGNvbGxlY3Rpb25zLlxuICovXG5jbGFzcyBMb25nVGVybU1lbW9yeSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIExvbmdUZXJtTWVtb3J5LlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29sbGVjdGlvbiAtIFRoZSBjb2xsZWN0aW9uIG9iamVjdCBjb250YWluaW5nIHRoZSBlbnZpcm9ubWVudCBhbmQgaXRlbXMuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb2xsZWN0aW9uKSB7XG4gICAgdGhpcy5lbnYgPSBjb2xsZWN0aW9uLmVudjtcbiAgICB0aGlzLmJyYWluID0gdGhpcy5lbnY7XG4gICAgdGhpcy5jb2xsZWN0aW9uID0gY29sbGVjdGlvbjtcbiAgICB0aGlzLnNhdmVfdGltZW91dCA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogU3RhdGljIG1ldGhvZCB0byBpbml0aWFsaXplIGEgTG9uZ1Rlcm1NZW1vcnkgaW5zdGFuY2UgdXNpbmcgYSBzcGVjaWZpYyBhZGFwdGVyLlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29sbGVjdGlvbiAtIFRoZSBjb2xsZWN0aW9uIG9iamVjdCB0byBiZSB1c2VkLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhZGFwdGVyIC0gVGhlIGFkYXB0ZXIgY2xhc3MgdG8gYmUgaW5zdGFudGlhdGVkLlxuICAgKiBAcmV0dXJucyB7TG9uZ1Rlcm1NZW1vcnl9IEFuIGluc3RhbmNlIG9mIHRoZSBhZGFwdGVyIGNsYXNzLlxuICAgKi9cbiAgc3RhdGljIHdha2VfdXAoY29sbGVjdGlvbiwgYWRhcHRlcikge1xuICAgIGNvbnN0IGx0bSA9IG5ldyBhZGFwdGVyKGNvbGxlY3Rpb24pO1xuICAgIHJldHVybiBsdG07XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbmFtZSBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAqL1xuICBnZXQgY29sbGVjdGlvbl9uYW1lKCkgeyByZXR1cm4gdGhpcy5jb2xsZWN0aW9uLmNvbGxlY3Rpb25fbmFtZTsgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBuYW1lIG9mIHRoZSBpdGVtIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgaXRlbS5cbiAgICovXG4gIGdldCBpdGVtX25hbWUoKSB7IHJldHVybiB0aGlzLmNvbGxlY3Rpb24uaXRlbV9uYW1lOyB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGRhdGEgcGF0aCBmcm9tIHRoZSBlbnZpcm9ubWVudC5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGRhdGEgcGF0aC5cbiAgICovXG4gIGdldCBkYXRhX3BhdGgoKSB7IHJldHVybiB0aGlzLmVudi5kYXRhX3BhdGg7IH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgZmlsZSBuYW1lLCBkZWZhdWx0aW5nIHRvIHRoZSBjb2xsZWN0aW9uIG5hbWUgaWYgbm90IGV4cGxpY2l0bHkgc2V0LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZmlsZSBuYW1lLlxuICAgKi9cbiAgZ2V0IGZpbGVfbmFtZSgpIHsgcmV0dXJuIHRoaXMuY29sbGVjdGlvbi5maWxlX25hbWUgfHwgdGhpcy5jb2xsZWN0aW9uLmNvbGxlY3Rpb25fbmFtZTsgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIHRoZSBmdWxsIGZpbGUgcGF0aCBmb3IgdGhlIGNvbGxlY3Rpb24ncyBkYXRhLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZnVsbCBmaWxlIHBhdGguXG4gICAqL1xuICBnZXQgZmlsZV9wYXRoKCkgeyByZXR1cm4gdGhpcy5kYXRhX3BhdGggKyAnLycgKyB0aGlzLmZpbGVfbmFtZTsgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBpdGVtcyBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBUaGUgaXRlbXMgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAqL1xuICBnZXQgaXRlbXMoKSB7IHJldHVybiB0aGlzLmNvbGxlY3Rpb24uaXRlbXM7IH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgaXRlbXMgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAqIEBwYXJhbSB7QXJyYXl9IGl0ZW1zIC0gVGhlIG5ldyBpdGVtcyBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICovXG4gIHNldCBpdGVtcyhpdGVtcykgeyB0aGlzLmNvbGxlY3Rpb24uaXRlbXMgPSBpdGVtczsgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBrZXlzIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBrZXlzIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgKi9cbiAgZ2V0IGtleXMoKSB7IHJldHVybiB0aGlzLmNvbGxlY3Rpb24ua2V5czsgfVxuXG4gIC8qKlxuICAgKiBQbGFjZWhvbGRlciBmb3IgbG9hZGluZyBkYXRhLCB0byBiZSBpbXBsZW1lbnRlZCBieSBzdWJjbGFzc2VzLlxuICAgKi9cbiAgYXN5bmMgbG9hZCgpIHsgfVxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IHNhdmUgbWV0aG9kLCBsb2dzIGEgbWVzc2FnZSBpZiBub3Qgb3ZlcnJpZGRlbi5cbiAgICovXG4gIHNhdmUoKSB7IGlmICh0aGlzLmNvbnN0cnVjdG9yLm5hbWUgIT09ICdMb25nVGVybU1lbW9yeScpIGNvbnNvbGUubG9nKFwiY2FsbGVkIGRlZmF1bHQsIG92ZXJyaWRlIG1lXCIpOyB9XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgYXN5bmNocm9ub3VzIHNhdmUgbWV0aG9kLCBsb2dzIGEgbWVzc2FnZSBpZiBub3Qgb3ZlcnJpZGRlbi5cbiAgICovXG4gIGFzeW5jIF9zYXZlKCkgeyBpZiAodGhpcy5jb25zdHJ1Y3Rvci5uYW1lICE9PSAnTG9uZ1Rlcm1NZW1vcnknKSBjb25zb2xlLmxvZyhcImNhbGxlZCBkZWZhdWx0LCBvdmVycmlkZSBtZVwiKTsgfVxuXG4gIC8qKlxuICAgKiBSZXZpdmVzIGEgdmFsdWUgZnJvbSBhIGtleS12YWx1ZSBwYWlyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSBpbiB0aGUga2V5LXZhbHVlIHBhaXIuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgaW4gdGhlIGtleS12YWx1ZSBwYWlyLlxuICAgKiBAcmV0dXJucyB7Kn0gVGhlIHBvc3NpYmx5IHRyYW5zZm9ybWVkIHZhbHVlLlxuICAgKi9cbiAgcmV2aXZlcihrZXksIHZhbHVlKSB7IHJldHVybiB0aGlzLmNvbGxlY3Rpb24ucmV2aXZlcihrZXksIHZhbHVlKTsgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhIHZhbHVlIGJlZm9yZSBpdCBpcyBzZXJpYWxpemVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSBpbiB0aGUga2V5LXZhbHVlIHBhaXIuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgaW4gdGhlIGtleS12YWx1ZSBwYWlyLlxuICAgKiBAcmV0dXJucyB7Kn0gVGhlIHBvc3NpYmx5IHRyYW5zZm9ybWVkIHZhbHVlLlxuICAgKi9cbiAgcmVwbGFjZXIoa2V5LCB2YWx1ZSkgeyByZXR1cm4gdGhpcy5jb2xsZWN0aW9uLnJlcGxhY2VyKGtleSwgdmFsdWUpOyB9XG59XG5cbi8vIEVYUE9SVFNcbmV4cG9ydHMuTG9uZ1Rlcm1NZW1vcnkgPSBMb25nVGVybU1lbW9yeTsiLCAiY29uc3QgeyBMb25nVGVybU1lbW9yeSB9ID0gcmVxdWlyZSgnLi9sb25nX3Rlcm1fbWVtb3J5Jyk7XG4vKipcbiAqIENsYXNzIE9ic0FKU09OIGV4dGVuZHMgTG9uZ1Rlcm1NZW1vcnkgdG8gaGFuZGxlIEpTT04tYmFzZWQgc3RvcmFnZSBvZiBjb2xsZWN0aW9ucy5cbiAqIFRoaXMgY2xhc3MgcHJvdmlkZXMgbWV0aG9kcyB0byBsb2FkIGFuZCBzYXZlIGNvbGxlY3Rpb25zIHRvIGEgSlNPTiBmaWxlIHdpdGggYXN5bmNocm9ub3VzIG9wZXJhdGlvbnMsXG4gKiBlbnN1cmluZyBkYXRhIGludGVncml0eSBhbmQgZXJyb3IgaGFuZGxpbmcuIEl0IHVzZXMgYW4gYWRhcHRlciB0byBpbnRlcmFjdCB3aXRoIHRoZSBmaWxlIHN5c3RlbS5cbiAqL1xuY2xhc3MgT2JzQUpTT04gZXh0ZW5kcyBMb25nVGVybU1lbW9yeSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGFuIGluc3RhbmNlIG9mIE9ic0FKU09OLlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29sbGVjdGlvbiAtIFRoZSBjb2xsZWN0aW9uIHRvIGJlIG1hbmFnZWQuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb2xsZWN0aW9uKSB7XG4gICAgc3VwZXIoY29sbGVjdGlvbik7XG4gICAgdGhpcy5hZGFwdGVyID0gdGhpcy5lbnYubWFpbi5hcHAudmF1bHQuYWRhcHRlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3luY2hyb25vdXNseSBsb2FkcyB0aGUgY29sbGVjdGlvbiBmcm9tIGEgSlNPTiBmaWxlLlxuICAgKiBQYXJzZXMgdGhlIGZpbGUgY29udGVudCBhbmQgaW5pdGlhbGl6ZXMgY29sbGVjdGlvbiBpdGVtcyBiYXNlZCBvbiB0aGUgc3RvcmVkIGRhdGEuXG4gICAqIEhhbmRsZXMgZmlsZSBub3QgZm91bmQgZXJyb3JzIGJ5IGNyZWF0aW5nIG5lY2Vzc2FyeSBkaXJlY3RvcmllcyBhbmQgZmlsZXMuXG4gICAqL1xuICBhc3luYyBsb2FkKCkge1xuICAgIGNvbnNvbGUubG9nKFwiTG9hZGluZzogXCIgKyB0aGlzLmZpbGVfcGF0aCk7XG4gICAgdHJ5IHtcbiAgICAgIChhd2FpdCB0aGlzLmFkYXB0ZXIucmVhZCh0aGlzLmZpbGVfcGF0aCkpXG4gICAgICAgIC5zcGxpdChcIixcXG5cIilcbiAgICAgICAgLmZpbHRlcihiYXRjaCA9PiBiYXRjaCkgLy8gcmVtb3ZlIGVtcHR5IHN0cmluZ3NcbiAgICAgICAgLmZvckVhY2goKGJhdGNoLCBpKSA9PiB7XG4gICAgICAgICAgY29uc3QgaXRlbXMgPSBKU09OLnBhcnNlKGB7JHtiYXRjaH19YCk7XG4gICAgICAgICAgT2JqZWN0LmVudHJpZXMoaXRlbXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb2xsZWN0aW9uLml0ZW1zW2tleV0gPSBuZXcgKHRoaXMuZW52Lml0ZW1fdHlwZXNbdmFsdWUuY2xhc3NfbmFtZV0pKHRoaXMuZW52LCB2YWx1ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICA7XG4gICAgICBjb25zb2xlLmxvZyhcIkxvYWRlZDogXCIgKyB0aGlzLmZpbGVfbmFtZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkVycm9yIGxvYWRpbmc6IFwiICsgdGhpcy5maWxlX3BhdGgpO1xuICAgICAgY29uc29sZS5sb2coZXJyLnN0YWNrKTsgLy8gc3RhY2sgdHJhY2VcbiAgICAgIC8vIENyZWF0ZSBmb2xkZXIgYW5kIGZpbGUgaWYgdGhleSBkb24ndCBleGlzdFxuICAgICAgaWYgKGVyci5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgICB0aGlzLml0ZW1zID0ge307XG4gICAgICAgIC8vIHRoaXMua2V5cyA9IFtdOyAvLyByZXBsYWNlZCBieSBnZXR0ZXJcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB0aGlzLmFkYXB0ZXIubWtkaXIodGhpcy5kYXRhX3BhdGgpO1xuICAgICAgICAgIGF3YWl0IHRoaXMuYWRhcHRlci53cml0ZSh0aGlzLmZpbGVfcGF0aCwgXCJcIik7XG4gICAgICAgIH0gY2F0Y2ggKGNyZWF0aW9uRXJyKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJGYWlsZWQgdG8gY3JlYXRlIGZvbGRlciBvciBmaWxlOiBcIiwgY3JlYXRpb25FcnIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gd3JhcHMgX3NhdmUgaW4gdGltZW91dCB0byBwcmV2ZW50IG11bHRpcGxlIHNhdmVzIGF0IG9uY2VcbiAgc2F2ZSgpIHtcbiAgICBpZih0aGlzLnNhdmVfdGltZW91dCkgY2xlYXJUaW1lb3V0KHRoaXMuc2F2ZV90aW1lb3V0KTtcbiAgICB0aGlzLnNhdmVfdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4geyB0aGlzLl9zYXZlKCk7IH0sIDEwMDAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTYXZlcyB0aGUgY29sbGVjdGlvbiB0byBhIEpTT04gZmlsZS4gVGhpcyBtZXRob2QgaXMgdGhyb3R0bGVkIHRvIHByZXZlbnQgbXVsdGlwbGUgc2F2ZXMgYXQgb25jZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbZm9yY2U9ZmFsc2VdIC0gRm9yY2VzIHRoZSBzYXZlIG9wZXJhdGlvbiBldmVuIGlmIGN1cnJlbnRseSBzYXZpbmcuXG4gICAqL1xuICBhc3luYyBfc2F2ZShmb3JjZT1mYWxzZSkge1xuICAgIGlmKHRoaXMuc2F2ZV90aW1lb3V0KSBjbGVhclRpbWVvdXQodGhpcy5zYXZlX3RpbWVvdXQpO1xuICAgIHRoaXMuc2F2ZV90aW1lb3V0ID0gbnVsbDtcbiAgICBpZih0aGlzLl9zYXZpbmcpIHJldHVybiBjb25zb2xlLmxvZyhcIkFscmVhZHkgc2F2aW5nOiBcIiArIHRoaXMuZmlsZV9uYW1lKTtcbiAgICB0aGlzLl9zYXZpbmcgPSB0cnVlOyAvLyBwcmV2ZW50IG11bHRpcGxlIHNhdmVzIGF0IG9uY2VcbiAgICBzZXRUaW1lb3V0KCgpID0+IHsgdGhpcy5fc2F2aW5nID0gZmFsc2U7IH0sIDEwMDAwKTsgLy8gc2V0IF9zYXZpbmcgdG8gZmFsc2UgYWZ0ZXIgMTAgc2Vjb25kc1xuICAgIGNvbnN0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zb2xlLmxvZyhcIlNhdmluZzogXCIgKyB0aGlzLmZpbGVfbmFtZSk7XG4gICAgLy8gcmVuYW1lIHRlbXAgZmlsZVxuICAgIGNvbnN0IHRlbXBfZmlsZV9wYXRoID0gdGhpcy5maWxlX3BhdGgucmVwbGFjZSgnLmFqc29uJywgJy50ZW1wLmFqc29uJyk7XG4gICAgaWYoYXdhaXQgdGhpcy5hZGFwdGVyLmV4aXN0cyh0ZW1wX2ZpbGVfcGF0aCkpIGF3YWl0IHRoaXMuYWRhcHRlci5yZW1vdmUodGVtcF9maWxlX3BhdGgpO1xuICAgIHRyeSB7XG4gICAgICAvLyBpbml0IHRlbXAgZmlsZVxuICAgICAgYXdhaXQgdGhpcy5hZGFwdGVyLndyaXRlKHRlbXBfZmlsZV9wYXRoLCBcIlwiKTtcbiAgICAgIGxldCBmaWxlX2NvbnRlbnQgPSBbXTtcbiAgICAgIGNvbnN0IGl0ZW1zID0gT2JqZWN0LnZhbHVlcyh0aGlzLml0ZW1zKS5maWx0ZXIoaSA9PiBpLnZlYyk7XG4gICAgICBjb25zdCBiYXRjaGVzID0gTWF0aC5jZWlsKGl0ZW1zLmxlbmd0aCAvIDEwMDApO1xuICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGJhdGNoZXM7IGkrKykge1xuICAgICAgICBmaWxlX2NvbnRlbnQgPSBpdGVtcy5zbGljZShpICogMTAwMCwgKGkgKyAxKSAqIDEwMDApLm1hcChpID0+IGkuYWpzb24pO1xuICAgICAgICBjb25zdCBiYXRjaF9jb250ZW50ID0gZmlsZV9jb250ZW50LmpvaW4oXCIsXCIpO1xuICAgICAgICBhd2FpdCB0aGlzLmFkYXB0ZXIuYXBwZW5kKHRlbXBfZmlsZV9wYXRoLCBiYXRjaF9jb250ZW50ICsgXCIsXFxuXCIpO1xuICAgICAgfVxuICAgICAgLy8gYXBwZW5kIGxhc3QgYmF0Y2hcbiAgICAgIGlmKGl0ZW1zLmxlbmd0aCA+IGJhdGNoZXMgKiAxMDAwKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuYWRhcHRlci5hcHBlbmQodGVtcF9maWxlX3BhdGgsIGl0ZW1zLnNsaWNlKGJhdGNoZXMgKiAxMDAwKS5tYXAoaSA9PiBpLmFqc29uKS5qb2luKFwiLFwiKSArIFwiLFxcblwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVuZCA9IERhdGUubm93KCk7IC8vIGxvZyB0aW1lXG4gICAgICBjb25zdCB0aW1lID0gZW5kIC0gc3RhcnQ7XG4gICAgICBpZihmb3JjZSB8fCBhd2FpdCB0aGlzLnZhbGlkYXRlX3NhdmUodGVtcF9maWxlX3BhdGgsIHRoaXMuZmlsZV9wYXRoKSkge1xuICAgICAgICBpZihhd2FpdCB0aGlzLmFkYXB0ZXIuZXhpc3RzKHRoaXMuZmlsZV9wYXRoKSkgYXdhaXQgdGhpcy5hZGFwdGVyLnJlbW92ZSh0aGlzLmZpbGVfcGF0aCk7XG4gICAgICAgIGF3YWl0IHRoaXMuYWRhcHRlci5yZW5hbWUodGVtcF9maWxlX3BhdGgsIHRoaXMuZmlsZV9wYXRoKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJTYXZlZCBcIiArIHRoaXMuZmlsZV9uYW1lICsgXCIgaW4gXCIgKyB0aW1lICsgXCJtc1wiKTtcbiAgICAgIH1lbHNle1xuICAgICAgICBjb25zb2xlLmxvZyhcIk5vdCBzYXZpbmcgXCIgKyB0aGlzLmZpbGVfbmFtZSArIFwiIGJlY2F1c2UgbmV3IGZpbGUgaXMgbGVzcyB0aGFuIDUwJSBvZiBvbGQgZmlsZVwiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBzYXZpbmc6IFwiICsgdGhpcy5maWxlX25hbWUpO1xuICAgICAgY29uc29sZS5lcnJvcihlcnIuc3RhY2spO1xuICAgICAgLy8gc2V0IG5ldyBmaWxlIHRvIFwiZmFpbGVkXCIgYW5kIHJlbmFtZSB0byBpbmxjbHVkZSBkYXRldGltZVxuICAgICAgY29uc3QgZmFpbGVkX2ZpbGVfcGF0aCA9IHRlbXBfZmlsZV9wYXRoLnJlcGxhY2UoJy50ZW1wLicsICcuZmFpbGVkLScgKyBEYXRlLm5vdygpICsgJy4nKTtcbiAgICAgIGF3YWl0IHRoaXMuYWRhcHRlci5yZW5hbWUodGVtcF9maWxlX3BhdGgsIGZhaWxlZF9maWxlX3BhdGgpO1xuICAgIH1cbiAgICB0aGlzLl9zYXZpbmcgPSBmYWxzZTtcbiAgICAvLyByZW1vdmUgdGVtcCBmaWxlIGFmdGVyIG5ldyBmaWxlIGlzIHNhdmVkXG4gICAgaWYoYXdhaXQgdGhpcy5hZGFwdGVyLmV4aXN0cyh0ZW1wX2ZpbGVfcGF0aCkgJiYgYXdhaXQgdGhpcy5hZGFwdGVyLmV4aXN0cyh0aGlzLmZpbGVfcGF0aCkpIGF3YWl0IHRoaXMuYWRhcHRlci5yZW1vdmUodGVtcF9maWxlX3BhdGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGUgbmV3IGZpbGUgc2l6ZSBhZ2FpbnN0IHRoZSBvbGQgZmlsZSBzaXplIHRvIGVuc3VyZSBkYXRhIGludGVncml0eS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5ld19maWxlX3BhdGggLSBQYXRoIHRvIHRoZSBuZXcgZmlsZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9sZF9maWxlX3BhdGggLSBQYXRoIHRvIHRoZSBvbGQgZmlsZS5cbiAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IFRydWUgaWYgdGhlIG5ldyBmaWxlIHNpemUgaXMgbW9yZSB0aGFuIDUwJSBvZiB0aGUgb2xkIGZpbGUgc2l6ZSwgb3RoZXJ3aXNlIGZhbHNlLlxuICAgKi9cbiAgYXN5bmMgdmFsaWRhdGVfc2F2ZShuZXdfZmlsZV9wYXRoLCBvbGRfZmlsZV9wYXRoKSB7XG4gICAgY29uc3QgbmV3X2ZpbGVfc2l6ZSA9IChhd2FpdCB0aGlzLmFkYXB0ZXIuc3RhdChuZXdfZmlsZV9wYXRoKSk/LnNpemU7XG4gICAgY29uc3Qgb2xkX2ZpbGVfc2l6ZSA9IChhd2FpdCB0aGlzLmFkYXB0ZXIuc3RhdChvbGRfZmlsZV9wYXRoKSk/LnNpemU7XG4gICAgaWYoIW9sZF9maWxlX3NpemUpIHJldHVybiB0cnVlO1xuICAgIGNvbnNvbGUubG9nKFwiTmV3IGZpbGUgc2l6ZTogXCIgKyBuZXdfZmlsZV9zaXplICsgXCIgYnl0ZXNcIik7XG4gICAgY29uc29sZS5sb2coXCJPbGQgZmlsZSBzaXplOiBcIiArIG9sZF9maWxlX3NpemUgKyBcIiBieXRlc1wiKTtcbiAgICByZXR1cm4gbmV3X2ZpbGVfc2l6ZSA+IChvbGRfZmlsZV9zaXplICogMC41KTtcbiAgfVxuXG4gIGdldCBmaWxlX25hbWUoKSB7IHJldHVybiBzdXBlci5maWxlX25hbWUgKyAnLmFqc29uJzsgfVxufVxuXG5leHBvcnRzLk9ic0FKU09OID0gT2JzQUpTT047IiwgImNvbnN0IHsgTG9uZ1Rlcm1NZW1vcnkgfSA9IHJlcXVpcmUoJy4vbG9uZ190ZXJtX21lbW9yeScpO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIHNwZWNpYWxpemVkIGZvcm0gb2YgTG9uZ1Rlcm1NZW1vcnkgdGhhdCBoYW5kbGVzIG11bHRpcGxlIC5hanNvbiBmaWxlcy5cbiAqIEl0IGV4dGVuZHMgdGhlIExvbmdUZXJtTWVtb3J5IGNsYXNzIHRvIG1hbmFnZSBjb2xsZWN0aW9ucyBvZiBpdGVtcyBzdG9yZWQgaW4gLmFqc29uIGZvcm1hdC5cbiAqL1xuY2xhc3MgT2JzTXVsdGlBSlNPTiBleHRlbmRzIExvbmdUZXJtTWVtb3J5IHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgT2JzTXVsdGlBSlNPTi5cbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbGxlY3Rpb24gLSBUaGUgY29sbGVjdGlvbiBvZiBpdGVtcyB0byBiZSBtYW5hZ2VkLlxuICAgKi9cbiAgY29uc3RydWN0b3IoY29sbGVjdGlvbikge1xuICAgIHN1cGVyKGNvbGxlY3Rpb24pO1xuICAgIHRoaXMuYWRhcHRlciA9IHRoaXMuZW52Lm1haW4uYXBwLnZhdWx0LmFkYXB0ZXI7XG4gIH1cblxuICAvKipcbiAgICogQXN5bmNocm9ub3VzbHkgbG9hZHMgY29sbGVjdGlvbiBpdGVtcyBmcm9tIC5hanNvbiBmaWxlcyB3aXRoaW4gdGhlIHNwZWNpZmllZCBkYXRhIHBhdGguXG4gICAqIEl0IGVuc3VyZXMgdGhhdCBvbmx5IC5hanNvbiBmaWxlcyBhcmUgcHJvY2Vzc2VkIGFuZCBoYW5kbGVzIEpTT04gcGFyc2luZyBhbmQgaXRlbSBpbnN0YW50aWF0aW9uLlxuICAgKi9cbiAgYXN5bmMgbG9hZCgpIHtcbiAgICBjb25zb2xlLmxvZyhcIkxvYWRpbmcgY29sbGVjdGlvbiBpdGVtc1wiKTtcbiAgICBpZighKGF3YWl0IHRoaXMuYWRhcHRlci5leGlzdHModGhpcy5kYXRhX3BhdGgpKSkgYXdhaXQgdGhpcy5hZGFwdGVyLm1rZGlyKHRoaXMuZGF0YV9wYXRoKTtcbiAgICBjb25zdCBmaWxlcyA9IChhd2FpdCB0aGlzLmFkYXB0ZXIubGlzdCh0aGlzLmRhdGFfcGF0aCkpLmZpbGVzOyAvLyBMaXN0IGFsbCBmaWxlcyBpbiB0aGUgZGlyZWN0b3J5XG4gICAgZm9yIChjb25zdCBmaWxlX3BhdGggb2YgZmlsZXMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChmaWxlX3BhdGguZW5kc1dpdGgoJy5hanNvbicpKSB7IC8vIEVuc3VyZSBpdCdzIGFuIC5hanNvbiBmaWxlXG4gICAgICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMuYWRhcHRlci5yZWFkKGZpbGVfcGF0aCk7XG4gICAgICAgICAgLy8gaWYgbGFzdCBjaGFyIGlzICwgcmVtb3ZlIGl0IGJlZm9yZSB3cmFwcGluZyBpbiB7fSBhbmQgcGFyc2VcbiAgICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShgeyR7Y29udGVudC5lbmRzV2l0aCgnLCcpID8gY29udGVudC5zbGljZSgwLCAtMSkgOiBjb250ZW50fX1gKTtcbiAgICAgICAgICBsZXQgcHJ1bmVkID0gJyc7XG4gICAgICAgICAgT2JqZWN0LmVudHJpZXMoZGF0YSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbnRpdHkgPSBuZXcgKHRoaXMuZW52Lml0ZW1fdHlwZXNbdmFsdWUuY2xhc3NfbmFtZV0pKHRoaXMuZW52LCB2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmVudltlbnRpdHkuY29sbGVjdGlvbl9uYW1lXS5pdGVtc1trZXldID0gZW50aXR5O1xuICAgICAgICAgICAgcHJ1bmVkICs9IGVudGl0eS5hanNvbiArICcsXFxuJztcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvLyBwYXJzZWQgZGF0YSByZW1vdmVzIGFueSBkdXBsaWNhdGUga2V5cyAocHJ1bmVkKVxuICAgICAgICAgIGF3YWl0IHRoaXMuYWRhcHRlci53cml0ZShmaWxlX3BhdGgsIHBydW5lZC50cmltKCkpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJFcnJvciBsb2FkaW5nIGZpbGU6IFwiICsgZmlsZV9wYXRoKTtcbiAgICAgICAgY29uc29sZS5sb2coZXJyLnN0YWNrKTsgLy8gc3RhY2sgdHJhY2VcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc29sZS5sb2coXCJMb2FkZWQgY29sbGVjdGlvbiBpdGVtc1wiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTY2hlZHVsZXMgYSBzYXZlIG9wZXJhdGlvbiB0byBwcmV2ZW50IG11bHRpcGxlIHNhdmVzIGhhcHBlbmluZyBhdCB0aGUgc2FtZSB0aW1lLlxuICAgKi9cbiAgc2F2ZSgpIHtcbiAgICBpZih0aGlzLnNhdmVfdGltZW91dCkgY2xlYXJUaW1lb3V0KHRoaXMuc2F2ZV90aW1lb3V0KTtcbiAgICB0aGlzLnNhdmVfdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4geyB0aGlzLl9zYXZlKCk7IH0sIDEwMDAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3luY2hyb25vdXNseSBzYXZlcyBtb2RpZmllZCBjb2xsZWN0aW9uIGl0ZW1zIHRvIHRoZWlyIHJlc3BlY3RpdmUgLmFqc29uIGZpbGVzLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmb3JjZT1mYWxzZV0gLSBGb3JjZXMgdGhlIHNhdmUgb3BlcmF0aW9uIGV2ZW4gaWYgaXQncyBjdXJyZW50bHkgZmxhZ2dlZCBhcyBzYXZpbmcuXG4gICAqL1xuICBhc3luYyBfc2F2ZShmb3JjZSA9IGZhbHNlKSB7XG4gICAgbGV0IHNhdmVkX2N0ID0gMDtcbiAgICBpZih0aGlzLl9zYXZpbmcpIHJldHVybiBjb25zb2xlLmxvZyhcIkFscmVhZHkgc2F2aW5nXCIpO1xuICAgIHRoaXMuX3NhdmluZyA9IHRydWU7IC8vIHByZXZlbnQgbXVsdGlwbGUgc2F2ZXMgYXQgb25jZVxuICAgIHNldFRpbWVvdXQoKCkgPT4geyB0aGlzLl9zYXZpbmcgPSBmYWxzZTsgfSwgMTAwMDApOyAvLyBzZXQgX3NhdmluZyB0byBmYWxzZSBhZnRlciAxMCBzZWNvbmRzXG4gICAgY29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIGNvbnNvbGUubG9nKFwiU2F2aW5nIGNvbGxlY3Rpb24gaXRlbXNcIik7XG4gICAgLy8gZW5zdXJlIGRhdGFfcGF0aCBleGlzdHNcbiAgICBpZighKGF3YWl0IHRoaXMuYWRhcHRlci5leGlzdHModGhpcy5kYXRhX3BhdGgpKSkgYXdhaXQgdGhpcy5hZGFwdGVyLm1rZGlyKHRoaXMuZGF0YV9wYXRoKTtcbiAgICBjb25zdCBpdGVtcyA9IE9iamVjdC52YWx1ZXModGhpcy5pdGVtcykuZmlsdGVyKGkgPT4gaS52ZWMgJiYgaS5jaGFuZ2VkKTtcbiAgICBpZihpdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuX3NhdmluZyA9IGZhbHNlO1xuICAgICAgY29uc29sZS5sb2coXCJOb3RoaW5nIHRvIHNhdmVcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgY29uc3QgaXRlbV9maWxlX3BhdGggPSBgJHt0aGlzLmRhdGFfcGF0aH0vJHtpdGVtLm11bHRpX2Fqc29uX2ZpbGVfbmFtZX0uYWpzb25gOyAvLyBVc2UgaXRlbS5maWxlX25hbWUgZm9yIGZpbGUgbmFtaW5nXG4gICAgICAgIGF3YWl0IHRoaXMuYWRhcHRlci5hcHBlbmQoaXRlbV9maWxlX3BhdGgsICdcXG4nICsgaXRlbS5hanNvbiArICcsJyk7XG4gICAgICAgIHNhdmVkX2N0Kys7XG4gICAgICB9XG4gICAgICBjb25zdCBlbmQgPSBEYXRlLm5vdygpOyAvLyBsb2cgdGltZVxuICAgICAgY29uc3QgdGltZSA9IGVuZCAtIHN0YXJ0O1xuICAgICAgY29uc29sZS5sb2coYFNhdmVkICR7c2F2ZWRfY3R9IGNvbGxlY3Rpb24gaXRlbXMgaW4gJHt0aW1lfW1zYCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igc2F2aW5nIGNvbGxlY3Rpb24gaXRlbXNcIik7XG4gICAgICBjb25zb2xlLmVycm9yKGVyci5zdGFjayk7XG4gICAgfVxuICAgIHRoaXMuX3NhdmluZyA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGUgc2F2ZSBvcGVyYXRpb24gYnkgY29tcGFyaW5nIHRoZSBmaWxlIHNpemVzIG9mIHRoZSBuZXcgYW5kIG9sZCBmaWxlcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5ld19maWxlX3BhdGggLSBQYXRoIHRvIHRoZSBuZXcgZmlsZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9sZF9maWxlX3BhdGggLSBQYXRoIHRvIHRoZSBvbGQgZmlsZS5cbiAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IC0gVHJ1ZSBpZiB0aGUgbmV3IGZpbGUgc2l6ZSBpcyBhdCBsZWFzdCA1MCUgb2YgdGhlIG9sZCBmaWxlIHNpemUsIG90aGVyd2lzZSBmYWxzZS5cbiAgICovXG4gIGFzeW5jIHZhbGlkYXRlX3NhdmUobmV3X2ZpbGVfcGF0aCwgb2xkX2ZpbGVfcGF0aCkge1xuICAgIGNvbnN0IG5ld19maWxlX3NpemUgPSAoYXdhaXQgdGhpcy5hZGFwdGVyLnN0YXQobmV3X2ZpbGVfcGF0aCkpPy5zaXplO1xuICAgIGNvbnN0IG9sZF9maWxlX3NpemUgPSAoYXdhaXQgdGhpcy5hZGFwdGVyLnN0YXQob2xkX2ZpbGVfcGF0aCkpPy5zaXplO1xuICAgIGlmKCFvbGRfZmlsZV9zaXplKSByZXR1cm4gdHJ1ZTtcbiAgICBjb25zb2xlLmxvZyhcIk5ldyBmaWxlIHNpemU6IFwiICsgbmV3X2ZpbGVfc2l6ZSArIFwiIGJ5dGVzXCIpO1xuICAgIGNvbnNvbGUubG9nKFwiT2xkIGZpbGUgc2l6ZTogXCIgKyBvbGRfZmlsZV9zaXplICsgXCIgYnl0ZXNcIik7XG4gICAgcmV0dXJuIG5ld19maWxlX3NpemUgPiAob2xkX2ZpbGVfc2l6ZSAqIDAuNSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgZGF0YSBwYXRoIGZvciBzdG9yaW5nIC5hanNvbiBmaWxlcywgYXBwZW5kaW5nICcvbXVsdGknIHRvIHRoZSBiYXNlIHBhdGguXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBkYXRhIHBhdGggZm9yIC5hanNvbiBmaWxlcy5cbiAgICovXG4gIGdldCBkYXRhX3BhdGgoKSB7IHJldHVybiBzdXBlci5kYXRhX3BhdGggKyAnL211bHRpJzsgfVxufVxuXG5leHBvcnRzLk9ic011bHRpQUpTT04gPSBPYnNNdWx0aUFKU09OOyIsICJjb25zdCB7IExvbmdUZXJtTWVtb3J5OiBMVE0gfSA9IHJlcXVpcmUoJy4vbG9uZ190ZXJtX21lbW9yeS5qcycpO1xuLy8gT1JDSEVTVFJBVE9SIENMQVNTXG5jbGFzcyBTbWFydEVudiB7XG4gIGNvbnN0cnVjdG9yKGx0bV9hZGFwdGVyID0gTFRNKSB7XG4gICAgdGhpcy5jb25maWcgPSB7fTtcbiAgICB0aGlzLml0ZW1fdHlwZXMgPSB7fTtcbiAgICB0aGlzLmNvbGxlY3Rpb25zID0ge307XG4gICAgdGhpcy5sdG1fYWRhcHRlciA9IGx0bV9hZGFwdGVyO1xuICAgIHRoaXMuZGF0YV9wYXRoID0gJy4vdGVzdC9kYXRhJztcbiAgfVxuICBpbml0KCkge1xuICAgIHRoaXMubG9hZF9jb2xsZWN0aW9ucygpO1xuICB9XG4gIGxvYWRfY29sbGVjdGlvbnMoKSB7XG4gICAgT2JqZWN0LmVudHJpZXModGhpcy5jb2xsZWN0aW9ucykubWFwKChbY29sbGVjdGlvbl9uYW1lLCBjb2xsZWN0aW9uXSkgPT4gdGhpc1tjb2xsZWN0aW9uX25hbWVdID0gY29sbGVjdGlvbi5sb2FkKHRoaXMpKTtcbiAgfVxuICBnZXRfcmVmKHJlZikgeyByZXR1cm4gdGhpc1tyZWYuY29sbGVjdGlvbl9uYW1lXS5nZXQocmVmLmtleSk7IH1cbn1cbmV4cG9ydHMuU21hcnRFbnYgPSBTbWFydEVudjtcblxuIiwgImNvbnN0IHsgU21hcnRFbnYgfSA9IHJlcXVpcmUoJy4vZW52LmpzJyk7XG4vLyBjb25zdCB7IExvbmdUZXJtTWVtb3J5OiBMVE0gfSA9IHJlcXVpcmUoJy4vbG9uZ190ZXJtX21lbW9yeS5qcycpO1xuLy8gT1JDSEVTVFJBVE9SIENMQVNTXG4vLyBjbGFzcyBCcmFpbiB7XG4vLyAgIGNvbnN0cnVjdG9yKGx0bV9hZGFwdGVyID0gTFRNKSB7XG4vLyAgICAgdGhpcy5jb25maWcgPSB7fTtcbi8vICAgICB0aGlzLml0ZW1fdHlwZXMgPSB7fTtcbi8vICAgICB0aGlzLmNvbGxlY3Rpb25zID0ge307XG4vLyAgICAgdGhpcy5sdG1fYWRhcHRlciA9IGx0bV9hZGFwdGVyO1xuLy8gICAgIHRoaXMuZGF0YV9wYXRoID0gJy4vdGVzdC9kYXRhJztcbi8vICAgfVxuLy8gICBpbml0KCkge1xuLy8gICAgIHRoaXMubG9hZF9jb2xsZWN0aW9ucygpO1xuLy8gICB9XG4vLyAgIGxvYWRfY29sbGVjdGlvbnMoKSB7XG4vLyAgICAgT2JqZWN0LmVudHJpZXModGhpcy5jb2xsZWN0aW9ucykubWFwKChbY29sbGVjdGlvbl9uYW1lLCBjb2xsZWN0aW9uXSkgPT4gdGhpc1tjb2xsZWN0aW9uX25hbWVdID0gY29sbGVjdGlvbi5sb2FkKHRoaXMpKTtcbi8vICAgfVxuLy8gICBnZXRfcmVmKHJlZikgeyByZXR1cm4gdGhpc1tyZWYuY29sbGVjdGlvbl9uYW1lXS5nZXQocmVmLmtleSk7IH1cbi8vIH1cbmV4cG9ydHMuQnJhaW4gPSBTbWFydEVudjsiLCAiLyoqXG4gKiBTbWFydE1hcmtkb3duIGlzIGEgY2xhc3MgZGVzaWduZWQgdG8gcGFyc2UgYW5kIG1hbmlwdWxhdGUgbWFya2Rvd24gY29udGVudFxuICogYmFzZWQgb24gc3BlY2lmaWVkIGNvbmZpZ3VyYXRpb25zLiBJdCBwcm92aWRlcyBmdW5jdGlvbmFsaXRpZXMgdG8gZXh0cmFjdFxuICogc3BlY2lmaWMgYmxvY2tzIG9mIHRleHQgYmFzZWQgb24gaGVhZGluZyBwYXRocywgaGFuZGxlIGV4Y2x1c2lvbnMgb2YgY2VydGFpblxuICogaGVhZGluZ3MsIGFuZCBtYW5hZ2UgdGhlIHNpemUgb2YgdGV4dCBibG9ja3MgYWNjb3JkaW5nIHRvIG1heGltdW0gYW5kIG1pbmltdW1cbiAqIGNoYXJhY3RlciBsaW1pdHMuXG4gKi9cbmNsYXNzIFNtYXJ0TWFya2Rvd24ge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIGZvciB0aGUgU21hcnRNYXJrZG93biBwYXJzZXIuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IERlZmF1bHQgY29uZmlndXJhdGlvbiBzZXR0aW5ncy5cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGV4Y2x1ZGVkX2hlYWRpbmdzOiBudWxsLCAvLyBjb21tYSBzZXBhcmF0ZWQgbGlzdCBvZiBoZWFkaW5ncyB0byBleGNsdWRlXG4gICAgICBlbWJlZF9pbnB1dF9tYXhfY2hhcnM6IDEwMDAsIC8vIG1heCBsZW5ndGggb2YgYmxvY2tcbiAgICAgIGVtYmVkX2lucHV0X21pbl9jaGFyczogNTAsIC8vIG1pbiBsZW5ndGggb2YgYmxvY2tcbiAgICAgIHNraXBfYmxvY2tzX3dpdGhfaGVhZGluZ3Nfb25seTogZmFsc2UsIC8vIHNraXAgYmxvY2tzIHRoYXQgb25seSBjb250YWluIGhlYWRpbmdzXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBTbWFydE1hcmtkb3duIHdpdGggdGhlIGdpdmVuIGNvbmZpZ3VyYXRpb24uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgLSBVc2VyLWRlZmluZWQgY29uZmlndXJhdGlvbiBzZXR0aW5ncy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHRoaXMuY29uZmlnID0gey4uLlNtYXJ0TWFya2Rvd24uZGVmYXVsdHMsIC4uLmNvbmZpZ307XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgbGlzdCBvZiBoZWFkaW5ncyB0byBiZSBleGNsdWRlZCBmcm9tIHBhcnNpbmcsIGlmIGFueS5cbiAgICogQHJldHVybnMge0FycmF5fG51bGx9IEFuIGFycmF5IG9mIGhlYWRpbmdzIHRvIGV4Y2x1ZGUsIG9yIG51bGwgaWYgbm9uZS5cbiAgICovXG4gIGdldCBleGNsdWRlZF9oZWFkaW5ncygpIHsgKHRoaXMuY29uZmlnLmV4Y2x1ZGVkX2hlYWRpbmdzPy5sZW5ndGgpID8gdGhpcy5jb25maWcuZXhjbHVkZWRfaGVhZGluZ3Muc3BsaXQoXCIsXCIpLm1hcCgoaGVhZGVyKSA9PiBoZWFkZXIudHJpbSgpKSA6IG51bGw7IH1cbiAgLyoqXG4gICAqIEFuYWx5emVzIHRoZSBtYXJrZG93biBjb250ZW50IHRvIGV4dHJhY3QgbWV0YWRhdGEgYWJvdXQgZWFjaCBoZWFkaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCAtIFRoZSBtYXJrZG93biBjb250ZW50IHRvIGFuYWx5emUuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gQW4gYXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nIG1ldGFkYXRhIGFib3V0IGVhY2ggaGVhZGluZy5cbiAgICovICBcbiAgLy8gV0lQXG4gIGdldF9oZWFkaW5nc19tZXRhKGNvbnRlbnQpIHtcbiAgICByZXR1cm4gY29udGVudC5zcGxpdCgnXFxuJykucmVkdWNlKChhY2MsIGxpbmUsIGxpbmVfaSwgbGluZXMpID0+IHtcbiAgICAgIGlmICghdGhpcy5pc19oZWFkaW5nKGxpbmUpKSByZXR1cm4gYWNjO1xuICAgICAgY29uc3QgY2hhcnNfdW50aWxfbmV4dF9oZWFkaW5nID0gbGluZXMuc2xpY2UobGluZV9pICsgMSkuZmluZEluZGV4KGxpbmUgPT4gdGhpcy5pc19oZWFkaW5nKGxpbmUpKTtcbiAgICAgIGNvbnN0IGhlYWRpbmdfbGV2ZWwgPSBsaW5lLnNwbGl0KCcjJykubGVuZ3RoIC0gMTtcbiAgICAgIGNvbnN0IGhlYWRpbmdfdGV4dCA9IGxpbmUucmVwbGFjZSgvIy9nLCAnJykudHJpbSgpO1xuICAgICAgYWNjLnB1c2ggPSB7IGxpbmVfaSwgaGVhZGluZ19sZXZlbCwgaGVhZGluZ190ZXh0LCBjaGFyc191bnRpbF9uZXh0X2hlYWRpbmcgfTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgW10pO1xuICB9XG5cbiAgLy8gdjFcbiAgLy8gZ2V0IGJsb2NrIGZyb20gcGF0aFxuICAvKipcbiAgICogRXh0cmFjdHMgYSBzcGVjaWZpYyBibG9jayBvZiBtYXJrZG93biBiYXNlZCBvbiBhIGhlYWRpbmcgcGF0aC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGJsb2NrX3BhdGggLSBUaGUgcGF0aCB0byB0aGUgYmxvY2ssIHNwZWNpZmllZCBhcyBhIHNlcmllcyBvZiBoZWFkaW5ncy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmtkb3duIC0gVGhlIG1hcmtkb3duIGNvbnRlbnQgdG8gcGFyc2UuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gT3B0aW9ucyBmb3IgYmxvY2sgZXh0cmFjdGlvbiwgc3VjaCBhcyBjaGFyYWN0ZXIgbGltaXRzIHBlciBsaW5lLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZXh0cmFjdGVkIGJsb2NrIG9mIG1hcmtkb3duIHRleHQuXG4gICAqL1xuICBnZXRfYmxvY2tfZnJvbV9wYXRoKGJsb2NrX3BhdGgsIG1hcmtkb3duLCBvcHRzPXt9KXtcbiAgICAvLyBpZiBibG9ja19wYXRoIGVuZHMgd2l0aCAjIGFuZCBvbmx5IG9uZSAjIHRoZW4gcmV0dXJucyBjb250ZW50IHByaW9yIHRvIGZpcnN0IGhlYWRpbmdcbiAgICBpZihibG9ja19wYXRoLmVuZHNXaXRoKCcjJykgJiYgYmxvY2tfcGF0aC5zcGxpdCgnIycpLmxlbmd0aCA9PT0gMikgcmV0dXJuIG1hcmtkb3duLnNwbGl0KCcjJylbMF07XG4gICAgaWYoIXRoaXMudmFsaWRhdGVfYmxvY2tfcGF0aChibG9ja19wYXRoKSkgcmV0dXJuIG1hcmtkb3duO1xuICAgIGNvbnN0IHtcbiAgICAgIGNoYXJzX3Blcl9saW5lID0gbnVsbCxcbiAgICAgIG1heF9jaGFycyA9IHRoaXMuY29uZmlnLmVtYmVkX2lucHV0X21heF9jaGFycyxcbiAgICAgIG1pbl9jaGFycyA9IHRoaXMuY29uZmlnLmVtYmVkX2lucHV0X21pbl9jaGFycyxcbiAgICB9ID0gb3B0cztcbiAgICBjb25zdCBibG9jayA9IFtdO1xuICAgIGNvbnN0IGJsb2NrX2hlYWRpbmdzID0gYmxvY2tfcGF0aC5zcGxpdChcIiNcIikuc2xpY2UoMSk7XG4gICAgbGV0IGN1cnJlbnRIZWFkZXJzID0gW107XG4gICAgbGV0IGJlZ2luX2xpbmUgPSAwO1xuICAgIGxldCBpc19jb2RlID0gZmFsc2U7XG4gICAgbGV0IGNoYXJfY291bnQgPSAwO1xuICAgIGxldCBoZWFkaW5nX29jY3VycmVuY2UgPSAwO1xuICAgIGxldCBvY2N1cnJlbmNlX2NvdW50ID0gMDtcbiAgICBpZihibG9ja19oZWFkaW5nc1tibG9ja19oZWFkaW5ncy5sZW5ndGgtMV0uaW5kZXhPZigneycpID4gLTEpIHtcbiAgICAgIGhlYWRpbmdfb2NjdXJyZW5jZSA9IHBhcnNlSW50KGJsb2NrX2hlYWRpbmdzW2Jsb2NrX2hlYWRpbmdzLmxlbmd0aC0xXS5zcGxpdCgneycpWzFdLnJlcGxhY2UoJ30nLCAnJykpOyAvLyBnZXQgdGhlIG9jY3VycmVuY2UgbnVtYmVyXG4gICAgICBibG9ja19oZWFkaW5nc1tibG9ja19oZWFkaW5ncy5sZW5ndGgtMV0gPSBibG9ja19oZWFkaW5nc1tibG9ja19oZWFkaW5ncy5sZW5ndGgtMV0uc3BsaXQoJ3snKVswXTsgLy8gcmVtb3ZlIHRoZSBvY2N1cnJlbmNlIGZyb20gdGhlIGxhc3QgaGVhZGluZ1xuICAgIH1cbiAgICBjb25zdCBsaW5lcyA9IG1hcmtkb3duLnNwbGl0KCdcXG4nKTtcbiAgICBsZXQgYmxvY2tfaGVhZGluZ19sZXZlbCA9IDA7XG4gICAgLy8gRklORCBIRUFESU5HXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgaWYobGluZS5pbmRleE9mKCdgYGAnKSA9PT0gMCkgaXNfY29kZSA9ICFpc19jb2RlOyAvLyBpZiBsaW5lIGJlZ2lucyB3aXRoIHRocmVlIGJhY2t0aWNrcyB0aGVuIHRvZ2dsZSBpc19jb2RlXG4gICAgICBpZihpc19jb2RlKSBjb250aW51ZTsgLy8gaWYgaXNfY29kZSBpcyB0cnVlIHRoZW4gYWRkIGxpbmUgd2l0aCBwcmVjZWRpbmcgdGFiIGFuZCBjb250aW51ZVxuICAgICAgaWYoWyctICcsICctIFsgXSAnXS5pbmRleE9mKGxpbmUpID4gLTEpIGNvbnRpbnVlOyAvLyBza2lwIGlmIGxpbmUgaXMgZW1wdHkgYnVsbGV0IG9yIGNoZWNrYm94XG4gICAgICBpZiAoIXRoaXMuaXNfaGVhZGluZyhsaW5lKSkgY29udGludWU7IC8vIHNraXAgaWYgbGluZSBpcyBub3QgYSBoZWFkaW5nXG4gICAgICBibG9ja19oZWFkaW5nX2xldmVsID0gdGhpcy5oZWFkaW5nX2xldmVsKGxpbmUpOyAvLyBnZXQgdGhlIGhlYWRpbmcgJ2xldmVsJ1xuICAgICAgY29uc3QgaGVhZGluZ190ZXh0ID0gbGluZS5yZXBsYWNlKC8jL2csICcnKS50cmltKCk7IC8vIGdldCB0aGUgaGVhZGluZyB0ZXh0XG4gICAgICBjb25zdCBoZWFkaW5nX2luZGV4ID0gYmxvY2tfaGVhZGluZ3MuaW5kZXhPZihoZWFkaW5nX3RleHQpO1xuICAgICAgaWYgKGhlYWRpbmdfaW5kZXggPCAwKSBjb250aW51ZTsgLy8gY29udGludWUgaWYgaGVhZGluZyB0ZXh0IGlzIG5vdCBpbiBibG9ja19oZWFkaW5nc1xuICAgICAgaWYgKGN1cnJlbnRIZWFkZXJzLmxlbmd0aCAhPT0gaGVhZGluZ19pbmRleCkgY29udGludWU7IC8vIGlmIGN1cnJlbnRIZWFkZXJzLmxlbmd0aCAhPT0gaGVhZGluZ19pbmRleCB0aGVuIHdlIGhhdmUgYSBtaXNtYXRjaFxuICAgICAgY3VycmVudEhlYWRlcnMucHVzaChoZWFkaW5nX3RleHQpOyAvLyBwdXNoIHRoZSBoZWFkaW5nIHRleHQgdG8gdGhlIGN1cnJlbnRIZWFkZXJzIGFycmF5XG4gICAgICBpZiAoY3VycmVudEhlYWRlcnMubGVuZ3RoID09PSBibG9ja19oZWFkaW5ncy5sZW5ndGgpIHsgLy8gaWYgY3VycmVudEhlYWRlcnMubGVuZ3RoID09PSBibG9ja19oZWFkaW5ncy5sZW5ndGggdGhlbiB3ZSBoYXZlIGEgbWF0Y2hcbiAgICAgICAgaWYoaGVhZGluZ19vY2N1cnJlbmNlID09PSAwKXtcbiAgICAgICAgICBiZWdpbl9saW5lID0gaSArIDE7XG4gICAgICAgICAgYnJlYWs7IC8vIGJyZWFrIG91dCBvZiBsb29wXG4gICAgICAgIH1cbiAgICAgICAgaWYob2NjdXJyZW5jZV9jb3VudCA9PT0gaGVhZGluZ19vY2N1cnJlbmNlKXtcbiAgICAgICAgICBiZWdpbl9saW5lID0gaSArIDE7XG4gICAgICAgICAgYnJlYWs7IC8vIGJyZWFrIG91dCBvZiBsb29wXG4gICAgICAgIH1cbiAgICAgICAgb2NjdXJyZW5jZV9jb3VudCsrOyAvLyBpbmNyZW1lbnQgb2NjdXJyZW5jZV9jb3VudFxuICAgICAgICBjdXJyZW50SGVhZGVycy5wb3AoKTsgLy8gcmVzZXQgY3VycmVudEhlYWRlcnNcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEJVSUxEIEJMT0NLXG4gICAgaWYgKGJlZ2luX2xpbmUgPT09IDApIHJldHVybiAnJzsgLy8gaWYgbm8gYmVnaW5fbGluZSB0aGVuIGhlYWRpbmcgbm90IGZvdW5kXG4gICAgaXNfY29kZSA9IGZhbHNlOyAvLyBpdGVyYXRlIHRocm91Z2ggbGluZXMgc3RhcnRpbmcgYXQgYmVnaW5fbGluZVxuICAgIGZvciAobGV0IGkgPSBiZWdpbl9saW5lOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBsaW5lID0gbGluZXNbaV07XG4gICAgICAvLyBpZihsaW5lLnRyaW0oKS5sZW5ndGggPT09IDApIGNvbnRpbnVlOyAvLyBpZiBsaW5lIGlzIGVtcHR5LCBza2lwIC8vIERPOiBtYWtlIHRoaXMgY29uZmlndXJhYmxlXG4gICAgICBpZih0aGlzLmlzX2hlYWRpbmcobGluZSkgJiYgKHRoaXMuaGVhZGluZ19sZXZlbChsaW5lKSA8PSBibG9ja19oZWFkaW5nX2xldmVsKSkgYnJlYWs7IC8vIGlmIGxpbmUgaXMgYSBoZWFkaW5nIGFuZCBoZWFkaW5nX2xldmVsIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBibG9ja19oZWFkaW5nX2xldmVsLCBicmVha1xuICAgICAgLy8gdmFsaWRhdGUvZm9ybWF0XG4gICAgICBpZiAoY2hhcnNfcGVyX2xpbmUgJiYgKGxpbmUubGVuZ3RoID4gY2hhcnNfcGVyX2xpbmUpKSBsaW5lID0gbGluZS5zbGljZSgwLCBjaGFyc19wZXJfbGluZSkgKyBcIi4uLlwiOyAvLyBsaW1pdCBsZW5ndGggb2YgbGluZSB0byBOIGNoYXJhY3RlcnNcbiAgICAgIGlmIChsaW5lLnN0YXJ0c1dpdGgoXCJgYGBcIikpIGlzX2NvZGUgPSAhaXNfY29kZTsgLy8gaWYgbGluZSBpcyBhIGNvZGUgYmxvY2ssIHNraXBcbiAgICAgIGJsb2NrLnB1c2gobGluZSk7IC8vIGFkZCBsaW5lIHRvIGJsb2NrXG4gICAgICBjaGFyX2NvdW50ICs9IGxpbmUubGVuZ3RoOyAvLyBpbmNyZW1lbnQgY2hhcl9jb3VudFxuICAgICAgaWYobWF4X2NoYXJzICYmIChjaGFyX2NvdW50ID4gbWF4X2NoYXJzKSl7XG4gICAgICAgIGNvbnN0IGRpZmYgPSBjaGFyX2NvdW50IC0gbWF4X2NoYXJzO1xuICAgICAgICBibG9ja1tibG9jay5sZW5ndGgtMV0gPSBibG9ja1tibG9jay5sZW5ndGgtMV0uc2xpY2UoMCwgYmxvY2tbYmxvY2subGVuZ3RoLTFdLmxlbmd0aCAtIGRpZmYpICsgXCIuLi5cIjtcbiAgICAgICAgYnJlYWs7IC8vIGJyZWFrIGlmIGNoYXJfY291bnQgaXMgZ3JlYXRlciB0aGFuIG1heF9jaGFyc1xuICAgICAgfVxuICAgICAgaWYobWF4X2NoYXJzICYmIChtYXhfY2hhcnMgLSBjaGFyX2NvdW50IDwgMTApKSBicmVhazsgLy8gYnJlYWsgaWYgbWF4X2NoYXJzIC0gY2hhcl9jb3VudCBpcyBsZXNzIHRoYW4gdGhyZXNob2xkXG4gICAgfVxuICAgIGlmIChpc19jb2RlKSBibG9jay5wdXNoKFwiYGBgXCIpOyAvLyBjbG9zZSBjb2RlIGJsb2NrIGlmIG9wZW5cbiAgICByZXR1cm4gYmxvY2suam9pbihcIlxcblwiKS50cmltKCk7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyB0aGUgbWFya2Rvd24gY29udGVudCBhbmQgb3JnYW5pemVzIGl0IGludG8gc3RydWN0dXJlZCBibG9ja3MgYmFzZWQgb24gaGVhZGluZ3MuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBQYXJhbWV0ZXJzIGNvbnRhaW5pbmcgY29udGVudCBhbmQgb3B0aW9uYWwgZmlsZSBwYXRoLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyBwYXJzZWQgYmxvY2tzIGFuZCBvdGhlciBtZXRhZGF0YS5cbiAgICovXG4gIHBhcnNlKHsgY29udGVudCwgZmlsZV9wYXRoPScnIH0pIHtcbiAgICBjb25zdCBmaWxlX2JyZWFkY3J1bWJzID0gdGhpcy5maWxlX3BhdGhfdG9fYnJlYWRjcnVtYnMoZmlsZV9wYXRoKSArIFwiOiBcIjsgLy8gYWRkIFwiOlwiIHRvIGluZGljYXRlIGJlZ2lubmluZyBvZiBoZWFkaW5nIGJyZWFkY3J1bWJzXG4gICAgLy8gaWYgaXMgZXhjYWxpZHJhdyBmaWxlLCBibG9jayBmb3IgJ1RleHQgRWxlbWVudHMnIGhlYWRpbmcgb25seVxuICAgIGlmKGZpbGVfcGF0aC5lbmRzV2l0aCgnLmV4Y2FsaWRyYXcubWQnKSkge1xuICAgICAgY29uc3QgZXhjYWxpZHJhd19ibG9jayA9IHRoaXMuZ2V0X2Jsb2NrX2Zyb21fcGF0aChmaWxlX3BhdGggKyBcIiNUZXh0IEVsZW1lbnRzXCIsIGNvbnRlbnQpLnJlcGxhY2UoJ1xcbiUlJywgJycpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYmxvY2tzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdGV4dDogZXhjYWxpZHJhd19ibG9jayxcbiAgICAgICAgICAgIHBhdGg6IGZpbGVfcGF0aCArIFwiI1RleHQgRWxlbWVudHNcIixcbiAgICAgICAgICAgIGxlbmd0aDogZXhjYWxpZHJhd19ibG9jay5sZW5ndGgsXG4gICAgICAgICAgICBoZWFkaW5nOiBcIlRleHQgRWxlbWVudHNcIixcbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIGxvZzogW10sXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IG91dHB1dCA9IGNvbnRlbnQuc3BsaXQoJ1xcbicpIC8vIHNwbGl0IHRoZSBtYXJrZG93biBpbnRvIGxpbmVzXG4gICAgICAucmVkdWNlKChhY2MsIGxpbmUsIGksIGFycikgPT4ge1xuICAgICAgICAvLyBpZiBsaW5lIGlzIGEgaGVhZGluZyBvciBsYXN0IGxpbmVcbiAgICAgICAgaWYodGhpcy5pc19oZWFkaW5nKGxpbmUpICYmICghYWNjLmN1cnJfbGV2ZWwgfHwgIXRoaXMuY29uZmlnLm11bHRpX2hlYWRpbmdfYmxvY2tzIHx8ICh0aGlzLmhlYWRpbmdfbGV2ZWwobGluZSkgPD0gYWNjLmN1cnJfbGV2ZWwpIHx8IChhY2MuY3Vyci5sZW5ndGggPiB0aGlzLmNvbmZpZy5lbWJlZF9pbnB1dF9tYXhfY2hhcnMpKSl7XG4gICAgICAgICAgdGhpcy5vdXRwdXRfYmxvY2soYWNjKTtcbiAgICAgICAgICBhY2MuY3Vycl9sZXZlbCA9IHRoaXMuaGVhZGluZ19sZXZlbChsaW5lKTsgLy8gZ2V0IHRoZSBoZWFkaW5nICdsZXZlbCdcbiAgICAgICAgICBhY2MuY3VycmVudF9oZWFkZXJzID0gYWNjLmN1cnJlbnRfaGVhZGVycy5maWx0ZXIoaGVhZGVyID0+IGhlYWRlci5sZXZlbCA8IGFjYy5jdXJyX2xldmVsKTsgLy8gcmVtb3ZlIGFueSBoZWFkZXJzIGZyb20gdGhlIGN1cnJlbnQgaGVhZGVycyBhcnJheSB0aGF0IGFyZSBoaWdoZXIgdGhhbiB0aGUgY3VycmVudCBoZWFkZXIgbGV2ZWxcbiAgICAgICAgICBhY2MuY3VycmVudF9oZWFkZXJzLnB1c2goeyBoZWFkZXI6IGxpbmUucmVwbGFjZSgvIy9nLCAnJykudHJpbSgpLCBsZXZlbDogYWNjLmN1cnJfbGV2ZWwgfSk7IC8vIGFkZCBoZWFkZXIgYW5kIGxldmVsIHRvIGN1cnJlbnQgaGVhZGVycyBhcnJheSwgdHJpbSB0aGUgaGVhZGVyIHRvIHJlbW92ZSBcIiNcIiBhbmQgYW55IHRyYWlsaW5nIHNwYWNlc1xuICAgICAgICAgIGFjYy5zdGFydF9saW5lID0gaTsgLy8gc2V0IHRoZSBzdGFydCBsaW5lXG4gICAgICAgICAgYWNjLmN1cnIgPSBmaWxlX2JyZWFkY3J1bWJzOyAvLyBpbml0aWFsaXplIHRoZSBibG9jayBicmVhZGNydW1icyB3aXRoIGZpbGUucGF0aCB0aGUgY3VycmVudCBoZWFkZXJzXG4gICAgICAgICAgYWNjLmN1cnIgKz0gYWNjLmN1cnJlbnRfaGVhZGVycy5tYXAoaGVhZGVyID0+IGhlYWRlci5oZWFkZXIpLmpvaW4oJyA+ICcpO1xuICAgICAgICAgIGFjYy5ibG9ja19oZWFkaW5ncyA9IFwiI1wiICsgYWNjLmN1cnJlbnRfaGVhZGVycy5tYXAoaGVhZGVyID0+IGhlYWRlci5oZWFkZXIpLmpvaW4oJyMnKTtcbiAgICAgICAgICB0aGlzLmhhbmRsZV9kdXBsaWNhdGVfaGVhZGluZ3MoYWNjKTtcbiAgICAgICAgICBhY2MuYmxvY2tfaGVhZGluZ3NfbGlzdC5wdXNoKGFjYy5ibG9ja19oZWFkaW5ncyk7XG4gICAgICAgICAgYWNjLmJsb2NrX3BhdGggPSBmaWxlX3BhdGggKyBhY2MuYmxvY2tfaGVhZGluZ3M7XG4gICAgICAgICAgYWNjLmN1cnJfaGVhZGluZyA9IGxpbmUucmVwbGFjZSgvIy9nLCAnJykudHJpbSgpO1xuICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgbGluZSBpcyBub3QgYSBoZWFkaW5nLCBhZGQgbGluZSB0byBjdXJyZW50IGJsb2NrXG4gICAgICAgIGlmKHRoaXMuaXNfY29udGVudF9saW5lKGxpbmUpKXtcbiAgICAgICAgICBpZihhY2MuY3Vyci5pbmRleE9mKFwiXFxuXCIpID09PSAtMSkgYWNjLmN1cnIgKz0gXCI6XCI7IC8vIGFkZCBcIjpcIiB0byBpbmRpY2F0ZSBlbmQgb2YgaGVhZGluZyBicmVhZGNydW1ic1xuICAgICAgICAgIGFjYy5jdXJyICs9IFwiXFxuXCIgKyBsaW5lOyAvLyBmaWx0ZXIgb3V0IGVtcHR5IGxpbmVzIGFuZCBidWxsZXRzXG4gICAgICAgICAgYWNjLmN1cnJfbGluZSA9IGk7IC8vIHNldCB0aGUgY3VycmVudCBsaW5lXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IGFyci5sZW5ndGggLSAxKSB0aGlzLm91dHB1dF9ibG9jayhhY2MpOyAvLyBpZiBsYXN0IGxpbmUsIG91dHB1dCB0aGUgYmxvY2tcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sIHsgYmxvY2tfaGVhZGluZ3M6ICcnLCBibG9ja19oZWFkaW5nc19saXN0OiBbXSwgYmxvY2tfcGF0aDogZmlsZV9wYXRoICsgXCIjXCIsIGN1cnI6IGZpbGVfYnJlYWRjcnVtYnMsIGN1cnJlbnRfaGVhZGVyczogW10sIGJsb2NrczogW10sIGxvZzogW10sIHN0YXJ0X2xpbmU6IDAsIGN1cnJfbGluZTogMCwgY3Vycl9oZWFkaW5nOiBudWxsIH0pXG4gICAgO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5vdXRwdXQsXG4gICAgICBmaWxlX3BhdGgsXG4gICAgICAvLyByZW1vdmUgcHJvcGVydGllcyB0aGF0IGFyZSBleGNsdXNpdmUgdG8gdGhlIHJlZHVjZSBmdW5jdGlvblxuICAgICAgYmxvY2tfaGVhZGluZ3M6IHVuZGVmaW5lZCxcbiAgICAgIGJsb2NrX2hlYWRpbmdzX2xpc3Q6IHVuZGVmaW5lZCxcbiAgICAgIGJsb2NrX3BhdGg6IHVuZGVmaW5lZCxcbiAgICAgIGN1cnI6IHVuZGVmaW5lZCxcbiAgICAgIGN1cnJlbnRfaGVhZGVyczogdW5kZWZpbmVkLFxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgZHVwbGljYXRlIGhlYWRpbmdzIGJ5IGFwcGVuZGluZyBhIHVuaXF1ZSBpZGVudGlmaWVyIHRvIHRoZSBoZWFkaW5nIHBhdGguXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhY2MgLSBUaGUgYWNjdW11bGF0b3Igb2JqZWN0IHVzZWQgaW4gcmVkdWNlIGZ1bmN0aW9uLlxuICAgKi9cbiAgLy8gaWYgYmxvY2tfaGVhZGluZ3MgaXMgYWxyZWFkeSBpbiBibG9ja19oZWFkaW5nc19saXN0IHRoZW4gYWRkIGEgbnVtYmVyIHRvIHRoZSBlbmRcbiAgaGFuZGxlX2R1cGxpY2F0ZV9oZWFkaW5ncyhhY2MpIHtcbiAgICBpZiAoIWFjYy5ibG9ja19oZWFkaW5nc19saXN0LmluY2x1ZGVzKGFjYy5ibG9ja19oZWFkaW5ncykpIHJldHVybjsgLy8gaWYgYmxvY2tfaGVhZGluZ3MgaXMgbm90IGluIGJsb2NrX2hlYWRpbmdzX2xpc3QgdGhlbiByZXR1cm5cbiAgICBsZXQgY291bnQgPSAxO1xuICAgIGNvbnN0IHVuaXF1ZUhlYWRpbmdzID0gbmV3IFNldChhY2MuYmxvY2tfaGVhZGluZ3NfbGlzdCk7XG4gICAgd2hpbGUgKHVuaXF1ZUhlYWRpbmdzLmhhcyhgJHthY2MuYmxvY2tfaGVhZGluZ3N9eyR7Y291bnR9fWApKSB7IGNvdW50Kys7IH1cbiAgICBhY2MuYmxvY2tfaGVhZGluZ3MgPSBgJHthY2MuYmxvY2tfaGVhZGluZ3N9eyR7Y291bnR9fWA7XG4gIH1cbiAgLyoqXG4gICAqIE91dHB1dHMgdGhlIGN1cnJlbnQgYmxvY2sgaW50byB0aGUgc3RydWN0dXJlZCBibG9ja3MgYXJyYXkgYWZ0ZXIgdmFsaWRhdGlvbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IGFjYyAtIFRoZSBhY2N1bXVsYXRvciBvYmplY3QgdXNlZCBpbiByZWR1Y2UgZnVuY3Rpb24uXG4gICAqL1xuICAvLyBwdXNoIHRoZSBjdXJyZW50IGJsb2NrIHRvIHRoZSBibG9ja3MgYXJyYXlcbiAgb3V0cHV0X2Jsb2NrKGFjYykge1xuICAgIGNvbnN0IHsgZW1iZWRfaW5wdXRfbWF4X2NoYXJzLCBlbWJlZF9pbnB1dF9taW5fY2hhcnMgfSA9IHRoaXMuY29uZmlnO1xuICAgIGlmKGFjYy5jdXJyLmluZGV4T2YoXCJcXG5cIikgPT09IC0xKSByZXR1cm4gYWNjLmxvZy5wdXNoKGBTa2lwcGluZyBlbXB0eSBibG9jazogJHthY2MuY3Vycn1gKTsgLy8gaW5kaWNhdGVkIGJ5IG5vIG5ld2xpbmVzIGluIGJsb2NrXG4gICAgaWYoIXRoaXMudmFsaWRhdGVfaGVhZGluZyhhY2MuYmxvY2tfaGVhZGluZ3MpKSByZXR1cm4gYWNjLmxvZy5wdXNoKGBTa2lwcGluZyBleGNsdWRlZCBoZWFkaW5nOiAke2FjYy5ibG9ja19oZWFkaW5nc31gKTtcbiAgICBpZihhY2MuY3Vyci5sZW5ndGggPiBlbWJlZF9pbnB1dF9tYXhfY2hhcnMpIGFjYy5jdXJyID0gYWNjLmN1cnIuc3Vic3RyaW5nKDAsIGVtYmVkX2lucHV0X21heF9jaGFycyk7IC8vIHRyaW0gYmxvY2sgdG8gbWF4IGxlbmd0aFxuICAgIGNvbnN0IGJyZWFkY3J1bWJzX2xlbmd0aCA9IGFjYy5jdXJyLmluZGV4T2YoXCJcXG5cIikgKyAxOyAvLyBicmVhZGNydW1icyBsZW5ndGggKGZpcnN0IGxpbmUgb2YgYmxvY2spXG4gICAgY29uc3QgYmxvY2tfbGVuZ3RoID0gYWNjLmN1cnIubGVuZ3RoIC0gYnJlYWRjcnVtYnNfbGVuZ3RoO1xuICAgIGlmKGJsb2NrX2xlbmd0aCA8IGVtYmVkX2lucHV0X21pbl9jaGFycykgcmV0dXJuIGFjYy5sb2cucHVzaChgU2tpcHBpbmcgYmxvY2sgc2hvcnRlciB0aGFuIG1pbiBsZW5ndGg6ICR7YWNjLmN1cnJ9YCk7IC8vIHNraXAgaWYgYmxvY2sgaXMgc2hvcnRlciB0aGFuIG1pbiBsZW5ndGhcbiAgICBpZih0aGlzLmNvbmZpZy5za2lwX2Jsb2Nrc193aXRoX2hlYWRpbmdzX29ubHkpeyAvLyBza2lwIGlmIGFsbCBsaW5lcyBhcmUgaGVhZGluZ3MgKGV4Y2VwdCBmaXJzdCBsaW5lIHdoaWNoIGlzIGJyZWFkY3J1bWJzKVxuICAgICAgY29uc3QgYmxvY2tfbGluZXMgPSBhY2MuY3Vyci5zcGxpdCgnXFxuJyk7XG4gICAgICBjb25zdCBibG9ja19oZWFkaW5ncyA9IGJsb2NrX2xpbmVzLnNsaWNlKDEpLmZpbHRlcihsaW5lID0+IHRoaXMuaXNfaGVhZGluZyhsaW5lKSk7XG4gICAgICBpZihibG9ja19oZWFkaW5ncy5sZW5ndGggPT09IGJsb2NrX2xpbmVzLmxlbmd0aCAtIDEpIHJldHVybiBhY2MubG9nLnB1c2goYFNraXBwaW5nIGJsb2NrIHdpdGggb25seSBoZWFkaW5nczogJHthY2MuY3Vycn1gKTtcbiAgICB9XG4gICAgYWNjLmJsb2Nrcy5wdXNoKHtcbiAgICAgIHRleHQ6IGFjYy5jdXJyLnRyaW0oKSxcbiAgICAgIHBhdGg6IGFjYy5ibG9ja19wYXRoLFxuICAgICAgbGVuZ3RoOiBibG9ja19sZW5ndGgsXG4gICAgICBoZWFkaW5nOiBhY2MuY3Vycl9oZWFkaW5nLFxuICAgICAgbGluZXM6IFthY2Muc3RhcnRfbGluZSwgYWNjLmN1cnJfbGluZV0sXG4gICAgfSk7IC8vIGFkZCBibG9jayB0byBibG9ja3MgYXJyYXlcbiAgfVxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiBhIGxpbmUgb2YgdGV4dCBzaG91bGQgYmUgY29uc2lkZXJlZCBhcyBjb250ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGluZSAtIFRoZSBsaW5lIG9mIHRleHQgdG8gZXZhbHVhdGUuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBsaW5lIGlzIGNvbnRlbnQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzX2NvbnRlbnRfbGluZShsaW5lKSB7XG4gICAgLy8gaWYgKGxpbmUgPT09ICcnKSByZXR1cm4gZmFsc2U7IC8vIHNraXAgaWYgbGluZSBpcyBlbXB0eSAvLyBETzogbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZVxuICAgIGlmIChbJy0gJywgJy0gWyBdICddLmluZGV4T2YobGluZSkgPiAtMSkgcmV0dXJuIGZhbHNlOyAvLyBza2lwIGlmIGxpbmUgaXMgZW1wdHkgYnVsbGV0IG9yIGNoZWNrYm94XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgZmlsZSBwYXRoIHRvIGEgYnJlYWRjcnVtYiBzdHJpbmcgZm9ybWF0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZV9wYXRoIC0gVGhlIGZpbGUgcGF0aCB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgYnJlYWRjcnVtYiBzdHJpbmcuXG4gICAqL1xuICBmaWxlX3BhdGhfdG9fYnJlYWRjcnVtYnMoZmlsZV9wYXRoKSB7IHJldHVybiBmaWxlX3BhdGgucmVwbGFjZSgnLm1kJywgJycpLnNwbGl0KCcvJykubWFwKGNydW1iID0+IGNydW1iLnRyaW0oKSkuZmlsdGVyKGNydW1iID0+IGNydW1iICE9PSAnJykuam9pbignID4gJyk7IH0gLy8gcmVtb3ZlIC5tZCBmaWxlIGV4dGVuc2lvbiBhbmQgY29udmVydCBmaWxlX3BhdGggdG8gYnJlYWRjcnVtYiBmb3JtYXR0aW5nXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBsZXZlbCBvZiBhIGhlYWRpbmcgYmFzZWQgb24gdGhlIG51bWJlciBvZiAnIycgY2hhcmFjdGVycy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGxpbmUgLSBUaGUgaGVhZGluZyBsaW5lIHRvIGV2YWx1YXRlLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbGV2ZWwgb2YgdGhlIGhlYWRpbmcuXG4gICAqLyAgXG4gIGhlYWRpbmdfbGV2ZWwobGluZSkgeyByZXR1cm4gbGluZS5zcGxpdCgnIycpLmxlbmd0aCAtIDE7IH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIGxpbmUgaXMgYSBoZWFkaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGluZSAtIFRoZSBsaW5lIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgbGluZSBpcyBhIGhlYWRpbmcsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGxpbmUgLSBUaGUgbGluZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIGxpbmUgaXMgYSBoZWFkaW5nLCBmYWxzZSBvdGhlcndpc2UuXG4gICovXG4gIGlzX2hlYWRpbmcobGluZSkgeyByZXR1cm4gbGluZS5zdGFydHNXaXRoKCcjJykgJiYgKFsnIycsICcgJ10uaW5kZXhPZihsaW5lWzFdKSA+IC0xKTsgfSAvLyBjaGVjayBpZiBsaW5lIGlzIGEgaGVhZGluZyAoc3RhcnRzIHdpdGggIyBhbmQgc2Vjb25kIGNoYXJhY3RlciBpcyBzcGFjZSBvciAjIGluZGljYXRpbmcgbm90IGEgdGFnKVxuICAvKipcbiAgICogVmFsaWRhdGVzIGlmIHRoZSBibG9jayBwYXRoIGlzIGNvcnJlY3RseSBmb3JtYXR0ZWQgdG8gaW5jbHVkZSBhdCBsZWFzdCBvbmUgaGVhZGluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGJsb2NrX3BhdGggLSBUaGUgYmxvY2sgcGF0aCB0byB2YWxpZGF0ZS5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIGJsb2NrIHBhdGggaXMgdmFsaWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIHZhbGlkYXRlX2Jsb2NrX3BhdGgoYmxvY2tfcGF0aCkgeyByZXR1cm4gYmxvY2tfcGF0aC5pbmRleE9mKFwiI1wiKSA+IC0xOyB9IC8vIHZhbGlkYXRlIGJsb2NrX3BhdGggY29udGFpbnMgYXQgbGVhc3Qgb25lIFwiI1wiXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgYSBoZWFkaW5nIGFnYWluc3QgdGhlIGxpc3Qgb2YgZXhjbHVkZWQgaGVhZGluZ3MuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBoZWFkaW5ncyAtIFRoZSBoZWFkaW5nIHRvIHZhbGlkYXRlLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgaGVhZGluZyBpcyBub3QgZXhjbHVkZWQsIGZhbHNlIGlmIGl0IGlzLlxuICAgKi8gIFxuICB2YWxpZGF0ZV9oZWFkaW5nKGhlYWRpbmdzKSB7IHJldHVybiAhISF0aGlzLmV4Y2x1ZGVkX2hlYWRpbmdzPy5zb21lKGV4Y2x1c2lvbiA9PiBoZWFkaW5ncy5pbmRleE9mKGV4Y2x1c2lvbikgPiAtMSk7IH0gLy8gdmFsaWRhdGUgaGVhZGluZyBhZ2FpbnN0IGV4Y2x1ZGVkIGhlYWRpbmdzXG5cbn1cbmV4cG9ydHMuU21hcnRNYXJrZG93biA9IFNtYXJ0TWFya2Rvd247IiwgIi8vIENvcHlyaWdodCAoYykgQnJpYW4gSm9zZXBoIFBldHJvXG5cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xuLy8gYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuLy8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXG4vLyB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4vLyBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbi8vIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbi8vIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkVcbi8vIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT05cbi8vIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxuLy8gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmNvbnN0IHsgU21hcnRNYXJrZG93biB9ID0gcmVxdWlyZSgnLi9TbWFydE1hcmtkb3duJyk7XG5leHBvcnRzLlNtYXJ0TWFya2Rvd24gPSBTbWFydE1hcmtkb3duOyIsICIvKipcbiAqIENyZWF0ZXMgYSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGdpdmVuIGRhdGEgd2l0aG91dCB1c2luZyBjcnlwdG9ncmFwaGljIG1ldGhvZHMuXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCB0byBjcmVhdGUgYSBVSUQgZm9yLlxuICogQHJldHVybnMge3N0cmluZ30gQSB1bmlxdWUgaWRlbnRpZmllciBiYXNlZCBvbiB0aGUgaW5wdXQgZGF0YS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlX3VpZChkYXRhKSB7XG4gIGNvbnN0IHN0ciA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICBsZXQgaGFzaCA9IDA7XG4gIGlmIChzdHIubGVuZ3RoID09PSAwKSByZXR1cm4gaGFzaDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGFyID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgY2hhcjtcbiAgICBoYXNoID0gaGFzaCAmIGhhc2g7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICAgIC8vIHJlbW92ZSBuZWdhdGl2ZSBzaWduXG4gICAgaWYgKGhhc2ggPCAwKSBoYXNoID0gaGFzaCAqIC0xO1xuICB9XG4gIHJldHVybiBoYXNoLnRvU3RyaW5nKCkgKyBzdHIubGVuZ3RoO1xufVxuZXhwb3J0cy5jcmVhdGVfdWlkID0gY3JlYXRlX3VpZDtcblxuLyoqXG4gKiBEZWVwbHkgbWVyZ2VzIHR3byBvYmplY3RzLCBnaXZpbmcgcHJlY2VkZW5jZSB0byB0aGUgcHJvcGVydGllcyBvZiB0aGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG9iamVjdCB0byBtZXJnZSBwcm9wZXJ0aWVzIGludG8uXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIC0gVGhlIHNvdXJjZSBvYmplY3QgZnJvbSB3aGljaCBwcm9wZXJ0aWVzIGFyZSBzb3VyY2VkLlxuICogQHJldHVybnMge09iamVjdH0gVGhlIG1lcmdlZCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGRlZXBfbWVyZ2UodGFyZ2V0LCBzb3VyY2UpIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XG4gICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAvLyBib3RoIGV4aXN0IGFuZCBhcmUgb2JqZWN0c1xuICAgICAgaWYgKGlzX29iaihzb3VyY2Vba2V5XSkgJiYgaXNfb2JqKHRhcmdldFtrZXldKSkgZGVlcF9tZXJnZSh0YXJnZXRba2V5XSwgc291cmNlW2tleV0pO1xuICAgICAgZWxzZSB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyAvLyBwcmVjZWRlbmNlIHRvIHNvdXJjZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xuICBmdW5jdGlvbiBpc19vYmooaXRlbSkgeyByZXR1cm4gKGl0ZW0gJiYgdHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGl0ZW0pKTsgfVxufVxuZXhwb3J0cy5kZWVwX21lcmdlID0gZGVlcF9tZXJnZTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGNsYXNzIG5hbWUgZnJvbSBjYW1lbENhc2UgdG8gc25ha2VfY2FzZSBhbmQgbWFrZXMgcGx1cmFsIGZvcm1zLlxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzX25hbWUgLSBUaGUgY2xhc3MgbmFtZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIHNuYWtlX2Nhc2UgYW5kIHBsdXJhbGl6ZWQgY2xhc3MgbmFtZS5cbiAqL1xuZnVuY3Rpb24gY29sbGVjdGlvbl9pbnN0YW5jZV9uYW1lX2Zyb20oY2xhc3NfbmFtZSkge1xuICByZXR1cm4gY2xhc3NfbmFtZVxuICAgIC5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCAnJDFfJDInKSAvLyBjb252ZXJ0IGNhbWVsQ2FzZSB0byBzbmFrZV9jYXNlXG4gICAgLnRvTG93ZXJDYXNlKCkgLy8gY29udmVydCB0byBsb3dlcmNhc2VcbiAgICAucmVwbGFjZSgveSQvLCAnaWUnKSAvLyBleC4gc3VtbWFyaWVzXG4gICAgKyAncyc7XG59XG5leHBvcnRzLmNvbGxlY3Rpb25faW5zdGFuY2VfbmFtZV9mcm9tID0gY29sbGVjdGlvbl9pbnN0YW5jZV9uYW1lX2Zyb207XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgY29zaW5lIHNpbWlsYXJpdHkgYmV0d2VlbiB0d28gdmVjdG9ycy5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gdmVjdG9yMSAtIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHZlY3RvcjIgLSBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBjb3NpbmUgc2ltaWxhcml0eSBiZXR3ZWVuIHRoZSB0d28gdmVjdG9ycy5cbiAqL1xuZnVuY3Rpb24gY29zX3NpbSh2ZWN0b3IxLCB2ZWN0b3IyKSB7XG4gIGNvbnN0IGRvdFByb2R1Y3QgPSB2ZWN0b3IxLnJlZHVjZSgoYWNjLCB2YWwsIGkpID0+IGFjYyArIHZhbCAqIHZlY3RvcjJbaV0sIDApO1xuICBjb25zdCBub3JtQSA9IE1hdGguc3FydCh2ZWN0b3IxLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYyArIHZhbCAqIHZhbCwgMCkpO1xuICBjb25zdCBub3JtQiA9IE1hdGguc3FydCh2ZWN0b3IyLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYyArIHZhbCAqIHZhbCwgMCkpO1xuICByZXR1cm4gbm9ybUEgPT09IDAgfHwgbm9ybUIgPT09IDAgPyAwIDogZG90UHJvZHVjdCAvIChub3JtQSAqIG5vcm1CKTtcbn1cbmV4cG9ydHMuY29zX3NpbSA9IGNvc19zaW07XG5cbi8qKlxuICogTWFpbnRhaW5zIGEgY29sbGVjdGlvbiBvZiB0b3AgaXRlbXMgYmFzZWQgb24gdGhlaXIgc2ltaWxhcml0eSBtZWFzdXJlLlxuICogQHBhcmFtIHtPYmplY3R9IF9hY2MgLSBUaGUgYWNjdW11bGF0b3Igb2JqZWN0IHRoYXQgc3RvcmVzIGl0ZW1zIGFuZCB0aGVpciBtaW5pbXVtIHNpbWlsYXJpdHkuXG4gKiBAcGFyYW0ge09iamVjdH0gaXRlbSAtIFRoZSBuZXcgaXRlbSB0byBjb25zaWRlciBmb3IgaW5jbHVzaW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtjdD0xMF0gLSBUaGUgY291bnQgb2YgdG9wIGl0ZW1zIHRvIG1haW50YWluLlxuICovXG5mdW5jdGlvbiB0b3BfYWNjKF9hY2MsIGl0ZW0sIGN0ID0gMTApIHtcbiAgaWYgKF9hY2MuaXRlbXMuc2l6ZSA8IGN0KSB7XG4gICAgX2FjYy5pdGVtcy5hZGQoaXRlbSk7XG4gIH0gZWxzZSBpZiAoaXRlbS5zaW0gPiBfYWNjLm1pbikge1xuICAgIF9hY2MuaXRlbXMuYWRkKGl0ZW0pO1xuICAgIF9hY2MuaXRlbXMuZGVsZXRlKF9hY2MubWluSXRlbSk7XG4gICAgX2FjYy5taW5JdGVtID0gQXJyYXkuZnJvbShfYWNjLml0ZW1zKS5yZWR1Y2UoKG1pbiwgY3VycikgPT4gKGN1cnIuc2ltIDwgbWluLnNpbSA/IGN1cnIgOiBtaW4pKTtcbiAgICBfYWNjLm1pbiA9IF9hY2MubWluSXRlbS5zaW07XG4gIH1cbn1cbmV4cG9ydHMudG9wX2FjYyA9IHRvcF9hY2M7XG5cbi8qKlxuICogRGVsYXlzIHRoZSBleGVjdXRpb24gb2YgdGhlIG5leHQgbGluZSBpbiB0aGUgY29kZSBieSBhIHNwZWNpZmllZCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IG1zIC0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgYWZ0ZXIgdGhlIHNwZWNpZmllZCBkZWxheS5cbiAqL1xuZnVuY3Rpb24gc2xlZXAobXMpIHsgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpOyB9XG5leHBvcnRzLnNsZWVwID0gc2xlZXA7IiwgImNvbnN0IGhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcbmNvbnN0IHtcbiAgY3JlYXRlX3VpZCxcbiAgZGVlcF9tZXJnZSxcbiAgY29sbGVjdGlvbl9pbnN0YW5jZV9uYW1lX2Zyb20sXG59ID0gaGVscGVycztcblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGl0ZW0gd2l0aGluIGEgY29sbGVjdGlvbiwgcHJvdmlkaW5nIG1ldGhvZHMgZm9yIGRhdGEgbWFuaXB1bGF0aW9uLCB2YWxpZGF0aW9uLCBhbmQgaW50ZXJhY3Rpb24gd2l0aCBpdHMgY29sbGVjdGlvbi5cbiAqL1xuY2xhc3MgQ29sbGVjdGlvbkl0ZW0ge1xuICAvKipcbiAgICogRGVmYXVsdCBwcm9wZXJ0aWVzIGZvciBhbiBpbnN0YW5jZSBvZiBDb2xsZWN0aW9uSXRlbS5cbiAgICogQHJldHVybnMge09iamVjdH0gRGVmYXVsdCBkYXRhIGNvbmZpZ3VyYXRpb24uXG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIGtleTogbnVsbCxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIENvbGxlY3Rpb25JdGVtLlxuICAgKiBAcGFyYW0ge09iamVjdH0gYnJhaW4gLSBUaGUgY2VudHJhbCBzdG9yYWdlIG9yIGNvbnRleHQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fG51bGx9IGRhdGEgLSBJbml0aWFsIGRhdGEgZm9yIHRoZSBpdGVtLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZW52LCBkYXRhID0gbnVsbCkge1xuICAgIHRoaXMuZW52ID0gZW52O1xuICAgIHRoaXMuYnJhaW4gPSB0aGlzLmVudjsgLy8gREVQUkVDQVRFRFxuICAgIHRoaXMuY29uZmlnID0gdGhpcy5lbnY/LmNvbmZpZztcbiAgICB0aGlzLm1lcmdlX2RlZmF1bHRzKCk7XG4gICAgaWYgKGRhdGEpIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgaWYoIXRoaXMuZGF0YS5jbGFzc19uYW1lKSB0aGlzLmRhdGEuY2xhc3NfbmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXJnZXMgZGVmYXVsdCBwcm9wZXJ0aWVzIGZyb20gYWxsIGNsYXNzZXMgaW4gdGhlIGluaGVyaXRhbmNlIGNoYWluLlxuICAgKi9cbiAgbWVyZ2VfZGVmYXVsdHMoKSB7XG4gICAgbGV0IGN1cnJlbnRfY2xhc3MgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgIHdoaWxlIChjdXJyZW50X2NsYXNzKSB7IC8vIGRlZXAgbWVyZ2UgZGVmYXVsdHNcbiAgICAgIGZvciAobGV0IGtleSBpbiBjdXJyZW50X2NsYXNzLmRlZmF1bHRzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY3VycmVudF9jbGFzcy5kZWZhdWx0c1trZXldID09PSAnb2JqZWN0JykgdGhpc1trZXldID0geyAuLi5jdXJyZW50X2NsYXNzLmRlZmF1bHRzW2tleV0sIC4uLnRoaXNba2V5XSB9O1xuICAgICAgICBlbHNlIHRoaXNba2V5XSA9IGN1cnJlbnRfY2xhc3MuZGVmYXVsdHNba2V5XTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRfY2xhc3MgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY3VycmVudF9jbGFzcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBvciByZXRyaWV2ZXMgYSB1bmlxdWUga2V5IGZvciB0aGUgaXRlbS4gQ2FuIGJlIG92ZXJyaWRkZW4gaW4gY2hpbGQgY2xhc3Nlcy5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHVuaXF1ZSBrZXkuXG4gICAqL1xuICBnZXRfa2V5KCkge1xuICAgIGNvbnNvbGUubG9nKFwiY2FsbGVkIGRlZmF1bHQgZ2V0X2tleVwiKTtcbiAgICByZXR1cm4gY3JlYXRlX3VpZCh0aGlzLmRhdGEpO1xuICB9XG4gIC8vIHVwZGF0ZV9kYXRhIC0gZm9yIGRhdGEgaW4gdGhpcy5kYXRhXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBkYXRhIG9mIHRoaXMgaXRlbSB3aXRoIG5ldyBkYXRhLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIFRoZSBuZXcgZGF0YSBmb3IgdGhlIGl0ZW0uXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIGRhdGEgd2FzIHN1Y2Nlc3NmdWxseSB1cGRhdGVkLlxuICAgKi9cbiAgdXBkYXRlX2RhdGEoZGF0YSkge1xuICAgIGRhdGEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGRhdGEsIHRoaXMudXBkYXRlX2RhdGFfcmVwbGFjZXIpKTtcbiAgICBkZWVwX21lcmdlKHRoaXMuZGF0YSwgZGF0YSk7IC8vIGRlZXAgbWVyZ2UgZGF0YVxuICAgIHJldHVybiB0cnVlOyAvLyByZXR1cm4gdHJ1ZSBpZiBkYXRhIGNoYW5nZWQgKGRlZmF1bHQgdHJ1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDdXN0b20gcmVwbGFjZXIgZnVuY3Rpb24gZm9yIEpTT04uc3RyaW5naWZ5IHVzZWQgaW4gdXBkYXRlX2RhdGEgdG8gaGFuZGxlIHNwZWNpYWwgb2JqZWN0IHR5cGVzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgYmVpbmcgc3RyaW5naWZpZWQuXG4gICAqIEBwYXJhbSB7YW55fSB2YWx1ZSAtIFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgYmVpbmcgc3RyaW5naWZpZWQuXG4gICAqIEByZXR1cm5zIHthbnl9IFRoZSB2YWx1ZSB0byBiZSB1c2VkIGluIHRoZSBKU09OIHN0cmluZy5cbiAgICovXG4gIHVwZGF0ZV9kYXRhX3JlcGxhY2VyKGtleSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBDb2xsZWN0aW9uSXRlbSkgcmV0dXJuIHZhbHVlLnJlZjtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHJldHVybiB2YWx1ZS5tYXAoKHZhbCkgPT4gKHZhbCBpbnN0YW5jZW9mIENvbGxlY3Rpb25JdGVtKSA/IHZhbC5yZWYgOiB2YWwpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICAvLyBpbml0IC0gZm9yIGRhdGEgbm90IGluIHRoaXMuZGF0YVxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGl0ZW0gd2l0aCBpbnB1dF9kYXRhLCBwb3RlbnRpYWxseSBhc3luY2hyb25vdXNseS5cbiAgICogSGFuZGxlcyBpbnRlcmFjdGlvbnMgd2l0aCBvdGhlciBjb2xsZWN0aW9uIGl0ZW1zLlxuICAgKi9cbiAgaW5pdCgpIHsgdGhpcy5zYXZlKCk7IH0gLy8gc2hvdWxkIGFsd2F5cyBjYWxsIHRoaXMuc2F2ZSgpIGluIGNoaWxkIGNsYXNzIGluaXQoKSBvdmVycmlkZXNcblxuICAvKipcbiAgICogU2F2ZXMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGl0ZW0gdG8gaXRzIGNvbGxlY3Rpb24uXG4gICAqL1xuICBzYXZlKCkge1xuICAgIGlmICghdGhpcy52YWxpZGF0ZV9zYXZlKCkpIHtcbiAgICAgIGlmICh0aGlzLmtleSkgdGhpcy5jb2xsZWN0aW9uLmRlbGV0ZSh0aGlzLmtleSk7XG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcihcIkludmFsaWQgc2F2ZTogXCIsIHsgZGF0YTogdGhpcy5kYXRhLCBzdGFjazogbmV3IEVycm9yKCkuc3RhY2sgfSk7XG4gICAgfVxuICAgIHRoaXMuY29sbGVjdGlvbi5zZXQodGhpcyk7IC8vIHNldCBlbnRpdHkgaW4gY29sbGVjdGlvblxuICAgIHRoaXMuY29sbGVjdGlvbi5zYXZlKCk7IC8vIHNhdmUgY29sbGVjdGlvblxuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGUgaXRlbSdzIGRhdGEgYmVmb3JlIHNhdmluZy5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIGRhdGEgaXMgdmFsaWQgZm9yIHNhdmluZy5cbiAgICovXG4gIHZhbGlkYXRlX3NhdmUoKSB7XG4gICAgaWYoIXRoaXMua2V5KSByZXR1cm4gZmFsc2U7XG4gICAgaWYodGhpcy5rZXkgPT09ICcnKSByZXR1cm4gZmFsc2U7XG4gICAgaWYodGhpcy5rZXkgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyB0aGUgaXRlbSBmcm9tIGl0cyBjb2xsZWN0aW9uLlxuICAgKi9cbiAgZGVsZXRlKCkgeyB0aGlzLmNvbGxlY3Rpb24uZGVsZXRlKHRoaXMua2V5KTsgfVxuXG4gIC8vIGZ1bmN0aW9uYWwgZmlsdGVyIChyZXR1cm5zIHRydWUgb3IgZmFsc2UpIGZvciBmaWx0ZXJpbmcgaXRlbXMgaW4gY29sbGVjdGlvbjsgY2FsbGVkIGJ5IGNvbGxlY3Rpb24gY2xhc3NcbiAgLyoqXG4gICAqIEZpbHRlcnMgaXRlbXMgaW4gdGhlIGNvbGxlY3Rpb24gYmFzZWQgb24gcHJvdmlkZWQgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBGaWx0ZXJpbmcgb3B0aW9ucy5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIGl0ZW0gcGFzc2VzIHRoZSBmaWx0ZXIuXG4gICAqL1xuICBmaWx0ZXIob3B0cyA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgZXhjbHVkZV9rZXksXG4gICAgICBleGNsdWRlX2tleXMgPSBleGNsdWRlX2tleSA/IFtleGNsdWRlX2tleV0gOiBbXSxcbiAgICAgIGV4Y2x1ZGVfa2V5X3N0YXJ0c193aXRoLFxuICAgICAga2V5X2VuZHNfd2l0aCxcbiAgICAgIGtleV9zdGFydHNfd2l0aCxcbiAgICAgIGtleV9zdGFydHNfd2l0aF9hbnksXG4gICAgfSA9IG9wdHM7XG4gICAgaWYgKGV4Y2x1ZGVfa2V5cz8uaW5jbHVkZXModGhpcy5rZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGV4Y2x1ZGVfa2V5X3N0YXJ0c193aXRoICYmIHRoaXMua2V5LnN0YXJ0c1dpdGgoZXhjbHVkZV9rZXlfc3RhcnRzX3dpdGgpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGtleV9lbmRzX3dpdGggJiYgIXRoaXMua2V5LmVuZHNXaXRoKGtleV9lbmRzX3dpdGgpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGtleV9zdGFydHNfd2l0aCAmJiAhdGhpcy5rZXkuc3RhcnRzV2l0aChrZXlfc3RhcnRzX3dpdGgpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGtleV9zdGFydHNfd2l0aF9hbnkgJiYgIWtleV9zdGFydHNfd2l0aF9hbnkuc29tZSgocHJlZml4KSA9PiB0aGlzLmtleS5zdGFydHNXaXRoKHByZWZpeCkpKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gT1ZFUlJJREUgRklMVEVSIExPR0lDIGhlcmU6IHBhdHRlcm46IGlmKG9wdHMucGF0dGVybiAmJiAhdGhpcy5kYXRhW29wdHMucGF0dGVybi5tYXRjaGVyXSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyB0aGUgaXRlbSdzIGRhdGEgZm9yIGFueSBuZWNlc3NhcnkgcHJvY2Vzc2luZyBvciB0cmFuc2Zvcm1hdGlvbi4gUGxhY2Vob2xkZXIgZm9yIG92ZXJyaWRlIGluIGNoaWxkIGNsYXNzZXMuXG4gICAqL1xuICBwYXJzZSgpIHsgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGNvbGxlY3Rpb24gbmFtZSBkZXJpdmVkIGZyb20gdGhlIGNsYXNzIG5hbWUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb2xsZWN0aW9uIG5hbWUuXG4gICAqL1xuICBzdGF0aWMgZ2V0IGNvbGxlY3Rpb25fbmFtZSgpIHsgcmV0dXJuIGNvbGxlY3Rpb25faW5zdGFuY2VfbmFtZV9mcm9tKHRoaXMubmFtZSk7IH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBjb2xsZWN0aW9uIG5hbWUgZm9yIHRoZSBpbnN0YW5jZSwgZWl0aGVyIGZyb20gZGF0YSBvciB0aGUgY2xhc3MgbWV0aG9kLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29sbGVjdGlvbiBuYW1lLlxuICAgKi9cbiAgZ2V0IGNvbGxlY3Rpb25fbmFtZSgpIHsgcmV0dXJuIHRoaXMuZGF0YS5jb2xsZWN0aW9uX25hbWUgPyB0aGlzLmRhdGEuY29sbGVjdGlvbl9uYW1lIDogY29sbGVjdGlvbl9pbnN0YW5jZV9uYW1lX2Zyb20odGhpcy5kYXRhLmNsYXNzX25hbWUgfHwgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lKTsgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGNvbGxlY3Rpb24gdGhpcyBpdGVtIGJlbG9uZ3MgdG8uXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBjb2xsZWN0aW9uIG9iamVjdC5cbiAgICovXG4gIGdldCBjb2xsZWN0aW9uKCkgeyByZXR1cm4gdGhpcy5lbnZbdGhpcy5jb2xsZWN0aW9uX25hbWVdOyB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBvciBnZW5lcmF0ZXMgdGhlIGtleSBmb3IgdGhpcyBpdGVtLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgaXRlbSdzIGtleS5cbiAgICovXG4gIGdldCBrZXkoKSB7IHJldHVybiB0aGlzLmRhdGEua2V5ID0gdGhpcy5kYXRhLmtleSB8fCB0aGlzLmdldF9rZXkoKTsgfVxuXG4gIC8qKlxuICAgKiBQcm92aWRlcyBhIHJlZmVyZW5jZSBvYmplY3QgZm9yIHRoaXMgaXRlbSwgY29udGFpbmluZyB0aGUgY29sbGVjdGlvbiBuYW1lIGFuZCBrZXkuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSByZWZlcmVuY2Ugb2JqZWN0LlxuICAgKi9cbiAgZ2V0IHJlZigpIHsgcmV0dXJuIHsgY29sbGVjdGlvbl9uYW1lOiB0aGlzLmNvbGxlY3Rpb25fbmFtZSwga2V5OiB0aGlzLmtleSB9OyB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgc2VxdWVuY2Uga2V5IGZvciB0aGlzIGl0ZW0sIHVzZWQgZm9yIGJ1aWxkaW5nIHNlcXVlbmNlIGtleXMuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBzZXF1ZW5jZSBrZXkuXG4gICAqL1xuICBnZXQgc2VxX2tleSgpIHsgcmV0dXJuIHRoaXMua2V5OyB9IC8vIHVzZWQgZm9yIGJ1aWxkaW5nIHNlcXVlbmNlIGtleXNcbn1cbmV4cG9ydHMuQ29sbGVjdGlvbkl0ZW0gPSBDb2xsZWN0aW9uSXRlbTsiLCAiY29uc3QgeyBDb2xsZWN0aW9uSXRlbSB9ID0gcmVxdWlyZSgnLi9Db2xsZWN0aW9uSXRlbScpO1xuY29uc3QgQXN5bmNGdW5jdGlvbiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihhc3luYyBmdW5jdGlvbigpe30pLmNvbnN0cnVjdG9yOyAvLyBmb3IgY2hlY2tpbmcgaWYgZnVuY3Rpb24gaXMgYXN5bmNcbmNvbnN0IGhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcbmNvbnN0IHsgZGVlcF9tZXJnZSwgfSA9IGhlbHBlcnM7XG5cbi8qKlxuICogQmFzZSBjbGFzcyByZXByZXNlbnRpbmcgYSBjb2xsZWN0aW9uIG9mIGl0ZW1zIHdpdGggdmFyaW91cyBtZXRob2RzIHRvIG1hbmlwdWxhdGUgYW5kIHJldHJpZXZlIHRoZXNlIGl0ZW1zLlxuICovXG5jbGFzcyBDb2xsZWN0aW9uIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgQ29sbGVjdGlvbiBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGVudiAtIFRoZSBlbnZpcm9ubWVudCBjb250ZXh0IGNvbnRhaW5pbmcgY29uZmlndXJhdGlvbnMgYW5kIGFkYXB0ZXJzLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZW52KSB7XG4gICAgdGhpcy5lbnYgPSBlbnY7XG4gICAgdGhpcy5icmFpbiA9IHRoaXMuZW52OyAvLyBERVBSRUNBVEVEOiB1c2UgZW52IGluc3RlYWQgb2YgYnJhaW5cbiAgICB0aGlzLmNvbmZpZyA9IHRoaXMuZW52LmNvbmZpZztcbiAgICB0aGlzLml0ZW1zID0ge307XG4gICAgdGhpcy5MVE0gPSB0aGlzLmVudi5sdG1fYWRhcHRlci53YWtlX3VwKHRoaXMsIHRoaXMuZW52Lmx0bV9hZGFwdGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkcyBhIGNvbGxlY3Rpb24gYmFzZWQgb24gdGhlIGVudmlyb25tZW50IGFuZCBvcHRpb25hbCBjb25maWd1cmF0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW52IC0gVGhlIGVudmlyb25tZW50IGNvbnRleHQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnPXt9XSAtIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBjb2xsZWN0aW9uLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDb2xsZWN0aW9uPnxDb2xsZWN0aW9ufSBUaGUgbG9hZGVkIGNvbGxlY3Rpb24gaW5zdGFuY2UuXG4gICAqL1xuICBzdGF0aWMgbG9hZChlbnYsIGNvbmZpZyA9IHt9KSB7XG4gICAgY29uc3QgeyBjdXN0b21fY29sbGVjdGlvbl9uYW1lIH0gPSBjb25maWc7XG4gICAgZW52W3RoaXMuY29sbGVjdGlvbl9uYW1lXSA9IG5ldyB0aGlzKGVudik7XG4gICAgaWYgKGN1c3RvbV9jb2xsZWN0aW9uX25hbWUpIHtcbiAgICAgIGVudlt0aGlzLmNvbGxlY3Rpb25fbmFtZV0uY29sbGVjdGlvbl9uYW1lID0gY3VzdG9tX2NvbGxlY3Rpb25fbmFtZTtcbiAgICAgIGVudi5jb2xsZWN0aW9uc1tjdXN0b21fY29sbGVjdGlvbl9uYW1lXSA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgfVxuICAgIGVudlt0aGlzLmNvbGxlY3Rpb25fbmFtZV0ubWVyZ2VfZGVmYXVsdHMoKTtcbiAgICAvLyByZXR1cm4gcHJvbWlzZSBpZiBhc3luY1xuICAgIGlmIChlbnZbdGhpcy5jb2xsZWN0aW9uX25hbWVdLmxvYWQgaW5zdGFuY2VvZiBBc3luY0Z1bmN0aW9uKSByZXR1cm4gZW52W3RoaXMuY29sbGVjdGlvbl9uYW1lXS5sb2FkKCkudGhlbigoKSA9PiBlbnZbdGhpcy5jb2xsZWN0aW9uX25hbWVdKTtcbiAgICBlbHNlIGVudlt0aGlzLmNvbGxlY3Rpb25fbmFtZV0ubG9hZCgpO1xuICAgIHJldHVybiBlbnZbdGhpcy5jb2xsZWN0aW9uX25hbWVdO1xuICB9XG4gIC8qKlxuICAgKiBNZXJnZXMgZGVmYXVsdCBjb25maWd1cmF0aW9ucyBmcm9tIGFsbCBjbGFzc2VzIGluIHRoZSBpbmhlcml0YW5jZSBjaGFpbi5cbiAgICovXG4gIG1lcmdlX2RlZmF1bHRzKCkge1xuICAgIGxldCBjdXJyZW50X2NsYXNzID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICB3aGlsZSAoY3VycmVudF9jbGFzcykgeyAvLyBtZXJnZSBjb2xsZWN0aW9uIGNvbmZpZyBpbnRvIGl0ZW0gY29uZmlnXG4gICAgICBjb25zdCBjb2xfY29uZiA9IHRoaXMuY29uZmlnPy5jb2xsZWN0aW9ucz8uW2N1cnJlbnRfY2xhc3MuY29sbGVjdGlvbl9uYW1lXTtcbiAgICAgIE9iamVjdC5lbnRyaWVzKCh0eXBlb2YgY29sX2NvbmYgPT09ICdvYmplY3QnKSA/IGNvbF9jb25mIDoge30pXG4gICAgICAgIC5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHRoaXNba2V5XSA9IHZhbHVlKVxuICAgICAgO1xuICAgICAgY3VycmVudF9jbGFzcyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihjdXJyZW50X2NsYXNzKTtcbiAgICB9XG4gICAgLy8gY29uc29sZS5sb2coT2JqZWN0LmtleXModGhpcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNhdmVzIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgKi9cbiAgc2F2ZSgpIHsgdGhpcy5MVE0uc2F2ZSgpOyB9XG5cbiAgLyoqXG4gICAqIExvYWRzIHRoZSBjb2xsZWN0aW9uIHN0YXRlLlxuICAgKi9cbiAgbG9hZCgpIHsgdGhpcy5MVE0ubG9hZCgpOyB9XG5cbiAgLyoqXG4gICAqIFJldml2ZXMgaXRlbXMgZnJvbSBhIHNlcmlhbGl6ZWQgc3RhdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IG9mIHRoZSBpdGVtLlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHNlcmlhbGl6ZWQgaXRlbSB2YWx1ZS5cbiAgICogQHJldHVybnMge0NvbGxlY3Rpb25JdGVtfCp9IFRoZSByZXZpdmVkIGl0ZW0gb3IgdGhlIG9yaWdpbmFsIHZhbHVlIGlmIG5vdCBhbiBvYmplY3QuXG4gICAqL1xuICByZXZpdmVyKGtleSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCB2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuIHZhbHVlOyAvLyBza2lwIG5vbi1vYmplY3RzLCBxdWljayByZXR1cm5cbiAgICBpZiAodmFsdWUuY2xhc3NfbmFtZSkgcmV0dXJuIG5ldyAodGhpcy5lbnYuaXRlbV90eXBlc1t2YWx1ZS5jbGFzc19uYW1lXSkodGhpcy5lbnYsIHZhbHVlKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIHRoaXMuaXRlbV90eXBlKSByZXR1cm4gdmFsdWUuZGF0YTtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBDb2xsZWN0aW9uSXRlbSkgcmV0dXJuIHZhbHVlLnJlZjtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBvciB1cGRhdGVzIGFuIGl0ZW0gaW4gdGhlIGNvbGxlY3Rpb24gYmFzZWQgb24gdGhlIHByb3ZpZGVkIGRhdGEuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgdG8gY3JlYXRlIG9yIHVwZGF0ZSBhbiBpdGVtLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDb2xsZWN0aW9uSXRlbT58Q29sbGVjdGlvbkl0ZW19IFRoZSBuZXdseSBjcmVhdGVkIG9yIHVwZGF0ZWQgaXRlbS5cbiAgICovXG4gIGNyZWF0ZV9vcl91cGRhdGUoZGF0YSA9IHt9KSB7XG4gICAgY29uc3QgZXhpc3RpbmcgPSB0aGlzLmZpbmRfYnkoZGF0YSk7XG4gICAgY29uc3QgaXRlbSA9IGV4aXN0aW5nID8gZXhpc3RpbmcgOiBuZXcgdGhpcy5pdGVtX3R5cGUodGhpcy5lbnYpO1xuICAgIGl0ZW0uaXNfbmV3ID0gISEhZXhpc3Rpbmc7XG4gICAgY29uc3QgY2hhbmdlZCA9IGl0ZW0udXBkYXRlX2RhdGEoZGF0YSk7IC8vIGhhbmRsZXMgdGhpcy5kYXRhXG4gICAgaWYgKGV4aXN0aW5nICYmICFjaGFuZ2VkKSByZXR1cm4gZXhpc3Rpbmc7IC8vIGlmIGV4aXN0aW5nIGl0ZW0gYW5kIG5vIGNoYW5nZXMsIHJldHVybiBleGlzdGluZyBpdGVtIChubyBuZWVkIHRvIHNhdmUpXG4gICAgaWYgKGl0ZW0udmFsaWRhdGVfc2F2ZSgpKSB0aGlzLnNldChpdGVtKTsgLy8gbWFrZSBpdCBhdmFpbGFibGUgaW4gY29sbGVjdGlvbiAoaWYgdmFsaWQpXG5cbiAgICAvLyBkeW5hbWljYWxseSBoYW5kbGUgYXN5bmMgaW5pdCBmdW5jdGlvbnNcbiAgICBpZiAoaXRlbS5pbml0IGluc3RhbmNlb2YgQXN5bmNGdW5jdGlvbikgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHsgaXRlbS5pbml0KGRhdGEpLnRoZW4oKCkgPT4gcmVzb2x2ZShpdGVtKSk7IH0pO1xuICAgIGl0ZW0uaW5pdChkYXRhKTsgLy8gaGFuZGxlcyBmdW5jdGlvbnMgdGhhdCBpbnZvbHZlIG90aGVyIGl0ZW1zXG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cblxuICAvKipcbiAgICogRmluZHMgYW4gaXRlbSBpbiB0aGUgY29sbGVjdGlvbiB0aGF0IG1hdGNoZXMgdGhlIGdpdmVuIGRhdGEuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gVGhlIGNyaXRlcmlhIHVzZWQgdG8gZmluZCB0aGUgaXRlbS5cbiAgICogQHJldHVybnMge0NvbGxlY3Rpb25JdGVtfG51bGx9IFRoZSBmb3VuZCBpdGVtIG9yIG51bGwgaWYgbm90IGZvdW5kLlxuICAgKi9cbiAgZmluZF9ieShkYXRhKSB7XG4gICAgaWYoZGF0YS5rZXkpIHJldHVybiB0aGlzLmdldChkYXRhLmtleSk7XG4gICAgY29uc3QgdGVtcCA9IG5ldyB0aGlzLml0ZW1fdHlwZSh0aGlzLmVudik7XG4gICAgY29uc3QgdGVtcF9kYXRhID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkYXRhLCB0ZW1wLnVwZGF0ZV9kYXRhX3JlcGxhY2VyKSk7XG4gICAgZGVlcF9tZXJnZSh0ZW1wLmRhdGEsIHRlbXBfZGF0YSk7IC8vIGRlZXAgbWVyZ2UgZGF0YVxuICAgIHJldHVybiB0ZW1wLmtleSA/IHRoaXMuZ2V0KHRlbXAua2V5KSA6IG51bGw7XG4gIH1cbiAgLy8gUkVBRFxuICAvKipcbiAgICogRmlsdGVycyB0aGUgaXRlbXMgaW4gdGhlIGNvbGxlY3Rpb24gYmFzZWQgb24gdGhlIHByb3ZpZGVkIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gVGhlIG9wdGlvbnMgdXNlZCB0byBmaWx0ZXIgdGhlIGl0ZW1zLlxuICAgKiBAcmV0dXJuIHtDb2xsZWN0aW9uSXRlbVtdfSBUaGUgZmlsdGVyZWQgaXRlbXMuXG4gICAqL1xuICBmaWx0ZXIob3B0cykgeyByZXR1cm4gT2JqZWN0LmVudHJpZXModGhpcy5pdGVtcykuZmlsdGVyKChba2V5LCBpdGVtXSkgPT4gaXRlbS5maWx0ZXIob3B0cykpLm1hcCgoW2tleSwgaXRlbV0pID0+IGl0ZW0pOyB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgaXRlbXMgZnJvbSB0aGUgY29sbGVjdGlvbiBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgc3RyYXRlZ3kgYW5kIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb25bXX0gc3RyYXRlZ3kgLSBUaGUgc3RyYXRlZ3kgdXNlZCB0byByZXRyaWV2ZSB0aGUgaXRlbXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gVGhlIG9wdGlvbnMgdXNlZCB0byByZXRyaWV2ZSB0aGUgaXRlbXMuXG4gICAqIEByZXR1cm4ge0NvbGxlY3Rpb25JdGVtW119IFRoZSByZXRyaWV2ZWQgaXRlbXMuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBUaHJvd3MgYW4gZXJyb3IgaWYgYW55IGZ1bmN0aW9uIGluIHRoZSBzdHJhdGVneSBhcnJheSBpcyBub3QgYWN0dWFsbHkgYSBmdW5jdGlvbiBvciBpZiBhbiBhc3luYyBmdW5jdGlvbiB0aHJvd3MgYW4gZXJyb3IuXG4gICAqL1xuICBhc3luYyByZXRyaWV2ZShzdHJhdGVneT1bXSwgb3B0cz17fSkgeyByZXR1cm4gYXdhaXQgc2VxdWVudGlhbF9hc3luY19wcm9jZXNzb3IoZnVuY3MsIHRoaXMuZmlsdGVyKG9wdHMpLCBvcHRzKTsgfVxuICAvKipcbiAgICogUmV0cmlldmVzIGEgc2luZ2xlIGl0ZW0gZnJvbSB0aGUgY29sbGVjdGlvbiBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgc3RyYXRlZ3kgYW5kIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSBUaGUga2V5IG9mIHRoZSBpdGVtIHRvIHJldHJpZXZlLlxuICAgKiBAcmV0dXJuIHtDb2xsZWN0aW9uSXRlbX0gVGhlIHJldHJpZXZlZCBpdGVtLlxuICAgKi9cbiAgZ2V0KGtleSkgeyByZXR1cm4gdGhpcy5pdGVtc1trZXldOyB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgbXVsdGlwbGUgaXRlbXMgZnJvbSB0aGUgY29sbGVjdGlvbiBiYXNlZCBvbiB0aGUgcHJvdmlkZWQga2V5cy5cbiAgICogQHBhcmFtIHtTdHJpbmdbXX0ga2V5cyAtIFRoZSBrZXlzIG9mIHRoZSBpdGVtcyB0byByZXRyaWV2ZS5cbiAgICogQHJldHVybiB7Q29sbGVjdGlvbkl0ZW1bXX0gVGhlIHJldHJpZXZlZCBpdGVtcy5cbiAgICovXG4gIGdldF9tYW55KGtleXMgPSBbXSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGtleXMpKSByZXR1cm4ga2V5cy5tYXAoKGtleSkgPT4gdGhpcy5nZXQoa2V5KSk7XG4gICAgY29uc29sZS5lcnJvcihcImdldF9tYW55IGNhbGxlZCB3aXRoIG5vbi1hcnJheSBrZXlzOiBcIiwga2V5cyk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhIHJhbmRvbSBpdGVtIGZyb20gdGhlIGNvbGxlY3Rpb24gYmFzZWQgb24gdGhlIHByb3ZpZGVkIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gVGhlIG9wdGlvbnMgdXNlZCB0byByZXRyaWV2ZSB0aGUgaXRlbS5cbiAgICogQHJldHVybiB7Q29sbGVjdGlvbkl0ZW19IFRoZSByZXRyaWV2ZWQgaXRlbS5cbiAgICovXG4gIGdldF9yYW5kKG9wdHMgPSBudWxsKSB7XG4gICAgaWYgKG9wdHMpIHtcbiAgICAgIGNvbnN0IGZpbHRlcmVkID0gdGhpcy5maWx0ZXIob3B0cyk7XG4gICAgICByZXR1cm4gZmlsdGVyZWRbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogZmlsdGVyZWQubGVuZ3RoKV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLml0ZW1zW3RoaXMua2V5c1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB0aGlzLmtleXMubGVuZ3RoKV1dO1xuICB9XG4gIC8vIFVQREFURVxuICAvKipcbiAgICogQWRkcyBvciB1cGRhdGVzIGFuIGl0ZW0gaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAqIEBwYXJhbSB7Q29sbGVjdGlvbkl0ZW19IGl0ZW0gLSBUaGUgaXRlbSB0byBhZGQgb3IgdXBkYXRlLlxuICAgKi9cbiAgc2V0KGl0ZW0pIHtcbiAgICBpZiAoIWl0ZW0ua2V5KSB0aHJvdyBuZXcgRXJyb3IoXCJJdGVtIG11c3QgaGF2ZSBrZXkgcHJvcGVydHlcIik7XG4gICAgdGhpcy5pdGVtc1tpdGVtLmtleV0gPSBpdGVtO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIG11bHRpcGxlIGl0ZW1zIGluIHRoZSBjb2xsZWN0aW9uIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBrZXlzIGFuZCBkYXRhLlxuICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBrZXlzIC0gVGhlIGtleXMgb2YgdGhlIGl0ZW1zIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSB0byB1cGRhdGUgdGhlIGl0ZW1zIHdpdGguXG4gICAqL1xuICB1cGRhdGVfbWFueShrZXlzID0gW10sIGRhdGEgPSB7fSkgeyB0aGlzLmdldF9tYW55KGtleXMpLmZvckVhY2goKGl0ZW0pID0+IGl0ZW0udXBkYXRlX2RhdGEoZGF0YSkpOyB9XG4gIC8vIERFU1RST1lcbiAgLyoqXG4gICAqIENsZWFycyBhbGwgaXRlbXMgZnJvbSB0aGUgY29sbGVjdGlvbi5cbiAgICovXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuaXRlbXMgPSB7fTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyBhbiBpdGVtIGZyb20gdGhlIGNvbGxlY3Rpb24gYmFzZWQgb24gaXRzIGtleS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleSAtIFRoZSBrZXkgb2YgdGhlIGl0ZW0gdG8gZGVsZXRlLlxuICAgKi9cbiAgZGVsZXRlKGtleSkge1xuICAgIGRlbGV0ZSB0aGlzLml0ZW1zW2tleV07XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgbXVsdGlwbGUgaXRlbXMgZnJvbSB0aGUgY29sbGVjdGlvbiBiYXNlZCBvbiB0aGVpciBrZXlzLlxuICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBrZXlzIC0gVGhlIGtleXMgb2YgdGhlIGl0ZW1zIHRvIGRlbGV0ZS5cbiAgICovXG4gIGRlbGV0ZV9tYW55KGtleXMgPSBbXSkge1xuICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiBkZWxldGUgdGhpcy5pdGVtc1trZXldKTtcbiAgfVxuICAvLyBDT05WRU5JRU5DRSBNRVRIT0RTIChuYW1lc3BhY2UgZ2V0dGVycylcbiAgLyoqXG4gICAqIEdldHMgdGhlIGNvbGxlY3Rpb24gbmFtZSBkZXJpdmVkIGZyb20gdGhlIGNsYXNzIG5hbWUuXG4gICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGNvbGxlY3Rpb24gbmFtZS5cbiAgICovXG4gIHN0YXRpYyBnZXQgY29sbGVjdGlvbl9uYW1lKCkgeyByZXR1cm4gdGhpcy5uYW1lLnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csIFwiJDFfJDJcIikudG9Mb3dlckNhc2UoKTsgfVxuICAvKipcbiAgICogR2V0cyBvciBzZXRzIHRoZSBjb2xsZWN0aW9uIG5hbWUuIElmIGEgbmFtZSBpcyBzZXQsIGl0IG92ZXJyaWRlcyB0aGUgZGVmYXVsdCBuYW1lLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIFRoZSBuZXcgY29sbGVjdGlvbiBuYW1lLlxuICAgKi9cbiAgZ2V0IGNvbGxlY3Rpb25fbmFtZSgpIHsgcmV0dXJuICh0aGlzLl9jb2xsZWN0aW9uX25hbWUpID8gdGhpcy5fY29sbGVjdGlvbl9uYW1lIDogdGhpcy5jb25zdHJ1Y3Rvci5jb2xsZWN0aW9uX25hbWU7IH1cbiAgc2V0IGNvbGxlY3Rpb25fbmFtZShuYW1lKSB7IHRoaXMuX2NvbGxlY3Rpb25fbmFtZSA9IG5hbWU7IH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIGtleXMgb2YgdGhlIGl0ZW1zIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgKiBAcmV0dXJuIHtTdHJpbmdbXX0gVGhlIGtleXMgb2YgdGhlIGl0ZW1zLlxuICAgKi9cbiAgZ2V0IGtleXMoKSB7IHJldHVybiBPYmplY3Qua2V5cyh0aGlzLml0ZW1zKTsgfVxuICAvKipcbiAgICogR2V0cyB0aGUgY2xhc3MgbmFtZSBvZiB0aGUgaXRlbSB0eXBlIHRoZSBjb2xsZWN0aW9uIG1hbmFnZXMuXG4gICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGl0ZW0gY2xhc3MgbmFtZS5cbiAgICovXG4gIGdldCBpdGVtX2NsYXNzX25hbWUoKSB7IHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUuc2xpY2UoMCwgLTEpLnJlcGxhY2UoLyhpZSkkL2csICd5Jyk7IH0gLy8gcmVtb3ZlICdzJyBmcm9tIGVuZCBvZiBuYW1lICYgaWYgbmFtZSBlbmRzIGluICdpZScsIHJlcGxhY2Ugd2l0aCAneSdcbiAgLyoqXG4gICAqIEdldHMgdGhlIG5hbWUgb2YgdGhlIGl0ZW0gdHlwZSB0aGUgY29sbGVjdGlvbiBtYW5hZ2VzLCBkZXJpdmVkIGZyb20gdGhlIGNsYXNzIG5hbWUuXG4gICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGl0ZW0gbmFtZS5cbiAgICovXG4gIGdldCBpdGVtX25hbWUoKSB7IHJldHVybiB0aGlzLml0ZW1fY2xhc3NfbmFtZS5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCBcIiQxXyQyXCIpLnRvTG93ZXJDYXNlKCk7IH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBpdGVtIHR5cGUgdGhlIGNvbGxlY3Rpb24gbWFuYWdlcy5cbiAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBpdGVtIHR5cGUgY29uc3RydWN0b3IuXG4gICAqL1xuICBnZXQgaXRlbV90eXBlKCkgeyByZXR1cm4gdGhpcy5lbnYuaXRlbV90eXBlc1t0aGlzLml0ZW1fY2xhc3NfbmFtZV07IH1cbn1cbmV4cG9ydHMuQ29sbGVjdGlvbiA9IENvbGxlY3Rpb247XG5cbi8qKlxuICogU2VxdWVudGlhbGx5IGV4ZWN1dGVzIGFuIGFycmF5IG9mIGFzeW5jaHJvbm91cyBmdW5jdGlvbnMsIHBhc3NpbmcgdGhlIHJlc3VsdCBvZiBlYWNoIGZ1bmN0aW9uXG4gKiBhcyB0aGUgaW5wdXQgdG8gdGhlIG5leHQsIGFsb25nIHdpdGggYW4gb3B0aW9uYWwgb3B0aW9ucyBvYmplY3QuXG4gKiBcbiAqIEBwYXJhbSB7RnVuY3Rpb25bXX0gZnVuY3MgLSBBbiBhcnJheSBvZiBmdW5jdGlvbnMgdG8gZXhlY3V0ZSBzZXF1ZW50aWFsbHkgKG1heSBiZSBhc3luYyBmdW5jdGlvbnMpLlxuICogQHBhcmFtIHsqfSBpbml0aWFsX3ZhbHVlIC0gVGhlIGluaXRpYWwgdmFsdWUgdG8gcGFzcyB0byB0aGUgZmlyc3QgZnVuY3Rpb24gaW4gdGhlIGFycmF5LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBPcHRpb25hbCBwYXJhbWV0ZXJzIHRvIHBhc3MgdG8gZWFjaCBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHsqfSBUaGUgZmluYWwgdmFsdWUgYWZ0ZXIgYWxsIGZ1bmN0aW9ucyBoYXZlIGJlZW4gZXhlY3V0ZWQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gVGhyb3dzIGFuIGVycm9yIGlmIGFueSBmdW5jdGlvbiBpbiB0aGUgYXJyYXkgaXMgbm90IGFjdHVhbGx5IGEgZnVuY3Rpb24gb3IgaWYgYW4gYXN5bmMgZnVuY3Rpb24gdGhyb3dzIGFuIGVycm9yLlxuICovXG5hc3luYyBmdW5jdGlvbiBzZXF1ZW50aWFsX2FzeW5jX3Byb2Nlc3NvcihmdW5jcywgaW5pdGlhbF92YWx1ZSwgb3B0cyA9IHt9KSB7XG4gIGxldCB2YWx1ZSA9IGluaXRpYWxfdmFsdWU7XG4gIGZvciAoY29uc3QgZnVuYyBvZiBmdW5jcykge1xuICAgIC8vIEVuc3VyZSBlYWNoIGVsZW1lbnQgaXMgYSBmdW5jdGlvbiBiZWZvcmUgYXR0ZW1wdGluZyB0byBjYWxsIGl0XG4gICAgaWYgKHR5cGVvZiBmdW5jICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbGwgZWxlbWVudHMgaW4gYXN5bmNfZnVuY3Rpb25zIGFycmF5IG11c3QgYmUgZnVuY3Rpb25zJyk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB2YWx1ZSA9IGF3YWl0IGZ1bmModmFsdWUsIG9wdHMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBjb25zb2xlLmVycm9yKFwiRXJyb3IgZW5jb3VudGVyZWQgZHVyaW5nIHNlcXVlbnRpYWwgcHJvY2Vzc2luZzpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7IC8vIFJldGhyb3cgdG8gaGFsdCBleGVjdXRpb24sIG9yIGhhbmRsZSBkaWZmZXJlbnRseSBpZiBjb250aW51YXRpb24gaXMgZGVzaXJlZFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydHMuc2VxdWVudGlhbF9hc3luY19wcm9jZXNzb3IgPSBzZXF1ZW50aWFsX2FzeW5jX3Byb2Nlc3NvcjtcbiIsICIvKipcbiAqIFJlcHJlc2VudHMgYSBnZW5lcmljIGFkYXB0ZXIgY2xhc3MgdGhhdCBpbml0aWFsaXplcyB3aXRoIGEgbWFpbiBjb250ZXh0IGFuZCBjb3BpZXMgaXRzIGNvbmZpZ3VyYXRpb24uXG4gKi9cbmNsYXNzIEFkYXB0ZXIge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhbiBpbnN0YW5jZSBvZiBBZGFwdGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbWFpbiAtIFRoZSBtYWluIGNvbnRleHQgb2JqZWN0IHdoaWNoIHNob3VsZCBjb250YWluIGEgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihtYWluKSB7XG4gICAgLyoqXG4gICAgICogVGhlIG1haW4gY29udGV4dCBvYmplY3QgZnJvbSB3aGljaCBjb25maWd1cmF0aW9uIGlzIGRlcml2ZWQuXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLm1haW4gPSBtYWluO1xuXG4gICAgLyoqXG4gICAgICogQ29waWVzIHByb3BlcnRpZXMgZnJvbSB0aGUgbWFpbiBvYmplY3QncyBjb25maWcgcHJvcGVydHkgdG8gdGhpcyBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIG1haW4uY29uZmlnKTsgLy8gQ29weSBjb25maWcgdG8gdGhpc1xuICB9XG59XG5cbi8vIEV4cG9ydCB0aGUgQWRhcHRlciBjbGFzcyB0byBiZSBhdmFpbGFibGUgZm9yIG90aGVyIG1vZHVsZXMuXG5leHBvcnRzLkFkYXB0ZXIgPSBBZGFwdGVyO1xuIiwgImNvbnN0IHsgQWRhcHRlciB9ID0gcmVxdWlyZShcIi4vYWRhcHRlclwiKTtcblxuLyoqXG4gKiBBcGlBZGFwdGVyIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBhbGwgQVBJIGFkYXB0ZXJzLlxuICogSXQgcHJvdmlkZXMgdGhlIGJhc2ljIGZ1bmN0aW9uYWxpdHkgZm9yIG1ha2luZyByZXF1ZXN0cyB0byB0aGUgQVBJLlxuICogSW1wbGVtZW50cyBPcGVuQUkgQVBJLlxuICogQGV4dGVuZHMgQWRhcHRlclxuICogUmVxdWlyZXMgbW9kZWxfY29uZmlnLnJlcXVlc3RfYWRhcHRlciB0byBiZSBzZXQuXG4gKi9cbmNsYXNzIEFwaUFkYXB0ZXIgZXh0ZW5kcyBBZGFwdGVyIHtcbiAgLyoqXG4gICAqIENvdW50cyB0aGUgbnVtYmVyIG9mIHRva2VucyBpbiB0aGUgaW5wdXQuXG4gICAqIE92ZXJyaWRlIGluIGNoaWxkIGNsYXNzZXMgdG8gaW1wbGVtZW50IHRoaXJkLXBhcnR5IHRva2VuIGNvdW50ZXJzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgLSBUaGUgaW5wdXQgdG8gY291bnQgdG9rZW5zIGZvci5cbiAgICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyPn0gVGhlIG51bWJlciBvZiB0b2tlbnMgaW4gdGhlIGlucHV0LlxuICAgKi9cbiAgYXN5bmMgY291bnRfdG9rZW5zKGlucHV0KSB7IHJldHVybiB0aGlzLmVzdGltYXRlX3Rva2VucyhpbnB1dCk7IH1cblxuICAvKipcbiAgICogRXN0aW1hdGVzIHRoZSBudW1iZXIgb2YgdG9rZW5zIGluIHRoZSBpbnB1dC5cbiAgICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBpbnB1dCAtIFRoZSBpbnB1dCB0byBlc3RpbWF0ZSB0b2tlbnMgZm9yLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgZXN0aW1hdGVkIG51bWJlciBvZiB0b2tlbnMuXG4gICAqL1xuICBlc3RpbWF0ZV90b2tlbnMoaW5wdXQpIHtcbiAgICBpZih0eXBlb2YgdGhpcy5hZGFwdGVyPy5lc3RpbWF0ZV90b2tlbnMgPT09ICdmdW5jdGlvbicpIHJldHVybiB0aGlzLmFkYXB0ZXIuZXN0aW1hdGVfdG9rZW5zKGlucHV0KTtcbiAgICBpZih0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnKSBpbnB1dCA9IEpTT04uc3RyaW5naWZ5KGlucHV0KTtcbiAgICByZXR1cm4gaW5wdXQubGVuZ3RoIC8gMy43O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG1heGltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgYWxsb3dlZCBpbiB0aGUgaW5wdXQgYmFzZWQgb24gbWF4X3Rva2Vucy5cbiAgICogQHJldHVybnMge251bWJlcn0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMuXG4gICAqL1xuICBnZXQgbWF4X2NoYXJzKCkgeyByZXR1cm4gKHRoaXMubWF4X3Rva2VucyAqIDQpIC0gMTAwOyB9XG5cbiAgLyoqXG4gICAqIEVtYmVkcyB0aGUgaW5wdXQgYW5kIHJldHVybnMgdGhlIGZpcnN0IGVtYmVkZGluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0IC0gVGhlIGlucHV0IHRvIGVtYmVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSBUaGUgZmlyc3QgZW1iZWRkaW5nIG9iamVjdC5cbiAgICovXG4gIGFzeW5jIGVtYmVkKGlucHV0KSB7XG4gICAgaWYoIWlucHV0Py5sZW5ndGgpIHJldHVybiBjb25zb2xlLmxvZyhcImlucHV0IGlzIGVtcHR5XCIpOyAvLyBjaGVjayBpZiBpbnB1dCBpcyBlbXB0eVxuICAgIGlucHV0ID0gdGhpcy5wcmVwYXJlX2VtYmVkX2lucHV0KGlucHV0KTtcbiAgICBjb25zdCBlbWJlZGRpbmdzID0gYXdhaXQgdGhpcy5yZXF1ZXN0X2VtYmVkZGluZyhpbnB1dCk7XG4gICAgcmV0dXJuIGVtYmVkZGluZ3NbMF07XG4gIH1cblxuICAvKipcbiAgICogRW1iZWRzIGEgYmF0Y2ggb2YgaXRlbXMgYW5kIHJldHVybnMgdGhlaXIgZW1iZWRkaW5ncy5cbiAgICogQHBhcmFtIHtBcnJheX0gaXRlbXMgLSBUaGUgaXRlbXMgdG8gZW1iZWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5Pn0gVGhlIGVtYmVkZGluZ3Mgb2YgdGhlIGl0ZW1zLlxuICAgKi9cbiAgYXN5bmMgZW1iZWRfYmF0Y2goaXRlbXMpIHtcbiAgICBpdGVtcyA9IGl0ZW1zLmZpbHRlcihpdGVtID0+IGl0ZW0uZW1iZWRfaW5wdXQ/Lmxlbmd0aCA+IDApOyAvLyByZW1vdmUgaXRlbXMgd2l0aCBlbXB0eSBlbWJlZF9pbnB1dCAoY2F1c2VzIDQwMCBlcnJvcilcbiAgICBpZihpdGVtcy5sZW5ndGggPT09IDApIHJldHVybiBjb25zb2xlLmxvZyhcImVtcHR5IGJhdGNoIChvciBhbGwgaXRlbXMgaGF2ZSBlbXB0eSBlbWJlZF9pbnB1dClcIik7XG4gICAgY29uc3QgZW1iZWRfaW5wdXRzID0gdGhpcy5wcmVwYXJlX2JhdGNoX2lucHV0KGl0ZW1zKTtcbiAgICBsZXQgZW1iZWRkaW5ncyA9IGF3YWl0IHRoaXMucmVxdWVzdF9lbWJlZGRpbmcoZW1iZWRfaW5wdXRzKTtcbiAgICBpZighZW1iZWRkaW5ncykgcmV0dXJuIGNvbnNvbGUuZXJyb3IoaXRlbXMpO1xuICAgIGVtYmVkZGluZ3MgPSBlbWJlZGRpbmdzLm1hcCgoZW1iZWRkaW5nLCBpKSA9PiB0aGlzLnBhcnNlX2VtYmVkZGluZ19vdXRwdXQoZW1iZWRfaW5wdXRzLCBlbWJlZGRpbmcsIGkpKTtcbiAgICByZXR1cm4gaXRlbXMubWFwKChpdGVtLCBpKSA9PiB7XG4gICAgICBpdGVtLnZlYyA9IGVtYmVkZGluZ3NbaV0udmVjO1xuICAgICAgaXRlbS50b2tlbnMgPSBlbWJlZGRpbmdzW2ldLnRva2VucztcbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyB0aGUgZW1iZWRkaW5nIG91dHB1dCBmb3IgZWFjaCBpbnB1dC5cbiAgICogQHBhcmFtIHtBcnJheX0gZW1iZWRfaW5wdXRzIC0gVGhlIGlucHV0cyB1c2VkIGZvciBlbWJlZGRpbmcuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBlbWJlZGRpbmcgLSBUaGUgZW1iZWRkaW5nIHJlc3VsdC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGkgLSBUaGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgZW1iZWRkaW5nLlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgcGFyc2VkIGVtYmVkZGluZyBvdXRwdXQuXG4gICAqL1xuICBwYXJzZV9lbWJlZGRpbmdfb3V0cHV0KGVtYmVkX2lucHV0cywgZW1iZWRkaW5nLCBpKSB7XG4gICAgY29uc3QgdG90YWxfY2hhcnMgPSB0aGlzLmNvdW50X2VtYmVkX2lucHV0X2NoYXJzKGVtYmVkX2lucHV0cyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZlYzogZW1iZWRkaW5nLnZlYyxcbiAgICAgIHRva2VuczogTWF0aC5yb3VuZCgoZW1iZWRfaW5wdXRzW2ldLmxlbmd0aCAvIHRvdGFsX2NoYXJzKSAqIGVtYmVkZGluZy50b2tlbnMpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb3VudHMgdGhlIHRvdGFsIG51bWJlciBvZiBjaGFyYWN0ZXJzIGluIGFsbCBlbWJlZCBpbnB1dHMuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGVtYmVkX2lucHV0cyAtIFRoZSBpbnB1dHMgdXNlZCBmb3IgZW1iZWRkaW5nLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgdG90YWwgbnVtYmVyIG9mIGNoYXJhY3RlcnMuXG4gICAqL1xuICBjb3VudF9lbWJlZF9pbnB1dF9jaGFycyhlbWJlZF9pbnB1dHMpIHsgcmV0dXJuIGVtYmVkX2lucHV0cy5yZWR1Y2UoKGFjYywgY3VycikgPT4gYWNjICsgY3Vyci5sZW5ndGgsIDApOyB9XG5cbiAgLyoqXG4gICAqIFByZXBhcmVzIHRoZSBiYXRjaCBpbnB1dCBieSBwcm9jZXNzaW5nIGVhY2ggaXRlbSdzIGVtYmVkIGlucHV0LlxuICAgKiBAcGFyYW0ge0FycmF5fSBpdGVtcyAtIFRoZSBpdGVtcyB0byBwcmVwYXJlLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBwcmVwYXJlZCBiYXRjaCBpbnB1dC5cbiAgICovXG4gIHByZXBhcmVfYmF0Y2hfaW5wdXQoaXRlbXMpIHsgcmV0dXJuIGl0ZW1zLm1hcChpdGVtID0+IHRoaXMucHJlcGFyZV9lbWJlZF9pbnB1dChpdGVtLmVtYmVkX2lucHV0KSk7IH1cblxuICAvKipcbiAgICogUHJlcGFyZXMgdGhlIGVtYmVkIGlucHV0IGJ5IHRydW5jYXRpbmcgaXQgaWYgbmVjZXNzYXJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZW1iZWRfaW5wdXQgLSBUaGUgaW5wdXQgdG8gcHJlcGFyZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHByZXBhcmVkIGVtYmVkIGlucHV0LlxuICAgKi9cbiAgcHJlcGFyZV9lbWJlZF9pbnB1dChlbWJlZF9pbnB1dCkgeyByZXR1cm4gKGVtYmVkX2lucHV0Lmxlbmd0aCA+IHRoaXMubWF4X2NoYXJzKSA/IGVtYmVkX2lucHV0LnNsaWNlKDAsIHRoaXMubWF4X2NoYXJzKSA6IGVtYmVkX2lucHV0OyB9XG5cbiAgLyoqXG4gICAqIFByZXBhcmVzIHRoZSByZXF1ZXN0IGJvZHkgZm9yIGVtYmVkZGluZy5cbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gZW1iZWRfaW5wdXQgLSBUaGUgaW5wdXQgdG8gZW1iZWQuXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSBwcmVwYXJlZCByZXF1ZXN0IGJvZHkuXG4gICAqL1xuICBwcmVwYXJlX3JlcXVlc3RfYm9keShlbWJlZF9pbnB1dCl7XG4gICAgY29uc3QgYm9keSA9IHtcbiAgICAgIG1vZGVsOiB0aGlzLm1vZGVsX25hbWUsXG4gICAgICBpbnB1dDogZW1iZWRfaW5wdXQsXG4gICAgfTtcbiAgICBpZiAodGhpcy5tb2RlbF9uYW1lLnN0YXJ0c1dpdGgoXCJ0ZXh0LWVtYmVkZGluZy0zXCIpKSB7XG4gICAgICBib2R5LmRpbWVuc2lvbnMgPSB0aGlzLmRpbXM7XG4gICAgfVxuICAgIHJldHVybiBib2R5O1xuICB9XG5cbiAgLyoqXG4gICAqIFByZXBhcmVzIHRoZSByZXF1ZXN0IGhlYWRlcnMgZm9yIHRoZSBBUEkgY2FsbC5cbiAgICogQHJldHVybnMge29iamVjdH0gVGhlIHByZXBhcmVkIHJlcXVlc3QgaGVhZGVycy5cbiAgICovXG4gIHByZXBhcmVfcmVxdWVzdF9oZWFkZXJzKCkge1xuICAgIGxldCBoZWFkZXJzID0ge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICBcIkF1dGhvcml6YXRpb25cIjogYEJlYXJlciAke3RoaXMuYXBpX2tleX1gXG4gICAgfTtcbiAgICBpZiAodGhpcy5oZWFkZXJzKSBoZWFkZXJzID0geyAuLi5oZWFkZXJzLCAuLi50aGlzLmhlYWRlcnMgfTtcbiAgICByZXR1cm4gaGVhZGVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0cyB0aGUgZW1iZWRkaW5nIGZyb20gdGhlIEFQSS5cbiAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGVtYmVkX2lucHV0IC0gVGhlIGlucHV0IHRvIGVtYmVkLiBNYXkgYmUgYSBzdHJpbmcgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAgICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0W10+fSBUaGUgZW1iZWRkaW5nIG9iamVjdHMge3ZlYywgdG9rZW5zfS5cbiAgICovXG4gIGFzeW5jIHJlcXVlc3RfZW1iZWRkaW5nKGVtYmVkX2lucHV0KSB7XG4gICAgLy8gQ2hlY2sgaWYgZW1iZWRfaW5wdXQgaXMgZW1wdHlcbiAgICBpZiAoZW1iZWRfaW5wdXQubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zb2xlLmxvZyhcImVtYmVkX2lucHV0IGlzIGVtcHR5XCIpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICB1cmw6IHRoaXMuZW5kcG9pbnQsXG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkodGhpcy5wcmVwYXJlX3JlcXVlc3RfYm9keShlbWJlZF9pbnB1dCkpLFxuICAgICAgaGVhZGVyczogdGhpcy5wcmVwYXJlX3JlcXVlc3RfaGVhZGVycygpXG4gICAgfTtcbiAgICBjb25zdCByZXNwID0gYXdhaXQgdGhpcy5yZXF1ZXN0KHJlcXVlc3QpO1xuICAgIHJldHVybiB0aGlzLnBhcnNlX3Jlc3BvbnNlKHJlc3ApO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyB0aGUgcmVzcG9uc2UgZnJvbSB0aGUgQVBJLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcmVzcCAtIFRoZSByZXNwb25zZSBmcm9tIHRoZSBBUEkuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHBhcnNlZCByZXNwb25zZSBkYXRhLlxuICAgKi9cbiAgcGFyc2VfcmVzcG9uc2UocmVzcCkge1xuICAgIHJldHVybiByZXNwLmRhdGEubWFwKGl0ZW0gPT4gKHtcbiAgICAgIHZlYzogaXRlbS5lbWJlZGRpbmcsXG4gICAgICB0b2tlbnM6IHJlc3AudXNhZ2UudG90YWxfdG9rZW5zIC8gcmVzcC5kYXRhLmxlbmd0aFxuICAgIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHJlc3BvbnNlIEpTT04gaW5kaWNhdGVzIGFuIGVycm9yLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcmVzcF9qc29uIC0gVGhlIHJlc3BvbnNlIEpTT04gdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZXJlIGlzIGFuIGVycm9yLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc19lcnJvcihyZXNwX2pzb24pIHsgcmV0dXJuICFyZXNwX2pzb24uZGF0YSB8fCAhcmVzcF9qc29uLnVzYWdlOyB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgSlNPTiBmcm9tIHRoZSByZXNwb25zZS5cbiAgICogQHBhcmFtIHtSZXNwb25zZX0gcmVzcCAtIFRoZSByZXNwb25zZSBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IFRoZSByZXNwb25zZSBKU09OLlxuICAgKi9cbiAgYXN5bmMgZ2V0X3Jlc3BfanNvbihyZXNwKSB7IHJldHVybiAodHlwZW9mIHJlc3AuanNvbiA9PT0gJ2Z1bmN0aW9uJykgPyBhd2FpdCByZXNwLmpzb24oKSA6IGF3YWl0IHJlc3AuanNvbjsgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSByZXF1ZXN0LCBpbmNsdWRpbmcgcmV0cmllcyBmb3Igc3BlY2lmaWMgZXJyb3JzLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcmVxIC0gVGhlIHJlcXVlc3Qgb2JqZWN0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmV0cmllcyAtIFRoZSBjdXJyZW50IHJldHJ5IGNvdW50LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3R8bnVsbD59IFRoZSByZXNwb25zZSBKU09OIG9yIG51bGwgaWYgYW4gZXJyb3Igb2NjdXJzLlxuICAgKi9cbiAgYXN5bmMgcmVxdWVzdChyZXEsIHJldHJpZXMgPSAwKXtcbiAgICB0cnkge1xuICAgICAgcmVxLnRocm93ID0gZmFsc2U7XG4gICAgICAvLyBoYW5kbGUgZmFsbGJhY2sgdG8gZmV0Y2ggKGFsbG93cyBmb3Igb3ZlcndyaXRpbmcgaW4gY2hpbGQgY2xhc3NlcylcbiAgICAgIGNvbnN0IHJlc3AgPSB0aGlzLnJlcXVlc3RfYWRhcHRlciA/IGF3YWl0IHRoaXMucmVxdWVzdF9hZGFwdGVyKHt1cmw6IHRoaXMuZW5kcG9pbnQsIC4uLnJlcX0pIDogYXdhaXQgZmV0Y2godGhpcy5lbmRwb2ludCwgcmVxKTtcbiAgICAgIGNvbnN0IHJlc3BfanNvbiA9IGF3YWl0IHRoaXMuZ2V0X3Jlc3BfanNvbihyZXNwKTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKHJlc3BfanNvbik7XG4gICAgICBpZih0aGlzLmlzX2Vycm9yKHJlc3BfanNvbikpIHJldHVybiBhd2FpdCB0aGlzLmhhbmRsZV9yZXF1ZXN0X2VycihyZXNwX2pzb24sIHJlcSwgcmV0cmllcyk7XG4gICAgICByZXR1cm4gcmVzcF9qc29uO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5oYW5kbGVfcmVxdWVzdF9lcnIoZXJyb3IsIHJlcSwgcmV0cmllcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgZXJyb3JzIGR1cmluZyB0aGUgcmVxdWVzdCwgaW5jbHVkaW5nIHJldHJ5aW5nIHRoZSByZXF1ZXN0LlxuICAgKiBAcGFyYW0ge0Vycm9yfSBlcnJvciAtIFRoZSBlcnJvciBlbmNvdW50ZXJlZC5cbiAgICogQHBhcmFtIHtvYmplY3R9IHJlcSAtIFRoZSByZXF1ZXN0IG9iamVjdC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJldHJpZXMgLSBUaGUgY3VycmVudCByZXRyeSBjb3VudC5cbiAgICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0fG51bGw+fSBUaGUgcmVzcG9uc2UgSlNPTiBvciBudWxsIGlmIGFuIGVycm9yIHBlcnNpc3RzLlxuICAgKi9cbiAgYXN5bmMgaGFuZGxlX3JlcXVlc3RfZXJyKGVycm9yLCByZXEsIHJldHJpZXMpIHtcbiAgICAvLyBjb25zb2xlLmxvZyhyZXEpO1xuICAgIC8vIGNvbnNvbGUubG9nKGVycm9yKTtcbiAgICAvLyBwYXJzZSB7bWVzc2FnZTogXCJUaGlzIG1vZGVsJ3MgbWF4aW11bSBjb250ZXh0IGxlbmd0aCBpcyA4MTkyIHRva2VucywgaG93ZXZlciB5b3UgcmVxdWVzdGVkIDEzNzc2IHRva2VucyAoMTM3NzYgaW4geW91ciBwcm9tcHQ7IDAgZm9yIHRoZSBjb21wbGV0aW9uKS4gUGxlYXNlIHJlZHVjZSB5b3VyIHByb21wdDsgb3IgY29tcGxldGlvbiBsZW5ndGguXCJcbiAgICBlcnJvciA9IGVycm9yLmVycm9yO1xuICAgIGlmKGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKFwibWF4aW11bSBjb250ZXh0IGxlbmd0aCBpc1wiKSkge1xuICAgICAgY29uc3QgbWF4X2xlbiA9IHBhcnNlSW50KGVycm9yLm1lc3NhZ2Uuc3BsaXQoXCJsZW5ndGggaXMgXCIpWzFdLnNwbGl0KFwidG9rZW5zXCIpWzBdLnRyaW0oKSk7XG4gICAgICBjb25zdCByZXF1ZXN0ZWRfbGVuID0gcGFyc2VJbnQoZXJyb3IubWVzc2FnZS5zcGxpdChcInJlcXVlc3RlZFwiKVsxXS5zcGxpdChcInRva2Vuc1wiKVswXS50cmltKCkpO1xuICAgICAgY29uc29sZS5sb2coYG1heCBjb250ZXh0IGxlbmd0aDogJHttYXhfbGVufSwgcmVxdWVzdGVkOiAke3JlcXVlc3RlZF9sZW59YCk7XG4gICAgICBjb25zdCBib2R5ID0gSlNPTi5wYXJzZShyZXEuYm9keSk7XG4gICAgICBjb25zdCBsb25nZXN0X2xlbiA9IE1hdGgubWF4KC4uLmJvZHkuaW5wdXQubWFwKGl0ZW0gPT4gaXRlbS5sZW5ndGgpKTtcbiAgICAgIGNvbnN0IGxvbmdlc3RfaSA9IGJvZHkuaW5wdXQuZmluZEluZGV4KGkgPT4gaS5sZW5ndGggPT09IGxvbmdlc3RfbGVuKTtcbiAgICAgIC8vIHJlZHVjZSB0aGUgbG9uZ2VzdCBpbnB1dCBieSB0aGUgc2FtZSByYXRpbyBhcyB0aGUgcmVxdWVzdGVkIGxlbmd0aCB0byB0aGUgbWF4IGxlbmd0aCAoMTAgcmVxdWVzdGVkLCA4IG1heCwgcmVkdWNlIGxvbmdlc3QgYnkgMjAlIHRvIDgpXG4gICAgICBjb25zdCByZWR1Y2VfZmFjdG9yID0gKHJlcXVlc3RlZF9sZW4gLSBtYXhfbGVuKSAvIHJlcXVlc3RlZF9sZW47XG4gICAgICAvLyBjb25zb2xlLmxvZyhgcmVkdWNlIGZhY3RvcjogJHtyZWR1Y2VfZmFjdG9yfWApO1xuICAgICAgYm9keS5pbnB1dFtsb25nZXN0X2ldID0gYm9keS5pbnB1dFtsb25nZXN0X2ldLnNsaWNlKDAsIE1hdGguZmxvb3IocmVkdWNlX2ZhY3RvciAqIGxvbmdlc3RfbGVuKSAtICg1MDAgKiByZXRyaWVzKSk7XG4gICAgICBjb25zb2xlLmxvZyhgdHJ1bmNhdGVkIGlucHV0OiAke2JvZHkuaW5wdXRbbG9uZ2VzdF9pXS5sZW5ndGh9YCk7XG4gICAgICByZXEuYm9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHkpO1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucmVxdWVzdChyZXEsIHJldHJpZXMgKyAxKTtcbiAgICB9XG4gICAgaWYgKGVycm9yLnN0YXR1cyA9PT0gNDI5ICYmIHJldHJpZXMgPCAzKSB7XG4gICAgICBjb25zdCBiYWNrb2ZmID0gTWF0aC5wb3cocmV0cmllcyArIDEsIDIpOyAvLyBleHBvbmVudGlhbCBiYWNrb2ZmXG4gICAgICBjb25zb2xlLmxvZyhgUmV0cnlpbmcgcmVxdWVzdCAoNDI5KSBpbiAke2JhY2tvZmZ9IHNlY29uZHMuLi5gKTtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHIgPT4gc2V0VGltZW91dChyLCAxMDAwICogYmFja29mZikpO1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucmVxdWVzdChyZXEsIHJldHJpZXMgKyAxKTtcbiAgICB9XG4gICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmV4cG9ydHMuQXBpQWRhcHRlciA9IEFwaUFkYXB0ZXI7IiwgImNvbnN0IHsgQXBpQWRhcHRlciB9ID0gcmVxdWlyZShcIi4vYXBpXCIpO1xuY2xhc3MgTG9jYWxBcGlBZGFwdGVyIGV4dGVuZHMgQXBpQWRhcHRlciB7XG4gIGFzeW5jIGVtYmVkKGlucHV0KSB7XG4gICAgY29uc3QgcmVzcCA9IGF3YWl0IHRoaXMuZW1iZWRfYmF0Y2goW3tcbiAgICAgIGVtYmVkX2lucHV0OiBpbnB1dCxcbiAgICB9XSk7XG4gICAgcmV0dXJuIHJlc3A/LlswXTtcbiAgfVxuICBhc3luYyBpbml0KCkge1xuICAgIHRoaXMuZW5kcG9pbnQgPSB0aGlzLmxvY2FsX2VuZHBvaW50O1xuICB9XG4gIHByZXBhcmVfYmF0Y2hfaW5wdXQoaXRlbXMpIHtcbiAgICByZXR1cm4gaXRlbXMubWFwKGl0ZW0gPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZW1iZWRfaW5wdXQ6IHRoaXMucHJlcGFyZV9lbWJlZF9pbnB1dChpdGVtLmVtYmVkX2lucHV0KSxcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBwYXJzZV9lbWJlZGRpbmdfb3V0cHV0KGVtYmVkX2lucHV0cywgZW1iZWRkaW5nLCBpKSB7IHJldHVybiBlbWJlZGRpbmc7IH1cbiAgcHJlcGFyZV9yZXF1ZXN0X2JvZHkoaW5wdXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbW9kZWxfY29uZmlnOiB0aGlzLm1haW4uY29uZmlnLFxuICAgICAgaW5wdXQ6IGlucHV0LFxuICAgIH07XG4gIH1cbiAgcHJlcGFyZV9yZXF1ZXN0X2hlYWRlcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIH07XG4gIH1cbiAgaXNfZXJyb3IocmVzcCkgeyByZXR1cm4gcmVzcD8uZXJyb3I7IH1cbiAgcGFyc2VfcmVzcG9uc2UocmVzcCkgeyByZXR1cm4gcmVzcDsgfVxufVxuZXhwb3J0cy5Mb2NhbEFwaUFkYXB0ZXIgPSBMb2NhbEFwaUFkYXB0ZXI7XG5cbiIsICJjb25zdCB7IEFkYXB0ZXIgfSA9IHJlcXVpcmUoXCIuL2FkYXB0ZXJcIik7XG5cbmNsYXNzIFRyYW5zZm9ybWVyc0FkYXB0ZXIgZXh0ZW5kcyBBZGFwdGVyIHtcbiAgYXN5bmMgaW5pdCgpIHtcbiAgICBjb25zdCB7IGVudiwgcGlwZWxpbmUsIEF1dG9Ub2tlbml6ZXIgfSA9IGF3YWl0IGltcG9ydCgnQHhlbm92YS90cmFuc2Zvcm1lcnMnKTtcbiAgICBlbnYuYWxsb3dMb2NhbE1vZGVscyA9IGZhbHNlO1xuICAgIHRoaXMubW9kZWwgPSBhd2FpdCBwaXBlbGluZSgnZmVhdHVyZS1leHRyYWN0aW9uJywgdGhpcy5tb2RlbF9uYW1lLCB7IHF1YW50aXplZDogdHJ1ZSwgbWF4X2xlbmd0aDogdGhpcy5tYXhfdG9rZW5zIH0pO1xuICAgIC8vIHRoaXMubW9kZWwgPSBhd2FpdCBwaXBlbGluZSgnZmVhdHVyZS1leHRyYWN0aW9uJywgdGhpcy5tb2RlbF9uYW1lLCB7IHF1YW50aXplZDogZmFsc2UgfSk7XG4gICAgdGhpcy50b2tlbml6ZXIgPSBhd2FpdCBBdXRvVG9rZW5pemVyLmZyb21fcHJldHJhaW5lZCh0aGlzLm1vZGVsX25hbWUpO1xuICB9XG4gIGFzeW5jIGVtYmVkX2JhdGNoKGl0ZW1zKSB7XG4gICAgaXRlbXMgPSBpdGVtcy5maWx0ZXIoaXRlbSA9PiBpdGVtLmVtYmVkX2lucHV0Py5sZW5ndGggPiAwKTsgLy8gcmVtb3ZlIGl0ZW1zIHdpdGggZW1wdHkgZW1iZWRfaW5wdXQgKGNhdXNlcyAuc3BsaXQoKSBlcnJvcilcbiAgICBpZighaXRlbXM/Lmxlbmd0aCkgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHRva2VucyA9IGF3YWl0IFByb21pc2UuYWxsKGl0ZW1zLm1hcChpdGVtID0+IHRoaXMuY291bnRfdG9rZW5zKGl0ZW0uZW1iZWRfaW5wdXQpKSk7XG4gICAgY29uc3QgZW1iZWRfaW5wdXQgPSBhd2FpdCBQcm9taXNlLmFsbChpdGVtcy5tYXAoYXN5bmMgKGl0ZW0sIGkpID0+IHtcbiAgICAgIGlmICh0b2tlbnNbaV0gPCB0aGlzLm1heF90b2tlbnMpIHJldHVybiBpdGVtLmVtYmVkX2lucHV0O1xuICAgICAgbGV0IHRva2VuX2N0ID0gdG9rZW5zW2ldO1xuICAgICAgbGV0IHRydW5jYXRlZF9pbnB1dCA9IGl0ZW0uZW1iZWRfaW5wdXQ7XG4gICAgICB3aGlsZSAodG9rZW5fY3QgPiB0aGlzLm1heF90b2tlbnMpIHtcbiAgICAgICAgY29uc3QgcGN0ID0gdGhpcy5tYXhfdG9rZW5zIC8gdG9rZW5fY3Q7IC8vIGdldCBwY3Qgb2YgaW5wdXQgdG8ga2VlcFxuICAgICAgICBjb25zdCBtYXhfY2hhcnMgPSBNYXRoLmZsb29yKHRydW5jYXRlZF9pbnB1dC5sZW5ndGggKiBwY3QgKiAwLjkwKTsgLy8gZ2V0IG51bWJlciBvZiBjaGFyYWN0ZXJzIHRvIGtlZXAgKG1pbnVzIDEwJSBmb3Igc2FmZXR5KVxuICAgICAgICB0cnVuY2F0ZWRfaW5wdXQgPSB0cnVuY2F0ZWRfaW5wdXQuc3Vic3RyaW5nKDAsIG1heF9jaGFycykgKyBcIi4uLlwiO1xuICAgICAgICB0b2tlbl9jdCA9IGF3YWl0IHRoaXMuY291bnRfdG9rZW5zKHRydW5jYXRlZF9pbnB1dCk7XG4gICAgICB9XG4gICAgICAvLyBjb25zb2xlLmxvZyhcIklucHV0IHRvbyBsb25nLiBUcnVuY2F0aW5nIHRvIFwiLCB0cnVuY2F0ZWRfaW5wdXQubGVuZ3RoLCBcIiBjaGFyYWN0ZXJzLlwiKTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiVG9rZW5zOiBcIiwgdG9rZW5zW2ldLCBcIiAtPiBcIiwgdG9rZW5fY3QpO1xuICAgICAgdG9rZW5zW2ldID0gdG9rZW5fY3Q7XG4gICAgICByZXR1cm4gdHJ1bmNhdGVkX2lucHV0O1xuICAgIH0pKTtcblxuICAgIC8vIGNvbnNvbGUubG9nKGVtYmVkX2lucHV0KTtcbiAgICB0cnl7XG4gICAgICBjb25zdCByZXNwID0gYXdhaXQgdGhpcy5tb2RlbChlbWJlZF9pbnB1dCwgeyBwb29saW5nOiAnbWVhbicsIG5vcm1hbGl6ZTogdHJ1ZSB9KTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKHJlc3ApO1xuICAgICAgcmV0dXJuIGl0ZW1zLm1hcCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICBpdGVtLnZlYyA9IEFycmF5LmZyb20ocmVzcFtpXS5kYXRhKTtcbiAgICAgICAgaXRlbS50b2tlbnMgPSB0b2tlbnNbaV07XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgfSk7XG4gICAgfWNhdGNoKGVycil7XG4gICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAgY29uc29sZS5sb2coXCJFcnJvciBlbWJlZGRpbmcgYmF0Y2guIFRyeWluZyBvbmUgYXQgYSB0aW1lLi4uXCIpO1xuICAgIH1cbiAgICBjb25zdCByZXNwID0gYXdhaXQgUHJvbWlzZS5hbGwoaXRlbXMubWFwKGFzeW5jIGl0ZW0gPT4ge1xuICAgICAgY29uc3QgeyB2ZWMsIHRva2VucywgZXJyb3IgfSA9IGF3YWl0IHRoaXMuZW1iZWQoaXRlbS5lbWJlZF9pbnB1dCk7XG4gICAgICBpZihlcnJvcil7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiRXJyb3IgZW1iZWRkaW5nIGl0ZW06IFwiLCBpdGVtLmtleSk7XG4gICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcbiAgICAgICAgaXRlbS5lcnJvciA9IGVycm9yO1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH1cbiAgICAgIGlmKCF2ZWMpe1xuICAgICAgICBjb25zb2xlLmxvZyhcIkVycm9yIGVtYmVkZGluZyBpdGVtOiBcIiwgaXRlbS5rZXkpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIlZlYzogXCIsIHZlYyk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiRXJyb3I6IFwiLCBlcnJvcik7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVG9rZW5zOiBcIiwgdG9rZW5zKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJObyB2ZWMgcmV0dXJuZWRcIik7XG4gICAgICAgIGl0ZW0uZXJyb3IgPSBcIk5vIHZlYyByZXR1cm5lZFwiO1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH1cbiAgICAgIGl0ZW0udmVjID0gdmVjLm1hcCh2YWwgPT4gTWF0aC5yb3VuZCh2YWwgKiAxMDAwMDAwMDApIC8gMTAwMDAwMDAwKTsgLy8gcmVkdWNlIHByZWNpc2lvbiB0byA4IGRlY2ltYWwgcGxhY2VzIHJlZjogaHR0cHM6Ly93Zmhicmlhbi5jb20vdmVjdG9yLWRpbWVuc2lvbi1wcmVjaXNpb24tZWZmZWN0LW9uLWNvc2luZS1zaW1pbGFyaXR5L1xuICAgICAgaXRlbS50b2tlbnMgPSB0b2tlbnM7XG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9KSk7XG4gICAgcmV0dXJuIHJlc3A7XG4gIH1cbiAgYXN5bmMgZW1iZWQoaW5wdXQpIHtcbiAgICBjb25zdCBvdXRwdXQgPSB7IGVtYmVkX2lucHV0OiBpbnB1dCB9O1xuICAgIGlmICghaW5wdXQpIHJldHVybiB7IC4uLm91dHB1dCwgZXJyb3I6IFwiTm8gaW5wdXQgdGV4dC5cIiB9O1xuICAgIGlmICghdGhpcy5tb2RlbCkgYXdhaXQgdGhpcy5pbml0KCk7XG4gICAgdHJ5IHtcbiAgICAgIG91dHB1dC50b2tlbnMgPSBhd2FpdCB0aGlzLmNvdW50X3Rva2VucyhpbnB1dCk7XG4gICAgICBpZiAob3V0cHV0LnRva2VucyA8IDEpIHJldHVybiB7IC4uLm91dHB1dCwgZXJyb3I6IFwiSW5wdXQgdG9vIHNob3J0LlwiIH07XG4gICAgICBpZiAob3V0cHV0LnRva2VucyA8IHRoaXMubWF4X3Rva2Vucykge1xuICAgICAgICBjb25zdCBlbWJlZGRpbmcgPSBhd2FpdCB0aGlzLm1vZGVsKGlucHV0LCB7IHBvb2xpbmc6ICdtZWFuJywgbm9ybWFsaXplOiB0cnVlIH0pO1xuICAgICAgICBvdXRwdXQudmVjID0gQXJyYXkuZnJvbShlbWJlZGRpbmcuZGF0YSkubWFwKHZhbCA9PiBNYXRoLnJvdW5kKHZhbCAqIDEwMDAwMDAwMCkgLyAxMDAwMDAwMDApOyAvLyByZWR1Y2UgcHJlY2lzaW9uIHRvIDggZGVjaW1hbCBwbGFjZXMgcmVmOiBodHRwczovL3dmaGJyaWFuLmNvbS92ZWN0b3ItZGltZW5zaW9uLXByZWNpc2lvbi1lZmZlY3Qtb24tY29zaW5lLXNpbWlsYXJpdHkvXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBwY3QgPSB0aGlzLm1heF90b2tlbnMgLyBvdXRwdXQudG9rZW5zOyAvLyBnZXQgcGN0IG9mIGlucHV0IHRvIGtlZXBcbiAgICAgICAgY29uc3QgbWF4X2NoYXJzID0gTWF0aC5mbG9vcihpbnB1dC5sZW5ndGggKiBwY3QgKiAwLjk1KTsgLy8gZ2V0IG51bWJlciBvZiBjaGFyYWN0ZXJzIHRvIGtlZXAgKG1pbnVzIDUlIGZvciBzYWZldHkpXG4gICAgICAgIGlucHV0ID0gaW5wdXQuc3Vic3RyaW5nKDAsIG1heF9jaGFycykgKyBcIi4uLlwiO1xuICAgICAgICBvdXRwdXQudHJ1bmNhdGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc29sZS5sb2coXCJJbnB1dCB0b28gbG9uZy4gVHJ1bmNhdGluZyB0byBcIiwgaW5wdXQubGVuZ3RoLCBcIiBjaGFyYWN0ZXJzLlwiKTtcbiAgICAgICAgY29uc3QgeyB2ZWMsIHRva2VucyB9ID0gYXdhaXQgdGhpcy5lbWJlZChpbnB1dCk7XG4gICAgICAgIG91dHB1dC52ZWMgPSB2ZWM7XG4gICAgICAgIG91dHB1dC50b2tlbnMgPSB0b2tlbnM7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgIHJldHVybiB7IC4uLm91dHB1dCwgZXJyb3I6IGVyci5tZXNzYWdlIH07XG4gICAgfVxuICB9XG4gIGFzeW5jIGNvdW50X3Rva2Vucyh0ZXh0KSB7XG4gICAgaWYgKCF0aGlzLnRva2VuaXplcikgYXdhaXQgdGhpcy5pbml0KCk7XG4gICAgY29uc3QgeyBpbnB1dF9pZHMgfSA9IGF3YWl0IHRoaXMudG9rZW5pemVyKHRleHQpO1xuICAgIHJldHVybiBpbnB1dF9pZHMuZGF0YS5sZW5ndGg7IC8vIFJldHVybiB0aGUgbnVtYmVyIG9mIHRva2Vuc1xuICB9XG59XG5cbmV4cG9ydHMuVHJhbnNmb3JtZXJzQWRhcHRlciA9IFRyYW5zZm9ybWVyc0FkYXB0ZXI7IiwgIntcbiAgXCJzY3JpcHRcIjogXCJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XFxudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XFxudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XFxudmFyIF9fY29tbW9uSlMgPSAoY2IsIG1vZCkgPT4gZnVuY3Rpb24gX19yZXF1aXJlKCkge1xcbiAgcmV0dXJuIG1vZCB8fCAoMCwgY2JbX19nZXRPd25Qcm9wTmFtZXMoY2IpWzBdXSkoKG1vZCA9IHsgZXhwb3J0czoge30gfSkuZXhwb3J0cywgbW9kKSwgbW9kLmV4cG9ydHM7XFxufTtcXG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFxcXCJvYmplY3RcXFwiIHx8IHR5cGVvZiBmcm9tID09PSBcXFwiZnVuY3Rpb25cXFwiKSB7XFxuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xcbiAgfVxcbiAgcmV0dXJuIHRvO1xcbn07XFxudmFyIF9fdG9FU00gPSAobW9kLCBpc05vZGVNb2RlLCB0YXJnZXQpID0+ICh0YXJnZXQgPSBtb2QgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2QpKSA6IHt9LCBfX2NvcHlQcm9wcyhcXG4gIC8vIElmIHRoZSBpbXBvcnRlciBpcyBpbiBub2RlIGNvbXBhdGliaWxpdHkgbW9kZSBvciB0aGlzIGlzIG5vdCBhbiBFU01cXG4gIC8vIGZpbGUgdGhhdCBoYXMgYmVlbiBjb252ZXJ0ZWQgdG8gYSBDb21tb25KUyBmaWxlIHVzaW5nIGEgQmFiZWwtXFxuICAvLyBjb21wYXRpYmxlIHRyYW5zZm9ybSAoaS5lLiBcXFwiX19lc01vZHVsZVxcXCIgaGFzIG5vdCBiZWVuIHNldCksIHRoZW4gc2V0XFxuICAvLyBcXFwiZGVmYXVsdFxcXCIgdG8gdGhlIENvbW1vbkpTIFxcXCJtb2R1bGUuZXhwb3J0c1xcXCIgZm9yIG5vZGUgY29tcGF0aWJpbGl0eS5cXG4gIGlzTm9kZU1vZGUgfHwgIW1vZCB8fCAhbW9kLl9fZXNNb2R1bGUgPyBfX2RlZlByb3AodGFyZ2V0LCBcXFwiZGVmYXVsdFxcXCIsIHsgdmFsdWU6IG1vZCwgZW51bWVyYWJsZTogdHJ1ZSB9KSA6IHRhcmdldCxcXG4gIG1vZFxcbikpO1xcblxcbi8vIGFkYXB0ZXJzL2FkYXB0ZXIuanNcXG52YXIgcmVxdWlyZV9hZGFwdGVyID0gX19jb21tb25KUyh7XFxuICBcXFwiYWRhcHRlcnMvYWRhcHRlci5qc1xcXCIoZXhwb3J0cykge1xcbiAgICB2YXIgQWRhcHRlciA9IGNsYXNzIHtcXG4gICAgICAvKipcXG4gICAgICAgKiBDb25zdHJ1Y3RzIGFuIGluc3RhbmNlIG9mIEFkYXB0ZXIuXFxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IG1haW4gLSBUaGUgbWFpbiBjb250ZXh0IG9iamVjdCB3aGljaCBzaG91bGQgY29udGFpbiBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxcbiAgICAgICAqL1xcbiAgICAgIGNvbnN0cnVjdG9yKG1haW4pIHtcXG4gICAgICAgIHRoaXMubWFpbiA9IG1haW47XFxuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIG1haW4uY29uZmlnKTtcXG4gICAgICB9XFxuICAgIH07XFxuICAgIGV4cG9ydHMuQWRhcHRlciA9IEFkYXB0ZXI7XFxuICB9XFxufSk7XFxuXFxuLy8gYWRhcHRlcnMvdHJhbnNmb3JtZXJzLmpzXFxudmFyIHJlcXVpcmVfdHJhbnNmb3JtZXJzID0gX19jb21tb25KUyh7XFxuICBcXFwiYWRhcHRlcnMvdHJhbnNmb3JtZXJzLmpzXFxcIihleHBvcnRzKSB7XFxuICAgIHZhciB7IEFkYXB0ZXIgfSA9IHJlcXVpcmVfYWRhcHRlcigpO1xcbiAgICB2YXIgVHJhbnNmb3JtZXJzQWRhcHRlciA9IGNsYXNzIGV4dGVuZHMgQWRhcHRlciB7XFxuICAgICAgYXN5bmMgaW5pdCgpIHtcXG4gICAgICAgIGNvbnN0IHsgZW52LCBwaXBlbGluZSwgQXV0b1Rva2VuaXplciB9ID0gYXdhaXQgaW1wb3J0KFxcXCJAeGVub3ZhL3RyYW5zZm9ybWVyc1xcXCIpO1xcbiAgICAgICAgZW52LmFsbG93TG9jYWxNb2RlbHMgPSBmYWxzZTtcXG4gICAgICAgIHRoaXMubW9kZWwgPSBhd2FpdCBwaXBlbGluZShcXFwiZmVhdHVyZS1leHRyYWN0aW9uXFxcIiwgdGhpcy5tb2RlbF9uYW1lLCB7IHF1YW50aXplZDogdHJ1ZSwgbWF4X2xlbmd0aDogdGhpcy5tYXhfdG9rZW5zIH0pO1xcbiAgICAgICAgdGhpcy50b2tlbml6ZXIgPSBhd2FpdCBBdXRvVG9rZW5pemVyLmZyb21fcHJldHJhaW5lZCh0aGlzLm1vZGVsX25hbWUpO1xcbiAgICAgIH1cXG4gICAgICBhc3luYyBlbWJlZF9iYXRjaChpdGVtcykge1xcbiAgICAgICAgaXRlbXMgPSBpdGVtcy5maWx0ZXIoKGl0ZW0pID0+IHtcXG4gICAgICAgICAgdmFyIF9hO1xcbiAgICAgICAgICByZXR1cm4gKChfYSA9IGl0ZW0uZW1iZWRfaW5wdXQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5sZW5ndGgpID4gMDtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgaWYgKCEoaXRlbXMgPT0gbnVsbCA/IHZvaWQgMCA6IGl0ZW1zLmxlbmd0aCkpXFxuICAgICAgICAgIHJldHVybiBbXTtcXG4gICAgICAgIGNvbnN0IHRva2VucyA9IGF3YWl0IFByb21pc2UuYWxsKGl0ZW1zLm1hcCgoaXRlbSkgPT4gdGhpcy5jb3VudF90b2tlbnMoaXRlbS5lbWJlZF9pbnB1dCkpKTtcXG4gICAgICAgIGNvbnN0IGVtYmVkX2lucHV0ID0gYXdhaXQgUHJvbWlzZS5hbGwoaXRlbXMubWFwKGFzeW5jIChpdGVtLCBpKSA9PiB7XFxuICAgICAgICAgIGlmICh0b2tlbnNbaV0gPCB0aGlzLm1heF90b2tlbnMpXFxuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uZW1iZWRfaW5wdXQ7XFxuICAgICAgICAgIGxldCB0b2tlbl9jdCA9IHRva2Vuc1tpXTtcXG4gICAgICAgICAgbGV0IHRydW5jYXRlZF9pbnB1dCA9IGl0ZW0uZW1iZWRfaW5wdXQ7XFxuICAgICAgICAgIHdoaWxlICh0b2tlbl9jdCA+IHRoaXMubWF4X3Rva2Vucykge1xcbiAgICAgICAgICAgIGNvbnN0IHBjdCA9IHRoaXMubWF4X3Rva2VucyAvIHRva2VuX2N0O1xcbiAgICAgICAgICAgIGNvbnN0IG1heF9jaGFycyA9IE1hdGguZmxvb3IodHJ1bmNhdGVkX2lucHV0Lmxlbmd0aCAqIHBjdCAqIDAuOSk7XFxuICAgICAgICAgICAgdHJ1bmNhdGVkX2lucHV0ID0gdHJ1bmNhdGVkX2lucHV0LnN1YnN0cmluZygwLCBtYXhfY2hhcnMpICsgXFxcIi4uLlxcXCI7XFxuICAgICAgICAgICAgdG9rZW5fY3QgPSBhd2FpdCB0aGlzLmNvdW50X3Rva2Vucyh0cnVuY2F0ZWRfaW5wdXQpO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHRva2Vuc1tpXSA9IHRva2VuX2N0O1xcbiAgICAgICAgICByZXR1cm4gdHJ1bmNhdGVkX2lucHV0O1xcbiAgICAgICAgfSkpO1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgY29uc3QgcmVzcDIgPSBhd2FpdCB0aGlzLm1vZGVsKGVtYmVkX2lucHV0LCB7IHBvb2xpbmc6IFxcXCJtZWFuXFxcIiwgbm9ybWFsaXplOiB0cnVlIH0pO1xcbiAgICAgICAgICByZXR1cm4gaXRlbXMubWFwKChpdGVtLCBpKSA9PiB7XFxuICAgICAgICAgICAgaXRlbS52ZWMgPSBBcnJheS5mcm9tKHJlc3AyW2ldLmRhdGEpO1xcbiAgICAgICAgICAgIGl0ZW0udG9rZW5zID0gdG9rZW5zW2ldO1xcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xcbiAgICAgICAgICBjb25zb2xlLmxvZyhcXFwiRXJyb3IgZW1iZWRkaW5nIGJhdGNoLiBUcnlpbmcgb25lIGF0IGEgdGltZS4uLlxcXCIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IFByb21pc2UuYWxsKGl0ZW1zLm1hcChhc3luYyAoaXRlbSkgPT4ge1xcbiAgICAgICAgICBjb25zdCB7IHZlYywgdG9rZW5zOiB0b2tlbnMyLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5lbWJlZChpdGVtLmVtYmVkX2lucHV0KTtcXG4gICAgICAgICAgaWYgKGVycm9yKSB7XFxuICAgICAgICAgICAgY29uc29sZS5sb2coXFxcIkVycm9yIGVtYmVkZGluZyBpdGVtOiBcXFwiLCBpdGVtLmtleSk7XFxuICAgICAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xcbiAgICAgICAgICAgIGl0ZW0uZXJyb3IgPSBlcnJvcjtcXG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZiAoIXZlYykge1xcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxcXCJFcnJvciBlbWJlZGRpbmcgaXRlbTogXFxcIiwgaXRlbS5rZXkpO1xcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxcXCJWZWM6IFxcXCIsIHZlYyk7XFxuICAgICAgICAgICAgY29uc29sZS5sb2coXFxcIkVycm9yOiBcXFwiLCBlcnJvcik7XFxuICAgICAgICAgICAgY29uc29sZS5sb2coXFxcIlRva2VuczogXFxcIiwgdG9rZW5zMik7XFxuICAgICAgICAgICAgY29uc29sZS5sb2coXFxcIk5vIHZlYyByZXR1cm5lZFxcXCIpO1xcbiAgICAgICAgICAgIGl0ZW0uZXJyb3IgPSBcXFwiTm8gdmVjIHJldHVybmVkXFxcIjtcXG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpdGVtLnZlYyA9IHZlYy5tYXAoKHZhbCkgPT4gTWF0aC5yb3VuZCh2YWwgKiAxZTgpIC8gMWU4KTtcXG4gICAgICAgICAgaXRlbS50b2tlbnMgPSB0b2tlbnMyO1xcbiAgICAgICAgICByZXR1cm4gaXRlbTtcXG4gICAgICAgIH0pKTtcXG4gICAgICAgIHJldHVybiByZXNwO1xcbiAgICAgIH1cXG4gICAgICBhc3luYyBlbWJlZChpbnB1dCkge1xcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0geyBlbWJlZF9pbnB1dDogaW5wdXQgfTtcXG4gICAgICAgIGlmICghaW5wdXQpXFxuICAgICAgICAgIHJldHVybiB7IC4uLm91dHB1dCwgZXJyb3I6IFxcXCJObyBpbnB1dCB0ZXh0LlxcXCIgfTtcXG4gICAgICAgIGlmICghdGhpcy5tb2RlbClcXG4gICAgICAgICAgYXdhaXQgdGhpcy5pbml0KCk7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICBvdXRwdXQudG9rZW5zID0gYXdhaXQgdGhpcy5jb3VudF90b2tlbnMoaW5wdXQpO1xcbiAgICAgICAgICBpZiAob3V0cHV0LnRva2VucyA8IDEpXFxuICAgICAgICAgICAgcmV0dXJuIHsgLi4ub3V0cHV0LCBlcnJvcjogXFxcIklucHV0IHRvbyBzaG9ydC5cXFwiIH07XFxuICAgICAgICAgIGlmIChvdXRwdXQudG9rZW5zIDwgdGhpcy5tYXhfdG9rZW5zKSB7XFxuICAgICAgICAgICAgY29uc3QgZW1iZWRkaW5nID0gYXdhaXQgdGhpcy5tb2RlbChpbnB1dCwgeyBwb29saW5nOiBcXFwibWVhblxcXCIsIG5vcm1hbGl6ZTogdHJ1ZSB9KTtcXG4gICAgICAgICAgICBvdXRwdXQudmVjID0gQXJyYXkuZnJvbShlbWJlZGRpbmcuZGF0YSkubWFwKCh2YWwpID0+IE1hdGgucm91bmQodmFsICogMWU4KSAvIDFlOCk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgY29uc3QgcGN0ID0gdGhpcy5tYXhfdG9rZW5zIC8gb3V0cHV0LnRva2VucztcXG4gICAgICAgICAgICBjb25zdCBtYXhfY2hhcnMgPSBNYXRoLmZsb29yKGlucHV0Lmxlbmd0aCAqIHBjdCAqIDAuOTUpO1xcbiAgICAgICAgICAgIGlucHV0ID0gaW5wdXQuc3Vic3RyaW5nKDAsIG1heF9jaGFycykgKyBcXFwiLi4uXFxcIjtcXG4gICAgICAgICAgICBvdXRwdXQudHJ1bmNhdGVkID0gdHJ1ZTtcXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcXFwiSW5wdXQgdG9vIGxvbmcuIFRydW5jYXRpbmcgdG8gXFxcIiwgaW5wdXQubGVuZ3RoLCBcXFwiIGNoYXJhY3RlcnMuXFxcIik7XFxuICAgICAgICAgICAgY29uc3QgeyB2ZWMsIHRva2VucyB9ID0gYXdhaXQgdGhpcy5lbWJlZChpbnB1dCk7XFxuICAgICAgICAgICAgb3V0cHV0LnZlYyA9IHZlYztcXG4gICAgICAgICAgICBvdXRwdXQudG9rZW5zID0gdG9rZW5zO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHJldHVybiBvdXRwdXQ7XFxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcXG4gICAgICAgICAgcmV0dXJuIHsgLi4ub3V0cHV0LCBlcnJvcjogZXJyLm1lc3NhZ2UgfTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgYXN5bmMgY291bnRfdG9rZW5zKHRleHQpIHtcXG4gICAgICAgIGlmICghdGhpcy50b2tlbml6ZXIpXFxuICAgICAgICAgIGF3YWl0IHRoaXMuaW5pdCgpO1xcbiAgICAgICAgY29uc3QgeyBpbnB1dF9pZHMgfSA9IGF3YWl0IHRoaXMudG9rZW5pemVyKHRleHQpO1xcbiAgICAgICAgcmV0dXJuIGlucHV0X2lkcy5kYXRhLmxlbmd0aDtcXG4gICAgICB9XFxuICAgIH07XFxuICAgIGV4cG9ydHMuVHJhbnNmb3JtZXJzQWRhcHRlciA9IFRyYW5zZm9ybWVyc0FkYXB0ZXI7XFxuICB9XFxufSk7XFxuXFxuLy8gdHJhbnNmb3JtZXJzX2lmcmFtZS5qc1xcbnZhciByZXF1aXJlX3RyYW5zZm9ybWVyc19pZnJhbWUgPSBfX2NvbW1vbkpTKHtcXG4gIFxcXCJ0cmFuc2Zvcm1lcnNfaWZyYW1lLmpzXFxcIihleHBvcnRzKSB7XFxuICAgIHZhciB7IFRyYW5zZm9ybWVyc0FkYXB0ZXIgfSA9IHJlcXVpcmVfdHJhbnNmb3JtZXJzKCk7XFxuICAgIHZhciBUcmFuc2Zvcm1lcnNJZnJhbWVDb25uZWN0b3IgPSBjbGFzcyBfVHJhbnNmb3JtZXJzSWZyYW1lQ29ubmVjdG9yIGV4dGVuZHMgVHJhbnNmb3JtZXJzQWRhcHRlciB7XFxuICAgICAgY29uc3RydWN0b3IobW9kZWxfY29uZmlnLCB3aW5kb3cyKSB7XFxuICAgICAgICBzdXBlcih7IGNvbmZpZzogbW9kZWxfY29uZmlnIH0pO1xcbiAgICAgICAgdGhpcy5tb2RlbCA9IG51bGw7XFxuICAgICAgICB0aGlzLnJ1bm5pbmdfaW5pdCA9IGZhbHNlO1xcbiAgICAgICAgdGhpcy53aW5kb3cgPSB3aW5kb3cyO1xcbiAgICAgICAgdGhpcy5lbWJlZF9jdCA9IDA7XFxuICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IG51bGw7XFxuICAgICAgICB0aGlzLnRva2VucyA9IDA7XFxuICAgICAgfVxcbiAgICAgIHN0YXRpYyBhc3luYyBjcmVhdGUobW9kZWxfY29uZmlnLCB3aW5kb3cyKSB7XFxuICAgICAgICBjb25zdCBjb25uZWN0b3IgPSBuZXcgX1RyYW5zZm9ybWVyc0lmcmFtZUNvbm5lY3Rvcihtb2RlbF9jb25maWcsIHdpbmRvdzIpO1xcbiAgICAgICAgYXdhaXQgY29ubmVjdG9yLmluaXQoKTtcXG4gICAgICAgIHJldHVybiBjb25uZWN0b3I7XFxuICAgICAgfVxcbiAgICAgIGFzeW5jIGluaXQoKSB7XFxuICAgICAgICBpZiAodGhpcy5tb2RlbClcXG4gICAgICAgICAgcmV0dXJuIGNvbnNvbGUubG9nKFxcXCJTbWFydCBMb2NhbCBNb2RlbCBhbHJlYWR5IGxvYWRlZFxcXCIpO1xcbiAgICAgICAgaWYgKHRoaXMucnVubmluZ19pbml0KVxcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzZTMpKTtcXG4gICAgICAgIGlmICghdGhpcy5tb2RlbCAmJiAhdGhpcy5ydW5uaW5nX2luaXQpXFxuICAgICAgICAgIHRoaXMucnVubmluZ19pbml0ID0gdHJ1ZTtcXG4gICAgICAgIGNvbnNvbGUubG9nKFxcXCJMb2FkaW5nIFNtYXJ0IExvY2FsIE1vZGVsXFxcIik7XFxuICAgICAgICBjb25zdCB7IHBpcGVsaW5lLCBlbnYsIEF1dG9Ub2tlbml6ZXIgfSA9IGF3YWl0IGltcG9ydChcXFwiaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AeGVub3ZhL3RyYW5zZm9ybWVyc0BsYXRlc3RcXFwiKTtcXG4gICAgICAgIGVudi5hbGxvd0xvY2FsTW9kZWxzID0gZmFsc2U7XFxuICAgICAgICB0aGlzLm1vZGVsID0gYXdhaXQgcGlwZWxpbmUoXFxcImZlYXR1cmUtZXh0cmFjdGlvblxcXCIsIHRoaXMubW9kZWxfbmFtZSwgeyBxdWFudGl6ZWQ6IHRydWUgfSk7XFxuICAgICAgICB0aGlzLnRva2VuaXplciA9IGF3YWl0IEF1dG9Ub2tlbml6ZXIuZnJvbV9wcmV0cmFpbmVkKHRoaXMubW9kZWxfbmFtZSk7XFxuICAgICAgICB0aGlzLnJ1bm5pbmdfaW5pdCA9IGZhbHNlO1xcbiAgICAgICAgdGhpcy53aW5kb3cudG9rZW5pemVyID0gdGhpcy50b2tlbml6ZXI7XFxuICAgICAgICBjb25zb2xlLmxvZyhhd2FpdCB0aGlzLmVtYmVkKFxcXCJ0ZXN0XFxcIikpO1xcbiAgICAgICAgdGhpcy53aW5kb3cucGFyZW50LnBvc3RNZXNzYWdlKHsgdHlwZTogXFxcIm1vZGVsX2xvYWRlZFxcXCIsIGRhdGE6IHRydWUgfSwgXFxcIipcXFwiKTtcXG4gICAgICAgIHRoaXMud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXFxcIm1lc3NhZ2VcXFwiLCB0aGlzLmhhbmRsZV9pcGMuYmluZCh0aGlzKSwgZmFsc2UpO1xcbiAgICAgIH1cXG4gICAgICBhc3luYyBoYW5kbGVfaXBjKGV2ZW50KSB7XFxuICAgICAgICBpZiAoZXZlbnQuZGF0YS50eXBlID09IFxcXCJzbWFydF9lbWJlZFxcXCIpXFxuICAgICAgICAgIHRoaXMuZW1iZWRfaGFuZGxlcihldmVudC5kYXRhKTtcXG4gICAgICAgIGlmIChldmVudC5kYXRhLnR5cGUgPT0gXFxcInNtYXJ0X2VtYmVkX3Rva2VuX2N0XFxcIilcXG4gICAgICAgICAgdGhpcy5jb3VudF90b2tlbnNfaGFuZGxlcihldmVudC5kYXRhLmVtYmVkX2lucHV0KTtcXG4gICAgICB9XFxuICAgICAgYXN5bmMgZW1iZWRfaGFuZGxlcihldmVudF9kYXRhKSB7XFxuICAgICAgICBjb25zdCB7IGVtYmVkX2lucHV0LCBoYW5kbGVyX2lkIH0gPSBldmVudF9kYXRhO1xcbiAgICAgICAgaWYgKCF0aGlzLnRpbWVzdGFtcClcXG4gICAgICAgICAgdGhpcy50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZW1iZWRfaW5wdXQpKSB7XFxuICAgICAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCB0aGlzLmVtYmVkX2JhdGNoKGVtYmVkX2lucHV0KTtcXG4gICAgICAgICAgY29uc3Qgc2VuZF9kYXRhID0ge1xcbiAgICAgICAgICAgIHR5cGU6IFxcXCJzbWFydF9lbWJlZF9yZXNwXFxcIixcXG4gICAgICAgICAgICBoYW5kbGVyX2lkLFxcbiAgICAgICAgICAgIGRhdGE6IHJlc3BcXG4gICAgICAgICAgfTtcXG4gICAgICAgICAgdGhpcy53aW5kb3cucG9zdE1lc3NhZ2Uoc2VuZF9kYXRhLCBcXFwiKlxcXCIpO1xcbiAgICAgICAgICB0aGlzLnRva2VucyArPSByZXNwLnJlZHVjZSgoYWNjLCBpdGVtKSA9PiBhY2MgKyBpdGVtLnRva2VucywgMCk7XFxuICAgICAgICAgIHRoaXMuZW1iZWRfY3QgKz0gcmVzcC5sZW5ndGg7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBpZiAoIXRoaXMudGltZXN0YW1wKVxcbiAgICAgICAgICAgIHRoaXMudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcXG4gICAgICAgICAgY29uc3Qgc2VuZF9kYXRhID0gYXdhaXQgdGhpcy5lbWJlZChlbWJlZF9pbnB1dCk7XFxuICAgICAgICAgIHNlbmRfZGF0YS50eXBlID0gXFxcInNtYXJ0X2VtYmVkX3Jlc3BcXFwiO1xcbiAgICAgICAgICBpZiAoaGFuZGxlcl9pZClcXG4gICAgICAgICAgICBzZW5kX2RhdGEuaGFuZGxlcl9pZCA9IGhhbmRsZXJfaWQ7XFxuICAgICAgICAgIHRoaXMud2luZG93LnBvc3RNZXNzYWdlKHNlbmRfZGF0YSwgXFxcIipcXFwiKTtcXG4gICAgICAgICAgdGhpcy50b2tlbnMgKz0gc2VuZF9kYXRhLnRva2VucztcXG4gICAgICAgICAgdGhpcy5lbWJlZF9jdCsrO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKERhdGUubm93KCkgLSB0aGlzLnRpbWVzdGFtcCA+IDFlNCkge1xcbiAgICAgICAgICBjb25zb2xlLmxvZyhgRW1iZWRkZWQ6ICR7dGhpcy5lbWJlZF9jdH0gaW5wdXRzICgke3RoaXMudG9rZW5zfSB0b2tlbnMsICR7KHRoaXMudG9rZW5zIC8gKChEYXRlLm5vdygpIC0gdGhpcy50aW1lc3RhbXApIC8gMWUzKSkudG9GaXhlZCgwKX0gdG9rZW5zL3NlYylgKTtcXG4gICAgICAgICAgdGhpcy50aW1lc3RhbXAgPSBudWxsO1xcbiAgICAgICAgICB0aGlzLnRva2VucyA9IDA7XFxuICAgICAgICAgIHRoaXMuZW1iZWRfY3QgPSAwO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBhc3luYyBjb3VudF90b2tlbnNfaGFuZGxlcihpbnB1dCkge1xcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgdGhpcy5jb3VudF90b2tlbnMoaW5wdXQpO1xcbiAgICAgICAgY29uc3Qgc2VuZF9kYXRhID0ge1xcbiAgICAgICAgICB0eXBlOiBcXFwic21hcnRfZW1iZWRfdG9rZW5fY3RcXFwiLFxcbiAgICAgICAgICB0ZXh0OiBcXFwiY291bnQ6XFxcIiArIGlucHV0LFxcbiAgICAgICAgICBjb3VudDogb3V0cHV0XFxuICAgICAgICB9O1xcbiAgICAgICAgdGhpcy53aW5kb3cucG9zdE1lc3NhZ2Uoc2VuZF9kYXRhLCBcXFwiKlxcXCIpO1xcbiAgICAgIH1cXG4gICAgfTtcXG4gICAgZXhwb3J0cy5UcmFuc2Zvcm1lcnNJZnJhbWVDb25uZWN0b3IgPSBUcmFuc2Zvcm1lcnNJZnJhbWVDb25uZWN0b3I7XFxuICB9XFxufSk7XFxuXFxuLy8gc21hcnRfZW1iZWRfd2ViLmpzXFxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXFxcIm1lc3NhZ2VcXFwiLCBpbml0KTtcXG5hc3luYyBmdW5jdGlvbiBpbml0KGV2ZW50KSB7XFxuICBpZiAoZXZlbnQuZGF0YS50eXBlID09PSBcXFwiaW5pdFxcXCIpIHtcXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXFxcIm1lc3NhZ2VcXFwiLCBpbml0KTtcXG4gICAgY29uc3QgbW9kZWxfY29uZmlnID0gZXZlbnQuZGF0YS5tb2RlbF9jb25maWc7XFxuICAgIGNvbnNvbGUubG9nKG1vZGVsX2NvbmZpZyk7XFxuICAgIGNvbnN0IHsgVHJhbnNmb3JtZXJzSWZyYW1lQ29ubmVjdG9yIH0gPSBhd2FpdCBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IF9fdG9FU00ocmVxdWlyZV90cmFuc2Zvcm1lcnNfaWZyYW1lKCkpKTtcXG4gICAgY29uc3QgbW9kZWwgPSBhd2FpdCBUcmFuc2Zvcm1lcnNJZnJhbWVDb25uZWN0b3IuY3JlYXRlKG1vZGVsX2NvbmZpZywgd2luZG93KTtcXG4gICAgd2luZG93Lm1vZGVsID0gbW9kZWw7XFxuICB9XFxufVxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXdvZ0lDSjJaWEp6YVc5dUlqb2dNeXdLSUNBaWMyOTFjbU5sY3lJNklGc2lZV1JoY0hSbGNuTXZZV1JoY0hSbGNpNXFjeUlzSUNKaFpHRndkR1Z5Y3k5MGNtRnVjMlp2Y20xbGNuTXVhbk1pTENBaWRISmhibk5tYjNKdFpYSnpYMmxtY21GdFpTNXFjeUlzSUNKemJXRnlkRjlsYldKbFpGOTNaV0l1YW5NaVhTd0tJQ0FpYzI5MWNtTmxjME52Ym5SbGJuUWlPaUJiSWk4cUtseHVJQ29nVW1Wd2NtVnpaVzUwY3lCaElHZGxibVZ5YVdNZ1lXUmhjSFJsY2lCamJHRnpjeUIwYUdGMElHbHVhWFJwWVd4cGVtVnpJSGRwZEdnZ1lTQnRZV2x1SUdOdmJuUmxlSFFnWVc1a0lHTnZjR2xsY3lCcGRITWdZMjl1Wm1sbmRYSmhkR2x2Ymk1Y2JpQXFMMXh1WTJ4aGMzTWdRV1JoY0hSbGNpQjdYRzRnSUM4cUtseHVJQ0FnS2lCRGIyNXpkSEoxWTNSeklHRnVJR2x1YzNSaGJtTmxJRzltSUVGa1lYQjBaWEl1WEc0Z0lDQXFJRUJ3WVhKaGJTQjdiMkpxWldOMGZTQnRZV2x1SUMwZ1ZHaGxJRzFoYVc0Z1kyOXVkR1Y0ZENCdlltcGxZM1FnZDJocFkyZ2djMmh2ZFd4a0lHTnZiblJoYVc0Z1lTQmpiMjVtYVdkMWNtRjBhVzl1SUc5aWFtVmpkQzVjYmlBZ0lDb3ZYRzRnSUdOdmJuTjBjblZqZEc5eUtHMWhhVzRwSUh0Y2JpQWdJQ0F2S2lwY2JpQWdJQ0FnS2lCVWFHVWdiV0ZwYmlCamIyNTBaWGgwSUc5aWFtVmpkQ0JtY205dElIZG9hV05vSUdOdmJtWnBaM1Z5WVhScGIyNGdhWE1nWkdWeWFYWmxaQzVjYmlBZ0lDQWdLaUJBZEhsd1pTQjdiMkpxWldOMGZWeHVJQ0FnSUNBcUwxeHVJQ0FnSUhSb2FYTXViV0ZwYmlBOUlHMWhhVzQ3WEc1Y2JpQWdJQ0F2S2lwY2JpQWdJQ0FnS2lCRGIzQnBaWE1nY0hKdmNHVnlkR2xsY3lCbWNtOXRJSFJvWlNCdFlXbHVJRzlpYW1WamRDZHpJR052Ym1acFp5QndjbTl3WlhKMGVTQjBieUIwYUdseklHbHVjM1JoYm1ObExseHVJQ0FnSUNBcUwxeHVJQ0FnSUU5aWFtVmpkQzVoYzNOcFoyNG9kR2hwY3l3Z2JXRnBiaTVqYjI1bWFXY3BPeUF2THlCRGIzQjVJR052Ym1acFp5QjBieUIwYUdselhHNGdJSDFjYm4xY2JseHVMeThnUlhod2IzSjBJSFJvWlNCQlpHRndkR1Z5SUdOc1lYTnpJSFJ2SUdKbElHRjJZV2xzWVdKc1pTQm1iM0lnYjNSb1pYSWdiVzlrZFd4bGN5NWNibVY0Y0c5eWRITXVRV1JoY0hSbGNpQTlJRUZrWVhCMFpYSTdYRzRpTENBaVkyOXVjM1FnZXlCQlpHRndkR1Z5SUgwZ1BTQnlaWEYxYVhKbEtGd2lMaTloWkdGd2RHVnlYQ0lwTzF4dVhHNWpiR0Z6Y3lCVWNtRnVjMlp2Y20xbGNuTkJaR0Z3ZEdWeUlHVjRkR1Z1WkhNZ1FXUmhjSFJsY2lCN1hHNGdJR0Z6ZVc1aklHbHVhWFFvS1NCN1hHNGdJQ0FnWTI5dWMzUWdleUJsYm5Zc0lIQnBjR1ZzYVc1bExDQkJkWFJ2Vkc5clpXNXBlbVZ5SUgwZ1BTQmhkMkZwZENCcGJYQnZjblFvSjBCNFpXNXZkbUV2ZEhKaGJuTm1iM0p0WlhKekp5azdYRzRnSUNBZ1pXNTJMbUZzYkc5M1RHOWpZV3hOYjJSbGJITWdQU0JtWVd4elpUdGNiaUFnSUNCMGFHbHpMbTF2WkdWc0lEMGdZWGRoYVhRZ2NHbHdaV3hwYm1Vb0oyWmxZWFIxY21VdFpYaDBjbUZqZEdsdmJpY3NJSFJvYVhNdWJXOWtaV3hmYm1GdFpTd2dleUJ4ZFdGdWRHbDZaV1E2SUhSeWRXVXNJRzFoZUY5c1pXNW5kR2c2SUhSb2FYTXViV0Y0WDNSdmEyVnVjeUI5S1R0Y2JpQWdJQ0F2THlCMGFHbHpMbTF2WkdWc0lEMGdZWGRoYVhRZ2NHbHdaV3hwYm1Vb0oyWmxZWFIxY21VdFpYaDBjbUZqZEdsdmJpY3NJSFJvYVhNdWJXOWtaV3hmYm1GdFpTd2dleUJ4ZFdGdWRHbDZaV1E2SUdaaGJITmxJSDBwTzF4dUlDQWdJSFJvYVhNdWRHOXJaVzVwZW1WeUlEMGdZWGRoYVhRZ1FYVjBiMVJ2YTJWdWFYcGxjaTVtY205dFgzQnlaWFJ5WVdsdVpXUW9kR2hwY3k1dGIyUmxiRjl1WVcxbEtUdGNiaUFnZlZ4dUlDQmhjM2x1WXlCbGJXSmxaRjlpWVhSamFDaHBkR1Z0Y3lrZ2UxeHVJQ0FnSUdsMFpXMXpJRDBnYVhSbGJYTXVabWxzZEdWeUtHbDBaVzBnUFQ0Z2FYUmxiUzVsYldKbFpGOXBibkIxZEQ4dWJHVnVaM1JvSUQ0Z01DazdJQzh2SUhKbGJXOTJaU0JwZEdWdGN5QjNhWFJvSUdWdGNIUjVJR1Z0WW1Wa1gybHVjSFYwSUNoallYVnpaWE1nTG5Od2JHbDBLQ2tnWlhKeWIzSXBYRzRnSUNBZ2FXWW9JV2wwWlcxelB5NXNaVzVuZEdncElISmxkSFZ5YmlCYlhUdGNiaUFnSUNCamIyNXpkQ0IwYjJ0bGJuTWdQU0JoZDJGcGRDQlFjbTl0YVhObExtRnNiQ2hwZEdWdGN5NXRZWEFvYVhSbGJTQTlQaUIwYUdsekxtTnZkVzUwWDNSdmEyVnVjeWhwZEdWdExtVnRZbVZrWDJsdWNIVjBLU2twTzF4dUlDQWdJR052Ym5OMElHVnRZbVZrWDJsdWNIVjBJRDBnWVhkaGFYUWdVSEp2YldselpTNWhiR3dvYVhSbGJYTXViV0Z3S0dGemVXNWpJQ2hwZEdWdExDQnBLU0E5UGlCN1hHNGdJQ0FnSUNCcFppQW9kRzlyWlc1elcybGRJRHdnZEdocGN5NXRZWGhmZEc5clpXNXpLU0J5WlhSMWNtNGdhWFJsYlM1bGJXSmxaRjlwYm5CMWREdGNiaUFnSUNBZ0lHeGxkQ0IwYjJ0bGJsOWpkQ0E5SUhSdmEyVnVjMXRwWFR0Y2JpQWdJQ0FnSUd4bGRDQjBjblZ1WTJGMFpXUmZhVzV3ZFhRZ1BTQnBkR1Z0TG1WdFltVmtYMmx1Y0hWME8xeHVJQ0FnSUNBZ2QyaHBiR1VnS0hSdmEyVnVYMk4wSUQ0Z2RHaHBjeTV0WVhoZmRHOXJaVzV6S1NCN1hHNGdJQ0FnSUNBZ0lHTnZibk4wSUhCamRDQTlJSFJvYVhNdWJXRjRYM1J2YTJWdWN5QXZJSFJ2YTJWdVgyTjBPeUF2THlCblpYUWdjR04wSUc5bUlHbHVjSFYwSUhSdklHdGxaWEJjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdiV0Y0WDJOb1lYSnpJRDBnVFdGMGFDNW1iRzl2Y2loMGNuVnVZMkYwWldSZmFXNXdkWFF1YkdWdVozUm9JQ29nY0dOMElDb2dNQzQ1TUNrN0lDOHZJR2RsZENCdWRXMWlaWElnYjJZZ1kyaGhjbUZqZEdWeWN5QjBieUJyWldWd0lDaHRhVzUxY3lBeE1DVWdabTl5SUhOaFptVjBlU2xjYmlBZ0lDQWdJQ0FnZEhKMWJtTmhkR1ZrWDJsdWNIVjBJRDBnZEhKMWJtTmhkR1ZrWDJsdWNIVjBMbk4xWW5OMGNtbHVaeWd3TENCdFlYaGZZMmhoY25NcElDc2dYQ0l1TGk1Y0lqdGNiaUFnSUNBZ0lDQWdkRzlyWlc1ZlkzUWdQU0JoZDJGcGRDQjBhR2x6TG1OdmRXNTBYM1J2YTJWdWN5aDBjblZ1WTJGMFpXUmZhVzV3ZFhRcE8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0x5OGdZMjl1YzI5c1pTNXNiMmNvWENKSmJuQjFkQ0IwYjI4Z2JHOXVaeTRnVkhKMWJtTmhkR2x1WnlCMGJ5QmNJaXdnZEhKMWJtTmhkR1ZrWDJsdWNIVjBMbXhsYm1kMGFDd2dYQ0lnWTJoaGNtRmpkR1Z5Y3k1Y0lpazdYRzRnSUNBZ0lDQXZMeUJqYjI1emIyeGxMbXh2WnloY0lsUnZhMlZ1Y3pvZ1hDSXNJSFJ2YTJWdWMxdHBYU3dnWENJZ0xUNGdYQ0lzSUhSdmEyVnVYMk4wS1R0Y2JpQWdJQ0FnSUhSdmEyVnVjMXRwWFNBOUlIUnZhMlZ1WDJOME8xeHVJQ0FnSUNBZ2NtVjBkWEp1SUhSeWRXNWpZWFJsWkY5cGJuQjFkRHRjYmlBZ0lDQjlLU2s3WEc1Y2JpQWdJQ0F2THlCamIyNXpiMnhsTG14dlp5aGxiV0psWkY5cGJuQjFkQ2s3WEc0Z0lDQWdkSEo1ZTF4dUlDQWdJQ0FnWTI5dWMzUWdjbVZ6Y0NBOUlHRjNZV2wwSUhSb2FYTXViVzlrWld3b1pXMWlaV1JmYVc1d2RYUXNJSHNnY0c5dmJHbHVaem9nSjIxbFlXNG5MQ0J1YjNKdFlXeHBlbVU2SUhSeWRXVWdmU2s3WEc0Z0lDQWdJQ0F2THlCamIyNXpiMnhsTG14dlp5aHlaWE53S1R0Y2JpQWdJQ0FnSUhKbGRIVnliaUJwZEdWdGN5NXRZWEFvS0dsMFpXMHNJR2twSUQwK0lIdGNiaUFnSUNBZ0lDQWdhWFJsYlM1MlpXTWdQU0JCY25KaGVTNW1jbTl0S0hKbGMzQmJhVjB1WkdGMFlTazdYRzRnSUNBZ0lDQWdJR2wwWlcwdWRHOXJaVzV6SUQwZ2RHOXJaVzV6VzJsZE8xeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2FYUmxiVHRjYmlBZ0lDQWdJSDBwTzF4dUlDQWdJSDFqWVhSamFDaGxjbklwZTF4dUlDQWdJQ0FnWTI5dWMyOXNaUzVzYjJjb1pYSnlLVHRjYmlBZ0lDQWdJR052Ym5OdmJHVXViRzluS0Z3aVJYSnliM0lnWlcxaVpXUmthVzVuSUdKaGRHTm9MaUJVY25scGJtY2diMjVsSUdGMElHRWdkR2x0WlM0dUxsd2lLVHRjYmlBZ0lDQjlYRzRnSUNBZ1kyOXVjM1FnY21WemNDQTlJR0YzWVdsMElGQnliMjFwYzJVdVlXeHNLR2wwWlcxekxtMWhjQ2hoYzNsdVl5QnBkR1Z0SUQwK0lIdGNiaUFnSUNBZ0lHTnZibk4wSUhzZ2RtVmpMQ0IwYjJ0bGJuTXNJR1Z5Y205eUlIMGdQU0JoZDJGcGRDQjBhR2x6TG1WdFltVmtLR2wwWlcwdVpXMWlaV1JmYVc1d2RYUXBPMXh1SUNBZ0lDQWdhV1lvWlhKeWIzSXBlMXh1SUNBZ0lDQWdJQ0JqYjI1emIyeGxMbXh2WnloY0lrVnljbTl5SUdWdFltVmtaR2x1WnlCcGRHVnRPaUJjSWl3Z2FYUmxiUzVyWlhrcE8xeHVJQ0FnSUNBZ0lDQmpiMjV6YjJ4bExteHZaeWhsY25KdmNpazdYRzRnSUNBZ0lDQWdJR2wwWlcwdVpYSnliM0lnUFNCbGNuSnZjanRjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJR2wwWlcwN1hHNGdJQ0FnSUNCOVhHNGdJQ0FnSUNCcFppZ2hkbVZqS1h0Y2JpQWdJQ0FnSUNBZ1kyOXVjMjlzWlM1c2IyY29YQ0pGY25KdmNpQmxiV0psWkdScGJtY2dhWFJsYlRvZ1hDSXNJR2wwWlcwdWEyVjVLVHRjYmlBZ0lDQWdJQ0FnWTI5dWMyOXNaUzVzYjJjb1hDSldaV002SUZ3aUxDQjJaV01wTzF4dUlDQWdJQ0FnSUNCamIyNXpiMnhsTG14dlp5aGNJa1Z5Y205eU9pQmNJaXdnWlhKeWIzSXBPMXh1SUNBZ0lDQWdJQ0JqYjI1emIyeGxMbXh2WnloY0lsUnZhMlZ1Y3pvZ1hDSXNJSFJ2YTJWdWN5azdYRzRnSUNBZ0lDQWdJR052Ym5OdmJHVXViRzluS0Z3aVRtOGdkbVZqSUhKbGRIVnlibVZrWENJcE8xeHVJQ0FnSUNBZ0lDQnBkR1Z0TG1WeWNtOXlJRDBnWENKT2J5QjJaV01nY21WMGRYSnVaV1JjSWp0Y2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUdsMFpXMDdYRzRnSUNBZ0lDQjlYRzRnSUNBZ0lDQnBkR1Z0TG5abFl5QTlJSFpsWXk1dFlYQW9kbUZzSUQwK0lFMWhkR2d1Y205MWJtUW9kbUZzSUNvZ01UQXdNREF3TURBd0tTQXZJREV3TURBd01EQXdNQ2s3SUM4dklISmxaSFZqWlNCd2NtVmphWE5wYjI0Z2RHOGdPQ0JrWldOcGJXRnNJSEJzWVdObGN5QnlaV1k2SUdoMGRIQnpPaTh2ZDJab1luSnBZVzR1WTI5dEwzWmxZM1J2Y2kxa2FXMWxibk5wYjI0dGNISmxZMmx6YVc5dUxXVm1abVZqZEMxdmJpMWpiM05wYm1VdGMybHRhV3hoY21sMGVTOWNiaUFnSUNBZ0lHbDBaVzB1ZEc5clpXNXpJRDBnZEc5clpXNXpPMXh1SUNBZ0lDQWdjbVYwZFhKdUlHbDBaVzA3WEc0Z0lDQWdmU2twTzF4dUlDQWdJSEpsZEhWeWJpQnlaWE53TzF4dUlDQjlYRzRnSUdGemVXNWpJR1Z0WW1Wa0tHbHVjSFYwS1NCN1hHNGdJQ0FnWTI5dWMzUWdiM1YwY0hWMElEMGdleUJsYldKbFpGOXBibkIxZERvZ2FXNXdkWFFnZlR0Y2JpQWdJQ0JwWmlBb0lXbHVjSFYwS1NCeVpYUjFjbTRnZXlBdUxpNXZkWFJ3ZFhRc0lHVnljbTl5T2lCY0lrNXZJR2x1Y0hWMElIUmxlSFF1WENJZ2ZUdGNiaUFnSUNCcFppQW9JWFJvYVhNdWJXOWtaV3dwSUdGM1lXbDBJSFJvYVhNdWFXNXBkQ2dwTzF4dUlDQWdJSFJ5ZVNCN1hHNGdJQ0FnSUNCdmRYUndkWFF1ZEc5clpXNXpJRDBnWVhkaGFYUWdkR2hwY3k1amIzVnVkRjkwYjJ0bGJuTW9hVzV3ZFhRcE8xeHVJQ0FnSUNBZ2FXWWdLRzkxZEhCMWRDNTBiMnRsYm5NZ1BDQXhLU0J5WlhSMWNtNGdleUF1TGk1dmRYUndkWFFzSUdWeWNtOXlPaUJjSWtsdWNIVjBJSFJ2YnlCemFHOXlkQzVjSWlCOU8xeHVJQ0FnSUNBZ2FXWWdLRzkxZEhCMWRDNTBiMnRsYm5NZ1BDQjBhR2x6TG0xaGVGOTBiMnRsYm5NcElIdGNiaUFnSUNBZ0lDQWdZMjl1YzNRZ1pXMWlaV1JrYVc1bklEMGdZWGRoYVhRZ2RHaHBjeTV0YjJSbGJDaHBibkIxZEN3Z2V5QndiMjlzYVc1bk9pQW5iV1ZoYmljc0lHNXZjbTFoYkdsNlpUb2dkSEoxWlNCOUtUdGNiaUFnSUNBZ0lDQWdiM1YwY0hWMExuWmxZeUE5SUVGeWNtRjVMbVp5YjIwb1pXMWlaV1JrYVc1bkxtUmhkR0VwTG0xaGNDaDJZV3dnUFQ0Z1RXRjBhQzV5YjNWdVpDaDJZV3dnS2lBeE1EQXdNREF3TURBcElDOGdNVEF3TURBd01EQXdLVHNnTHk4Z2NtVmtkV05sSUhCeVpXTnBjMmx2YmlCMGJ5QTRJR1JsWTJsdFlXd2djR3hoWTJWeklISmxaam9nYUhSMGNITTZMeTkzWm1oaWNtbGhiaTVqYjIwdmRtVmpkRzl5TFdScGJXVnVjMmx2Ymkxd2NtVmphWE5wYjI0dFpXWm1aV04wTFc5dUxXTnZjMmx1WlMxemFXMXBiR0Z5YVhSNUwxeHVJQ0FnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUNBZ1kyOXVjM1FnY0dOMElEMGdkR2hwY3k1dFlYaGZkRzlyWlc1eklDOGdiM1YwY0hWMExuUnZhMlZ1Y3pzZ0x5OGdaMlYwSUhCamRDQnZaaUJwYm5CMWRDQjBieUJyWldWd1hHNGdJQ0FnSUNBZ0lHTnZibk4wSUcxaGVGOWphR0Z5Y3lBOUlFMWhkR2d1Wm14dmIzSW9hVzV3ZFhRdWJHVnVaM1JvSUNvZ2NHTjBJQ29nTUM0NU5TazdJQzh2SUdkbGRDQnVkVzFpWlhJZ2IyWWdZMmhoY21GamRHVnljeUIwYnlCclpXVndJQ2h0YVc1MWN5QTFKU0JtYjNJZ2MyRm1aWFI1S1Z4dUlDQWdJQ0FnSUNCcGJuQjFkQ0E5SUdsdWNIVjBMbk4xWW5OMGNtbHVaeWd3TENCdFlYaGZZMmhoY25NcElDc2dYQ0l1TGk1Y0lqdGNiaUFnSUNBZ0lDQWdiM1YwY0hWMExuUnlkVzVqWVhSbFpDQTlJSFJ5ZFdVN1hHNGdJQ0FnSUNBZ0lHTnZibk52YkdVdWJHOW5LRndpU1c1d2RYUWdkRzl2SUd4dmJtY3VJRlJ5ZFc1allYUnBibWNnZEc4Z1hDSXNJR2x1Y0hWMExteGxibWQwYUN3Z1hDSWdZMmhoY21GamRHVnljeTVjSWlrN1hHNGdJQ0FnSUNBZ0lHTnZibk4wSUhzZ2RtVmpMQ0IwYjJ0bGJuTWdmU0E5SUdGM1lXbDBJSFJvYVhNdVpXMWlaV1FvYVc1d2RYUXBPMXh1SUNBZ0lDQWdJQ0J2ZFhSd2RYUXVkbVZqSUQwZ2RtVmpPMXh1SUNBZ0lDQWdJQ0J2ZFhSd2RYUXVkRzlyWlc1eklEMGdkRzlyWlc1ek8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ2NtVjBkWEp1SUc5MWRIQjFkRHRjYmlBZ0lDQjlJR05oZEdOb0lDaGxjbklwSUh0Y2JpQWdJQ0FnSUdOdmJuTnZiR1V1Ykc5bktHVnljaWs3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdleUF1TGk1dmRYUndkWFFzSUdWeWNtOXlPaUJsY25JdWJXVnpjMkZuWlNCOU8xeHVJQ0FnSUgxY2JpQWdmVnh1SUNCaGMzbHVZeUJqYjNWdWRGOTBiMnRsYm5Nb2RHVjRkQ2tnZTF4dUlDQWdJR2xtSUNnaGRHaHBjeTUwYjJ0bGJtbDZaWElwSUdGM1lXbDBJSFJvYVhNdWFXNXBkQ2dwTzF4dUlDQWdJR052Ym5OMElIc2dhVzV3ZFhSZmFXUnpJSDBnUFNCaGQyRnBkQ0IwYUdsekxuUnZhMlZ1YVhwbGNpaDBaWGgwS1R0Y2JpQWdJQ0J5WlhSMWNtNGdhVzV3ZFhSZmFXUnpMbVJoZEdFdWJHVnVaM1JvT3lBdkx5QlNaWFIxY200Z2RHaGxJRzUxYldKbGNpQnZaaUIwYjJ0bGJuTmNiaUFnZlZ4dWZWeHVYRzVsZUhCdmNuUnpMbFJ5WVc1elptOXliV1Z5YzBGa1lYQjBaWElnUFNCVWNtRnVjMlp2Y20xbGNuTkJaR0Z3ZEdWeU95SXNJQ0pqYjI1emRDQjdJRlJ5WVc1elptOXliV1Z5YzBGa1lYQjBaWElnZlNBOUlISmxjWFZwY21Vb0p5NHZZV1JoY0hSbGNuTXZkSEpoYm5ObWIzSnRaWEp6SnlrN1hHNWNiaTh2SUVOUFRrNUZRMVJQVWlCR1QxSWdUMEpUU1VSSlFVNWNibU5zWVhOeklGUnlZVzV6Wm05eWJXVnljMGxtY21GdFpVTnZibTVsWTNSdmNpQmxlSFJsYm1SeklGUnlZVzV6Wm05eWJXVnljMEZrWVhCMFpYSWdlMXh1SUNCamIyNXpkSEoxWTNSdmNpaHRiMlJsYkY5amIyNW1hV2NzSUhkcGJtUnZkeWtnZTF4dUlDQWdJSE4xY0dWeUtIdGpiMjVtYVdjNklHMXZaR1ZzWDJOdmJtWnBaMzBwT3lBdkx5QmhjM05wWjI1eklHTnZibVpwWnlCMGJ5QjBhR2x6SUdsdUlFRmtZWEIwWlhKY2JpQWdJQ0IwYUdsekxtMXZaR1ZzSUQwZ2JuVnNiRHRjYmlBZ0lDQjBhR2x6TG5KMWJtNXBibWRmYVc1cGRDQTlJR1poYkhObE8xeHVJQ0FnSUhSb2FYTXVkMmx1Wkc5M0lEMGdkMmx1Wkc5M08xeHVJQ0FnSUM4dklITjBZWFJ6WEc0Z0lDQWdkR2hwY3k1bGJXSmxaRjlqZENBOUlEQTdYRzRnSUNBZ2RHaHBjeTUwYVcxbGMzUmhiWEFnUFNCdWRXeHNPMXh1SUNBZ0lIUm9hWE11ZEc5clpXNXpJRDBnTUR0Y2JpQWdmVnh1SUNCemRHRjBhV01nWVhONWJtTWdZM0psWVhSbEtHMXZaR1ZzWDJOdmJtWnBaeXdnZDJsdVpHOTNLU0I3WEc0Z0lDQWdZMjl1YzNRZ1kyOXVibVZqZEc5eUlEMGdibVYzSUZSeVlXNXpabTl5YldWeWMwbG1jbUZ0WlVOdmJtNWxZM1J2Y2lodGIyUmxiRjlqYjI1bWFXY3NJSGRwYm1SdmR5azdYRzRnSUNBZ1lYZGhhWFFnWTI5dWJtVmpkRzl5TG1sdWFYUW9LVHRjYmlBZ0lDQnlaWFIxY200Z1kyOXVibVZqZEc5eU8xeHVJQ0I5WEc0Z0lHRnplVzVqSUdsdWFYUW9LU0I3WEc0Z0lDQWdhV1lnS0hSb2FYTXViVzlrWld3cElISmxkSFZ5YmlCamIyNXpiMnhsTG14dlp5aGNJbE50WVhKMElFeHZZMkZzSUUxdlpHVnNJR0ZzY21WaFpIa2diRzloWkdWa1hDSXBPMXh1SUNBZ0lHbG1JQ2gwYUdsekxuSjFibTVwYm1kZmFXNXBkQ2tnWVhkaGFYUWdibVYzSUZCeWIyMXBjMlVvY21WemIyeDJaU0E5UGlCelpYUlVhVzFsYjNWMEtISmxjMjlzZG1Vc0lETXdNREFwS1R0Y2JpQWdJQ0JwWmlBb0lYUm9hWE11Ylc5a1pXd2dKaVlnSVhSb2FYTXVjblZ1Ym1sdVoxOXBibWwwS1NCMGFHbHpMbkoxYm01cGJtZGZhVzVwZENBOUlIUnlkV1U3WEc0Z0lDQWdZMjl1YzI5c1pTNXNiMmNvWENKTWIyRmthVzVuSUZOdFlYSjBJRXh2WTJGc0lFMXZaR1ZzWENJcE8xeHVJQ0FnSUM4dklHTnZibk4wSUhzZ2NHbHdaV3hwYm1Vc0lHVnVkaXdnUVhWMGIxUnZhMlZ1YVhwbGNpQjlJRDBnWVhkaGFYUWdhVzF3YjNKMEtDZG9kSFJ3Y3pvdkwyTmtiaTVxYzJSbGJHbDJjaTV1WlhRdmJuQnRMMEI0Wlc1dmRtRXZkSEpoYm5ObWIzSnRaWEp6UURJdU1UTXVNQ2NwTzF4dUlDQWdJR052Ym5OMElIc2djR2x3Wld4cGJtVXNJR1Z1ZGl3Z1FYVjBiMVJ2YTJWdWFYcGxjaUI5SUQwZ1lYZGhhWFFnYVcxd2IzSjBLQ2RvZEhSd2N6b3ZMMk5rYmk1cWMyUmxiR2wyY2k1dVpYUXZibkJ0TDBCNFpXNXZkbUV2ZEhKaGJuTm1iM0p0WlhKelFHeGhkR1Z6ZENjcE8xeHVJQ0FnSUdWdWRpNWhiR3h2ZDB4dlkyRnNUVzlrWld4eklEMGdabUZzYzJVN1hHNGdJQ0FnZEdocGN5NXRiMlJsYkNBOUlHRjNZV2wwSUhCcGNHVnNhVzVsS0NkbVpXRjBkWEpsTFdWNGRISmhZM1JwYjI0bkxDQjBhR2x6TG0xdlpHVnNYMjVoYldVc0lIc2djWFZoYm5ScGVtVmtPaUIwY25WbElIMHBPMXh1SUNBZ0lIUm9hWE11ZEc5clpXNXBlbVZ5SUQwZ1lYZGhhWFFnUVhWMGIxUnZhMlZ1YVhwbGNpNW1jbTl0WDNCeVpYUnlZV2x1WldRb2RHaHBjeTV0YjJSbGJGOXVZVzFsS1R0Y2JpQWdJQ0IwYUdsekxuSjFibTVwYm1kZmFXNXBkQ0E5SUdaaGJITmxPMXh1SUNBZ0lIUm9hWE11ZDJsdVpHOTNMblJ2YTJWdWFYcGxjaUE5SUhSb2FYTXVkRzlyWlc1cGVtVnlPMXh1SUNBZ0lHTnZibk52YkdVdWJHOW5LR0YzWVdsMElIUm9hWE11WlcxaVpXUW9YQ0owWlhOMFhDSXBLVHRjYmlBZ0lDQjBhR2x6TG5kcGJtUnZkeTV3WVhKbGJuUXVjRzl6ZEUxbGMzTmhaMlVvZXlCMGVYQmxPaUJjSW0xdlpHVnNYMnh2WVdSbFpGd2lMQ0JrWVhSaE9pQjBjblZsSUgwc0lGd2lLbHdpS1RzZ0x5OGdjRzl6ZENCdFpYTnpZV2RsSUhSdklIQmhjbVZ1ZENCMGFHRjBJRzF2WkdWc0lHbHpJR3h2WVdSbFpGeHVJQ0FnSUhSb2FYTXVkMmx1Wkc5M0xtRmtaRVYyWlc1MFRHbHpkR1Z1WlhJb1hDSnRaWE56WVdkbFhDSXNJSFJvYVhNdWFHRnVaR3hsWDJsd1l5NWlhVzVrS0hSb2FYTXBMQ0JtWVd4elpTazdYRzRnSUgxY2JpQWdZWE41Ym1NZ2FHRnVaR3hsWDJsd1l5aGxkbVZ1ZENrZ2UxeHVJQ0FnSUdsbUlDaGxkbVZ1ZEM1a1lYUmhMblI1Y0dVZ1BUMGdYQ0p6YldGeWRGOWxiV0psWkZ3aUtTQjBhR2x6TG1WdFltVmtYMmhoYm1Sc1pYSW9aWFpsYm5RdVpHRjBZU2s3WEc0Z0lDQWdMeThnYVdZZ0tHVjJaVzUwTG1SaGRHRXVkSGx3WlNBOVBTQmNJbk50WVhKMFgyVnRZbVZrWDJKaGRHTm9YQ0lwSUhSb2FYTXVaVzFpWldSZlltRjBZMmhmYUdGdVpHeGxjaWhsZG1WdWRDNWtZWFJoTG1WdFltVmtYMmx1Y0hWMEtUdGNiaUFnSUNCcFppQW9aWFpsYm5RdVpHRjBZUzUwZVhCbElEMDlJRndpYzIxaGNuUmZaVzFpWldSZmRHOXJaVzVmWTNSY0lpa2dkR2hwY3k1amIzVnVkRjkwYjJ0bGJuTmZhR0Z1Wkd4bGNpaGxkbVZ1ZEM1a1lYUmhMbVZ0WW1Wa1gybHVjSFYwS1R0Y2JpQWdmVnh1SUNCaGMzbHVZeUJsYldKbFpGOW9ZVzVrYkdWeUtHVjJaVzUwWDJSaGRHRXBJSHRjYmlBZ0lDQmpiMjV6ZENCN0lHVnRZbVZrWDJsdWNIVjBMQ0JvWVc1a2JHVnlYMmxrSUgwZ1BTQmxkbVZ1ZEY5a1lYUmhPMXh1SUNBZ0lDOHZJR052Ym5OdmJHVXViRzluS0dWdFltVmtYMmx1Y0hWMEtUdGNiaUFnSUNCcFppZ2hkR2hwY3k1MGFXMWxjM1JoYlhBcElIUm9hWE11ZEdsdFpYTjBZVzF3SUQwZ1JHRjBaUzV1YjNjb0tUdGNiaUFnSUNCcFppaEJjbkpoZVM1cGMwRnljbUY1S0dWdFltVmtYMmx1Y0hWMEtTa2dlMXh1SUNBZ0lDQWdZMjl1YzNRZ2NtVnpjQ0E5SUdGM1lXbDBJSFJvYVhNdVpXMWlaV1JmWW1GMFkyZ29aVzFpWldSZmFXNXdkWFFwTzF4dUlDQWdJQ0FnWTI5dWMzUWdjMlZ1WkY5a1lYUmhJRDBnZTF4dUlDQWdJQ0FnSUNCMGVYQmxPaUJjSW5OdFlYSjBYMlZ0WW1Wa1gzSmxjM0JjSWl4Y2JpQWdJQ0FnSUNBZ2FHRnVaR3hsY2w5cFpDeGNiaUFnSUNBZ0lDQWdaR0YwWVRvZ2NtVnpjQ3hjYmlBZ0lDQWdJSDA3WEc0Z0lDQWdJQ0IwYUdsekxuZHBibVJ2ZHk1d2IzTjBUV1Z6YzJGblpTaHpaVzVrWDJSaGRHRXNJRndpS2x3aUtUdGNiaUFnSUNBZ0lIUm9hWE11ZEc5clpXNXpJQ3M5SUhKbGMzQXVjbVZrZFdObEtDaGhZMk1zSUdsMFpXMHBJRDArSUdGall5QXJJR2wwWlcwdWRHOXJaVzV6TENBd0tUdGNiaUFnSUNBZ0lIUm9hWE11WlcxaVpXUmZZM1FnS3owZ2NtVnpjQzVzWlc1bmRHZzdYRzRnSUNBZ2ZXVnNjMlY3WEc0Z0lDQWdJQ0JwWmlBb0lYUm9hWE11ZEdsdFpYTjBZVzF3S1NCMGFHbHpMblJwYldWemRHRnRjQ0E5SUVSaGRHVXVibTkzS0NrN1hHNGdJQ0FnSUNCamIyNXpkQ0J6Wlc1a1gyUmhkR0VnUFNCaGQyRnBkQ0IwYUdsekxtVnRZbVZrS0dWdFltVmtYMmx1Y0hWMEtUdGNiaUFnSUNBZ0lITmxibVJmWkdGMFlTNTBlWEJsSUQwZ1hDSnpiV0Z5ZEY5bGJXSmxaRjl5WlhOd1hDSTdYRzRnSUNBZ0lDQnBaaUFvYUdGdVpHeGxjbDlwWkNrZ2MyVnVaRjlrWVhSaExtaGhibVJzWlhKZmFXUWdQU0JvWVc1a2JHVnlYMmxrTzF4dUlDQWdJQ0FnZEdocGN5NTNhVzVrYjNjdWNHOXpkRTFsYzNOaFoyVW9jMlZ1WkY5a1lYUmhMQ0JjSWlwY0lpazdYRzRnSUNBZ0lDQjBhR2x6TG5SdmEyVnVjeUFyUFNCelpXNWtYMlJoZEdFdWRHOXJaVzV6TzF4dUlDQWdJQ0FnZEdocGN5NWxiV0psWkY5amRDc3JPMXh1SUNBZ0lIMWNiaUFnSUNCcFppQW9SR0YwWlM1dWIzY29LU0F0SUhSb2FYTXVkR2x0WlhOMFlXMXdJRDRnTVRBd01EQXBJSHRjYmlBZ0lDQWdJR052Ym5OdmJHVXViRzluS0dCRmJXSmxaR1JsWkRvZ0pIdDBhR2x6TG1WdFltVmtYMk4wZlNCcGJuQjFkSE1nS0NSN2RHaHBjeTUwYjJ0bGJuTjlJSFJ2YTJWdWN5d2dKSHNvZEdocGN5NTBiMnRsYm5NZ0x5QW9LRVJoZEdVdWJtOTNLQ2tnTFNCMGFHbHpMblJwYldWemRHRnRjQ2tnTHlBeE1EQXdLU2t1ZEc5R2FYaGxaQ2d3S1gwZ2RHOXJaVzV6TDNObFl5bGdLVHRjYmlBZ0lDQWdJSFJvYVhNdWRHbHRaWE4wWVcxd0lEMGdiblZzYkR0Y2JpQWdJQ0FnSUhSb2FYTXVkRzlyWlc1eklEMGdNRHRjYmlBZ0lDQWdJSFJvYVhNdVpXMWlaV1JmWTNRZ1BTQXdPMXh1SUNBZ0lIMWNiaUFnZlZ4dUlDQmhjM2x1WXlCamIzVnVkRjkwYjJ0bGJuTmZhR0Z1Wkd4bGNpaHBibkIxZENrZ2UxeHVJQ0FnSUdOdmJuTjBJRzkxZEhCMWRDQTlJR0YzWVdsMElIUm9hWE11WTI5MWJuUmZkRzlyWlc1ektHbHVjSFYwS1R0Y2JpQWdJQ0JqYjI1emRDQnpaVzVrWDJSaGRHRWdQU0I3WEc0Z0lDQWdJQ0IwZVhCbE9pQmNJbk50WVhKMFgyVnRZbVZrWDNSdmEyVnVYMk4wWENJc1hHNGdJQ0FnSUNCMFpYaDBPaUJjSW1OdmRXNTBPbHdpSUNzZ2FXNXdkWFFzWEc0Z0lDQWdJQ0JqYjNWdWREb2diM1YwY0hWMFhHNGdJQ0FnZlR0Y2JpQWdJQ0IwYUdsekxuZHBibVJ2ZHk1d2IzTjBUV1Z6YzJGblpTaHpaVzVrWDJSaGRHRXNJRndpS2x3aUtUdGNiaUFnZlZ4dWZWeHVaWGh3YjNKMGN5NVVjbUZ1YzJadmNtMWxjbk5KWm5KaGJXVkRiMjV1WldOMGIzSWdQU0JVY21GdWMyWnZjbTFsY25OSlpuSmhiV1ZEYjI1dVpXTjBiM0k3WEc1Y2JpSXNJQ0ozYVc1a2IzY3VZV1JrUlhabGJuUk1hWE4wWlc1bGNpZ25iV1Z6YzJGblpTY3NJR2x1YVhRcE95QXZMeUJzYVhOMFpXNGdabTl5SUdsdWFYUWdiV1Z6YzJGblpWeHVZWE41Ym1NZ1puVnVZM1JwYjI0Z2FXNXBkQ2hsZG1WdWRDa2dlMXh1SUNCcFppQW9aWFpsYm5RdVpHRjBZUzUwZVhCbElEMDlQU0FuYVc1cGRDY3BJSHRjYmlBZ0lDQjNhVzVrYjNjdWNtVnRiM1psUlhabGJuUk1hWE4wWlc1bGNpZ25iV1Z6YzJGblpTY3NJR2x1YVhRcE95QXZMeUJ5WlcxdmRtVWdkR2hwY3lCbGRtVnVkQ0JzYVhOMFpXNWxjbHh1SUNBZ0lHTnZibk4wSUcxdlpHVnNYMk52Ym1acFp5QTlJR1YyWlc1MExtUmhkR0V1Ylc5a1pXeGZZMjl1Wm1sbk8xeHVJQ0FnSUdOdmJuTnZiR1V1Ykc5bktHMXZaR1ZzWDJOdmJtWnBaeWs3WEc0Z0lDQWdZMjl1YzNRZ2V5QlVjbUZ1YzJadmNtMWxjbk5KWm5KaGJXVkRiMjV1WldOMGIzSWdmU0E5SUdGM1lXbDBJR2x0Y0c5eWRDZ25MaTkwY21GdWMyWnZjbTFsY25OZmFXWnlZVzFsTG1wekp5azdYRzRnSUNBZ1kyOXVjM1FnYlc5a1pXd2dQU0JoZDJGcGRDQlVjbUZ1YzJadmNtMWxjbk5KWm5KaGJXVkRiMjV1WldOMGIzSXVZM0psWVhSbEtHMXZaR1ZzWDJOdmJtWnBaeXdnZDJsdVpHOTNLVHRjYmlBZ0lDQjNhVzVrYjNjdWJXOWtaV3dnUFNCdGIyUmxiRHRjYmlBZ2ZWeHVmU0pkTEFvZ0lDSnRZWEJ3YVc1bmN5STZJQ0k3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenRCUVVGQk8wRkJRVUU3UVVGSFFTeFJRVUZOTEZWQlFVNHNUVUZCWXp0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUVzVFVGTFdpeFpRVUZaTEUxQlFVMDdRVUZMYUVJc1lVRkJTeXhQUVVGUE8wRkJTMW9zWlVGQlR5eFBRVUZQTEUxQlFVMHNTMEZCU3l4TlFVRk5PMEZCUVVFc1RVRkRha003UVVGQlFTeEpRVU5HTzBGQlIwRXNXVUZCVVN4VlFVRlZPMEZCUVVFN1FVRkJRVHM3TzBGRGRrSnNRanRCUVVGQk8wRkJRVUVzVVVGQlRTeEZRVUZGTEZGQlFWRXNTVUZCU1R0QlFVVndRaXhSUVVGTkxITkNRVUZPTEdOQlFXdERMRkZCUVZFN1FVRkJRU3hOUVVONFF5eE5RVUZOTEU5QlFVODdRVUZEV0N4alFVRk5MRVZCUVVVc1MwRkJTeXhWUVVGVkxHTkJRV01zU1VGQlNTeE5RVUZOTEU5QlFVOHNjMEpCUVhOQ08wRkJRelZGTEZsQlFVa3NiVUpCUVcxQ08wRkJRM1pDTEdGQlFVc3NVVUZCVVN4TlFVRk5MRk5CUVZNc2MwSkJRWE5DTEV0QlFVc3NXVUZCV1N4RlFVRkZMRmRCUVZjc1RVRkJUU3haUVVGWkxFdEJRVXNzVjBGQlZ5eERRVUZETzBGQlJXNUlMR0ZCUVVzc1dVRkJXU3hOUVVGTkxHTkJRV01zWjBKQlFXZENMRXRCUVVzc1ZVRkJWVHRCUVVGQkxFMUJRM1JGTzBGQlFVRXNUVUZEUVN4TlFVRk5MRmxCUVZrc1QwRkJUenRCUVVOMlFpeG5Ra0ZCVVN4TlFVRk5MRTlCUVU4c1ZVRkJTenRCUVZnNVFqdEJRVmRwUXl3MlFrRkJTeXhuUWtGQlRDeHRRa0ZCYTBJc1ZVRkJVenRCUVVGQkxGTkJRVU03UVVGRGVrUXNXVUZCUnl4RlFVRkRMQ3RDUVVGUE8wRkJRVkVzYVVKQlFVOHNRMEZCUXp0QlFVTXpRaXhqUVVGTkxGTkJRVk1zVFVGQlRTeFJRVUZSTEVsQlFVa3NUVUZCVFN4SlFVRkpMRlZCUVZFc1MwRkJTeXhoUVVGaExFdEJRVXNzVjBGQlZ5eERRVUZETEVOQlFVTTdRVUZEZGtZc1kwRkJUU3hqUVVGakxFMUJRVTBzVVVGQlVTeEpRVUZKTEUxQlFVMHNTVUZCU1N4UFFVRlBMRTFCUVUwc1RVRkJUVHRCUVVOcVJTeGpRVUZKTEU5QlFVOHNRMEZCUXl4SlFVRkpMRXRCUVVzN1FVRkJXU3h0UWtGQlR5eExRVUZMTzBGQlF6ZERMR05CUVVrc1YwRkJWeXhQUVVGUExFTkJRVU03UVVGRGRrSXNZMEZCU1N4clFrRkJhMElzUzBGQlN6dEJRVU16UWl4cFFrRkJUeXhYUVVGWExFdEJRVXNzV1VGQldUdEJRVU5xUXl4clFrRkJUU3hOUVVGTkxFdEJRVXNzWVVGQllUdEJRVU01UWl4clFrRkJUU3haUVVGWkxFdEJRVXNzVFVGQlRTeG5Ra0ZCWjBJc1UwRkJVeXhOUVVGTkxFZEJRVWs3UVVGRGFFVXNPRUpCUVd0Q0xHZENRVUZuUWl4VlFVRlZMRWRCUVVjc1UwRkJVeXhKUVVGSk8wRkJRelZFTEhWQ1FVRlhMRTFCUVUwc1MwRkJTeXhoUVVGaExHVkJRV1U3UVVGQlFTeFZRVU53UkR0QlFVZEJMR2xDUVVGUExFTkJRVU1zU1VGQlNUdEJRVU5hTEdsQ1FVRlBPMEZCUVVFc1VVRkRWQ3hEUVVGRExFTkJRVU03UVVGSFJpeFpRVUZITzBGQlEwUXNaMEpCUVUxQkxGRkJRVThzVFVGQlRTeExRVUZMTEUxQlFVMHNZVUZCWVN4RlFVRkZMRk5CUVZNc1VVRkJVU3hYUVVGWExFdEJRVXNzUTBGQlF6dEJRVVV2UlN4cFFrRkJUeXhOUVVGTkxFbEJRVWtzUTBGQlF5eE5RVUZOTEUxQlFVMDdRVUZETlVJc2FVSkJRVXNzVFVGQlRTeE5RVUZOTEV0QlFVdEJMRTFCUVVzc1EwRkJReXhGUVVGRkxFbEJRVWs3UVVGRGJFTXNhVUpCUVVzc1UwRkJVeXhQUVVGUExFTkJRVU03UVVGRGRFSXNiVUpCUVU4N1FVRkJRU3hWUVVOVUxFTkJRVU03UVVGQlFTeFJRVU5JTEZOQlFVOHNTMEZCU1R0QlFVTlVMR3RDUVVGUkxFbEJRVWtzUjBGQlJ6dEJRVU5tTEd0Q1FVRlJMRWxCUVVrc1owUkJRV2RFTzBGQlFVRXNVVUZET1VRN1FVRkRRU3hqUVVGTkxFOUJRVThzVFVGQlRTeFJRVUZSTEVsQlFVa3NUVUZCVFN4SlFVRkpMRTlCUVUwc1UwRkJVVHRCUVVOeVJDeG5Ra0ZCVFN4RlFVRkZMRXRCUVVzc1VVRkJRVU1zVTBGQlVTeE5RVUZOTEVsQlFVa3NUVUZCVFN4TFFVRkxMRTFCUVUwc1MwRkJTeXhYUVVGWE8wRkJRMmhGTEdOQlFVY3NUMEZCVFR0QlFVTlFMRzlDUVVGUkxFbEJRVWtzTUVKQlFUQkNMRXRCUVVzc1IwRkJSenRCUVVNNVF5eHZRa0ZCVVN4SlFVRkpMRXRCUVVzN1FVRkRha0lzYVVKQlFVc3NVVUZCVVR0QlFVTmlMRzFDUVVGUE8wRkJRVUVzVlVGRFZEdEJRVU5CTEdOQlFVY3NRMEZCUXl4TFFVRkpPMEZCUTA0c2IwSkJRVkVzU1VGQlNTd3dRa0ZCTUVJc1MwRkJTeXhIUVVGSE8wRkJRemxETEc5Q1FVRlJMRWxCUVVrc1UwRkJVeXhIUVVGSE8wRkJRM2hDTEc5Q1FVRlJMRWxCUVVrc1YwRkJWeXhMUVVGTE8wRkJRelZDTEc5Q1FVRlJMRWxCUVVrc1dVRkJXVUVzVDBGQlRUdEJRVU01UWl4dlFrRkJVU3hKUVVGSkxHbENRVUZwUWp0QlFVTTNRaXhwUWtGQlN5eFJRVUZSTzBGQlEySXNiVUpCUVU4N1FVRkJRU3hWUVVOVU8wRkJRMEVzWlVGQlN5eE5RVUZOTEVsQlFVa3NTVUZCU1N4VFFVRlBMRXRCUVVzc1RVRkJUU3hOUVVGTkxFZEJRVk1zU1VGQlNTeEhRVUZUTzBGQlEycEZMR1ZCUVVzc1UwRkJVMEU3UVVGRFpDeHBRa0ZCVHp0QlFVRkJMRkZCUTFRc1EwRkJReXhEUVVGRE8wRkJRMFlzWlVGQlR6dEJRVUZCTEUxQlExUTdRVUZCUVN4TlFVTkJMRTFCUVUwc1RVRkJUU3hQUVVGUE8wRkJRMnBDTEdOQlFVMHNVMEZCVXl4RlFVRkZMR0ZCUVdFc1RVRkJUVHRCUVVOd1F5eFpRVUZKTEVOQlFVTTdRVUZCVHl4cFFrRkJUeXhGUVVGRkxFZEJRVWNzVVVGQlVTeFBRVUZQTEdsQ1FVRnBRanRCUVVONFJDeFpRVUZKTEVOQlFVTXNTMEZCU3p0QlFVRlBMR2RDUVVGTkxFdEJRVXNzUzBGQlN6dEJRVU5xUXl4WlFVRkpPMEZCUTBZc2FVSkJRVThzVTBGQlV5eE5RVUZOTEV0QlFVc3NZVUZCWVN4TFFVRkxPMEZCUXpkRExHTkJRVWtzVDBGQlR5eFRRVUZUTzBGQlFVY3NiVUpCUVU4c1JVRkJSU3hIUVVGSExGRkJRVkVzVDBGQlR5eHRRa0ZCYlVJN1FVRkRja1VzWTBGQlNTeFBRVUZQTEZOQlFWTXNTMEZCU3l4WlFVRlpPMEZCUTI1RExHdENRVUZOTEZsQlFWa3NUVUZCVFN4TFFVRkxMRTFCUVUwc1QwRkJUeXhGUVVGRkxGTkJRVk1zVVVGQlVTeFhRVUZYTEV0QlFVc3NRMEZCUXp0QlFVTTVSU3h0UWtGQlR5eE5RVUZOTEUxQlFVMHNTMEZCU3l4VlFVRlZMRWxCUVVrc1JVRkJSU3hKUVVGSkxGTkJRVThzUzBGQlN5eE5RVUZOTEUxQlFVMHNSMEZCVXl4SlFVRkpMRWRCUVZNN1FVRkJRU3hWUVVNMVJpeFBRVUZQTzBGQlEwd3NhMEpCUVUwc1RVRkJUU3hMUVVGTExHRkJRV0VzVDBGQlR6dEJRVU55UXl4clFrRkJUU3haUVVGWkxFdEJRVXNzVFVGQlRTeE5RVUZOTEZOQlFWTXNUVUZCVFN4SlFVRkpPMEZCUTNSRUxHOUNRVUZSTEUxQlFVMHNWVUZCVlN4SFFVRkhMRk5CUVZNc1NVRkJTVHRCUVVONFF5eHRRa0ZCVHl4WlFVRlpPMEZCUTI1Q0xHOUNRVUZSTEVsQlFVa3NhME5CUVd0RExFMUJRVTBzVVVGQlVTeGpRVUZqTzBGQlF6RkZMR3RDUVVGTkxFVkJRVVVzUzBGQlN5eFBRVUZQTEVsQlFVa3NUVUZCVFN4TFFVRkxMRTFCUVUwc1MwRkJTenRCUVVNNVF5eHRRa0ZCVHl4TlFVRk5PMEZCUTJJc2JVSkJRVThzVTBGQlV6dEJRVUZCTEZWQlEyeENPMEZCUTBFc2FVSkJRVTg3UVVGQlFTeFJRVU5VTEZOQlFWTXNTMEZCU3p0QlFVTmFMR3RDUVVGUkxFbEJRVWtzUjBGQlJ6dEJRVU5tTEdsQ1FVRlBMRVZCUVVVc1IwRkJSeXhSUVVGUkxFOUJRVThzU1VGQlNTeFJRVUZSTzBGQlFVRXNVVUZEZWtNN1FVRkJRU3hOUVVOR08wRkJRVUVzVFVGRFFTeE5RVUZOTEdGQlFXRXNUVUZCVFR0QlFVTjJRaXhaUVVGSkxFTkJRVU1zUzBGQlN6dEJRVUZYTEdkQ1FVRk5MRXRCUVVzc1MwRkJTenRCUVVOeVF5eGpRVUZOTEVWQlFVVXNWVUZCVlN4SlFVRkpMRTFCUVUwc1MwRkJTeXhWUVVGVkxFbEJRVWs3UVVGREwwTXNaVUZCVHl4VlFVRlZMRXRCUVVzN1FVRkJRU3hOUVVONFFqdEJRVUZCTEVsQlEwWTdRVUZGUVN4WlFVRlJMSE5DUVVGelFqdEJRVUZCTzBGQlFVRTdPenRCUTI1SE9VSTdRVUZCUVR0QlFVRkJMRkZCUVUwc1JVRkJSU3h2UWtGQmIwSXNTVUZCU1R0QlFVZG9ReXhSUVVGTkxEaENRVUZPTEUxQlFVMHNjVU5CUVc5RExHOUNRVUZ2UWp0QlFVRkJMRTFCUXpWRUxGbEJRVmtzWTBGQlkwTXNVMEZCVVR0QlFVTm9ReXhqUVVGTkxFVkJRVU1zVVVGQlVTeGhRVUZaTEVOQlFVTTdRVUZETlVJc1lVRkJTeXhSUVVGUk8wRkJRMklzWVVGQlN5eGxRVUZsTzBGQlEzQkNMR0ZCUVVzc1UwRkJVMEU3UVVGRlpDeGhRVUZMTEZkQlFWYzdRVUZEYUVJc1lVRkJTeXhaUVVGWk8wRkJRMnBDTEdGQlFVc3NVMEZCVXp0QlFVRkJMRTFCUTJoQ08wRkJRVUVzVFVGRFFTeGhRVUZoTEU5QlFVOHNZMEZCWTBFc1UwRkJVVHRCUVVONFF5eGpRVUZOTEZsQlFWa3NTVUZCU1N3MlFrRkJORUlzWTBGQlkwRXNUMEZCVFR0QlFVTjBSU3hqUVVGTkxGVkJRVlVzUzBGQlN6dEJRVU55UWl4bFFVRlBPMEZCUVVFc1RVRkRWRHRCUVVGQkxFMUJRMEVzVFVGQlRTeFBRVUZQTzBGQlExZ3NXVUZCU1N4TFFVRkxPMEZCUVU4c2FVSkJRVThzVVVGQlVTeEpRVUZKTEd0RFFVRnJRenRCUVVOeVJTeFpRVUZKTEV0QlFVczdRVUZCWXl4blFrRkJUU3hKUVVGSkxGRkJRVkVzWVVGQlZ5eFhRVUZYTEZOQlFWTXNSMEZCU1N4RFFVRkRPMEZCUXpkRkxGbEJRVWtzUTBGQlF5eExRVUZMTEZOQlFWTXNRMEZCUXl4TFFVRkxPMEZCUVdNc1pVRkJTeXhsUVVGbE8wRkJRek5FTEdkQ1FVRlJMRWxCUVVrc01rSkJRVEpDTzBGQlJYWkRMR05CUVUwc1JVRkJSU3hWUVVGVkxFdEJRVXNzWTBGQll5eEpRVUZKTEUxQlFVMHNUMEZCVHl3d1JFRkJNRVE3UVVGRGFFZ3NXVUZCU1N4dFFrRkJiVUk3UVVGRGRrSXNZVUZCU3l4UlFVRlJMRTFCUVUwc1UwRkJVeXh6UWtGQmMwSXNTMEZCU3l4WlFVRlpMRVZCUVVVc1YwRkJWeXhMUVVGTExFTkJRVU03UVVGRGRFWXNZVUZCU3l4WlFVRlpMRTFCUVUwc1kwRkJZeXhuUWtGQlowSXNTMEZCU3l4VlFVRlZPMEZCUTNCRkxHRkJRVXNzWlVGQlpUdEJRVU53UWl4aFFVRkxMRTlCUVU4c1dVRkJXU3hMUVVGTE8wRkJRemRDTEdkQ1FVRlJMRWxCUVVrc1RVRkJUU3hMUVVGTExFMUJRVTBzVFVGQlRTeERRVUZETzBGQlEzQkRMR0ZCUVVzc1QwRkJUeXhQUVVGUExGbEJRVmtzUlVGQlJTeE5RVUZOTEdkQ1FVRm5RaXhOUVVGTkxFdEJRVXNzUjBGQlJ5eEhRVUZITzBGQlEzaEZMR0ZCUVVzc1QwRkJUeXhwUWtGQmFVSXNWMEZCVnl4TFFVRkxMRmRCUVZjc1MwRkJTeXhKUVVGSkxFZEJRVWNzUzBGQlN6dEJRVUZCTEUxQlF6TkZPMEZCUVVFc1RVRkRRU3hOUVVGTkxGZEJRVmNzVDBGQlR6dEJRVU4wUWl4WlFVRkpMRTFCUVUwc1MwRkJTeXhSUVVGUk8wRkJRV1VzWlVGQlN5eGpRVUZqTEUxQlFVMHNTVUZCU1R0QlFVVnVSU3haUVVGSkxFMUJRVTBzUzBGQlN5eFJRVUZSTzBGQlFYZENMR1ZCUVVzc2NVSkJRWEZDTEUxQlFVMHNTMEZCU3l4WFFVRlhPMEZCUVVFc1RVRkRha2M3UVVGQlFTeE5RVU5CTEUxQlFVMHNZMEZCWXl4WlFVRlpPMEZCUXpsQ0xHTkJRVTBzUlVGQlJTeGhRVUZoTEZkQlFWY3NTVUZCU1R0QlFVVndReXhaUVVGSExFTkJRVU1zUzBGQlN6dEJRVUZYTEdWQlFVc3NXVUZCV1N4TFFVRkxMRWxCUVVrN1FVRkRPVU1zV1VGQlJ5eE5RVUZOTEZGQlFWRXNWMEZCVnl4SFFVRkhPMEZCUXpkQ0xHZENRVUZOTEU5QlFVOHNUVUZCVFN4TFFVRkxMRmxCUVZrc1YwRkJWenRCUVVNdlF5eG5Ra0ZCVFN4WlFVRlpPMEZCUVVFc1dVRkRhRUlzVFVGQlRUdEJRVUZCTEZsQlEwNDdRVUZCUVN4WlFVTkJMRTFCUVUwN1FVRkJRU3hWUVVOU08wRkJRMEVzWlVGQlN5eFBRVUZQTEZsQlFWa3NWMEZCVnl4SFFVRkhPMEZCUTNSRExHVkJRVXNzVlVGQlZTeExRVUZMTEU5QlFVOHNRMEZCUXl4TFFVRkxMRk5CUVZNc1RVRkJUU3hMUVVGTExGRkJRVkVzUTBGQlF6dEJRVU01UkN4bFFVRkxMRmxCUVZrc1MwRkJTenRCUVVGQkxGRkJRM2hDTEU5QlFVczdRVUZEU0N4alFVRkpMRU5CUVVNc1MwRkJTenRCUVVGWExHbENRVUZMTEZsQlFWa3NTMEZCU3l4SlFVRkpPMEZCUXk5RExHZENRVUZOTEZsQlFWa3NUVUZCVFN4TFFVRkxMRTFCUVUwc1YwRkJWenRCUVVNNVF5eHZRa0ZCVlN4UFFVRlBPMEZCUTJwQ0xHTkJRVWs3UVVGQldTeHpRa0ZCVlN4aFFVRmhPMEZCUTNaRExHVkJRVXNzVDBGQlR5eFpRVUZaTEZkQlFWY3NSMEZCUnp0QlFVTjBReXhsUVVGTExGVkJRVlVzVlVGQlZUdEJRVU42UWl4bFFVRkxPMEZCUVVFc1VVRkRVRHRCUVVOQkxGbEJRVWtzUzBGQlN5eEpRVUZKTEVsQlFVa3NTMEZCU3l4WlFVRlpMRXRCUVU4N1FVRkRka01zYTBKQlFWRXNTVUZCU1N4aFFVRmhMRXRCUVVzc1VVRkJVU3haUVVGWkxFdEJRVXNzVFVGQlRTeGhRVUZoTEV0QlFVc3NWMEZCVnl4TFFVRkxMRWxCUVVrc1NVRkJTU3hMUVVGTExHRkJRV0VzVFVGQlR5eFJRVUZSTEVOQlFVTXNRMEZCUXl4alFVRmpPMEZCUTNoS0xHVkJRVXNzV1VGQldUdEJRVU5xUWl4bFFVRkxMRk5CUVZNN1FVRkRaQ3hsUVVGTExGZEJRVmM3UVVGQlFTeFJRVU5zUWp0QlFVRkJMRTFCUTBZN1FVRkJRU3hOUVVOQkxFMUJRVTBzY1VKQlFYRkNMRTlCUVU4N1FVRkRhRU1zWTBGQlRTeFRRVUZUTEUxQlFVMHNTMEZCU3l4aFFVRmhMRXRCUVVzN1FVRkROVU1zWTBGQlRTeFpRVUZaTzBGQlFVRXNWVUZEYUVJc1RVRkJUVHRCUVVGQkxGVkJRMDRzVFVGQlRTeFhRVUZYTzBGQlFVRXNWVUZEYWtJc1QwRkJUenRCUVVGQkxGRkJRMVE3UVVGRFFTeGhRVUZMTEU5QlFVOHNXVUZCV1N4WFFVRlhMRWRCUVVjN1FVRkJRU3hOUVVONFF6dEJRVUZCTEVsQlEwWTdRVUZEUVN4WlFVRlJMRGhDUVVFNFFqdEJRVUZCTzBGQlFVRTdPenRCUTJoR2RFTXNUMEZCVHl4cFFrRkJhVUlzVjBGQlZ5eEpRVUZKTzBGQlEzWkRMR1ZCUVdVc1MwRkJTeXhQUVVGUE8wRkJRM3BDTEUxQlFVa3NUVUZCVFN4TFFVRkxMRk5CUVZNc1VVRkJVVHRCUVVNNVFpeFhRVUZQTEc5Q1FVRnZRaXhYUVVGWExFbEJRVWs3UVVGRE1VTXNWVUZCVFN4bFFVRmxMRTFCUVUwc1MwRkJTenRCUVVOb1F5eFpRVUZSTEVsQlFVa3NXVUZCV1R0QlFVTjRRaXhWUVVGTkxFVkJRVVVzTkVKQlFUUkNMRWxCUVVrc1RVRkJUVHRCUVVNNVF5eFZRVUZOTEZGQlFWRXNUVUZCVFN3MFFrRkJORUlzVDBGQlR5eGpRVUZqTEUxQlFVMDdRVUZETTBVc1YwRkJUeXhSUVVGUk8wRkJRVUVzUlVGRGFrSTdRVUZEUmpzaUxBb2dJQ0p1WVcxbGN5STZJRnNpY21WemNDSXNJQ0owYjJ0bGJuTWlMQ0FpZDJsdVpHOTNJbDBLZlFvPVxcblwiXG59IiwgImNvbnN0IHsgQWRhcHRlciB9ID0gcmVxdWlyZSgnLi9hZGFwdGVyJyk7XG5jb25zdCB3ZWJfY29ubmVjdG9yID0gcmVxdWlyZSgnLi4vd2ViX2Nvbm5lY3RvcicpO1xuXG5jbGFzcyBJZnJhbWVBZGFwdGVyIGV4dGVuZHMgQWRhcHRlciB7XG4gIGNvbnN0cnVjdG9yKG1haW4pIHtcbiAgICBzdXBlcihtYWluKTtcbiAgICB0aGlzLmZyYW1lID0gbnVsbDtcbiAgICB0aGlzLm91dHB1dCA9IHt9O1xuICAgIHRoaXMucmVzcG9uc2VfaGFuZGxlcnMgPSB7fTtcbiAgICB0aGlzLndlYl9zY3JpcHQgPSB3ZWJfY29ubmVjdG9yLnNjcmlwdDsgLy8gd2ViIHNjcmlwdCB0byBsb2FkIGluIGlmcmFtZVxuICB9XG4gIHVubG9hZCgpIHtcbiAgICBjb25zb2xlLmxvZyhcIlNtYXJ0RW1iZWRUcmFuc2Zvcm1lcnNXZWJBZGFwdGVyIFVubG9hZGluZ1wiKTtcbiAgICB0aGlzLnJlbW92ZV9mcmFtZSgpO1xuICAgIHRoaXMuZnJhbWUgPSBudWxsO1xuICAgIHRoaXMub3V0cHV0ID0ge307XG4gICAgdGhpcy5yZXNwb25zZV9oYW5kbGVycyA9IHt9O1xuICB9XG4gIGFzeW5jIGluaXQoKSB7XG4gICAgLy8gdGhpcy5mcmFtZSA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIjXCIgKyB0aGlzLmNvbnRhaW5lcl9pZCk7XG4gICAgaWYoIXRoaXMuZnJhbWUpIHtcbiAgICAgIHRoaXMuZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO1xuICAgICAgdGhpcy5mcmFtZS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICB0aGlzLmZyYW1lLnN0eWxlLndpZHRoID0gXCIwXCI7XG4gICAgICB0aGlzLmZyYW1lLnN0eWxlLmhlaWdodCA9IFwiMFwiO1xuICAgICAgLy8gdGhpcy5mcmFtZS5pZCA9IHRoaXMuY29udGFpbmVyX2lkO1xuICAgICAgdGhpcy5mcmFtZV9sb2FkZWQgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHRoaXMuZnJhbWUub25sb2FkID0gcmVzb2x2ZSk7IC8vIHdhaXQgZm9yIGlmcmFtZSB0byBsb2FkXG4gICAgICBjb25zdCBtb2RlbF9sb2FkZWQgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICBpZiAoZXZlbnQuZGF0YS50eXBlID09PSBcIm1vZGVsX2xvYWRlZFwiKXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTW9kZWwgTG9hZGVkOiBcIiArIHRoaXMubW9kZWxfbmFtZSk7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7IG9uY2U6IHRydWUsIGNhcHR1cmU6IGZhbHNlIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmZyYW1lLnNyY2RvYyA9IHRoaXMuaWZyYW1lX3NjcmlwdDtcbiAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZnJhbWUpO1xuICAgICAgYXdhaXQgdGhpcy5mcmFtZV9sb2FkZWQ7IC8vIHdhaXQgZm9yIGlmcmFtZSB0byBsb2FkXG4gICAgICB0aGlzLmZyYW1lLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UoeyB0eXBlOiBcImluaXRcIiwgbW9kZWxfY29uZmlnOiB7Li4udGhpcy5tYWluLmNvbmZpZywgY29udGFpbmVyOiBudWxsfSB9LCBcIipcIik7IC8vIHNlbmQgaW5pdCBtZXNzYWdlIHRvIGlmcmFtZVxuICAgICAgYXdhaXQgbW9kZWxfbG9hZGVkOyAvLyB3YWl0IGZvciBtb2RlbCB0byBsb2FkXG4gICAgICB0aGlzLmZyYW1lLmNvbnRlbnRXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgdGhpcy5oYW5kbGVfaWZyYW1lX21lc3NhZ2VzLmJpbmQodGhpcyksIGZhbHNlKTtcbiAgICB9XG4gICAgLy8gY29uc29sZS5sb2coYXdhaXQgdGhpcy5yZXF1ZXN0X2VtYmVkZGluZyhcInRlc3RcIikpO1xuICAgIGNvbnNvbGUubG9nKFwiU21hcnRFbWJlZFRyYW5zZm9ybWVyc1dlYkFkYXB0ZXIgQ29ubmVjdGVkXCIpO1xuICB9XG4gIHJlcXVlc3RfZW1iZWRkaW5nKGVtYmVkX2lucHV0LCByZXRyaWVzID0gMCkge1xuICAgIGlmICghZW1iZWRfaW5wdXQ/Lmxlbmd0aCkgcmV0dXJuIGNvbnNvbGUubG9nKFwiZW1iZWRfaW5wdXQgaXMgZW1wdHlcIik7IC8vIGNoZWNrIGlmIGVtYmVkX2lucHV0IGlzIGVtcHR5XG4gICAgY29uc3QgaGFuZGxlcl9pZCA9ICh0eXBlb2YgZW1iZWRfaW5wdXQgPT09IFwic3RyaW5nXCIpID8gZW1iZWRfaW5wdXQgOiBjcmVhdGVfdWlkKGVtYmVkX2lucHV0KTtcbiAgICB0aGlzLmZyYW1lLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UoeyB0eXBlOiBcInNtYXJ0X2VtYmVkXCIsIGVtYmVkX2lucHV0LCBoYW5kbGVyX2lkIH0sIFwiKlwiKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5yZXNwb25zZV9oYW5kbGVyc1toYW5kbGVyX2lkXSA9ICh7IGVycm9yLCBkYXRhIH0pID0+IHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5yZXNwb25zZV9oYW5kbGVyc1toYW5kbGVyX2lkXSkge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJUaW1lb3V0IHdhaXRpbmcgZm9yIHJlc3BvbnNlXCIpKTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5yZXNwb25zZV9oYW5kbGVyc1toYW5kbGVyX2lkXTtcbiAgICAgICAgfVxuICAgICAgfSwgNjAwMDApO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGVtYmVkX2JhdGNoKGl0ZW1zKSB7XG4gICAgaXRlbXMgPSBpdGVtcy5maWx0ZXIoaXRlbSA9PiBpdGVtLmVtYmVkX2lucHV0Py5sZW5ndGggPiAwKTtcbiAgICBpZighaXRlbXM/Lmxlbmd0aCkgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHJlc3AgPSBhd2FpdCB0aGlzLnJlcXVlc3RfZW1iZWRkaW5nKGl0ZW1zLm1hcChpdGVtID0+ICh7IGVtYmVkX2lucHV0OiBpdGVtLmVtYmVkX2lucHV0IH0pKSk7XG4gICAgcmV0dXJuIGl0ZW1zLm1hcCgoaXRlbSwgaSkgPT4ge1xuICAgICAgY29uc3QgcmVzcF9pdGVtID0gcmVzcC5kYXRhW2ldO1xuICAgICAgaXRlbS52ZWMgPSByZXNwX2l0ZW0udmVjO1xuICAgICAgaXRlbS50b2tlbnMgPSByZXNwX2l0ZW0udG9rZW5zO1xuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfSk7XG4gIH1cbiAgZW1iZWQoaW5wdXQpIHsgcmV0dXJuIHRoaXMucmVxdWVzdF9lbWJlZGRpbmcoaW5wdXQpOyB9XG4gIGNvdW50X3Rva2VucyhpbnB1dCwgdGltZW91dCA9IDYwMDAwKSB7XG4gICAgdGhpcy5mcmFtZS5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKHsgdHlwZTogXCJzbWFydF9lbWJlZF90b2tlbl9jdFwiLCBlbWJlZF9pbnB1dDogaW5wdXQgfSwgXCIqXCIpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnJlc3BvbnNlX2hhbmRsZXJzW1wiY291bnQ6XCIgKyBpbnB1dF0gPSAoeyBlcnJvciwgZGF0YSB9KSA9PiB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMucmVzcG9uc2VfaGFuZGxlcnNbXCJjb3VudDpcIiArIGlucHV0XSkge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJUaW1lb3V0IHdhaXRpbmcgZm9yIHJlc3BvbnNlXCIpKTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5yZXNwb25zZV9oYW5kbGVyc1tcImNvdW50OlwiICsgaW5wdXRdO1xuICAgICAgICB9XG4gICAgICB9LCB0aW1lb3V0KTtcbiAgICB9KTtcbiAgfVxuICBnZXQgaWZyYW1lX3NjcmlwdCgpIHsgcmV0dXJuIGA8c2NyaXB0IHR5cGU9XCJtb2R1bGVcIj4ke3RoaXMud2ViX3NjcmlwdH08L3NjcmlwdD5gOyB9XG4gIGdldCBpc19lbWJlZGRpbmcoKSB7IHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnJlc3BvbnNlX2hhbmRsZXJzKS5sZW5ndGggPiAwOyB9XG4gIGdldCBxdWV1ZV9sZW5ndGgoKSB7IHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnJlc3BvbnNlX2hhbmRsZXJzKS5sZW5ndGg7IH1cbiAgZ2V0IGNvbnRhaW5lcl9pZCgpIHsgcmV0dXJuIHRoaXMubW9kZWxfbmFtZS5yZXBsYWNlKC9bXmEtejAtOV0vZ2ksICdfJykudG9Mb3dlckNhc2UoKTsgfVxuICByZW1vdmVfZnJhbWUoKSB7XG4gICAgaWYgKHRoaXMuZnJhbWUpIHRoaXMuZnJhbWUucmVtb3ZlKCk7XG4gICAgY29uc3QgZnJhbWVfY2hlY2sgPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiI1wiICsgdGhpcy5jb250YWluZXJfaWQpO1xuICAgIGlmIChmcmFtZV9jaGVjaykgZnJhbWVfY2hlY2sucmVtb3ZlKCk7XG4gICAgY29uc29sZS5sb2coXCJTbWFydEVtYmVkVHJhbnNmb3JtZXJzV2ViQWRhcHRlciBEaXNjb25uZWN0ZWRcIik7XG4gIH1cbiAgaGFuZGxlX2lmcmFtZV9tZXNzYWdlcyhldmVudCkge1xuICAgIGlmIChldmVudC5kYXRhLnR5cGUgPT09IFwic21hcnRfZW1iZWRfcmVzcFwiIHx8IGV2ZW50LmRhdGEudHlwZSA9PT0gXCJzbWFydF9lbWJlZF90b2tlbl9jdFwiKSB7XG4gICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5yZXNwb25zZV9oYW5kbGVyc1tldmVudC5kYXRhLmhhbmRsZXJfaWQgfHwgZXZlbnQuZGF0YS50ZXh0XTtcbiAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgIGhhbmRsZXIoeyBlcnJvcjogbnVsbCwgZGF0YTogZXZlbnQuZGF0YSB9KTtcbiAgICAgICAgZGVsZXRlIHRoaXMucmVzcG9uc2VfaGFuZGxlcnNbZXZlbnQuZGF0YS5oYW5kbGVyX2lkIHx8IGV2ZW50LmRhdGEudGV4dF07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5leHBvcnRzLklmcmFtZUFkYXB0ZXIgPSBJZnJhbWVBZGFwdGVyO1xuXG5mdW5jdGlvbiBjcmVhdGVfdWlkKGRhdGEpIHtcbiAgY29uc3Qgc3RyID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gIGxldCBoYXNoID0gMDtcbiAgaWYgKHN0ci5sZW5ndGggPT09IDApIHJldHVybiBoYXNoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoYXIgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBjaGFyO1xuICAgIGhhc2ggPSBoYXNoICYgaGFzaDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gICAgLy8gcmVtb3ZlIG5lZ2F0aXZlIHNpZ25cbiAgICBpZiAoaGFzaCA8IDApIGhhc2ggPSBoYXNoICogLTE7XG4gIH1cbiAgcmV0dXJuIGhhc2gudG9TdHJpbmcoKSArIHN0ci5sZW5ndGg7XG59IiwgImNvbnN0IHsgQXBpQWRhcHRlciB9ID0gcmVxdWlyZSgnLi9hZGFwdGVycy9hcGknKTtcbmV4cG9ydHMuYXBpID0gQXBpQWRhcHRlcjtcbmNvbnN0IHsgTG9jYWxBcGlBZGFwdGVyIH0gPSByZXF1aXJlKCcuL2FkYXB0ZXJzL2xvY2FsX2FwaScpO1xuZXhwb3J0cy5sb2NhbF9hcGkgPSBMb2NhbEFwaUFkYXB0ZXI7XG5jb25zdCB7IFRyYW5zZm9ybWVyc0FkYXB0ZXIgfSA9IHJlcXVpcmUoJy4vYWRhcHRlcnMvdHJhbnNmb3JtZXJzJyk7XG5leHBvcnRzLnRyYW5zZm9ybWVycyA9IFRyYW5zZm9ybWVyc0FkYXB0ZXI7XG5jb25zdCB7IElmcmFtZUFkYXB0ZXIgfSA9IHJlcXVpcmUoJy4vYWRhcHRlcnMvaWZyYW1lJyk7XG5leHBvcnRzLmlmcmFtZSA9IElmcmFtZUFkYXB0ZXI7IiwgIntcbiAgXCJUYXlsb3JBSS9iZ2UtbWljcm8tdjJcIjoge1xuICAgIFwibW9kZWxfbmFtZVwiOiBcIlRheWxvckFJL2JnZS1taWNyby12MlwiLFxuICAgIFwiYmF0Y2hfc2l6ZVwiOiAxLFxuICAgIFwiZGltc1wiOiAzODQsXG4gICAgXCJtYXhfdG9rZW5zXCI6IDUxMixcbiAgICBcIm5hbWVcIjogXCJCR0UtbWljcm8tdjJcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiTG9jYWwsIDUxMiB0b2tlbnMsIDM4NCBkaW1cIixcbiAgICBcInR5cGVcIjogXCJodWdnaW5nZmFjZS10cmFuc2Zvcm1lcnNcIlxuICB9LFxuICBcImFuZGVyc29uYmNkZWZnL2JnZS1zbWFsbC00MDk2XCI6IHtcbiAgICBcIm1vZGVsX25hbWVcIjogXCJhbmRlcnNvbmJjZGVmZy9iZ2Utc21hbGwtNDA5NlwiLFxuICAgIFwiYmF0Y2hfc2l6ZVwiOiAxLFxuICAgIFwiZGltc1wiOiAzODQsXG4gICAgXCJtYXhfdG9rZW5zXCI6IDQwOTYsXG4gICAgXCJuYW1lXCI6IFwiQkdFLXNtYWxsLTRLXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkxvY2FsLCA0LDA5NiB0b2tlbnMsIDM4NCBkaW1cIixcbiAgICBcInR5cGVcIjogXCJodWdnaW5nZmFjZS10cmFuc2Zvcm1lcnNcIlxuICB9LFxuICBcIlhlbm92YS9qaW5hLWVtYmVkZGluZ3MtdjItYmFzZS16aC04MTkyXCI6IHtcbiAgICBcIm1vZGVsX25hbWVcIjogXCJYZW5vdmEvamluYS1lbWJlZGRpbmdzLXYyLWJhc2UtemhcIixcbiAgICBcImJhdGNoX3NpemVcIjogMSxcbiAgICBcImRpbXNcIjogNTEyLFxuICAgIFwibWF4X3Rva2Vuc1wiOiA4MTkyLFxuICAgIFwibmFtZVwiOiBcIkppbmEtdjItYmFzZS16aC04S1wiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJMb2NhbCwgOCwxOTIgdG9rZW5zLCA1MTIgZGltLCBDaGluZXNlL0VuZ2xpc2ggYmlsaW5ndWFsXCIsXG4gICAgXCJ0eXBlXCI6IFwiaHVnZ2luZ2ZhY2UtdHJhbnNmb3JtZXJzXCJcbiAgfSxcbiAgXCJ0ZXh0LWVtYmVkZGluZy0zLXNtYWxsXCI6IHtcbiAgICBcIm1vZGVsX25hbWVcIjogXCJ0ZXh0LWVtYmVkZGluZy0zLXNtYWxsXCIsXG4gICAgXCJiYXRjaF9zaXplXCI6IDEwLFxuICAgIFwiZGltc1wiOiAxNTM2LFxuICAgIFwibWF4X3Rva2Vuc1wiOiA4MTkxLFxuICAgIFwibmFtZVwiOiBcIk9wZW5BSSBUZXh0LTMgU21hbGxcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQVBJLCA4LDE5MSB0b2tlbnMsIDEsNTM2IGRpbVwiLFxuICAgIFwiZW5kcG9pbnRcIjogXCJodHRwczovL2FwaS5vcGVuYWkuY29tL3YxL2VtYmVkZGluZ3NcIixcbiAgICBcInR5cGVcIjogXCJvcGVuYWlcIlxuICB9LFxuICBcInRleHQtZW1iZWRkaW5nLTMtbGFyZ2VcIjoge1xuICAgIFwibW9kZWxfbmFtZVwiOiBcInRleHQtZW1iZWRkaW5nLTMtbGFyZ2VcIixcbiAgICBcImJhdGNoX3NpemVcIjogMTAsXG4gICAgXCJkaW1zXCI6IDMwNzIsXG4gICAgXCJtYXhfdG9rZW5zXCI6IDgxOTEsXG4gICAgXCJuYW1lXCI6IFwiT3BlbkFJIFRleHQtMyBMYXJnZVwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJBUEksIDgsMTkxIHRva2VucywgMywwNzIgZGltXCIsXG4gICAgXCJlbmRwb2ludFwiOiBcImh0dHBzOi8vYXBpLm9wZW5haS5jb20vdjEvZW1iZWRkaW5nc1wiLFxuICAgIFwidHlwZVwiOiBcIm9wZW5haVwiXG4gIH0sXG4gIFwidGV4dC1lbWJlZGRpbmctMy1zbWFsbC01MTJcIjoge1xuICAgIFwibW9kZWxfbmFtZVwiOiBcInRleHQtZW1iZWRkaW5nLTMtc21hbGxcIixcbiAgICBcImJhdGNoX3NpemVcIjogNTAsXG4gICAgXCJkaW1zXCI6IDUxMixcbiAgICBcIm1heF90b2tlbnNcIjogODE5MSxcbiAgICBcIm5hbWVcIjogXCJPcGVuQUkgVGV4dC0zIFNtYWxsIC0gNTEyXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkFQSSwgOCwxOTEgdG9rZW5zLCA1MTIgZGltXCIsXG4gICAgXCJlbmRwb2ludFwiOiBcImh0dHBzOi8vYXBpLm9wZW5haS5jb20vdjEvZW1iZWRkaW5nc1wiLFxuICAgIFwidHlwZVwiOiBcIm9wZW5haVwiXG4gIH0sXG4gIFwidGV4dC1lbWJlZGRpbmctMy1sYXJnZS0yNTZcIjoge1xuICAgIFwibW9kZWxfbmFtZVwiOiBcInRleHQtZW1iZWRkaW5nLTMtbGFyZ2VcIixcbiAgICBcImJhdGNoX3NpemVcIjogMTAsXG4gICAgXCJkaW1zXCI6IDI1NixcbiAgICBcIm1heF90b2tlbnNcIjogODE5MSxcbiAgICBcIm5hbWVcIjogXCJPcGVuQUkgVGV4dC0zIExhcmdlIC0gMjU2XCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkFQSSwgOCwxOTEgdG9rZW5zLCAyNTYgZGltXCIsXG4gICAgXCJlbmRwb2ludFwiOiBcImh0dHBzOi8vYXBpLm9wZW5haS5jb20vdjEvZW1iZWRkaW5nc1wiLFxuICAgIFwidHlwZVwiOiBcIm9wZW5haVwiXG4gIH0sXG4gIFwidGV4dC1lbWJlZGRpbmctYWRhLTAwMlwiOiB7XG4gICAgXCJtb2RlbF9uYW1lXCI6IFwidGV4dC1lbWJlZGRpbmctYWRhLTAwMlwiLFxuICAgIFwiYmF0Y2hfc2l6ZVwiOiAxMCxcbiAgICBcImRpbXNcIjogMTUzNixcbiAgICBcIm1heF90b2tlbnNcIjogODE5MSxcbiAgICBcIm5hbWVcIjogXCJPcGVuQUkgQWRhXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkFQSSwgOCwxOTEgdG9rZW5zLCAxLDUzNiBkaW1cIixcbiAgICBcImVuZHBvaW50XCI6IFwiaHR0cHM6Ly9hcGkub3BlbmFpLmNvbS92MS9lbWJlZGRpbmdzXCIsXG4gICAgXCJ0eXBlXCI6IFwib3BlbmFpXCJcbiAgfSxcbiAgXCJYZW5vdmEvamluYS1lbWJlZGRpbmdzLXYyLXNtYWxsLWVuXCI6IHtcbiAgICBcIm1vZGVsX25hbWVcIjogXCJYZW5vdmEvamluYS1lbWJlZGRpbmdzLXYyLXNtYWxsLWVuXCIsXG4gICAgXCJiYXRjaF9zaXplXCI6IDEsXG4gICAgXCJkaW1zXCI6IDUxMixcbiAgICBcIm1heF90b2tlbnNcIjogODE5MixcbiAgICBcIm5hbWVcIjogXCJKaW5hLXYyLXNtYWxsLWVuXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkxvY2FsLCA4LDE5MiB0b2tlbnMsIDUxMiBkaW1cIixcbiAgICBcInR5cGVcIjogXCJodWdnaW5nZmFjZS10cmFuc2Zvcm1lcnNcIlxuICB9LFxuICBcIm5vbWljLWFpL25vbWljLWVtYmVkLXRleHQtdjEuNS0yNTZcIjoge1xuICAgIFwibW9kZWxfbmFtZVwiOiBcIm5vbWljLWFpL25vbWljLWVtYmVkLXRleHQtdjEuNVwiLFxuICAgIFwiYmF0Y2hfc2l6ZVwiOiAxLFxuICAgIFwiZGltc1wiOiAyNTYsXG4gICAgXCJtYXhfdG9rZW5zXCI6IDgxOTIsXG4gICAgXCJuYW1lXCI6IFwiTm9taWMtZW1iZWQtdGV4dC12MS41XCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkxvY2FsLCA4LDE5MiB0b2tlbnMsIDI1NiBkaW1cIixcbiAgICBcInR5cGVcIjogXCJodWdnaW5nZmFjZS10cmFuc2Zvcm1lcnNcIlxuICB9LFxuICBcIlhlbm92YS9iZ2Utc21hbGwtZW4tdjEuNVwiOiB7XG4gICAgXCJtb2RlbF9uYW1lXCI6IFwiWGVub3ZhL2JnZS1zbWFsbC1lbi12MS41XCIsXG4gICAgXCJiYXRjaF9zaXplXCI6IDEsXG4gICAgXCJkaW1zXCI6IDM4NCxcbiAgICBcIm1heF90b2tlbnNcIjogNTEyLFxuICAgIFwibmFtZVwiOiBcIkJHRS1zbWFsbFwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJMb2NhbCwgNTEyIHRva2VucywgMzg0IGRpbVwiLFxuICAgIFwidHlwZVwiOiBcImh1Z2dpbmdmYWNlLXRyYW5zZm9ybWVyc1wiXG4gIH0sXG4gIFwibm9taWMtYWkvbm9taWMtZW1iZWQtdGV4dC12MVwiOiB7XG4gICAgXCJtb2RlbF9uYW1lXCI6IFwibm9taWMtYWkvbm9taWMtZW1iZWQtdGV4dC12MVwiLFxuICAgIFwiYmF0Y2hfc2l6ZVwiOiAxLFxuICAgIFwiZGltc1wiOiA3NjgsXG4gICAgXCJtYXhfdG9rZW5zXCI6IDIwNDgsXG4gICAgXCJuYW1lXCI6IFwiTm9taWMtZW1iZWQtdGV4dFwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJMb2NhbCwgMiwwNDggdG9rZW5zLCA3NjggZGltXCIsXG4gICAgXCJ0eXBlXCI6IFwiaHVnZ2luZ2ZhY2UtdHJhbnNmb3JtZXJzXCJcbiAgfVxufSIsICIvLyBDb3B5cmlnaHQgKGMpIEJyaWFuIEpvc2VwaCBQZXRyb1xuXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbi8vIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbi8vIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xuLy8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuLy8gaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4vLyBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4vLyBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFXG4vLyBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OXG4vLyBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cbi8vIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5jb25zdCBhZGFwdGVycyA9IHJlcXVpcmUoJy4vYWRhcHRlcnMnKTtcbmNvbnN0IGVtYmVkX21vZGVscyA9IHJlcXVpcmUoJy4vbW9kZWxzJyk7XG5cbi8qKlxuICogQW4gdW5pdmVyc2FsIGludGVyZmFjZSBmb3IgZW1iZWRkaW5nIG1vZGVscy5cbiAqL1xuY2xhc3MgU21hcnRFbWJlZE1vZGVsIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIFNtYXJ0RW1iZWQgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbnYgLSBUaGUgZW52aXJvbm1lbnQgdG8gdXNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IGNvbmZpZyAtIFRoZSBtb2RlbCBjb25maWd1cmF0aW9uIGtleSBvciB0aGUgbW9kZWwgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAqIGV4cGVjdHMgbW9kZWwgdG8gY29udGFpbiBhdCBsZWFzdCBhIG1vZGVsX2tleVxuICAgKi9cbiAgY29uc3RydWN0b3IoZW52LCBjb25maWcpIHtcbiAgICB0aGlzLmVudiA9IGVudjtcbiAgICBpZihjb25maWcubW9kZWxfa2V5KSB0aGlzLmNvbmZpZyA9IHsuLi5lbWJlZF9tb2RlbHNbY29uZmlnLm1vZGVsX2tleV0sIC4uLmNvbmZpZ307XG4gICAgZWxzZSB0aGlzLmNvbmZpZyA9IHsgLi4uY29uZmlnIH07XG4gICAgLy8gSW5pdGlhbGl6ZSBzdGF0aXN0aWNzXG4gICAgdGhpcy5lbWJlZF9jdCA9IDA7IC8vIENvdW50IG9mIGVtYmVkZGluZ3MgcHJvY2Vzc2VkXG4gICAgdGhpcy50aW1lc3RhbXAgPSBudWxsOyAvLyBMYXN0IG9wZXJhdGlvbiB0aW1lc3RhbXBcbiAgICB0aGlzLnRva2VucyA9IDA7IC8vIENvdW50IG9mIHRva2VucyBwcm9jZXNzZWRcbiAgICAvLyBJbml0aWFsaXplIGFkYXB0ZXIgaWYgc3BlY2lmaWVkIGluIHRoZSBjb25maWd1cmF0aW9uIChlbHNlIHVzZSBhcGkgYWRhcHRlcilcbiAgICBpZih0aGlzLmNvbmZpZy5hZGFwdGVyKSB0aGlzLmFkYXB0ZXIgPSBuZXcgYWRhcHRlcnNbdGhpcy5jb25maWcuYWRhcHRlcl0odGhpcyk7XG4gICAgZWxzZSB0aGlzLmFkYXB0ZXIgPSBuZXcgYWRhcHRlcnNbJ2FwaSddKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBTbWFydEVtYmVkIGluc3RhbmNlIGFuZCBpbml0aWFsaXplIGl0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZW52IC0gVGhlIGVudmlyb25tZW50IHRvIHVzZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG1vZGVsX2NvbmZpZyAtIEZ1bGwgbW9kZWwgY29uZmlndXJhdGlvbiBvYmplY3Qgb3IgYXQgbGVhc3QgYSBtb2RlbF9rZXksIGFwaV9rZXksIGFuZCBhZGFwdGVyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFNtYXJ0RW1iZWQ+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGFuIGluaXRpYWxpemVkIFNtYXJ0RW1iZWQgaW5zdGFuY2UuXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgY3JlYXRlKGVudiwgbW9kZWxfY29uZmlnKSB7XG4gICAgY29uc3QgbW9kZWwgPSBuZXcgdGhpcyhlbnYsIG1vZGVsX2NvbmZpZyk7XG4gICAgLy8gSW5pdGlhbGl6ZSBhZGFwdGVyLXNwZWNpZmljIGxvZ2ljIGlmIGFkYXB0ZXIgaXMgcHJlc2VudFxuICAgIGlmIChtb2RlbC5hZGFwdGVyICYmIHR5cGVvZiBtb2RlbC5hZGFwdGVyLmluaXQgPT09ICdmdW5jdGlvbicpIGF3YWl0IG1vZGVsLmFkYXB0ZXIuaW5pdCgpO1xuICAgIHJldHVybiBtb2RlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb3VudCB0aGUgbnVtYmVyIG9mIHRva2VucyBpbiB0aGUgaW5wdXQgc3RyaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgLSBUaGUgaW5wdXQgc3RyaW5nIHRvIHByb2Nlc3MuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlcj59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIG51bWJlciBvZiB0b2tlbnMuXG4gICAqL1xuICBhc3luYyBjb3VudF90b2tlbnMoaW5wdXQpIHtcbiAgICBpZiAodGhpcy5hZGFwdGVyICYmIHR5cGVvZiB0aGlzLmFkYXB0ZXIuY291bnRfdG9rZW5zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5hZGFwdGVyLmNvdW50X3Rva2VucyhpbnB1dCk7XG4gICAgfVxuICAgIC8vIERlZmF1bHQgdG9rZW4gY291bnRpbmcgbG9naWMgaGVyZSBpZiBubyBhZGFwdGVyIG9yIGFkYXB0ZXIgbGFja3MgdGhlIG1ldGhvZFxuICB9XG5cbiAgLyoqXG4gICAqIEVtYmVkIHRoZSBpbnB1dCBzdHJpbmcgaW50byBhIG51bWVyaWNhbCBhcnJheS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0IC0gVGhlIGlucHV0IHN0cmluZyB0byBlbWJlZC5cbiAgICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyW10+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBlbWJlZGRpbmcgYXJyYXkuXG4gICAqL1xuICBhc3luYyBlbWJlZChpbnB1dCkge1xuICAgIGlmICh0aGlzLmFkYXB0ZXIgJiYgdHlwZW9mIHRoaXMuYWRhcHRlci5lbWJlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuYWRhcHRlci5lbWJlZChpbnB1dCk7XG4gICAgfVxuICAgIC8vIERlZmF1bHQgZW1iZWRkaW5nIGxvZ2ljIGhlcmUgaWYgbm8gYWRhcHRlciBvciBhZGFwdGVyIGxhY2tzIHRoZSBtZXRob2RcbiAgfVxuXG4gIC8qKlxuICAgKiBFbWJlZCBhIGJhdGNoIG9mIGlucHV0IHN0cmluZ3MgaW50byBhcnJheXMgb2YgbnVtZXJpY2FsIGFycmF5cy5cbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gaW5wdXQgLSBUaGUgYXJyYXkgb2Ygc3RyaW5ncyB0byBlbWJlZC5cbiAgICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyW11bXT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGFycmF5IG9mIGVtYmVkZGluZyBhcnJheXMuXG4gICAqL1xuICBhc3luYyBlbWJlZF9iYXRjaChpbnB1dCkge1xuICAgIGlmICh0aGlzLmFkYXB0ZXIgJiYgdHlwZW9mIHRoaXMuYWRhcHRlci5lbWJlZF9iYXRjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuYWRhcHRlci5lbWJlZF9iYXRjaChpbnB1dCk7XG4gICAgfVxuICAgIC8vIERlZmF1bHQgYmF0Y2ggZW1iZWRkaW5nIGxvZ2ljIGhlcmUgaWYgbm8gYWRhcHRlciBvciBhZGFwdGVyIGxhY2tzIHRoZSBtZXRob2RcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvbmZpZ3VyZWQgYmF0Y2ggc2l6ZSBmb3IgZW1iZWRkaW5nLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgYmF0Y2ggc2l6ZS5cbiAgICovXG4gIGdldCBiYXRjaF9zaXplKCkgeyByZXR1cm4gdGhpcy5jb25maWcuYmF0Y2hfc2l6ZTsgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGVtYmVkZGluZy5cbiAgICogQHJldHVybnMge251bWJlcn0gVGhlIGRpbWVuc2lvbnMgb2YgdGhlIGVtYmVkZGluZy5cbiAgICovXG4gIGdldCBkaW1zKCkgeyByZXR1cm4gdGhpcy5jb25maWcuZGltczsgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1heGltdW0gbnVtYmVyIG9mIHRva2VucyB0aGF0IGNhbiBiZSBwcm9jZXNzZWQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBtYXhpbXVtIG51bWJlciBvZiB0b2tlbnMuXG4gICAqL1xuICBnZXQgbWF4X3Rva2VucygpIHsgcmV0dXJuIHRoaXMuY29uZmlnLm1heF90b2tlbnM7IH1cblxuICAvKipcbiAgICogR2V0IHRoZSBuYW1lIG9mIHRoZSBtb2RlbCB1c2VkIGZvciBlbWJlZGRpbmcuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBtb2RlbCBuYW1lLlxuICAgKi9cbiAgZ2V0IG1vZGVsX25hbWUoKSB7IHJldHVybiB0aGlzLmNvbmZpZy5tb2RlbF9uYW1lOyB9XG59XG5cbmV4cG9ydHMuU21hcnRFbWJlZE1vZGVsID0gU21hcnRFbWJlZE1vZGVsOyIsICIvLyBDb3B5cmlnaHQgKGMpIEJyaWFuIEpvc2VwaCBQZXRyb1xuXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbi8vIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbi8vIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xuLy8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuLy8gaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4vLyBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4vLyBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFXG4vLyBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OXG4vLyBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cbi8vIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5jb25zdCB7IENvbGxlY3Rpb24gfSA9IHJlcXVpcmUoXCJzbWFydC1jb2xsZWN0aW9ucy9Db2xsZWN0aW9uXCIpOyAvLyBucG1cbmNvbnN0IHsgQ29sbGVjdGlvbkl0ZW0gfSA9IHJlcXVpcmUoXCJzbWFydC1jb2xsZWN0aW9ucy9Db2xsZWN0aW9uSXRlbVwiKTsgLy8gbnBtXG5jb25zdCB7IFNtYXJ0RW1iZWRNb2RlbCB9ID0gcmVxdWlyZSgnc21hcnQtZW1iZWQtbW9kZWwnKTtcbmNsYXNzIFNtYXJ0RW50aXRpZXMgZXh0ZW5kcyBDb2xsZWN0aW9uIHtcbiAgY29uc3RydWN0b3IoZW52KSB7XG4gICAgc3VwZXIoZW52KTtcbiAgICB0aGlzLmVudiA9IGVudjsgLy8gZW52IGlzIHRoZSBicmFpbiAoYnJhaW4gaXMgRGVwcmVjYXRlZClcbiAgICB0aGlzLl9wYXVzZV9lbWJlZGRpbmdzID0gZmFsc2U7IC8vIHVzZWQgdG8gcGF1c2UgZW5zdXJlX2VtYmVkZGluZ3NcbiAgfVxuICBhc3luYyBfc2F2ZSgpIHsgYXdhaXQgdGhpcy5MVE0uX3NhdmUoKTsgfSAvLyBhc3luYyBiL2MgT2JzaWRpYW4gQVBJIGlzIGFzeW5jXG4gIHJlcGxhY2VyKGtleSwgdmFsdWUpIHsgLy8gSlNPTi5zdHJpbmdpZnkgcmVwbGFjZXJcbiAgICBpZih2YWx1ZSBpbnN0YW5jZW9mIHRoaXMuaXRlbV90eXBlKXtcbiAgICAgIGlmKCF2YWx1ZS52YWxpZGF0ZV9zYXZlKCkpe1xuICAgICAgICBjb25zb2xlLmxvZyhcIkludmFsaWQgYmxvY2ssIHNraXBwaW5nIHNhdmU6IFwiLCB2YWx1ZS5kYXRhKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDsgLy8gc2tpcCBpZiBpbnZhbGlkXG4gICAgICB9XG4gICAgICBpZih2YWx1ZS5kYXRhLmVtYmVkZGluZy52ZWMgJiYgdmFsdWUuZGF0YS50ZXh0KSB2YWx1ZS5kYXRhLnRleHQgPSB1bmRlZmluZWQ7IC8vIGNsZWFyIHRleHQgaWYgZW1iZWRkaW5nIGV4aXN0c1xuICAgICAgcmV0dXJuIHZhbHVlLmRhdGE7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5yZXBsYWNlcihrZXksIHZhbHVlKTtcbiAgfVxuICB1bmxvYWQoKXtcbiAgICBpZih0eXBlb2YgdGhpcy5zbWFydF9lbWJlZD8udW5sb2FkID09PSAnZnVuY3Rpb24nKXtcbiAgICAgIHRoaXMuc21hcnRfZW1iZWQudW5sb2FkKCk7XG4gICAgICBkZWxldGUgdGhpcy5zbWFydF9lbWJlZDtcbiAgICB9XG4gICAgaWYodGhpcy5zbWFydF9lbWJlZF9jb250YWluZXIpe1xuICAgICAgY29uc3QgaWZyYW1lID0gdGhpcy5zbWFydF9lbWJlZF9jb250YWluZXIucXVlcnlTZWxlY3RvcignaWZyYW1lJyk7XG4gICAgICBpZiAoIWlmcmFtZSkgcmV0dXJuO1xuICAgICAgLy8gRE86IGltcHJvdmUgcmVtb3ZlIG9mIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgaWZyYW1lLnNyY2RvYyA9ICcnO1xuICAgICAgaWZyYW1lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICAgIHRoaXMuc21hcnRfZW1iZWRfY29udGFpbmVyLnJlbW92ZSgpO1xuICAgIH1cbiAgfVxuICBhc3luYyBsb2FkKCkge1xuICAgIGF3YWl0IHRoaXMuTFRNLmxvYWQoKTsgLy8gTVVTVCBSVU4gQkVGT1JFIFNNQVJUIEVNQkVEIGFzeW5jIGIvYyBPYnNpZGlhbiBBUEkgaXMgYXN5bmNcbiAgICBjb25zb2xlLmxvZyh0aGlzKTtcbiAgICBjb25zb2xlLmxvZyh0aGlzLmVudik7XG4gICAgYXdhaXQgdGhpcy5sb2FkX3NtYXJ0X2VtYmVkKCk7XG4gIH1cbiAgYXN5bmMgbG9hZF9zbWFydF9lbWJlZCgpIHtcbiAgICAvLyBjb25zb2xlLmxvZyhcIkxvYWRpbmcgU21hcnRFbWJlZCBmb3IgXCIgKyB0aGlzLmNvbGxlY3Rpb25fbmFtZSArIFwiIE1vZGVsOiBcIiArIHRoaXMuc21hcnRfZW1iZWRfbW9kZWwpO1xuICAgIGlmKHRoaXMuc21hcnRfZW1iZWRfbW9kZWwgPT09IFwiTm9uZVwiKSByZXR1cm47IC8vIGNvbnNvbGUubG9nKFwiU21hcnRFbWJlZCBkaXNhYmxlZCBmb3IgXCIsIHRoaXMuY29sbGVjdGlvbl9uYW1lKTtcbiAgICBpZih0aGlzLmVudi5zbWFydF9lbWJlZF9hY3RpdmVfbW9kZWxzW3RoaXMuc21hcnRfZW1iZWRfbW9kZWxdIGluc3RhbmNlb2YgU21hcnRFbWJlZE1vZGVsKXtcbiAgICAgIHRoaXMuc21hcnRfZW1iZWQgPSB0aGlzLmVudi5zbWFydF9lbWJlZF9hY3RpdmVfbW9kZWxzW3RoaXMuc21hcnRfZW1iZWRfbW9kZWxdO1xuICAgICAgY29uc29sZS5sb2coXCJTbWFydEVtYmVkIGFscmVhZHkgbG9hZGVkIGZvciBcIiArIHRoaXMuY29sbGVjdGlvbl9uYW1lICsgXCI6IE1vZGVsOiBcIiArIHRoaXMuc21hcnRfZW1iZWRfbW9kZWwpO1xuICAgIH1lbHNle1xuICAgICAgY29uc3QgbW9kZWwgPSB7bW9kZWxfa2V5OiB0aGlzLnNtYXJ0X2VtYmVkX21vZGVsfTtcbiAgICAgIGlmKHRoaXMuc21hcnRfZW1iZWRfbW9kZWwuaW5jbHVkZXMoXCIvXCIpKSB7IC8vIFRPRE86IGJldHRlciB3YXkgdG8gZGV0ZWN0IGxvY2FsIG1vZGVsXG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMuZW52LmxvY2FsX21vZGVsX3R5cGUpO1xuICAgICAgICB0aGlzLm1vZGVsX2tleSA9IHRoaXMuc21hcnRfZW1iZWRfbW9kZWw7XG4gICAgICAgIGNvbnN0IGxvY2FsX21heCA9IHRoaXMuZW52LmNvbmZpZy5sb2NhbF9lbWJlZGRpbmdfbWF4X3Rva2VucztcbiAgICAgICAgaWYobG9jYWxfbWF4IDwgbW9kZWwubWF4X3Rva2VucykgbW9kZWwubWF4X3Rva2VucyA9IGxvY2FsX21heDtcbiAgICAgICAgLy8gY2hlY2sgaWYgaHR0cDovL2xvY2FsaG9zdDozNzQyMC9lbWJlZCBpcyBhdmFpbGFibGVcbiAgICAgICAgY29uc29sZS5sb2coJ0NoZWNraW5nIGZvciBsb2NhbCBTbWFydCBDb25uZWN0IHNlcnZlci4uLicpO1xuICAgICAgICB0cnl7XG4gICAgICAgICAgY29uc3QgcmVxdWVzdF9hZGFwdGVyID0gdGhpcy5lbnYubWFpbi5vYnNpZGlhbj8ucmVxdWVzdFVybCB8fCBudWxsO1xuICAgICAgICAgIGNvbnN0IHNjX2xvY2FsID0gIXJlcXVlc3RfYWRhcHRlciA/IGF3YWl0IGZldGNoKCdodHRwOi8vbG9jYWxob3N0OjM3NDIxLycpIDogYXdhaXQgcmVxdWVzdF9hZGFwdGVyKHt1cmw6ICdodHRwOi8vbG9jYWxob3N0OjM3NDIxLycsIG1ldGhvZDogJ0dFVCd9KTtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhzY19sb2NhbCk7XG4gICAgICAgICAgaWYoc2NfbG9jYWwuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdMb2NhbCBTbWFydCBDb25uZWN0IHNlcnZlciBmb3VuZCcpO1xuICAgICAgICAgICAgdGhpcy5zbWFydF9lbWJlZCA9IGF3YWl0IFNtYXJ0RW1iZWRNb2RlbC5jcmVhdGUodGhpcy5lbnYsIHsuLi5tb2RlbCwgcmVxdWVzdF9hZGFwdGVyOiByZXF1ZXN0X2FkYXB0ZXIsIGFkYXB0ZXI6ICdsb2NhbF9hcGknLCBsb2NhbF9lbmRwb2ludDogJ2h0dHA6Ly9sb2NhbGhvc3Q6Mzc0MjEvZW1iZWRfYmF0Y2gnfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9Y2F0Y2goZXJyKXtcbiAgICAgICAgICBjb25zb2xlLmxvZygnQ291bGQgbm90IGNvbm5lY3QgdG8gbG9jYWwgU21hcnQgQ29ubmVjdCBzZXJ2ZXInKTtcbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLmVudi5sb2NhbF9tb2RlbF90eXBlID09PSAnV2ViJyl7XG4gICAgICAgICAgdGhpcy5tb2RlbF9rZXkgKz0gJ193ZWInOyAvLyBtb2RlbCByZWdpc3RyeSBuYW1lXG4gICAgICAgICAgaWYodGhpcy5zbWFydF9lbWJlZCkgY29uc29sZS5sb2coYEV4aXN0aW5nIFdlYkFkYXB0ZXIgZm9yICR7dGhpcy5jb2xsZWN0aW9uX25hbWV9IG1vZGVsOiAke3RoaXMuc21hcnRfZW1iZWRfbW9kZWx9YCk7XG4gICAgICAgICAgZWxzZSB0aGlzLnNtYXJ0X2VtYmVkID0gYXdhaXQgU21hcnRFbWJlZE1vZGVsLmNyZWF0ZSh0aGlzLmVudiwgey4uLm1vZGVsLCBhZGFwdGVyOiAnaWZyYW1lJywgY29udGFpbmVyOiB0aGlzLnNtYXJ0X2VtYmVkX2NvbnRhaW5lcn0pO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICB0aGlzLm1vZGVsX2tleSArPSAnX25vZGUnOyAvLyBtb2RlbCByZWdpc3RyeSBuYW1lXG4gICAgICAgICAgaWYodGhpcy5zbWFydF9lbWJlZCkgY29uc29sZS5sb2coYEV4aXN0aW5nIE5vZGVBZGFwdGVyIGZvciAke3RoaXMuY29sbGVjdGlvbl9uYW1lfSBtb2RlbDogJHt0aGlzLnNtYXJ0X2VtYmVkX21vZGVsfWApOyAvLyBDaGVjayBpZiBhIGNvbm5lY3Rpb24gZm9yIHRoaXMgbW9kZWwgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgICBlbHNlIHRoaXMuc21hcnRfZW1iZWQgPSBhd2FpdCBTbWFydEVtYmVkTW9kZWwuY3JlYXRlKHRoaXMuZW52LCB7Li4ubW9kZWwsIGFkYXB0ZXI6ICd0cmFuc2Zvcm1lcnMnfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7IC8vIGlzIEFQSSBtb2RlbFxuICAgICAgICB0aGlzLm1vZGVsX2tleSArPSAnX2FwaSc7IC8vIG1vZGVsIHJlZ2lzdHJ5IG5hbWVcbiAgICAgICAgaWYodGhpcy5zbWFydF9lbWJlZCkgY29uc29sZS5sb2coYEV4aXN0aW5nIEFwaUFkYXB0ZXIgZm9yICR7dGhpcy5jb2xsZWN0aW9uX25hbWV9IG1vZGVsOiAke3RoaXMuc21hcnRfZW1iZWRfbW9kZWx9YCk7IC8vIENoZWNrIGlmIGEgY29ubmVjdGlvbiBmb3IgdGhpcyBtb2RlbCBhbHJlYWR5IGV4aXN0c1xuICAgICAgICBlbHNlIHRoaXMuc21hcnRfZW1iZWQgPSBhd2FpdCBTbWFydEVtYmVkTW9kZWwuY3JlYXRlKHRoaXMuZW52LCB7Li4ubW9kZWwsIHJlcXVlc3RfYWRhcHRlcjogdGhpcy5lbnYubWFpbi5vYnNpZGlhbj8ucmVxdWVzdFVybCwgYXBpX2tleTogdGhpcy5jb25maWcuYXBpX2tleX0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgc21hcnRfZW1iZWRfY29udGFpbmVyKCkge1xuICAgIGlmKCF0aGlzLm1vZGVsX2tleSkgcmV0dXJuIGNvbnNvbGUubG9nKCdtb2RlbF9rZXkgbm90IHNldCcpO1xuICAgIGNvbnN0IGlkID0gdGhpcy5tb2RlbF9rZXkucmVwbGFjZSgvW15hLXpBLVowLTldL2csICdfJyk7XG4gICAgaWYoIXdpbmRvdy5kb2N1bWVudCkgcmV0dXJuIGNvbnNvbGUubG9nKCd3aW5kb3cuZG9jdW1lbnQgbm90IGF2YWlsYWJsZScpO1xuICAgIGlmKHdpbmRvdy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKGAjJHtpZH1gKSkgcmV0dXJuIHdpbmRvdy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKGAjJHtpZH1gKTtcbiAgICBjb25zdCBjb250YWluZXIgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyLmlkID0gaWQ7XG4gICAgd2luZG93LmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICByZXR1cm4gY29udGFpbmVyO1xuICB9XG4gIGdldCBzbWFydF9lbWJlZCgpIHsgcmV0dXJuIHRoaXMuZW52LmFjdGl2ZV9lbWJlZF9tb2RlbHM/Llt0aGlzLm1vZGVsX2tleV07IH1cbiAgc2V0IHNtYXJ0X2VtYmVkKHZhbCkge1xuICAgIGlmKCF0aGlzLm1vZGVsX2tleSkgdGhpcy5tb2RlbF9rZXkgPSB2YWwubW9kZWxfbmFtZSArIFwiX1wiICsgdmFsLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgaWYoIXRoaXMuZW52LmFjdGl2ZV9lbWJlZF9tb2RlbHMpIHRoaXMuZW52LmFjdGl2ZV9lbWJlZF9tb2RlbHMgPSB7fTtcbiAgICB0aGlzLmVudi5hY3RpdmVfZW1iZWRfbW9kZWxzW3RoaXMubW9kZWxfa2V5XSA9IHZhbDtcbiAgfVxuICBwYXVzZV9lbWJlZGRpbmcoKSB7XG4gICAgdGhpcy5fcGF1c2VfZW1iZWRkaW5ncyA9IHRydWU7XG4gICAgdGhpcy5lbnYubWFpbi5ub3RpY2VzLnJlbW92ZSgnZW1iZWRkaW5nIHByb2dyZXNzJyk7XG4gIH1cbiAgYXN5bmMgZW5zdXJlX2VtYmVkZGluZ3Moc2hvd19ub3RpY2UgPSBudWxsKSB7XG4gICAgY29uc29sZS5sb2coXCJlbnN1cmVfZW1iZWRkaW5nc1wiKTtcbiAgICBpZighdGhpcy5zbWFydF9lbWJlZCkgcmV0dXJuIGNvbnNvbGUubG9nKFwiU21hcnRFbWJlZCBub3QgbG9hZGVkIGZvciBcIiArIHRoaXMuY29sbGVjdGlvbl9uYW1lKTtcbiAgICBjb25zdCB1bmVtYmVkZGVkX2l0ZW1zID0gdGhpcy51bmVtYmVkZGVkX2l0ZW1zOyAvLyBnZXRzIGFsbCB3aXRob3V0IHZlY1xuICAgIGlmKHVuZW1iZWRkZWRfaXRlbXMubGVuZ3RoID09PSAwKSByZXR1cm4gdHJ1ZTsgLy8gc2tpcCBpZiBubyB1bmVtYmVkZGVkIGl0ZW1zXG4gICAgY29uc29sZS5sb2coXCJ1bmVtYmVkZGVkX2l0ZW1zOiBcIiwgdW5lbWJlZGRlZF9pdGVtcyk7XG4gICAgY29uc3QgcGVyZm9ybWFuY2Vfbm90aWNlX21zZyA9IFwiKFRoaXMgaXMgYSByZXNvdXJjZSBpbnRlbnNpdmUgb3BlcmF0aW9uKVwiO1xuICAgIGlmKChzaG93X25vdGljZSAhPT0gZmFsc2UpICYmICh1bmVtYmVkZGVkX2l0ZW1zLmxlbmd0aCA+IDMwKSkge1xuICAgICAgY29uc3Qgc3RhcnRfYnRuID0ge3RleHQ6IFwiU3RhcnQgZW1iZWRkaW5nXCIsIGNhbGxiYWNrOiAoKSA9PiB0aGlzLmVuc3VyZV9lbWJlZGRpbmdzKGZhbHNlKSB9O1xuICAgICAgdGhpcy5lbnYubWFpbi5ub3RpY2VzLnNob3coJ3N0YXJ0IGVtYmVkZGluZycsIFtgQXJlIHlvdSByZWFkeSB0byBiZWdpbiBlbWJlZGRpbmcgJHt1bmVtYmVkZGVkX2l0ZW1zLmxlbmd0aH0gJHt0aGlzLmNvbGxlY3Rpb25fbmFtZX0/YCwgcGVyZm9ybWFuY2Vfbm90aWNlX21zZ10sIHsgdGltZW91dDogMCwgY29uZmlybTogc3RhcnRfYnRufSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmKHRoaXMuaXNfZW1iZWRkaW5nKSByZXR1cm4gY29uc29sZS5sb2coJ2FscmVhZHkgZW1iZWRkaW5nJyk7XG4gICAgdGhpcy5pc19lbWJlZGRpbmcgPSB0cnVlO1xuICAgIGNvbnN0IGJhdGNoX3NpemUgPSB0aGlzLnNtYXJ0X2VtYmVkLmJhdGNoX3NpemU7XG4gICAgdGhpcy5lbnYubWFpbi5ub3RpY2VzLnJlbW92ZSgnc3RhcnQgZW1iZWRkaW5nJyk7XG4gICAgbGV0IHRvdGFsX3Rva2VucyA9IDA7XG4gICAgbGV0IHRpbWVfc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIGxldCB0aW1lX2VsYXBzZWQgPSAwO1xuICAgIGxldCB0b2tlbnNfcGVyX3NlYyA9IDA7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHVuZW1iZWRkZWRfaXRlbXMubGVuZ3RoOyBpICs9IGJhdGNoX3NpemUpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiaTogXCIsIGkpO1xuICAgICAgaWYodGhpcy5fcGF1c2VfZW1iZWRkaW5ncykge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcInBhdXNlX2VtYmVkZGluZ3NcIik7XG4gICAgICAgIHRoaXMuX3BhdXNlX2VtYmVkZGluZ3MgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgcmVzdGFydF9idG4gPSB7dGV4dDogXCJSZXN0YXJ0XCIsIGNhbGxiYWNrOiAoKSA9PiB0aGlzLmVuc3VyZV9lbWJlZGRpbmdzKCkgfTtcbiAgICAgICAgdGhpcy5lbnYubWFpbi5ub3RpY2VzLnNob3coJ3Jlc3RhcnQgZW1iZWRkaW5nJywgW2BFbWJlZGRpbmcgJHt0aGlzLmNvbGxlY3Rpb25fbmFtZX0uLi5gLCBgUGF1c2VkIGF0ICR7aX0gLyAke3VuZW1iZWRkZWRfaXRlbXMubGVuZ3RofSAke3RoaXMuY29sbGVjdGlvbl9uYW1lfWAsIHBlcmZvcm1hbmNlX25vdGljZV9tc2ddLCB7IHRpbWVvdXQ6IDAsIGJ1dHRvbjogcmVzdGFydF9idG59KTtcbiAgICAgICAgdGhpcy5MVE0uX3NhdmUodHJ1ZSk7IC8vIHNhdmUgaW1tZWRpYXRlbHksIG92ZXJ3cml0ZXMgZXhpc3RpbmcgZmlsZVxuICAgICAgICB0aGlzLmlzX2VtYmVkZGluZyA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZihpICUgMTAgPT09IDApe1xuICAgICAgICBjb25zdCBwYXVzZV9idG4gPSB7dGV4dDogXCJQYXVzZVwiLCBjYWxsYmFjazogKCkgPT4gdGhpcy5wYXVzZV9lbWJlZGRpbmcoKSwgc3RheV9vcGVuOiB0cnVlfTtcbiAgICAgICAgdGhpcy5lbnYubWFpbi5ub3RpY2VzLnNob3coJ2VtYmVkZGluZyBwcm9ncmVzcycsIFtgRW1iZWRkaW5nICR7dGhpcy5jb2xsZWN0aW9uX25hbWV9Li4uYCwgYFByb2dyZXNzOiAke2l9IC8gJHt1bmVtYmVkZGVkX2l0ZW1zLmxlbmd0aH0gJHt0aGlzLmNvbGxlY3Rpb25fbmFtZX1gLCBgJHt0b2tlbnNfcGVyX3NlY30gdG9rZW5zL3NlY2AsIHBlcmZvcm1hbmNlX25vdGljZV9tc2ddLCB7IHRpbWVvdXQ6IDAsIGJ1dHRvbjogcGF1c2VfYnRuLCBpbW11dGFibGU6IHRydWV9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGl0ZW1zID0gdW5lbWJlZGRlZF9pdGVtcy5zbGljZShpLCBpICsgYmF0Y2hfc2l6ZSk7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChpdGVtcy5tYXAoYXN5bmMgaXRlbSA9PiBhd2FpdCBpdGVtLmdldF9lbWJlZF9pbnB1dCgpKSk7IC8vIG1ha2Ugc3VyZSBhbGwgaXRlbXMgaGF2ZSBlbWJlZF9pbnB1dCAoaW4gY2FjaGUgZm9yIGNhbGwgYnkgZW1iZWRfYmF0Y2gpXG4gICAgICBjb25zdCByZXNwID0gYXdhaXQgdGhpcy5zbWFydF9lbWJlZC5lbWJlZF9iYXRjaChpdGVtcyk7XG4gICAgICAvLyBjb25zb2xlLmxvZyhcInJlc3A6IFwiLCByZXNwKTtcbiAgICAgIGl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgIGl0ZW0uX2VtYmVkX2lucHV0ID0gbnVsbDsgLy8gY2xlYXIgX2VtYmVkX2lucHV0IGNhY2hlIGFmdGVyIGVtYmVkZGluZ1xuICAgICAgICBpdGVtLmNoYW5nZWQgPSB0cnVlOyAvLyBtYXJrIGFzIGNoYW5nZWRcbiAgICAgIH0pO1xuICAgICAgdG90YWxfdG9rZW5zICs9IHJlc3AucmVkdWNlKChhY2MsIGl0ZW0pID0+IGFjYyArIGl0ZW0udG9rZW5zLCAwKTtcbiAgICAgIHRpbWVfZWxhcHNlZCA9IERhdGUubm93KCkgLSB0aW1lX3N0YXJ0O1xuICAgICAgdG9rZW5zX3Blcl9zZWMgPSBNYXRoLnJvdW5kKHRvdGFsX3Rva2VucyAvICh0aW1lX2VsYXBzZWQgLyAxMDAwKSk7XG4gICAgICAvLyBjb25zb2xlLmxvZyhpdGVtcy5maWx0ZXIoaSA9PiAhaS52ZWMpLm1hcChpdGVtID0+IGl0ZW0pKTtcbiAgICAgIGlmKGkgJiYgKGkgJSA1MDAgPT09IDApKXtcbiAgICAgICAgLy8gY29uc29sZS5sb2codW5lbWJlZGRlZF9pdGVtc1tpXSk7XG4gICAgICAgIGF3YWl0IHRoaXMuTFRNLl9zYXZlKCk7XG4gICAgICB9XG4gICAgICAvLyBjb25zb2xlLmxvZyhcImRvbmUgaTogXCIsIGkpO1xuICAgIH1cbiAgICBpZih0aGlzLmVudi5tYWluLl9ub3RpY2U/Lm5vdGljZUVsPy5wYXJlbnRFbGVtZW50KSB0aGlzLmVudi5tYWluLl9ub3RpY2UuaGlkZSgpO1xuICAgIGNvbnN0IGVtYmVkZGVkX2N0ID0gdW5lbWJlZGRlZF9pdGVtcy5maWx0ZXIoaSA9PiBpLnZlYykubGVuZ3RoO1xuICAgIC8vIGNvbnNvbGUubG9nKHVuZW1iZWRkZWRfaXRlbXMubWFwKGkgPT4gaS5rZXkpKTtcbiAgICB0aGlzLmVudi5tYWluLm5vdGljZXMucmVtb3ZlKCdlbWJlZGRpbmcgcHJvZ3Jlc3MnKTtcbiAgICB0aGlzLmVudi5tYWluLm5vdGljZXMuc2hvdygnZG9uZSBlbWJlZGRpbmcnLCBbYEVtYmVkZGluZyAke3RoaXMuY29sbGVjdGlvbl9uYW1lfS4uLmAsIGBEb25lIGNyZWF0aW5nICR7ZW1iZWRkZWRfY3R9IGVtYmVkZGluZ3MuYF0sIHsgdGltZW91dDogMTAwMDAgfSk7XG4gICAgaWYodW5lbWJlZGRlZF9pdGVtcy5sZW5ndGgpIHRoaXMuTFRNLl9zYXZlKCk7XG4gICAgdGhpcy5pc19lbWJlZGRpbmcgPSBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBnZXQgZW1iZWRkZWRfaXRlbXMoKSB7IHJldHVybiB0aGlzLnNtYXJ0X2VtYmVkID8gT2JqZWN0LnZhbHVlcyh0aGlzLml0ZW1zKS5maWx0ZXIoaSA9PiBpLnZlYykgOiBPYmplY3QudmFsdWVzKHRoaXMuaXRlbXMpOyB9XG4gIGdldCB1bmVtYmVkZGVkX2l0ZW1zKCkgeyByZXR1cm4gdGhpcy5zbWFydF9lbWJlZCA/IE9iamVjdC52YWx1ZXModGhpcy5pdGVtcykuZmlsdGVyKGl0ZW0gPT4gIWl0ZW0udmVjKSA6IFtdOyB9XG5cbiAgbmVhcmVzdCh2ZWMsIGZpbHRlcj17fSkge1xuICAgIGlmKCF2ZWMpIHJldHVybiBjb25zb2xlLmxvZyhcIm5vIHZlY1wiKTtcbiAgICBjb25zdCB7XG4gICAgICAvLyByZXN1bHRzX2NvdW50ID0gMjAsXG4gICAgICByZXN1bHRzX2NvdW50ID0gNTAsXG4gICAgfSA9IGZpbHRlcjtcbiAgICBjb25zdCBuZWFyZXN0ID0gdGhpcy5maWx0ZXIoZmlsdGVyKVxuICAgICAgLnJlZHVjZSgoYWNjLCBpdGVtKSA9PiB7XG4gICAgICAgIGlmKCFpdGVtLmRhdGEuZW1iZWRkaW5nPy52ZWMpIHJldHVybiBhY2M7IC8vIHNraXAgaWYgbm8gdmVjXG4gICAgICAgIGl0ZW0uc2ltID0gY29zX3NpbSh2ZWMsIGl0ZW0uZGF0YS5lbWJlZGRpbmcudmVjKTtcbiAgICAgICAgdG9wX2FjYyhhY2MsIGl0ZW0sIHJlc3VsdHNfY291bnQpOyAvLyB1cGRhdGUgYWNjXG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LCB7IG1pbjogMCwgaXRlbXM6IG5ldyBTZXQoKSB9KVxuICAgIDtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShuZWFyZXN0Lml0ZW1zKTtcbiAgfVxuICBnZXQgZmlsZV9uYW1lKCkgeyByZXR1cm4gdGhpcy5jb2xsZWN0aW9uX25hbWUgKyAnLScgKyB0aGlzLnNtYXJ0X2VtYmVkX21vZGVsLnNwbGl0KFwiL1wiKS5wb3AoKTsgfVxuICBnZXQgc21hcnRfZW1iZWRfbW9kZWwoKSB7IHJldHVybiB0aGlzLmNvbmZpZ1t0aGlzLmNvbGxlY3Rpb25fbmFtZSArIFwiX2VtYmVkX21vZGVsXCJdOyB9XG59XG5jbGFzcyBTbWFydEVudGl0eSBleHRlbmRzIENvbGxlY3Rpb25JdGVtIHtcbiAgc3RhdGljIGdldCBkZWZhdWx0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YToge1xuICAgICAgICBwYXRoOiBudWxsLFxuICAgICAgICBlbWJlZGRpbmc6IHt9LFxuICAgICAgfSxcbiAgICB9O1xuICB9XG4gIGdldF9rZXkoKSB7IHJldHVybiB0aGlzLmRhdGEucGF0aDsgfVxuICAvLyBETzogY2xhcmlmaWVkL2ltcHJvdmVkIGxvZ2ljXG4gIHNhdmUoKSB7XG4gICAgdGhpcy5jb2xsZWN0aW9uLnNldCh0aGlzKTtcbiAgICB0aGlzLmVudi5zYXZlKCk7XG4gIH1cbiAgZ2V0X25lYXJlc3QoZmlsdGVyPXt9KSB7IC8qIFRPRE8gKi8gfVxuICBhc3luYyBnZXRfYXNfY29udGV4dChwYXJhbXMgPSB7fSkge1xuICAgIHJldHVybiBgLS0tQkVHSU4gTk9URSR7cGFyYW1zLmkgPyBcIiBcIiArIHBhcmFtcy5pIDogXCJcIn0gW1ske3RoaXMucGF0aH1dXS0tLVxcbiR7YXdhaXQgdGhpcy5nZXRfY29udGVudCgpfVxcbi0tLUVORCBOT1RFJHtwYXJhbXMuaSA/IFwiIFwiICsgcGFyYW1zLmkgOiBcIlwifS0tLWA7XG4gIH1cbiAgYXN5bmMgZ2V0X2NvbnRlbnQoKSB7fSAvLyBvdmVycmlkZSBpbiBjaGlsZCBjbGFzc1xuICBhc3luYyBnZXRfZW1iZWRfaW5wdXQoKSB7fSAvLyBvdmVycmlkZSBpbiBjaGlsZCBjbGFzc1xuICAvLyBnZXR0ZXJzXG4gIGdldCBhanNvbigpIHsgcmV0dXJuIGAke0pTT04uc3RyaW5naWZ5KHRoaXMua2V5KX06ICR7SlNPTi5zdHJpbmdpZnkodGhpcy5kYXRhKX1gOyB9XG4gIGdldCBlbWJlZF9saW5rKCkgeyByZXR1cm4gYCFbWyR7dGhpcy5kYXRhLnBhdGh9XV1gOyB9XG4gIGdldCBtdWx0aV9hanNvbl9maWxlX25hbWUoKSB7IHJldHVybiAodGhpcy5wYXRoLnNwbGl0KFwiI1wiKS5zaGlmdCgpKS5yZXBsYWNlKC9bXmEtekEtWjAtOV0vZywgJ18nKS5yZXBsYWNlKFwiLm1kXCIsIFwiXCIpOyB9XG4gIGdldCBuYW1lKCkgeyByZXR1cm4gKCF0aGlzLmVudi5tYWluLnNldHRpbmdzLnNob3dfZnVsbF9wYXRoID8gdGhpcy5wYXRoLnNwbGl0KFwiL1wiKS5wb3AoKSA6IHRoaXMucGF0aC5zcGxpdChcIi9cIikuam9pbihcIiA+IFwiKSkuc3BsaXQoXCIjXCIpLmpvaW4oXCIgPiBcIikucmVwbGFjZShcIi5tZFwiLCBcIlwiKTsgfVxuICBnZXQgcGF0aCgpIHsgcmV0dXJuIHRoaXMuZGF0YS5wYXRoOyB9XG4gIGdldCB0b2tlbnMoKSB7IHJldHVybiB0aGlzLmRhdGEuZW1iZWRkaW5nLnRva2VuczsgfVxuICBnZXQgdmVjKCkgeyByZXR1cm4gdGhpcy5kYXRhLmVtYmVkZGluZy52ZWM7IH1cbiAgLy8gc2V0dGVyc1xuICBzZXQgZXJyb3IoZXJyb3IpIHsgdGhpcy5kYXRhLmVtYmVkZGluZy5lcnJvciA9IGVycm9yOyB9XG4gIHNldCB0b2tlbnModG9rZW5zKSB7IHRoaXMuZGF0YS5lbWJlZGRpbmcudG9rZW5zID0gdG9rZW5zOyB9XG4gIHNldCB2ZWModmVjKSB7IHRoaXMuZGF0YS5lbWJlZGRpbmcudmVjID0gdmVjOyB9XG59XG4vLyBDT1NJTkUgU0lNSUxBUklUWVxuZnVuY3Rpb24gY29zX3NpbSh2ZWN0b3IxLCB2ZWN0b3IyKSB7XG4gIGNvbnN0IGRvdFByb2R1Y3QgPSB2ZWN0b3IxLnJlZHVjZSgoYWNjLCB2YWwsIGkpID0+IGFjYyArIHZhbCAqIHZlY3RvcjJbaV0sIDApO1xuICBjb25zdCBub3JtQSA9IE1hdGguc3FydCh2ZWN0b3IxLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYyArIHZhbCAqIHZhbCwgMCkpO1xuICBjb25zdCBub3JtQiA9IE1hdGguc3FydCh2ZWN0b3IyLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYyArIHZhbCAqIHZhbCwgMCkpO1xuICByZXR1cm4gbm9ybUEgPT09IDAgfHwgbm9ybUIgPT09IDAgPyAwIDogZG90UHJvZHVjdCAvIChub3JtQSAqIG5vcm1CKTtcbn1cbmZ1bmN0aW9uIHRvcF9hY2MoX2FjYywgaXRlbSwgY3QgPSAxMCkge1xuICBpZiAoX2FjYy5pdGVtcy5zaXplIDwgY3QpIHtcbiAgICBfYWNjLml0ZW1zLmFkZChpdGVtKTtcbiAgfSBlbHNlIGlmIChpdGVtLnNpbSA+IF9hY2MubWluKSB7XG4gICAgX2FjYy5pdGVtcy5hZGQoaXRlbSk7XG4gICAgX2FjYy5pdGVtcy5kZWxldGUoX2FjYy5taW5JdGVtKTtcbiAgICBfYWNjLm1pbkl0ZW0gPSBBcnJheS5mcm9tKF9hY2MuaXRlbXMpLnJlZHVjZSgobWluLCBjdXJyKSA9PiAoY3Vyci5zaW0gPCBtaW4uc2ltID8gY3VyciA6IG1pbikpO1xuICAgIF9hY2MubWluID0gX2FjYy5taW5JdGVtLnNpbTtcbiAgfVxufVxuXG5leHBvcnRzLlNtYXJ0RW50aXR5ID0gU21hcnRFbnRpdHk7XG5leHBvcnRzLlNtYXJ0RW50aXRpZXMgPSBTbWFydEVudGl0aWVzO1xuZXhwb3J0cy5jb3Nfc2ltID0gY29zX3NpbTtcblxuLy8gRE86IEV4dHJhY3QgdG8gc2VwYXJhdGUgZmlsZXNcbmNsYXNzIFNtYXJ0Tm90ZXMgZXh0ZW5kcyBTbWFydEVudGl0aWVzIHtcbiAgYXN5bmMgaW1wb3J0KGZpbGVzLCBvcHRzPSB7fSkge1xuICAgIHRyeXtcbiAgICAgIGxldCBiYXRjaCA9IFtdO1xuICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgaWYoYmF0Y2gubGVuZ3RoICUgMTAgPT09IDApe1xuICAgICAgICAgIHRoaXMuZW52Lm1haW4ubm90aWNlcy5zaG93KCdpbml0aWFsIHNjYW4gcHJvZ3Jlc3MnLCBbYE1ha2luZyBTbWFydCBDb25uZWN0aW9ucy4uLmAsIGBQcm9ncmVzczogJHtpfSAvICR7ZmlsZXMubGVuZ3RofSBmaWxlc2BdLCB7IHRpbWVvdXQ6IDAgfSk7XG4gICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoYmF0Y2gpO1xuICAgICAgICAgIGJhdGNoID0gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm90ZSA9IHRoaXMuZ2V0KGZpbGVzW2ldLnBhdGgpO1xuICAgICAgICBpZighbm90ZSkgYmF0Y2gucHVzaCh0aGlzLmNyZWF0ZV9vcl91cGRhdGUoeyBwYXRoOiBmaWxlc1tpXS5wYXRoIH0pKTtcbiAgICAgICAgaWYobm90ZSAmJiBub3RlLm1ldGFfY2hhbmdlZCl7XG4gICAgICAgICAgbm90ZS5kYXRhLmVtYmVkZGluZyA9IHt9O1xuICAgICAgICAgIGJhdGNoLnB1c2godGhpcy5jcmVhdGVfb3JfdXBkYXRlKHsgcGF0aDogZmlsZXNbaV0ucGF0aCB9KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKGJhdGNoKTtcbiAgICAgIHRoaXMuZW52Lm1haW4ubm90aWNlcy5yZW1vdmUoJ2luaXRpYWwgc2NhbiBwcm9ncmVzcycpO1xuICAgICAgdGhpcy5lbnYubWFpbi5ub3RpY2VzLnNob3coJ2RvbmUgaW5pdGlhbCBzY2FuJywgW2BNYWtpbmcgU21hcnQgQ29ubmVjdGlvbnMuLi5gLCBgRG9uZSBpbXBvcnRpbmcgU21hcnQgTm90ZXMuYF0sIHsgdGltZW91dDogMzAwMCB9KTtcbiAgICAgIHRoaXMuZW5zdXJlX2VtYmVkZGluZ3MoKTtcbiAgICB9Y2F0Y2goZSl7XG4gICAgICBjb25zb2xlLmxvZyhcImVycm9yIGltcG9ydGluZyBibG9ja3NcIik7XG4gICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZW5zdXJlX2VtYmVkZGluZ3Moc2hvd19ub3RpY2UgPSBmYWxzZSkge1xuICAgIGF3YWl0IHN1cGVyLmVuc3VyZV9lbWJlZGRpbmdzKHNob3dfbm90aWNlKTtcbiAgICBhd2FpdCB0aGlzLnBydW5lKHRydWUpO1xuICAgIGlmKHRoaXMuZW52LnNtYXJ0X2Jsb2Nrcz8uc21hcnRfZW1iZWQpe1xuICAgICAgYXdhaXQgdGhpcy5lbnYuc21hcnRfYmxvY2tzLmVuc3VyZV9lbWJlZGRpbmdzKHtzaG93X25vdGljZX0pOyAvLyB0cmlnZ2VyIGJsb2NrLWxldmVsIGltcG9ydFxuICAgICAgYXdhaXQgdGhpcy5lbnYuc21hcnRfYmxvY2tzLnBydW5lKHRydWUpO1xuICAgIH1cbiAgfVxuICBhc3luYyBwcnVuZShvdmVycmlkZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgcmVtb3ZlID0gW107XG4gICAgY29uc3QgaXRlbXNfd192ZWMgPSBPYmplY3QuZW50cmllcyh0aGlzLml0ZW1zKS5maWx0ZXIoKFtrZXksIG5vdGVdKSA9PiBub3RlLnZlYyk7XG4gICAgY29uc3QgdG90YWxfaXRlbXNfd192ZWMgPSBpdGVtc193X3ZlYy5sZW5ndGg7XG4gICAgY29uc3QgYXZhaWxhYmxlX25vdGVzID0gdGhpcy5lbnYuZmlsZXMucmVkdWNlKChhY2MsIGZpbGUpID0+IHtcbiAgICAgIGFjY1tmaWxlLnBhdGhdID0gdHJ1ZTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICAgIGlmKCF0b3RhbF9pdGVtc193X3ZlYyl7XG4gICAgICB0aGlzLmNsZWFyKCk7IC8vIGNsZWFyIGlmIG5vIGl0ZW1zIHdpdGggdmVjIChyZWJ1aWxkcyBpbiBpbXBvcnQpXG4gICAgICByZXR1cm47IC8vIHNraXAgcmVzdCBpZiBubyBpdGVtcyB3aXRoIHZlY1xuICAgIH1cbiAgICBmb3IoY29uc3QgW2tleSwgbm90ZV0gb2YgaXRlbXNfd192ZWMpe1xuICAgICAgaWYoIWF2YWlsYWJsZV9ub3Rlc1tub3RlLmRhdGEucGF0aF0pe1xuICAgICAgICByZW1vdmUucHVzaChrZXkpOyAvLyByZW1vdmUgaWYgbm90IGF2YWlsYWJsZVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmKG5vdGUuaXNfZ29uZSl7XG4gICAgICAgIHJlbW92ZS5wdXNoKGtleSk7IC8vIHJlbW92ZSBpZiBleHBpcmVkXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYobm90ZS5tZXRhX2NoYW5nZWQpe1xuICAgICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgbm90ZS5nZXRfY29udGVudCgpO1xuICAgICAgICBjb25zdCBoYXNoID0gYXdhaXQgY3JlYXRlX2hhc2goY29udGVudCk7XG4gICAgICAgIGlmKGhhc2ggIT09IG5vdGUubGFzdF9oaXN0b3J5Py5oYXNoKXtcbiAgICAgICAgICByZW1vdmUucHVzaChrZXkpOyAvLyByZW1vdmUgaWYgY2hhbmdlZFxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKHJlbW92ZSk7XG4gICAgY29uc3QgcmVtb3ZlX3JhdGlvID0gcmVtb3ZlLmxlbmd0aCAvIHRvdGFsX2l0ZW1zX3dfdmVjO1xuICAgIGlmKChvdmVycmlkZSAmJiAocmVtb3ZlX3JhdGlvIDwgMC41KSkgfHwgY29uZmlybShgQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIGRlbGV0ZSAke3JlbW92ZS5sZW5ndGh9ICgke01hdGguZmxvb3IocmVtb3ZlX3JhdGlvKjEwMCl9JSkgTm90ZS1sZXZlbCBFbWJlZGRpbmdzP2ApKXtcbiAgICAgIHRoaXMuZGVsZXRlX21hbnkocmVtb3ZlKTtcbiAgICAgIHRoaXMuTFRNLl9zYXZlKHRydWUpOyAvLyBzYXZlIGlmIG5vdCBvdmVycmlkZVxuICAgICAgY29uc29sZS5sb2coYFBydW5lZCAke3JlbW92ZS5sZW5ndGh9IFNtYXJ0IE5vdGVzYCk7XG4gICAgfVxuICB9XG4gIGdldCBjdXJyZW50X25vdGUoKSB7IHJldHVybiB0aGlzLmdldCh0aGlzLmVudi5tYWluLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpLnBhdGgpOyB9XG4gIGdldCBibG9ja3MoKSB7IHRoaXMuZW52LnNtYXJ0X2Jsb2Nrcy5nZXRfbWFueSh0aGlzLmxhc3RfaGlzdG9yeS5ibG9ja3MpOyB9XG59XG5jbGFzcyBTbWFydE5vdGUgZXh0ZW5kcyBTbWFydEVudGl0eSB7XG4gIHN0YXRpYyBnZXQgZGVmYXVsdHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgaGlzdG9yeTogW10sIC8vIGFycmF5IG9mIHsgbXRpbWUsIGhhc2gsIGxlbmd0aCwgYmxvY2tzW10gfVxuICAgICAgfSxcbiAgICAgIF9lbWJlZF9pbnB1dDogbnVsbCwgLy8gc3RvcmVkIHRlbXBvcmFyaWx5XG4gICAgfTtcbiAgfVxuICBhc3luYyBpbml0KCkge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLmdldF9jb250ZW50KCk7XG4gICAgY29uc3QgaGFzaCA9IGF3YWl0IGNyZWF0ZV9oYXNoKGNvbnRlbnQpOyAvLyB1cGRhdGUgaGFzaFxuICAgIGlmKGhhc2ggIT09IHRoaXMubGFzdF9oaXN0b3J5Py5oYXNoKXtcbiAgICAgIHRoaXMuZGF0YS5oaXN0b3J5LnB1c2goeyBibG9ja3M6IHt9LCBtdGltZTogdGhpcy50X2ZpbGUuc3RhdC5tdGltZSwgc2l6ZTogdGhpcy50X2ZpbGUuc3RhdC5zaXplLCBoYXNoIH0pOyAvLyBhZGQgaGlzdG9yeSBlbnRyeVxuICAgICAgdGhpcy5kYXRhLmVtYmVkZGluZyA9IHt9OyAvLyBjbGVhciBlbWJlZGRpbmdcbiAgICB9ZWxzZXtcbiAgICAgIHRoaXMubGFzdF9oaXN0b3J5Lm10aW1lID0gdGhpcy50X2ZpbGUuc3RhdC5tdGltZTsgLy8gdXBkYXRlIG10aW1lXG4gICAgICB0aGlzLmxhc3RfaGlzdG9yeS5zaXplID0gdGhpcy50X2ZpbGUuc3RhdC5zaXplOyAvLyB1cGRhdGUgc2l6ZVxuICAgIH1cbiAgICB0aGlzLmVudi5zbWFydF9ibG9ja3MuaW1wb3J0KHRoaXMsIHsgc2hvd19ub3RpY2U6IGZhbHNlIH0pO1xuICB9XG4gIGFzeW5jIGdldF9lbWJlZF9pbnB1dCgpIHtcbiAgICBpZih0eXBlb2YgdGhpcy5fZW1iZWRfaW5wdXQgPT09ICdzdHJpbmcnICYmIHRoaXMuX2VtYmVkX2lucHV0Lmxlbmd0aCkgcmV0dXJuIHRoaXMuX2VtYmVkX2lucHV0OyAvLyByZXR1cm4gY2FjaGVkICh0ZW1wb3JhcnkpIGlucHV0XG4gICAgY29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMuZ2V0X2NvbnRlbnQoKTsgLy8gZ2V0IGNvbnRlbnQgZnJvbSBmaWxlXG4gICAgY29uc3QgYnJlYWRjcnVtYnMgPSB0aGlzLmRhdGEucGF0aC5zcGxpdChcIi9cIikuam9pbihcIiA+IFwiKS5yZXBsYWNlKFwiLm1kXCIsIFwiXCIpO1xuICAgIHRoaXMuX2VtYmVkX2lucHV0ID0gYCR7YnJlYWRjcnVtYnN9OlxcbiR7Y29udGVudH1gO1xuICAgIHJldHVybiB0aGlzLl9lbWJlZF9pbnB1dDtcbiAgfVxuICBmaW5kX2Nvbm5lY3Rpb25zKCkge1xuICAgIGxldCByZXN1bHRzID0gW107XG4gICAgaWYoIXRoaXMudmVjICYmICF0aGlzLm1lZGlhbl9ibG9ja192ZWMpe1xuICAgICAgLy8gY29uc29sZS5sb2codGhpcyk7XG4gICAgICBjb25zdCBzdGFydF9lbWJlZGRpbmdfYnRuID0ge1xuICAgICAgICB0ZXh0OiBcIlN0YXJ0IGVtYmVkZGluZ1wiLFxuICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgIHRoaXMuY29sbGVjdGlvbi5pbXBvcnQoKS50aGVuKCgpID0+IHRoaXMuZW52Lm1haW4udmlldy5yZW5kZXJfbmVhcmVzdCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLmVudi5tYWluLm5vdGljZXMuc2hvdygnbm8gZW1iZWRkaW5nIGZvdW5kJywgYE5vIGVtYmVkZGluZ3MgZm91bmQgZm9yICR7dGhpcy5uYW1lfS5gLCB7IGNvbmZpcm06IHN0YXJ0X2VtYmVkZGluZ19idG4gfSk7XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgaWYodGhpcy52ZWMgJiYgdGhpcy5tZWRpYW5fYmxvY2tfdmVjICYmIHRoaXMuZW52LnNtYXJ0X2Jsb2Nrcy5zbWFydF9lbWJlZCAmJiB0aGlzLmNvbGxlY3Rpb24uc21hcnRfZW1iZWQpe1xuICAgICAgY29uc3QgbmVhcmVzdF9ibG9ja3MgPSB0aGlzLmVudi5zbWFydF9ibG9ja3MubmVhcmVzdCh0aGlzLm1lZGlhbl9ibG9ja192ZWMsIHsgZXhjbHVkZV9rZXlfc3RhcnRzX3dpdGg6IHRoaXMua2V5IH0pO1xuICAgICAgY29uc3QgbmVhcmVzdF9ub3RlcyA9IHRoaXMuZW52LnNtYXJ0X25vdGVzLm5lYXJlc3QodGhpcy52ZWMsIHsgZXhjbHVkZV9rZXlfc3RhcnRzX3dpdGg6IHRoaXMua2V5IH0pO1xuICAgICAgcmVzdWx0cyA9IG5lYXJlc3RfYmxvY2tzXG4gICAgICAgIC5tYXAoYmxvY2sgPT4ge1xuICAgICAgICAgIGNvbnN0IG5vdGUgPSBuZWFyZXN0X25vdGVzLmZpbmQobm90ZSA9PiBub3RlLmtleSA9PT0gYmxvY2subm90ZV9rZXkpO1xuICAgICAgICAgIGlmKCFub3RlKSBibG9jay5zY29yZSA9IGJsb2NrLnNpbTtcbiAgICAgICAgICBlbHNlIGJsb2NrLnNjb3JlID0gKGJsb2NrLnNpbSArIG5vdGUuc2ltKSAvIDI7XG4gICAgICAgICAgcmV0dXJuIGJsb2NrO1xuICAgICAgICB9KVxuICAgICAgICAvLyBzb3J0IGJ5IGl0ZW0uc2NvcmUgZGVzY2VuZGluZ1xuICAgICAgICAuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgIGlmKGEuc2NvcmUgPT09IGIuc2NvcmUpIHJldHVybiAwO1xuICAgICAgICAgIHJldHVybiAoYS5zY29yZSA+IGIuc2NvcmUpID8gLTEgOiAxO1xuICAgICAgICB9KVxuICAgICAgO1xuICAgIH1lbHNlIGlmKHRoaXMubWVkaWFuX2Jsb2NrX3ZlYyAmJiB0aGlzLmVudi5zbWFydF9ibG9ja3Muc21hcnRfZW1iZWQpe1xuICAgICAgY29uc3QgbmVhcmVzdF9ibG9ja3MgPSB0aGlzLmVudi5zbWFydF9ibG9ja3MubmVhcmVzdCh0aGlzLm1lZGlhbl9ibG9ja192ZWMsIHsgZXhjbHVkZV9rZXlfc3RhcnRzX3dpdGg6IHRoaXMua2V5IH0pO1xuICAgICAgLy8gcmUtcmFuazogc29ydCBieSBibG9jayBub3RlIG1lZGlhbiBibG9jayB2ZWMgc2ltXG4gICAgICByZXN1bHRzID0gbmVhcmVzdF9ibG9ja3NcbiAgICAgICAgLm1hcChibG9jayA9PiB7XG4gICAgICAgICAgaWYoIWJsb2NrLm5vdGU/Lm1lZGlhbl9ibG9ja192ZWMubGVuZ3RoKXtcbiAgICAgICAgICAgIGJsb2NrLnNjb3JlID0gYmxvY2suc2ltO1xuICAgICAgICAgICAgcmV0dXJuIGJsb2NrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBibG9jay5zY29yZSA9IChibG9jay5zaW0gKyBjb3Nfc2ltKHRoaXMubWVkaWFuX2Jsb2NrX3ZlYywgYmxvY2subm90ZS5tZWRpYW5fYmxvY2tfdmVjKSkgLyAyO1xuICAgICAgICAgIHJldHVybiBibG9jaztcbiAgICAgICAgfSlcbiAgICAgICAgLy8gc29ydCBieSBpdGVtLnNjb3JlIGRlc2NlbmRpbmdcbiAgICAgICAgLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICBpZihhLnNjb3JlID09PSBiLnNjb3JlKSByZXR1cm4gMDtcbiAgICAgICAgICByZXR1cm4gKGEuc2NvcmUgPiBiLnNjb3JlKSA/IC0xIDogMTtcbiAgICAgICAgfSlcbiAgICAgIDtcbiAgICB9ZWxzZSBpZih0aGlzLnZlYyAmJiB0aGlzLmNvbGxlY3Rpb24uc21hcnRfZW1iZWQpe1xuICAgICAgY29uc3QgbmVhcmVzdF9ub3RlcyA9IHRoaXMuZW52LnNtYXJ0X25vdGVzLm5lYXJlc3QodGhpcy52ZWMsIHsgZXhjbHVkZV9rZXlfc3RhcnRzX3dpdGg6IHRoaXMua2V5IH0pO1xuICAgICAgcmVzdWx0cyA9IG5lYXJlc3Rfbm90ZXNcbiAgICAgICAgLm1hcChub3RlID0+IHtcbiAgICAgICAgICBub3RlLnNjb3JlID0gbm90ZS5zaW07XG4gICAgICAgICAgcmV0dXJuIG5vdGU7XG4gICAgICAgIH0pXG4gICAgICAgIC8vIHNvcnQgYnkgaXRlbS5zY29yZSBkZXNjZW5kaW5nXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgaWYoYS5zY29yZSA9PT0gYi5zY29yZSkgcmV0dXJuIDA7XG4gICAgICAgICAgcmV0dXJuIChhLnNjb3JlID4gYi5zY29yZSkgPyAtMSA6IDE7XG4gICAgICAgIH0pXG4gICAgICA7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG4gIG9wZW4oKSB7IHRoaXMuZW52Lm1haW4ub3Blbl9ub3RlKHRoaXMuZGF0YS5wYXRoKTsgfVxuICBnZXRfYmxvY2tfYnlfbGluZShsaW5lKSB7IHJldHVybiB0aGlzLmJsb2Nrcy5maW5kKGJsb2NrID0+IGJsb2NrLmRhdGEubGluZXNbMF0gPD0gbGluZSAmJiBibG9jay5kYXRhLmxpbmVzWzFdID49IGxpbmUpOyB9XG4gIGdldCBibG9ja192ZWNzKCkgeyByZXR1cm4gdGhpcy5ibG9ja3MubWFwKGJsb2NrID0+IGJsb2NrLmRhdGEuZW1iZWRkaW5nLnZlYykuZmlsdGVyKHZlYyA9PiB2ZWMpOyB9IC8vIGZpbHRlciBvdXQgYmxvY2tzIHdpdGhvdXQgdmVjXG4gIGdldCBibG9ja3MoKSB7IHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmxhc3RfaGlzdG9yeS5ibG9ja3MpLm1hcChibG9ja19rZXkgPT4gdGhpcy5lbnYuc21hcnRfYmxvY2tzLmdldChibG9ja19rZXkpKS5maWx0ZXIoYmxvY2sgPT4gYmxvY2spOyB9IC8vIGZpbHRlciBvdXQgYmxvY2tzIHRoYXQgZG9uJ3QgZXhpc3RcbiAgZ2V0IGVtYmVkX2lucHV0KCkgeyByZXR1cm4gdGhpcy5fZW1iZWRfaW5wdXQgPyB0aGlzLl9lbWJlZF9pbnB1dCA6IHRoaXMuZ2V0X2VtYmVkX2lucHV0KCk7IH1cbiAgZ2V0IG1ldGFfY2hhbmdlZCgpIHtcbiAgICBpZighdGhpcy5sYXN0X2hpc3RvcnkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiAodGhpcy5sYXN0X2hpc3RvcnkubXRpbWUgIT09IHRoaXMudF9maWxlLnN0YXQubXRpbWUpICYmICh0aGlzLmxhc3RfaGlzdG9yeS5zaXplICE9PSB0aGlzLnRfZmlsZS5zdGF0LnNpemUpO1xuICB9XG4gIGdldCBpc19jYW52YXMoKSB7IHJldHVybiB0aGlzLmRhdGEucGF0aC5lbmRzV2l0aChcImNhbnZhc1wiKTsgfVxuICBnZXQgaXNfZXhjYWxpZHJhdygpIHsgcmV0dXJuIHRoaXMuZGF0YS5wYXRoLmVuZHNXaXRoKFwiZXhjYWxpZHJhdy5tZFwiKTsgfVxuICBnZXQgaXNfZ29uZSgpIHsgcmV0dXJuIHRoaXMudF9maWxlID09PSBudWxsOyB9XG4gIGdldCBsYXN0X2hpc3RvcnkoKSB7IHJldHVybiB0aGlzLmRhdGEuaGlzdG9yeS5sZW5ndGggPyB0aGlzLmRhdGEuaGlzdG9yeVt0aGlzLmRhdGEuaGlzdG9yeS5sZW5ndGggLSAxXSA6IG51bGw7IH1cbiAgZ2V0IG1lYW5fYmxvY2tfdmVjKCkgeyByZXR1cm4gdGhpcy5fbWVhbl9ibG9ja192ZWMgPyB0aGlzLl9tZWFuX2Jsb2NrX3ZlYyA6IHRoaXMuX21lYW5fYmxvY2tfdmVjID0gdGhpcy5ibG9ja192ZWNzLnJlZHVjZSgoYWNjLCB2ZWMpID0+IGFjYy5tYXAoKHZhbCwgaSkgPT4gdmFsICsgdmVjW2ldKSwgQXJyYXkoMzg0KS5maWxsKDApKS5tYXAodmFsID0+IHZhbCAvIHRoaXMuYmxvY2tfdmVjcy5sZW5ndGgpOyB9XG4gIGdldCBtZWRpYW5fYmxvY2tfdmVjKCkgeyByZXR1cm4gdGhpcy5fbWVkaWFuX2Jsb2NrX3ZlYyA/IHRoaXMuX21lZGlhbl9ibG9ja192ZWMgOiB0aGlzLl9tZWRpYW5fYmxvY2tfdmVjID0gdGhpcy5ibG9ja192ZWNzWzBdPy5tYXAoKHZhbCwgaSkgPT4gdGhpcy5ibG9ja192ZWNzLm1hcCh2ZWMgPT4gdmVjW2ldKS5zb3J0KClbTWF0aC5mbG9vcih0aGlzLmJsb2NrX3ZlY3MubGVuZ3RoIC8gMildKTsgfVxuICBnZXQgbm90ZV9uYW1lKCkgeyByZXR1cm4gdGhpcy5wYXRoLnNwbGl0KFwiL1wiKS5wb3AoKS5yZXBsYWNlKFwiLm1kXCIsIFwiXCIpOyB9XG4gIGdldCB0X2ZpbGUoKSB7IHJldHVybiB0aGlzLmVudi5nZXRfdGZpbGUodGhpcy5kYXRhLnBhdGgpOyB9XG59XG5jbGFzcyBTbWFydEJsb2NrcyBleHRlbmRzIFNtYXJ0RW50aXRpZXMge1xuICBhc3luYyBpbXBvcnQobm90ZSkge1xuICAgIHRyeXtcbiAgICAgIGNvbnN0IG5vdGVfcGF0aCA9IG5vdGUuZGF0YS5wYXRoO1xuICAgICAgY29uc3Qgbm90ZV9jb250ZW50ID0gYXdhaXQgbm90ZS5nZXRfY29udGVudCgpO1xuICAgICAgY29uc3QgeyBibG9ja3MgfSA9IHRoaXMuZW52LnNtYXJ0X21hcmtkb3duLnBhcnNlKHsgY29udGVudDogbm90ZV9jb250ZW50LCBmaWxlX3BhdGg6IG5vdGVfcGF0aCB9KTtcbiAgICAgIGJsb2Nrcy5mb3JFYWNoKGJsb2NrID0+IHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuY3JlYXRlX29yX3VwZGF0ZShibG9jayk7XG4gICAgICAgIG5vdGUubGFzdF9oaXN0b3J5LmJsb2Nrc1tpdGVtLmtleV0gPSB0cnVlO1xuICAgICAgfSk7XG4gICAgfWNhdGNoKGUpe1xuICAgICAgY29uc29sZS5sb2coXCJlcnJvciBwYXJzaW5nIGJsb2NrcyBmb3Igbm90ZTogXCIsIG5vdGUua2V5KTtcbiAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgIH1cbiAgfVxuICBhc3luYyBwcnVuZShvdmVycmlkZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgcmVtb3ZlID0gW107XG4gICAgY29uc3QgdG90YWxfaXRlbXNfd192ZWMgPSB0aGlzLmVtYmVkZGVkX2l0ZW1zLmxlbmd0aDtcbiAgICAvLyBjb25zb2xlLmxvZyhcInRvdGFsX2l0ZW1zX3dfdmVjOiBcIiwgdG90YWxfaXRlbXNfd192ZWMpO1xuICAgIGlmKCF0b3RhbF9pdGVtc193X3ZlYyl7XG4gICAgICAvLyBET0VTIE5PVCBjbGVhciBsaWtlIGluIG5vdGVzXG4gICAgICByZXR1cm47IC8vIHNraXAgcmVzdCBpZiBubyBpdGVtcyB3aXRoIHZlY1xuICAgIH1cbiAgICBmb3IoY29uc3QgW2tleSwgYmxvY2tdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuaXRlbXMpKSB7XG4gICAgICBpZihibG9jay5pc19nb25lKSByZW1vdmUucHVzaChrZXkpOyAvLyByZW1vdmUgaWYgZXhwaXJlZFxuICAgIH1cbiAgICBjb25zdCByZW1vdmVfcmF0aW8gPSByZW1vdmUubGVuZ3RoIC8gdG90YWxfaXRlbXNfd192ZWM7XG4gICAgaWYoKG92ZXJyaWRlICYmIChyZW1vdmVfcmF0aW8gPCAwLjUpKSB8fCBjb25maXJtKGBBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gZGVsZXRlICR7cmVtb3ZlLmxlbmd0aH0gKCR7TWF0aC5mbG9vcihyZW1vdmVfcmF0aW8qMTAwKX0lKSBCbG9jay1sZXZlbCBlbWJlZGRpbmdzP2ApKXtcbiAgICAgIHRoaXMuZGVsZXRlX21hbnkocmVtb3ZlKTtcbiAgICAgIGlmKCFvdmVycmlkZSkgdGhpcy5MVE0uX3NhdmUodHJ1ZSk7IC8vIHNhdmUgaWYgbm90IG92ZXJyaWRlXG4gICAgfVxuICAgIGNvbnNvbGUubG9nKGBQcnVuZWQgJHtyZW1vdmUubGVuZ3RofSBTbWFydEJsb2Nrcy5gKTtcbiAgfVxufVxuY2xhc3MgU21hcnRCbG9jayBleHRlbmRzIFNtYXJ0RW50aXR5IHtcbiAgc3RhdGljIGdldCBkZWZhdWx0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YToge1xuICAgICAgICB0ZXh0OiBudWxsLFxuICAgICAgICAvLyBoYXNoOiBudWxsLFxuICAgICAgICBsZW5ndGg6IDAsXG4gICAgICB9LFxuICAgICAgX2VtYmVkX2lucHV0OiAnJywgLy8gc3RvcmVkIHRlbXBvcmFyaWx5XG4gICAgfTtcbiAgfVxuICAvLyBTbWFydENodW5rOiB0ZXh0LCBsZW5ndGgsIHBhdGhcbiAgdXBkYXRlX2RhdGEoZGF0YSkge1xuICAgIGlmKCF0aGlzLmlzX25ldyl7XG4gICAgICAvLyBsZW5ndGggcmV0dXJuZWQgYnkgU21hcnRNYXJrZG93blxuICAgICAgaWYodGhpcy5kYXRhLmxlbmd0aCAhPT0gZGF0YS5sZW5ndGgpIHRoaXMuZGF0YS5lbWJlZGRpbmcgPSB7fTsgLy8gY2xlYXIgZW1iZWRkaW5nXG4gICAgfVxuICAgIGlmKCF0aGlzLmRhdGEuZW1iZWRkaW5nPy52ZWMpIHRoaXMuX2VtYmVkX2lucHV0ICs9IGRhdGEudGV4dDsgLy8gc3RvcmUgdGV4dCBmb3IgZW1iZWRkaW5nXG4gICAgZGVsZXRlIGRhdGEudGV4dDsgLy8gY2xlYXIgZGF0YS50ZXh0IHRvIHByZXZlbnQgc2F2aW5nIHRleHRcbiAgICBzdXBlci51cGRhdGVfZGF0YShkYXRhKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpbml0KCkge1xuICAgIGlmKCF0aGlzLm5vdGUpIHJldHVybiBjb25zb2xlLmxvZyh7XCJubyBub3RlIGZvciBibG9ja1wiOiB0aGlzLmRhdGF9KTtcbiAgICBpZihBcnJheS5pc0FycmF5KHRoaXMubm90ZS5sYXN0X2hpc3RvcnkuYmxvY2tzKSkgdGhpcy5ub3RlLmxhc3RfaGlzdG9yeS5ibG9ja3MgPSB7fTsgLy8gY29udmVydCB0byBvYmplY3RcbiAgICB0aGlzLm5vdGUubGFzdF9oaXN0b3J5LmJsb2Nrc1t0aGlzLmtleV0gPSB0cnVlOyAvLyBhZGQgYmxvY2sga2V5IHRvIG5vdGUgaGlzdG9yeSBlbnRyeVxuICB9XG4gIGFzeW5jIGdldF9jb250ZW50KCkge1xuICAgIGNvbnN0IG5vdGVfY29udGVudCA9IGF3YWl0IHRoaXMubm90ZT8uZ2V0X2NvbnRlbnQoKTtcbiAgICBpZighbm90ZV9jb250ZW50KSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBibG9ja19jb250ZW50ID0gdGhpcy5lbnYuc21hcnRfbWFya2Rvd24uZ2V0X2Jsb2NrX2Zyb21fcGF0aCh0aGlzLmRhdGEucGF0aCwgbm90ZV9jb250ZW50KTtcbiAgICByZXR1cm4gYmxvY2tfY29udGVudDtcbiAgfVxuICBhc3luYyBnZXRfZW1iZWRfaW5wdXQoKSB7XG4gICAgaWYodHlwZW9mIHRoaXMuX2VtYmVkX2lucHV0ID09PSAnc3RyaW5nJyAmJiB0aGlzLl9lbWJlZF9pbnB1dC5sZW5ndGgpIHJldHVybiB0aGlzLl9lbWJlZF9pbnB1dDsgLy8gcmV0dXJuIGNhY2hlZCAodGVtcG9yYXJ5KSBpbnB1dFxuICAgIHRoaXMuX2VtYmVkX2lucHV0ID0gdGhpcy5icmVhZGNydW1icyArIFwiXFxuXCIgKyAoYXdhaXQgdGhpcy5nZXRfY29udGVudCgpKTtcbiAgICByZXR1cm4gdGhpcy5fZW1iZWRfaW5wdXQ7XG4gIH1cbiAgYXN5bmMgZ2V0X25leHRfa19zaG90KGkpIHtcbiAgICBpZighdGhpcy5uZXh0X2Jsb2NrKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBjdXJyZW50ID0gYXdhaXQgdGhpcy5nZXRfY29udGVudCgpO1xuICAgIGNvbnN0IG5leHQgPSBhd2FpdCB0aGlzLm5leHRfYmxvY2suZ2V0X2NvbnRlbnQoKTtcbiAgICByZXR1cm4gYC0tLUJFR0lOIENVUlJFTlQgJHtpfS0tLVxcbiR7Y3VycmVudH1cXG4tLS1FTkQgQ1VSUkVOVCAke2l9LS0tXFxuLS0tQkVHSU4gTkVYVCAke2l9LS0tXFxuJHtuZXh0fVxcbi0tLUVORCBORVhUICR7aX0tLS1cXG5gO1xuICB9XG4gIGZpbmRfY29ubmVjdGlvbnMoKSB7XG4gICAgaWYoIXRoaXMudmVjKSByZXR1cm4gW107XG4gICAgcmV0dXJuIHRoaXMuZW52LnNtYXJ0X2Jsb2Nrcy5uZWFyZXN0KHRoaXMudmVjLCB7IGV4Y2x1ZGVfa2V5X3N0YXJ0c193aXRoOiB0aGlzLm5vdGUua2V5IH0pO1xuICB9XG4gIGdldCBicmVhZGNydW1icygpIHsgcmV0dXJuIHRoaXMuZGF0YS5wYXRoLnNwbGl0KFwiL1wiKS5qb2luKFwiID4gXCIpLnNwbGl0KFwiI1wiKS5qb2luKFwiID4gXCIpLnJlcGxhY2UoXCIubWRcIiwgXCJcIik7IH1cbiAgZ2V0IGVtYmVkX2lucHV0KCkgeyByZXR1cm4gdGhpcy5fZW1iZWRfaW5wdXQgPyB0aGlzLl9lbWJlZF9pbnB1dCA6IHRoaXMuZ2V0X2VtYmVkX2lucHV0KCk7IH1cbiAgZ2V0IGxpbmVzKCkgeyByZXR1cm4geyBzdGFydDogdGhpcy5kYXRhLmxpbmVzWzBdLCBlbmQ6IHRoaXMuZGF0YS5saW5lc1sxXSB9IH07XG4gIGdldCBmb2xkZXIoKSB7IHJldHVybiB0aGlzLmRhdGEucGF0aC5zcGxpdChcIi9cIikuc2xpY2UoMCwgLTEpLmpvaW4oXCIvXCIpOyB9XG4gIGdldCBpc19ibG9jaygpIHsgdGhpcy5kYXRhLnBhdGguaW5jbHVkZXMoXCIjXCIpOyB9XG4gIGdldCBpc19nb25lKCkge1xuICAgIGlmKHRoaXMuZW52LnNtYXJ0X25vdGVzLnVuZW1iZWRkZWRfaXRlbXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7IC8vIG5vdGUgbm90IGdvbmUgaWYgYW55IG5vdGVzIGFyZSB1bmVtYmVkZGVkIChwcmV2ZW50IGVycm9uZW91cyBkZWxldGUpXG4gICAgaWYoIXRoaXMubm90ZSkgcmV0dXJuIHRydWU7XG4gICAgaWYodGhpcy5ub3RlLmlzX2dvbmUpIHJldHVybiB0cnVlO1xuICAgIGlmKCF0aGlzLm5vdGUubGFzdF9oaXN0b3J5LmJsb2Nrc1t0aGlzLmtleV0pIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyB1c2UgdGV4dCBsZW5ndGggdG8gZGV0ZWN0IGNoYW5nZXNcbiAgZ2V0IG5hbWUoKSB7IHJldHVybiAoIXRoaXMuZW52Lm1haW4uc2V0dGluZ3Muc2hvd19mdWxsX3BhdGggPyB0aGlzLmRhdGEucGF0aC5zcGxpdChcIi9cIikucG9wKCkgOiB0aGlzLmRhdGEucGF0aC5zcGxpdChcIi9cIikuam9pbihcIiA+IFwiKSkuc3BsaXQoXCIjXCIpLmpvaW4oXCIgPiBcIikucmVwbGFjZShcIi5tZFwiLCBcIlwiKTsgfVxuICAvLyB1c2VzIGRhdGEubGluZXMgdG8gZ2V0IG5leHQgYmxvY2tcbiAgZ2V0IG5leHRfYmxvY2soKSB7XG4gICAgaWYoIXRoaXMuZGF0YS5saW5lcykgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgbmV4dF9saW5lID0gdGhpcy5kYXRhLmxpbmVzWzFdICsgMTtcbiAgICByZXR1cm4gdGhpcy5ub3RlLmJsb2Nrcz8uZmluZChibG9jayA9PiBuZXh0X2xpbmUgPT09IGJsb2NrLmRhdGE/LmxpbmVzPy5bMF0pOyBcbiAgfVxuICBnZXQgbm90ZSgpIHsgcmV0dXJuIHRoaXMuZW52LnNtYXJ0X25vdGVzLmdldCh0aGlzLm5vdGVfa2V5KTsgfVxuICBnZXQgbm90ZV9rZXkoKSB7IHJldHVybiB0aGlzLmRhdGEucGF0aC5zcGxpdChcIiNcIilbMF07IH1cbiAgZ2V0IG5vdGVfbmFtZSgpIHsgcmV0dXJuIHRoaXMubm90ZV9rZXkuc3BsaXQoXCIvXCIpLnBvcCgpLnJlcGxhY2UoXCIubWRcIiwgXCJcIik7IH1cbiAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgKERFUFJFQ0FURUQpXG4gIGdldCBsaW5rKCkgeyByZXR1cm4gdGhpcy5kYXRhLnBhdGg7IH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlX2hhc2godGV4dCkge1xuICBjb25zdCBtc2dVaW50OCA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh0ZXh0LnRyaW0oKSk7IC8vIGVuY29kZSBhcyAodXRmLTgpIFVpbnQ4QXJyYXlcbiAgY29uc3QgaGFzaEJ1ZmZlciA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KCdTSEEtMjU2JywgbXNnVWludDgpOyAvLyBoYXNoIHRoZSBtZXNzYWdlXG4gIGNvbnN0IGhhc2hBcnJheSA9IEFycmF5LmZyb20obmV3IFVpbnQ4QXJyYXkoaGFzaEJ1ZmZlcikpOyAvLyBjb252ZXJ0IGJ1ZmZlciB0byBieXRlIGFycmF5XG4gIGNvbnN0IGhhc2hIZXggPSBoYXNoQXJyYXkubWFwKGIgPT4gYi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSkuam9pbignJyk7IC8vIGNvbnZlcnQgYnl0ZXMgdG8gaGV4IHN0cmluZ1xuICByZXR1cm4gaGFzaEhleDtcbn1cblxuZXhwb3J0cy5TbWFydEJsb2NrID0gU21hcnRCbG9jaztcbmV4cG9ydHMuU21hcnRCbG9ja3MgPSBTbWFydEJsb2NrcztcbmV4cG9ydHMuU21hcnROb3RlID0gU21hcnROb3RlO1xuZXhwb3J0cy5TbWFydE5vdGVzID0gU21hcnROb3RlczsiLCAiYXN5bmMgZnVuY3Rpb24gcmVuZGVyX2RhdGF2aWV3X2NvZGVibG9ja3MoZmlsZV9jb250ZW50LCBub3RlX3BhdGgsIG9wdHMgPSB7fSkge1xuICBvcHRzID0ge1xuICAgIGNoYXJfbGltaXQ6IG51bGwsXG4gICAgLi4ub3B0c1xuICB9O1xuICBjb25zdCBkYXRhdmlld19hcGkgPSB3aW5kb3c/LltcIkRhdGF2aWV3QVBJXCJdOyAvLyB1c2Ugd2luZG93IHRvIGdldCBkYXRhdmlldyBhcGlcbiAgaWYgKCFkYXRhdmlld19hcGkpIHJldHVybiBmaWxlX2NvbnRlbnQ7IC8vIHNraXAgaWYgZGF0YXZpZXcgYXBpIG5vdCBmb3VuZFxuICBpZighZmlsZV9jb250ZW50KSByZXR1cm4gZmlsZV9jb250ZW50OyAvLyBza2lwIGlmIGZpbGVfY29udGVudCBpcyBlbXB0eVxuICBjb25zdCBkYXRhdmlld19jb2RlX2Jsb2NrcyA9IGZpbGVfY29udGVudC5tYXRjaCgvYGBgZGF0YXZpZXcoLio/KWBgYC9ncyk7XG4gIGlmKCFkYXRhdmlld19jb2RlX2Jsb2NrcykgcmV0dXJuIGZpbGVfY29udGVudDsgLy8gc2tpcCBpZiBubyBkYXRhdmlldyBjb2RlIGJsb2NrcyBmb3VuZFxuICAvLyBmb3IgZWFjaCBkYXRhdmlldyBjb2RlIGJsb2NrXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YXZpZXdfY29kZV9ibG9ja3MubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBpZiBvcHRzIGNoYXJfbGltaXQgaXMgbGVzcyB0aGFuIGluZGV4T2YgZGF0YXZpZXcgY29kZSBibG9jaywgYnJlYWtcbiAgICBpZiAob3B0cy5jaGFyX2xpbWl0ICYmIG9wdHMuY2hhcl9saW1pdCA8IGZpbGVfY29udGVudC5pbmRleE9mKGRhdGF2aWV3X2NvZGVfYmxvY2tzW2ldKSkgYnJlYWs7XG4gICAgLy8gZ2V0IGRhdGF2aWV3IGNvZGUgYmxvY2tcbiAgICBjb25zdCBkYXRhdmlld19jb2RlX2Jsb2NrID0gZGF0YXZpZXdfY29kZV9ibG9ja3NbaV07XG4gICAgLy8gZ2V0IGNvbnRlbnQgb2YgZGF0YXZpZXcgY29kZSBibG9ja1xuICAgIGNvbnN0IGRhdGF2aWV3X2NvZGVfYmxvY2tfY29udGVudCA9IGRhdGF2aWV3X2NvZGVfYmxvY2sucmVwbGFjZShcImBgYGRhdGF2aWV3XCIsIFwiXCIpLnJlcGxhY2UoXCJgYGBcIiwgXCJcIik7XG4gICAgLy8gZ2V0IGRhdGF2aWV3IHF1ZXJ5IHJlc3VsdFxuICAgIGNvbnN0IGRhdGF2aWV3X3F1ZXJ5X3Jlc3VsdCA9IGF3YWl0IGRhdGF2aWV3X2FwaS5xdWVyeU1hcmtkb3duKGRhdGF2aWV3X2NvZGVfYmxvY2tfY29udGVudCwgbm90ZV9wYXRoLCBudWxsKTtcbiAgICAvLyBpZiBxdWVyeSByZXN1bHQgaXMgc3VjY2Vzc2Z1bCwgcmVwbGFjZSBkYXRhdmlldyBjb2RlIGJsb2NrIHdpdGggcXVlcnkgcmVzdWx0XG4gICAgaWYgKGRhdGF2aWV3X3F1ZXJ5X3Jlc3VsdC5zdWNjZXNzZnVsKSB7XG4gICAgICBmaWxlX2NvbnRlbnQgPSBmaWxlX2NvbnRlbnQucmVwbGFjZShkYXRhdmlld19jb2RlX2Jsb2NrLCBkYXRhdmlld19xdWVyeV9yZXN1bHQudmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmlsZV9jb250ZW50O1xufVxuZXhwb3J0cy5yZW5kZXJfZGF0YXZpZXdfY29kZWJsb2NrcyA9IHJlbmRlcl9kYXRhdmlld19jb2RlYmxvY2tzOyIsICJjb25zdCB7XG4gIFNtYXJ0QmxvY2s6IEJhc2VTbWFydEJsb2NrLFxuICBTbWFydEJsb2NrcyxcbiAgU21hcnROb3RlOiBCYXNlU21hcnROb3RlLFxuICBTbWFydE5vdGVzLFxufSA9IHJlcXVpcmUoJ3NtYXJ0LWVudGl0aWVzJyk7XG5jb25zdCB7IHJlbmRlcl9kYXRhdmlld19jb2RlYmxvY2tzIH0gPSByZXF1aXJlKCcuL3JlbmRlcl9kYXRhdmlld19jb2RlYmxvY2tzJyk7XG5jbGFzcyBTbWFydE5vdGUgZXh0ZW5kcyBCYXNlU21hcnROb3RlIHtcbiAgYXN5bmMgZ2V0X2NvbnRlbnQoKSB7IHJldHVybiBhd2FpdCB0aGlzLmJyYWluLmNhY2hlZF9yZWFkKHRoaXMuZGF0YS5wYXRoKTsgfVxuICBhc3luYyBnZXRfYXNfY29udGV4dChwYXJhbXMgPSB7fSkge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCByZW5kZXJfZGF0YXZpZXdfY29kZWJsb2Nrcyhhd2FpdCB0aGlzLmdldF9jb250ZW50KCksIHRoaXMuZGF0YS5wYXRoKTtcbiAgICByZXR1cm4gYC0tLUJFR0lOIE5PVEUke3BhcmFtcy5pID8gXCIgXCIgKyBwYXJhbXMuaSA6IFwiXCJ9IFtbJHt0aGlzLnBhdGh9XV0tLS1cXG4ke2NvbnRlbnR9XFxuLS0tRU5EIE5PVEUke3BhcmFtcy5pID8gXCIgXCIgKyBwYXJhbXMuaSA6IFwiXCJ9LS0tYDtcbiAgfVxufVxuY2xhc3MgU21hcnRCbG9jayBleHRlbmRzIEJhc2VTbWFydEJsb2NrIHtcbiAgYXN5bmMgZ2V0X2FzX2NvbnRleHQocGFyYW1zID0ge30pIHtcbiAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgcmVuZGVyX2RhdGF2aWV3X2NvZGVibG9ja3MoYXdhaXQgdGhpcy5nZXRfY29udGVudCgpLCB0aGlzLmRhdGEucGF0aCk7XG4gICAgcmV0dXJuIGAtLS1CRUdJTiBOT1RFJHtwYXJhbXMuaSA/IFwiIFwiICsgcGFyYW1zLmkgOiBcIlwifSBbWyR7dGhpcy5wYXRofV1dLS0tXFxuJHtjb250ZW50fVxcbi0tLUVORCBOT1RFJHtwYXJhbXMuaSA/IFwiIFwiICsgcGFyYW1zLmkgOiBcIlwifS0tLWA7XG4gIH1cbn1cbmV4cG9ydHMuU21hcnROb3RlcyA9IFNtYXJ0Tm90ZXM7XG5leHBvcnRzLlNtYXJ0Tm90ZSA9IFNtYXJ0Tm90ZTtcbmV4cG9ydHMuU21hcnRCbG9ja3MgPSBTbWFydEJsb2NrcztcbmV4cG9ydHMuU21hcnRCbG9jayA9IFNtYXJ0QmxvY2s7XG5cbiIsICJjbGFzcyBTbWFydFNvY2tldCB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFNtYXJ0U29ja2V0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gcG9ydCBUaGUgcG9ydCBudW1iZXIgdG8gY29ubmVjdCB0by5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHBvcnQpIHtcbiAgICB0aGlzLnBvcnQgPSBwb3J0O1xuICAgIHRoaXMud3NfcmV0cmllcyA9IDA7XG4gICAgLy8gSW5pdGlhbGl6ZSB3cyBhcyBudWxsIHRvIGluZGljYXRlIG5vIGFjdGl2ZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBpbml0aWFsbHlcbiAgICB0aGlzLndzID0gbnVsbDtcbiAgICB0aGlzLnJldHJ5ID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhdGVzIHRoZSBjb25uZWN0aW9uIHByb2Nlc3MsIHdpdGggb3B0aW9uYWwgcmV0cnkgbG9naWMuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldHJ5PWZhbHNlXSBXaGV0aGVyIHRvIGF0dGVtcHQgYSByZWNvbm5lY3Rpb24uXG4gICAqL1xuICBhc3luYyBjb25uZWN0KHJldHJ5ID0gZmFsc2UpIHtcbiAgICB0aGlzLnJldHJ5ID0gcmV0cnk7XG4gICAgaWYgKCF0aGlzLmNhbl9hdHRlbXB0X2Nvbm5lY3Rpb24ocmV0cnkpKSByZXR1cm47XG5cbiAgICBpZihyZXRyeSkgYXdhaXQgdGhpcy5jYWxjdWxhdGVfYmFja29mZihyZXRyeSk7XG4gICAgaWYodHlwZW9mIHRoaXMuaXNfc2VydmVyX3J1bm5pbmcgPT09ICdmdW5jdGlvbicpe1xuICAgICAgY29uc3QgaXNfcnVubmluZyA9IGF3YWl0IHRoaXMuaXNfc2VydmVyX3J1bm5pbmcoKTtcbiAgICAgIGlmKCFpc19ydW5uaW5nKXtcbiAgICAgICAgY29uc29sZS5sb2coXCJTbWFydCBDb25uZWN0IGlzIG5vdCBydW5uaW5nLCB3aWxsIHRyeSB0byBjb25uZWN0IGFnYWluIGxhdGVyXCIpO1xuICAgICAgICB0aGlzLmNvbm5lY3QodHJ1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZV93ZWJzb2NrZXQoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIGNvbnNvbGUuZXJyb3IoYFdlYlNvY2tldCBjb25uZWN0aW9uIGVycm9yIG9uIHJldHJ5ICR7dGhpcy53c19yZXRyaWVzfTogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgIGlmIChyZXRyeSAmJiAoKHRoaXMud3NfcmV0cmllcyA8IDEwKSB8fCAodHlwZW9mIHRoaXMuaXNfc2VydmVyX3J1bm5pbmcgPT09ICdmdW5jdGlvbicpKSkge1xuICAgICAgICBhd2FpdCB0aGlzLmhhbmRsZV9jb25uZWN0aW9uX2Vycm9yKHRydWUsIGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uX2ZhaWxfdG9fcmVjb25uZWN0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIG5ldyBjb25uZWN0aW9uIGF0dGVtcHQgY2FuIGJlIG1hZGUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmV0cnkgSW5kaWNhdGVzIGlmIHRoaXMgaXMgYSByZXRyeSBhdHRlbXB0LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBhIGNvbm5lY3Rpb24gYXR0ZW1wdCBjYW4gYmUgbWFkZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgY2FuX2F0dGVtcHRfY29ubmVjdGlvbihyZXRyeSkge1xuICAgIHJldHJ5ID0gcmV0cnkgfHwgdGhpcy5yZXRyeTtcbiAgICBpZiAodGhpcy53cyAmJiB0aGlzLndzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIldlYlNvY2tldCBpcyBhbHJlYWR5IGNvbm5lY3RlZC4gQWJvcnRpbmcgbmV3IGNvbm5lY3Rpb24gYXR0ZW1wdC5cIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChyZXRyeSAmJiB0aGlzLndzX3JldHJpZXMgPj0gMTApIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gcmVjb25uZWN0IGFmdGVyIDEwIGF0dGVtcHRzXCIpO1xuICAgICAgdGhpcy5vbl9mYWlsX3RvX3JlY29ubmVjdCgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIGFuZCBhcHBsaWVzIGEgYmFja29mZiBkZWxheSBmb3IgcmVjb25uZWN0aW9uIGF0dGVtcHRzLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJldHJ5IEluZGljYXRlcyBpZiB0aGlzIGlzIGEgcmV0cnkgYXR0ZW1wdC5cbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIGFmdGVyIHRoZSBiYWNrb2ZmIGRlbGF5LlxuICAgKi9cbiAgY2FsY3VsYXRlX2JhY2tvZmYocmV0cnkpIHtcbiAgICBpZiAocmV0cnkgfHwgdGhpcy5yZXRyeSkge1xuICAgICAgdGhpcy53c19yZXRyaWVzICs9IDE7XG4gICAgICBjb25zdCBiYWNrb2ZmX3RpbWUgPSBNYXRoLm1pbigxMDAwICogTWF0aC5wb3coMiwgdGhpcy53c19yZXRyaWVzKSwgNjAwMDApO1xuICAgICAgY29uc29sZS5sb2coYEF0dGVtcHRpbmcgdG8gcmVjb25uZWN0IGluICR7YmFja29mZl90aW1lIC8gMTAwMH0gc2Vjb25kcy4uLmApO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBiYWNrb2ZmX3RpbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbi5cbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIFdlYlNvY2tldCBpcyBzdWNjZXNzZnVsbHkgb3BlbmVkLlxuICAgKi9cbiAgYXN5bmMgaW5pdGlhbGl6ZV93ZWJzb2NrZXQoKSB7XG4gICAgLy8gQ2xlYW4gdXAgYW55IGV4aXN0aW5nIFdlYlNvY2tldCBjb25uZWN0aW9uIGJlZm9yZSBpbml0aWFsaXppbmcgYSBuZXcgb25lXG4gICAgdGhpcy5jbGVhbnVwX3dlYnNvY2tldCgpO1xuXG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgdGltZW91dF9pZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMud3MgfHwgdGhpcy53cy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgICAgIHRoaXMud3M/LmNsb3NlKCk7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignV2ViU29ja2V0IGZhaWxlZCB0byBjb25uZWN0JykpO1xuICAgICAgICB9XG4gICAgICB9LCAxMDAwMCk7XG4gIFxuICAgICAgdGhpcy53cyA9IG5ldyBXZWJTb2NrZXQoYHdzOi8vbG9jYWxob3N0OiR7dGhpcy5wb3J0fWApO1xuICAgICAgdGhpcy53cy5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0X2lkKTtcbiAgICAgICAgdGhpcy5vbl9vcGVuKCk7XG4gICAgICAgIHRoaXMud3NfcmV0cmllcyA9IDA7IC8vIFJlc2V0IHJldHJpZXMgb24gc3VjY2Vzc2Z1bCBjb25uZWN0aW9uXG4gICAgICAgIHRoaXMucmV0cnkgPSB0cnVlOyAvLyBzZXQgcmV0cnkgc2luY2Ugd2Uga25vdyBjb25uZWN0aW9uIGlzIGF2YWlsYWJsZVxuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9O1xuICAgICAgdGhpcy53cy5vbmNsb3NlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIHRoaXMuY2xlYW51cF93ZWJzb2NrZXQoKTsgLy8gRW5zdXJlIGNsZWFudXAgd2hlbiB0aGUgV2ViU29ja2V0IGlzIGNsb3NlZFxuICAgICAgICByZWplY3QobmV3IEVycm9yKCdXZWJTb2NrZXQgY2xvc2VkJykpO1xuICAgICAgICB0aGlzLm9uX2Nsb3NlKCk7XG4gICAgICB9O1xuICAgICAgdGhpcy53cy5vbmVycm9yID0gKGVycikgPT4ge1xuICAgICAgICB0aGlzLmNsZWFudXBfd2Vic29ja2V0KCk7IC8vIEVuc3VyZSBjbGVhbnVwIG9uIGVycm9yXG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB0aGlzLm9uX2Vycm9yKGVycik7XG4gICAgICB9O1xuICAgICAgdGhpcy53cy5vbm1lc3NhZ2UgPSB0aGlzLmhhbmRsZV9tZXNzYWdlLmJpbmQodGhpcyk7XG4gICAgfSk7XG4gIH1cblxuICBjbGVhbnVwX3dlYnNvY2tldCgpIHtcbiAgICBpZiAodGhpcy53cykge1xuICAgICAgLy8gUmVtb3ZlIGFsbCBldmVudCBsaXN0ZW5lcnMgdG8gcHJldmVudCBtZW1vcnkgbGVha3NcbiAgICAgIHRoaXMud3Mub25vcGVuID0gbnVsbDtcbiAgICAgIHRoaXMud3Mub25jbG9zZSA9IG51bGw7XG4gICAgICB0aGlzLndzLm9uZXJyb3IgPSBudWxsO1xuICAgICAgdGhpcy53cy5vbm1lc3NhZ2UgPSBudWxsO1xuICAgICAgLy8gQ2xvc2UgdGhlIFdlYlNvY2tldCBpZiBpdCdzIG5vdCBhbHJlYWR5IGNsb3NlZFxuICAgICAgaWYgKHRoaXMud3MucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4gfHwgdGhpcy53cy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgICB0aGlzLndzLmNsb3NlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLndzID0gbnVsbDsgLy8gQ2xlYXIgdGhlIHJlZmVyZW5jZSB0byBmYWNpbGl0YXRlIGdhcmJhZ2UgY29sbGVjdGlvblxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGNvbm5lY3Rpb24gZXJyb3JzIGFuZCBkZWNpZGVzIHdoZXRoZXIgdG8gcmV0cnkuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmV0cnkgSW5kaWNhdGVzIGlmIHRoaXMgaXMgYSByZXRyeSBhdHRlbXB0LlxuICAgKiBAcGFyYW0ge0Vycm9yfSBlcnIgVGhlIGVycm9yIHRoYXQgb2NjdXJyZWQgZHVyaW5nIGNvbm5lY3Rpb24uXG4gICAqL1xuICBhc3luYyBoYW5kbGVfY29ubmVjdGlvbl9lcnJvcihyZXRyeSwgZXJyKSB7XG4gICAgY29uc29sZS5sb2coXCJIYW5kbGluZyBXZWJTb2NrZXQgY29ubmVjdGlvbiBlcnJvciBvbiBwb3J0IFwiICsgdGhpcy5wb3J0KTtcbiAgICBpZiAocmV0cnkgJiYgdGhpcy53c19yZXRyaWVzIDwgMTApIHtcbiAgICAgIGF3YWl0IHRoaXMuY29ubmVjdCh0cnVlKTsgLy8gUmV0cnkgd2l0aCBiYWNrb2ZmXG4gICAgfSBlbHNlIGlmICghcmV0cnkgfHwgdGhpcy53c19yZXRyaWVzID49IDEwKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGNvbm5lY3QgdG8gV2ViU29ja2V0IGFmdGVyIHJldHJpZXM6XCIpO1xuICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgIHRoaXMub25fZmFpbF90b19yZWNvbm5lY3QoKTtcbiAgICB9XG4gIH1cbiAgXG5cbiAgLyoqXG4gICAqIFBsYWNlaG9sZGVyIGZvciBlcnJvciBoYW5kbGluZyBsb2dpYy5cbiAgICogQHBhcmFtIHtFcnJvcn0gZXJyIFRoZSBlcnJvciBlbmNvdW50ZXJlZC5cbiAgICovXG4gIG9uX2Vycm9yKGVycikge1xuICAgIC8vIGNvbnNvbGUuZXJyb3IoXCJXZWJTb2NrZXQgZXJyb3JcIiwgZXJyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIFdlYlNvY2tldCBjbG9zdXJlIGFuZCBhdHRlbXB0cyByZWNvbm5lY3Rpb24uXG4gICAqL1xuICBvbl9jbG9zZSgpIHtcbiAgICBjb25zb2xlLmxvZyhcIkRpc2Nvbm5lY3RlZCBmcm9tIFdlYlNvY2tldFwiKTtcbiAgXG4gICAgLy8gTm93LCB1c2UgdGhlIGBzaG91bGRfYXR0ZW1wdF9yZWNvbm5lY3RgIHRvIGRlY2lkZSB3aGV0aGVyIHRvIGluaXRpYXRlIGEgcmVjb25uZWN0aW9uLlxuICAgIGlmKHRoaXMucmV0cnkgJiYgdGhpcy5zaG91bGRfYXR0ZW1wdF9yZWNvbm5lY3QpIHtcbiAgICAgIHRoaXMuY29ubmVjdCh0cnVlKTsgLy8gQXR0ZW1wdCB0byByZWNvbm5lY3Qgd2l0aCBiYWNrb2ZmXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiUmVjb25uZWN0aW9uIG5vdCBhdHRlbXB0ZWQgZHVlIHRvIHBvbGljeSAoaW50ZW50aW9uYWwgZGlzY29ubmVjdGlvbiBvciByZXRyeSBsaW1pdCByZWFjaGVkKS5cIik7XG4gICAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgbm8gcmVjb25uZWN0aW9uIHdpbGwgYmUgYXR0ZW1wdGVkLCBzdWNoIGFzIGJ5IGluZm9ybWluZyB0aGUgdXNlci5cbiAgICB9XG4gIH1cbiAgXG4gIGdldCBzaG91bGRfYXR0ZW1wdF9yZWNvbm5lY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMud3NfcmV0cmllcyA8IDEwO1xuICB9XG4gIFxuXG4gIC8qKlxuICAgKiBMb2dzIHN1Y2Nlc3NmdWwgV2ViU29ja2V0IGNvbm5lY3Rpb24uXG4gICAqL1xuICBvbl9vcGVuKCkge1xuICAgIGNvbnNvbGUubG9nKGBDb25uZWN0ZWQgdG8gV2ViU29ja2V0IG9uIHBvcnQgJHt0aGlzLnBvcnR9YCk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBpbmNvbWluZyBXZWJTb2NrZXQgbWVzc2FnZXMuXG4gICAqIEBwYXJhbSB7TWVzc2FnZUV2ZW50fSBldmVudCBUaGUgbWVzc2FnZSBldmVudC5cbiAgICovXG4gIGhhbmRsZV9tZXNzYWdlKGV2ZW50KSB7XG4gICAgY29uc29sZS5sb2coXCJNZXNzYWdlIGZyb20gc2VydmVyXCIsIGV2ZW50LmRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgZmFpbHVyZSB0byByZWNvbm5lY3QgYWZ0ZXIgbXVsdGlwbGUgYXR0ZW1wdHMuXG4gICAqL1xuICBvbl9mYWlsX3RvX3JlY29ubmVjdCgpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHJlY29ubmVjdCwgd2lsbCBub3QgcmV0cnkuLi5cIik7XG4gIH1cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24uXG4gICAqL1xuICB1bmxvYWQoKSB7XG4gICAgdGhpcy5jbGVhbnVwX3dlYnNvY2tldCgpO1xuICB9XG59XG5leHBvcnRzLlNtYXJ0U29ja2V0ID0gU21hcnRTb2NrZXQ7IiwgImNvbnN0IHsgU21hcnRTb2NrZXQgfSA9IHJlcXVpcmUoXCIuL3NtYXJ0X3NvY2tldFwiKTtcblxuY2xhc3MgRGF0YXZpZXdTb2NrZXQgZXh0ZW5kcyBTbWFydFNvY2tldCB7XG4gIGNvbnN0cnVjdG9yKGVudiwgcG9ydCkge1xuICAgIHN1cGVyKHBvcnQpO1xuICAgIHRoaXMuZW52ID0gZW52O1xuICAgIHRoaXMuYnJhaW4gPSB0aGlzLmVudjsgLy8gREVQUkVDQVRFRFxuICAgIHRoaXMuZGF0YXZpZXdfYXBpID0gbnVsbDtcbiAgfVxuICBzdGF0aWMgYXN5bmMgY3JlYXRlKGVudiwgcG9ydCkge1xuICAgIGNvbnN0IHNtYXJ0X3NvY2tldCA9IG5ldyBEYXRhdmlld1NvY2tldChlbnYsIHBvcnQpO1xuICAgIGVudi5kdl93cyA9IHNtYXJ0X3NvY2tldDtcbiAgICBhd2FpdCBzbWFydF9zb2NrZXQuaW5pdCgpO1xuICAgIHJldHVybiBzbWFydF9zb2NrZXQ7XG4gIH1cbiAgYXN5bmMgaW5pdCgpIHtcbiAgICBhd2FpdCB0aGlzLmdldF9kYXRhdmlld19hcGkoKTtcbiAgICBhd2FpdCB0aGlzLmNvbm5lY3QoKTtcbiAgICAvLyBjb25zb2xlLmxvZyhcIkRhdGF2aWV3U29ja2V0IGluaXRpYWxpemVkXCIpO1xuICB9XG4gIGFzeW5jIGlzX3NlcnZlcl9ydW5uaW5nKCl7XG4gICAgdHJ5e1xuICAgICAgY29uc3Qgc2NfbG9jYWwgPSBhd2FpdCB0aGlzLmVudi5tYWluLm9ic2lkaWFuPy5yZXF1ZXN0VXJsKHt1cmw6ICdodHRwOi8vbG9jYWxob3N0OjM3NDIxLycsIG1ldGhvZDogJ0dFVCd9KTtcbiAgICAgIGNvbnNvbGUubG9nKHNjX2xvY2FsKTtcbiAgICAgIHJldHVybiBzY19sb2NhbD8uc3RhdHVzID09PSAyMDA7XG4gICAgfWNhdGNoKGVycil7XG4gICAgICAvLyBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGFzeW5jIGdldF9kYXRhdmlld19hcGkocmV0cmllcyA9IDApIHtcbiAgICB0aGlzLmRhdGF2aWV3X2FwaSA9IHdpbmRvd1tcIkRhdGF2aWV3QVBJXCJdO1xuICAgIGlmICghdGhpcy5kYXRhdmlld19hcGkpIHtcbiAgICAgIGlmIChyZXRyaWVzIDwgMTApIHtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHJldHJpZXMgKiAxMDAwKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldF9kYXRhdmlld19hcGkocmV0cmllcyArIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5icmFpbi5tYWluLnNob3dfbm90aWNlKFwiRGF0YXZpZXcgQVBJIG5vdCBmb3VuZFwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYXN5bmMgaGFuZGxlX21lc3NhZ2UoZXZlbnQpIHtcbiAgICBjb25zb2xlLmxvZyhcIk1lc3NhZ2UgZnJvbSBzZXJ2ZXIgXCIsIGV2ZW50LmRhdGEpO1xuICAgIGNvbnNvbGUubG9nKHR5cGVvZiBldmVudC5kYXRhKTtcbiAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IHRoaXMuZGF0YXZpZXdfYXBpLnF1ZXJ5TWFya2Rvd24oZGF0YS5xdWVyeSwgZGF0YS5yZWxfcGF0aCwgbnVsbCk7XG4gICAgICBjb25zb2xlLmxvZyhyZXNwKTtcbiAgICAgIHRoaXMud3Muc2VuZChKU09OLnN0cmluZ2lmeShyZXNwKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICB0aGlzLndzLnNlbmQoSlNPTi5zdHJpbmdpZnkoeyBzdGF0dXM6IFwiZXJyb3JcIiwgbWVzc2FnZTogZXJyIH0pKTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydHMuRGF0YXZpZXdTb2NrZXQgPSBEYXRhdmlld1NvY2tldDtcbiIsICJ7XG4gIFwiYXR0cmlidXRpb25cIjogXCI8ZGl2IGNsYXNzPVxcXCJzYy1icmFuZFxcXCI+XFxuICA8c3ZnIHZpZXdCb3g9XFxcIjAgMCAxMDAgMTAwXFxcIiBjbGFzcz1cXFwic3ZnLWljb24gc21hcnQtY29ubmVjdGlvbnNcXFwiPlxcbiAgICA8cGF0aCBkPVxcXCJNNTAsMjAgTDgwLDQwIEw4MCw2MCBMNTAsMTAwXFxcIiBzdHJva2U9XFxcImN1cnJlbnRDb2xvclxcXCIgc3Ryb2tlLXdpZHRoPVxcXCI0XFxcIiBmaWxsPVxcXCJub25lXFxcIj48L3BhdGg+XFxuICAgIDxwYXRoIGQ9XFxcIk0zMCw1MCBMNTUsNzBcXFwiIHN0cm9rZT1cXFwiY3VycmVudENvbG9yXFxcIiBzdHJva2Utd2lkdGg9XFxcIjVcXFwiIGZpbGw9XFxcIm5vbmVcXFwiPjwvcGF0aD5cXG4gICAgPGNpcmNsZSBjeD1cXFwiNTBcXFwiIGN5PVxcXCIyMFxcXCIgcj1cXFwiOVxcXCIgZmlsbD1cXFwiY3VycmVudENvbG9yXFxcIj48L2NpcmNsZT5cXG4gICAgPGNpcmNsZSBjeD1cXFwiODBcXFwiIGN5PVxcXCI0MFxcXCIgcj1cXFwiOVxcXCIgZmlsbD1cXFwiY3VycmVudENvbG9yXFxcIj48L2NpcmNsZT5cXG4gICAgPGNpcmNsZSBjeD1cXFwiODBcXFwiIGN5PVxcXCI3MFxcXCIgcj1cXFwiOVxcXCIgZmlsbD1cXFwiY3VycmVudENvbG9yXFxcIj48L2NpcmNsZT5cXG4gICAgPGNpcmNsZSBjeD1cXFwiNTBcXFwiIGN5PVxcXCIxMDBcXFwiIHI9XFxcIjlcXFwiIGZpbGw9XFxcImN1cnJlbnRDb2xvclxcXCI+PC9jaXJjbGU+XFxuICAgIDxjaXJjbGUgY3g9XFxcIjMwXFxcIiBjeT1cXFwiNTBcXFwiIHI9XFxcIjlcXFwiIGZpbGw9XFxcImN1cnJlbnRDb2xvclxcXCI+PC9jaXJjbGU+XFxuICA8L3N2Zz5cXG4gIDxwPjxhIHN0eWxlPVxcXCJmb250LXdlaWdodDogNzAwO1xcXCIgaHJlZj1cXFwiaHR0cHM6Ly9zbWFydGNvbm5lY3Rpb25zLmFwcC9cXFwiPlNtYXJ0IENvbm5lY3Rpb25zPC9hPjwvcD5cXG48L2Rpdj5cIixcbiAgXCJzY19jaGFuZ2VcIjogXCI8ZGl2IGNsYXNzPVxcXCJzYy1jaGFuZ2VcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwiYWN0aW9uc1xcXCI+XFxuICAgIDxidXR0b24+QWNjZXB0PC9idXR0b24+XFxuICAgIDxidXR0b24+UmVqZWN0PC9idXR0b24+XFxuICAgIDxidXR0b24+U2hvdyBPbGQ8L2J1dHRvbj5cXG4gICAgPGJ1dHRvbiBzdHlsZT1cXFwiZGlzcGxheTogbm9uZTtcXFwiPkhpZGUgT2xkPC9idXR0b24+XFxuICAgIDxkaXY+VGltZSBzYXZlZDogPCU9IHRpbWVfc2F2ZWQgJT48L2Rpdj5cXG4gICAgPCUtIHRoaXMuYXR0cmlidXRpb24gJT5cXG4gIDwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwib2xkLWNvbnRlbnRcXFwiIHN0eWxlPVxcXCJkaXNwbGF5OiBub25lO1xcXCI+PC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJuZXctY29udGVudFxcXCI+PC9kaXY+XFxuPC9kaXY+XFxuXFxuXCIsXG4gIFwic21hcnRfY2hhdFwiOiBcIjxkaXYgY2xhc3M9XFxcIndvcmtzcGFjZS1sZWFmLWNvbnRlbnRcXFwiIGRhdGEtdHlwZT1cXFwic21hcnQtY29ubmVjdGlvbnMtY2hhdC12aWV3XFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcInNjLWNoYXQtY29udGFpbmVyXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwic2MtdG9wLWJhci1jb250YWluZXJcXFwiPlxcbiAgICAgIDxpbnB1dCBjbGFzcz1cXFwic2MtY2hhdC1uYW1lLWlucHV0XFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiB2YWx1ZT1cXFwiPCU9IG5hbWUgJT5cXFwiIHBsYWNlaG9sZGVyPVxcXCJDaGF0IE5hbWVcXFwiPlxcbiAgICAgIDxidXR0b24gdGl0bGU9XFxcIk9wZW4gQ29udmVyc2F0aW9uIE5vdGVcXFwiPjwlLSB0aGlzLmdldF9pY29uKCdleHRlcm5hbC1saW5rJykgJT48L2J1dHRvbj5cXG4gICAgICA8YnV0dG9uIHRpdGxlPVxcXCJDaGF0IEhpc3RvcnlcXFwiPjwlLSB0aGlzLmdldF9pY29uKCdoaXN0b3J5JykgJT48L2J1dHRvbj5cXG4gICAgICA8YnV0dG9uIHRpdGxlPVxcXCJTZXR0aW5nc1xcXCI+PCUtIHRoaXMuZ2V0X2ljb24oJ2dlYXInKSAlPjwvYnV0dG9uPlxcbiAgICAgIDxidXR0b24gdGl0bGU9XFxcIk5ldyBDaGF0XFxcIj48JS0gdGhpcy5nZXRfaWNvbigncGx1cycpICU+PC9idXR0b24+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJzYy1jaGF0LWJveFxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwic2MtbWVzc2FnZS1jb250YWluZXJcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwic2MtbWVzc2FnZSBhc3Npc3RhbnRcXFwiPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJzYy1tZXNzYWdlLWNvbnRlbnRcXFwiPlxcbiAgICAgICAgICAgIDxzcGFuPlxcbiAgICAgICAgICAgICAgSGkgdGhlcmUsIHdlbGNvbWUgdG8gdGhlIFNtYXJ0IENoYXQuJm5ic3A7QXNrIG1lIGEgcXVlc3Rpb24gYWJvdXQgeW91ciBub3RlcyBhbmQgSSdsbCB0cnkgdG8gYW5zd2VyIGl0LlxcbiAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwlLSBtZXNzYWdlcyAlPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwic2MtY2hhdC1mb3JtXFxcIj48dGV4dGFyZWEgY2xhc3M9XFxcInNjLWNoYXQtaW5wdXRcXFwiXFxuICAgICAgICBwbGFjZWhvbGRlcj1cXFwiVHJ5ICZxdW90O0Jhc2VkIG9uIG15IG5vdGVzJnF1b3Q7IG9yICZxdW90O1N1bW1hcml6ZSBbW3RoaXMgbm90ZV1dJnF1b3Q7IG9yICZxdW90O0ltcG9ydGFudCB0YXNrcyBpbiAvZm9sZGVyLyZxdW90O1xcXCI+PC90ZXh0YXJlYT5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJzYy1idXR0b24tY29udGFpbmVyXFxcIj5cXG4gICAgICAgIDxzcGFuIGlkPVxcXCJzYy1hYm9ydC1idXR0b25cXFwiIHN0eWxlPVxcXCJkaXNwbGF5OiBub25lO1xcXCI+PCUtIHRoaXMuZ2V0X2ljb24oJ3NxdWFyZScpICU+PC9zcGFuPlxcbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwic2VuZC1idXR0b25cXFwiIGlkPVxcXCJzYy1zZW5kLWJ1dHRvblxcXCI+U2VuZDwvYnV0dG9uPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBpZD1cXFwic2V0dGluZ3NcXFwiPjwvZGl2PlxcbiAgPC9kaXY+XFxuICA8JS0gdGhpcy5hdHRyaWJ1dGlvbiAlPlxcbjwvZGl2PlwiLFxuICBcInNtYXJ0X2NoYXRfbXNnXCI6IFwiPGRpdiBjbGFzcz1cXFwic2MtbWVzc2FnZSA8JT0gcm9sZSAlPlxcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJzYy1tZXNzYWdlLWNvbnRlbnRcXFwiIGRhdGEtY29udGVudD1cXFwiPCU9IGNvbnRlbnQgJT5cXFwiPlxcbiAgICA8c3Bhbj48JT0gY29udGVudCAlPjwvc3Bhbj5cXG4gICAgPHNwYW4gY2xhc3M9XFxcInNjLW1zZy1idXR0b25cXFwiIHRpdGxlPVxcXCJDb3B5IG1lc3NhZ2UgdG8gY2xpcGJvYXJkXFxcIj48JS0gdGhpcy5nZXRfaWNvbignY29weScpICU+PC9zcGFuPlxcbiAgICA8IS0tIFRPRE86IENvcHkgY29udGV4dCB0byBjbGlwYm9hcmQgKGljb246IGV5ZSkgLS0+XFxuICAgIDwhLS0gVE9ETzogQ29weSBwcm9tcHQgdG8gY2xpcGJvYXJkIChpY29uOiBmaWxlcykgLS0+XFxuICA8L2Rpdj5cXG48L2Rpdj5cIixcbiAgXCJzbWFydF9jaGF0X3NldHRpbmdzXCI6IFwiPGRpdiBjbGFzcz1cXFwic2V0dGluZy1jb21wb25lbnRcXFwiXFxuICBkYXRhLW5hbWU9XFxcIk1vZGVsIFBsYXRmb3JtXFxcIlxcbiAgZGF0YS1zZXR0aW5nPVxcXCJjaGF0X21vZGVsX3BsYXRmb3JtX2tleVxcXCJcXG4gIGRhdGEtdHlwZT1cXFwiZHJvcGRvd25cXFwiXFxuICBkYXRhLWRlc2NyaXB0aW9uPVxcXCJTZWxlY3QgYSBtb2RlbCBwbGF0Zm9ybSB0byB1c2Ugd2l0aCBTbWFydCBDaGF0LlxcXCJcXG4gIDwlLSBjaGF0X3BsYXRmb3Jtcy5tYXAoKHBsYXRmb3JtLCBpKSA9PiBgZGF0YS1vcHRpb24tJHtpICsgMX09XFxcIiR7cGxhdGZvcm0ua2V5fXwke3BsYXRmb3JtLmRlc2NyaXB0aW9ufVxcXCJgKS5qb2luKCdcXFxcbicpICU+XFxuICBkYXRhLWNhbGxiYWNrPVxcXCJjaGFuZ2VkX3NtYXJ0X2NoYXRfbW9kZWxcXFwiXFxuPjwvZGl2PlxcbjwlIGlmKGNoYXRfcGxhdGZvcm0/LmZldGNoX21vZGVscykgeyAlPlxcbiAgPCUgaWYoc2V0dGluZ3Nbc2V0dGluZ3MuY2hhdF9tb2RlbF9wbGF0Zm9ybV9rZXldPy5hcGlfa2V5KSB7ICU+XFxuICAgIDxkaXYgY2xhc3M9XFxcInNldHRpbmctY29tcG9uZW50XFxcIlxcbiAgICAgIGRhdGEtbmFtZT1cXFwiTW9kZWwgTmFtZVxcXCJcXG4gICAgICBkYXRhLXR5cGU9XFxcImRyb3Bkb3duXFxcIlxcbiAgICAgIGRhdGEtc2V0dGluZz1cXFwiPCU9IHNldHRpbmdzLmNoYXRfbW9kZWxfcGxhdGZvcm1fa2V5ICU+Lm1vZGVsX25hbWVcXFwiXFxuICAgICAgZGF0YS1jYWxsYmFjaz1cXFwiY2hhbmdlZF9zbWFydF9jaGF0X21vZGVsXFxcIlxcbiAgICAgIDwlLSBwbGF0Zm9ybV9jaGF0X21vZGVscy5tYXAoKG1vZGVsLCBpKSA9PiBgZGF0YS1vcHRpb24tJHtpfT1cXFwiJHttb2RlbC5rZXl9fCR7bW9kZWwubW9kZWxfbmFtZX0gKCR7bW9kZWwuZGVzY3JpcHRpb259KVxcXCJgKS5qb2luKCdcXFxcbicpICU+XFxuICAgID48L2Rpdj5cXG4gIDwlIH0gJT5cXG4gIDwlIGlmKCFwbGF0Zm9ybV9jaGF0X21vZGVscy5sZW5ndGgpIHsgJT5cXG4gICAgPGRpdiBjbGFzcz1cXFwic2V0dGluZy1jb21wb25lbnRcXFwiXFxuICAgICAgZGF0YS1uYW1lPVxcXCJSZWZyZXNoIE1vZGVscyBMaXN0XFxcIlxcbiAgICAgIGRhdGEtdHlwZT1cXFwiYnV0dG9uXFxcIlxcbiAgICAgIGRhdGEtY2FsbGJhY2s9XFxcImNoYW5nZWRfc21hcnRfY2hhdF9tb2RlbFxcXCJcXG4gICAgPjwvZGl2PlxcbiAgPCUgfSAlPlxcbiAgPGRpdiBjbGFzcz1cXFwic2V0dGluZy1jb21wb25lbnRcXFwiXFxuICAgIGRhdGEtbmFtZT1cXFwiPCU9IGNoYXRfcGxhdGZvcm0uZGVzY3JpcHRpb24gJT4gQVBJIEtleVxcXCJcXG4gICAgZGF0YS10eXBlPVxcXCJ0ZXh0XFxcIlxcbiAgICBkYXRhLXNldHRpbmc9XFxcIjwlPSBzZXR0aW5ncy5jaGF0X21vZGVsX3BsYXRmb3JtX2tleSAlPi5hcGlfa2V5XFxcIlxcbiAgICA8JSBpZihjaGF0X3BsYXRmb3JtLnNpZ251cF91cmwpIHsgJT5cXG4gICAgICBkYXRhLWRlc2NyaXB0aW9uPVxcXCI8YSBocmVmPSc8JT0gY2hhdF9wbGF0Zm9ybS5zaWdudXBfdXJsICU+Jz5HZXQgQVBJIEtleTwvYT4gZm9yIDwlPSBjaGF0X3BsYXRmb3JtLmRlc2NyaXB0aW9uICU+LlxcXCJcXG4gICAgPCUgfSBlbHNlIHsgJT5cXG4gICAgICBkYXRhLWRlc2NyaXB0aW9uPVxcXCJBUEkgS2V5IGZvciA8JT0gY2hhdF9wbGF0Zm9ybS5kZXNjcmlwdGlvbiAlPi5cXFwiXFxuICAgIDwlIH0gJT5cXG4gICAgZGF0YS1wbGFjZWhvbGRlcj1cXFwiRW50ZXIgYW4gQVBJIEtleVxcXCJcXG4gICAgZGF0YS1idXR0b249XFxcIlNhdmVcXFwiXFxuICAgIGRhdGEtY2FsbGJhY2s9XFxcInRlc3RfY2hhdF9hcGlfa2V5XFxcIlxcbiAgPjwvZGl2PlxcbjwlIH0gJT5cXG48JSBpZiAoc2V0dGluZ3MuY2hhdF9tb2RlbF9wbGF0Zm9ybV9rZXkuc3RhcnRzV2l0aCgnY3VzdG9tX2xvY2FsJykpIHsgJT5cXG4gIDxoMz5DdXN0b20gTG9jYWwgTW9kZWw8L2gzPlxcbiAgPGRpdiBjbGFzcz1cXFwic2V0dGluZy1jb21wb25lbnRcXFwiXFxuICAgIGRhdGEtbmFtZT1cXFwiTW9kZWwgTmFtZVxcXCJcXG4gICAgZGF0YS10eXBlPVxcXCJ0ZXh0XFxcIlxcbiAgICBkYXRhLXNldHRpbmc9XFxcImN1c3RvbV9sb2NhbC5tb2RlbF9uYW1lXFxcIlxcbiAgICBkYXRhLWRlc2NyaXB0aW9uPVxcXCJOYW1lIG9mIHRoZSBjdXN0b20gbW9kZWwuXFxcIlxcbiAgICBkYXRhLXBsYWNlaG9sZGVyPVxcXCJFbnRlciBhIG1vZGVsIG5hbWVcXFwiXFxuICAgIGRhdGEtY2FsbGJhY2s9XFxcImNoYW5nZWRfc21hcnRfY2hhdF9tb2RlbFxcXCJcXG4gID48L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFxcInNldHRpbmctY29tcG9uZW50XFxcIlxcbiAgICBkYXRhLW5hbWU9XFxcInByb3RvY29sXFxcIlxcbiAgICBkYXRhLXR5cGU9XFxcInRleHRcXFwiXFxuICAgIGRhdGEtc2V0dGluZz1cXFwiY3VzdG9tX2xvY2FsLnByb3RvY29sXFxcIlxcbiAgICBkYXRhLWRlc2NyaXB0aW9uPVxcXCJQcm90b2NvbCBmb3IgY2hhdCBzZXJ2ZXIgKGh0dHAgb3IgaHR0cHMpLlxcXCJcXG4gICAgZGF0YS1wbGFjZWhvbGRlcj1cXFwiRW50ZXIgYSBwcm90b2NvbFxcXCJcXG4gICAgZGF0YS1jYWxsYmFjaz1cXFwiY2hhbmdlZF9zbWFydF9jaGF0X21vZGVsXFxcIlxcbiAgPjwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwic2V0dGluZy1jb21wb25lbnRcXFwiXFxuICAgIGRhdGEtbmFtZT1cXFwiaG9zdG5hbWVcXFwiXFxuICAgIGRhdGEtdHlwZT1cXFwidGV4dFxcXCJcXG4gICAgZGF0YS1zZXR0aW5nPVxcXCJjdXN0b21fbG9jYWwuaG9zdG5hbWVcXFwiXFxuICAgIGRhdGEtZGVzY3JpcHRpb249XFxcIkhvc3QgZm9yIGxvY2FsIGNoYXQgc2VydmVyLlxcXCJcXG4gICAgZGF0YS1wbGFjZWhvbGRlcj1cXFwiRW50ZXIgYSBob3N0XFxcIlxcbiAgICBkYXRhLWNhbGxiYWNrPVxcXCJjaGFuZ2VkX3NtYXJ0X2NoYXRfbW9kZWxcXFwiXFxuICA+PC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJzZXR0aW5nLWNvbXBvbmVudFxcXCJcXG4gICAgZGF0YS1uYW1lPVxcXCJwb3J0XFxcIlxcbiAgICBkYXRhLXR5cGU9XFxcIm51bWJlclxcXCJcXG4gICAgZGF0YS1zZXR0aW5nPVxcXCJjdXN0b21fbG9jYWwucG9ydFxcXCJcXG4gICAgZGF0YS1kZXNjcmlwdGlvbj1cXFwiUG9ydCBmb3IgbG9jYWwgY2hhdCBzZXJ2ZXIuXFxcIlxcbiAgICBkYXRhLXBsYWNlaG9sZGVyPVxcXCJFbnRlciBhIHBvcnQgbnVtYmVyXFxcIlxcbiAgICBkYXRhLWNhbGxiYWNrPVxcXCJjaGFuZ2VkX3NtYXJ0X2NoYXRfbW9kZWxcXFwiXFxuICA+PC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJzZXR0aW5nLWNvbXBvbmVudFxcXCJcXG4gICAgZGF0YS1uYW1lPVxcXCJwYXRoXFxcIlxcbiAgICBkYXRhLXR5cGU9XFxcInRleHRcXFwiXFxuICAgIGRhdGEtc2V0dGluZz1cXFwiY3VzdG9tX2xvY2FsLnBhdGhcXFwiXFxuICAgIGRhdGEtZGVzY3JpcHRpb249XFxcIlBhdGggZm9yIGxvY2FsIGNoYXQgc2VydmVyLlxcXCJcXG4gICAgZGF0YS1wbGFjZWhvbGRlcj1cXFwiRW50ZXIgYSBwYXRoXFxcIlxcbiAgICBkYXRhLWNhbGxiYWNrPVxcXCJjaGFuZ2VkX3NtYXJ0X2NoYXRfbW9kZWxcXFwiXFxuICA+PC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJzZXR0aW5nLWNvbXBvbmVudFxcXCJcXG4gICAgZGF0YS1uYW1lPVxcXCJzdHJlYW1pbmdcXFwiXFxuICAgIGRhdGEtdHlwZT1cXFwidG9nZ2xlXFxcIlxcbiAgICBkYXRhLXNldHRpbmc9XFxcImN1c3RvbV9sb2NhbC5zdHJlYW1pbmdcXFwiXFxuICAgIGRhdGEtZGVzY3JpcHRpb249XFxcIkVuYWJsZSBzdHJlYW1pbmcgZm9yIGxvY2FsIGNoYXQgc2VydmVyLiBEaXNhYmxlIGlmIHlvdSBhcmUgZ2V0dGluZyBDT1JTIGVycm9ycy5cXFwiXFxuICAgIGRhdGEtY2FsbGJhY2s9XFxcImNoYW5nZWRfc21hcnRfY2hhdF9tb2RlbFxcXCJcXG4gID48L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFxcInNldHRpbmctY29tcG9uZW50XFxcIlxcbiAgICBkYXRhLW5hbWU9XFxcIk1heCBpbnB1dCB0b2tlbnNcXFwiXFxuICAgIGRhdGEtZGVzY3JpcHRpb249XFxcIk1heGltdW0gbnVtYmVyIG9mIHRva2VucyBmb3IgaW5wdXQgdG8gdGhlIG1vZGVsLlxcXCJcXG4gICAgZGF0YS10eXBlPVxcXCJudW1iZXJcXFwiXFxuICAgIGRhdGEtc2V0dGluZz1cXFwiY3VzdG9tX2xvY2FsLm1heF9pbnB1dF90b2tlbnNcXFwiXFxuICAgIGRhdGEtcGxhY2Vob2xkZXI9XFxcIkVudGVyIGEgbnVtYmVyXFxcIlxcbiAgICBkYXRhLWNhbGxiYWNrPVxcXCJjaGFuZ2VkX3NtYXJ0X2NoYXRfbW9kZWxcXFwiXFxuICA+PC9kaXY+XFxuPCUgfSBlbHNlIGlmKHNldHRpbmdzLmNoYXRfbW9kZWxfcGxhdGZvcm1fa2V5LnN0YXJ0c1dpdGgoJ2N1c3RvbV9hcGknKSkgeyAlPlxcbiAgPGgzPkN1c3RvbSBTZXJ2ZXI8L2gzPlxcbiAgPGRpdiBjbGFzcz1cXFwic2V0dGluZy1jb21wb25lbnRcXFwiXFxuICAgIGRhdGEtbmFtZT1cXFwiTW9kZWwgTmFtZVxcXCJcXG4gICAgZGF0YS10eXBlPVxcXCJ0ZXh0XFxcIlxcbiAgICBkYXRhLXNldHRpbmc9XFxcImN1c3RvbV9hcGkubW9kZWxfbmFtZVxcXCJcXG4gICAgZGF0YS1kZXNjcmlwdGlvbj1cXFwiTmFtZSBvZiB0aGUgY3VzdG9tIG1vZGVsLlxcXCJcXG4gICAgZGF0YS1wbGFjZWhvbGRlcj1cXFwiRW50ZXIgYSBtb2RlbCBuYW1lXFxcIlxcbiAgICBkYXRhLWNhbGxiYWNrPVxcXCJjaGFuZ2VkX3NtYXJ0X2NoYXRfbW9kZWxcXFwiXFxuICA+PC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJzZXR0aW5nLWNvbXBvbmVudFxcXCJcXG4gICAgZGF0YS1uYW1lPVxcXCJwcm90b2NvbFxcXCJcXG4gICAgZGF0YS10eXBlPVxcXCJ0ZXh0XFxcIlxcbiAgICBkYXRhLXNldHRpbmc9XFxcImN1c3RvbV9hcGkucHJvdG9jb2xcXFwiXFxuICAgIGRhdGEtZGVzY3JpcHRpb249XFxcIlByb3RvY29sIGZvciBjaGF0IHNlcnZlciAoaHR0cCBvciBodHRwcykuXFxcIlxcbiAgICBkYXRhLXBsYWNlaG9sZGVyPVxcXCJFbnRlciBhIHByb3RvY29sXFxcIlxcbiAgICBkYXRhLWNhbGxiYWNrPVxcXCJjaGFuZ2VkX3NtYXJ0X2NoYXRfbW9kZWxcXFwiXFxuICA+PC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJzZXR0aW5nLWNvbXBvbmVudFxcXCJcXG4gICAgZGF0YS1uYW1lPVxcXCJob3N0bmFtZVxcXCJcXG4gICAgZGF0YS10eXBlPVxcXCJ0ZXh0XFxcIlxcbiAgICBkYXRhLXNldHRpbmc9XFxcImN1c3RvbV9hcGkuaG9zdG5hbWVcXFwiXFxuICAgIGRhdGEtZGVzY3JpcHRpb249XFxcIkhvc3QgZm9yIGNoYXQgc2VydmVyLlxcXCJcXG4gICAgZGF0YS1wbGFjZWhvbGRlcj1cXFwiRW50ZXIgYSBob3N0XFxcIlxcbiAgICBkYXRhLWNhbGxiYWNrPVxcXCJjaGFuZ2VkX3NtYXJ0X2NoYXRfbW9kZWxcXFwiXFxuICA+PC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJzZXR0aW5nLWNvbXBvbmVudFxcXCJcXG4gICAgZGF0YS1uYW1lPVxcXCJwYXRoXFxcIlxcbiAgICBkYXRhLXR5cGU9XFxcInRleHRcXFwiXFxuICAgIGRhdGEtc2V0dGluZz1cXFwiY3VzdG9tX2FwaS5wYXRoXFxcIlxcbiAgICBkYXRhLWRlc2NyaXB0aW9uPVxcXCJQYXRoIGZvciBjaGF0IHNlcnZlci5cXFwiXFxuICAgIGRhdGEtcGxhY2Vob2xkZXI9XFxcIkVudGVyIGEgcGF0aFxcXCJcXG4gICAgZGF0YS1jYWxsYmFjaz1cXFwiY2hhbmdlZF9zbWFydF9jaGF0X21vZGVsXFxcIlxcbiAgPjwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwic2V0dGluZy1jb21wb25lbnRcXFwiXFxuICAgIGRhdGEtbmFtZT1cXFwic3RyZWFtaW5nXFxcIlxcbiAgICBkYXRhLXR5cGU9XFxcInRvZ2dsZVxcXCJcXG4gICAgZGF0YS1zZXR0aW5nPVxcXCJjdXN0b21fYXBpLnN0cmVhbWluZ1xcXCJcXG4gICAgZGF0YS1kZXNjcmlwdGlvbj1cXFwiRW5hYmxlIHN0cmVhbWluZyBmb3IgY2hhdCBzZXJ2ZXIuIERpc2FibGUgaWYgeW91IGFyZSBnZXR0aW5nIENPUlMgZXJyb3JzLlxcXCJcXG4gICAgZGF0YS1jYWxsYmFjaz1cXFwiY2hhbmdlZF9zbWFydF9jaGF0X21vZGVsXFxcIlxcbiAgPjwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwic2V0dGluZy1jb21wb25lbnRcXFwiXFxuICAgIGRhdGEtbmFtZT1cXFwiTWF4IGlucHV0IHRva2Vuc1xcXCJcXG4gICAgZGF0YS1kZXNjcmlwdGlvbj1cXFwiTWF4aW11bSBudW1iZXIgb2YgdG9rZW5zIGZvciBpbnB1dCB0byB0aGUgbW9kZWwuXFxcIlxcbiAgICBkYXRhLXR5cGU9XFxcIm51bWJlclxcXCJcXG4gICAgZGF0YS1zZXR0aW5nPVxcXCJjdXN0b21fYXBpLm1heF9pbnB1dF90b2tlbnNcXFwiXFxuICAgIGRhdGEtcGxhY2Vob2xkZXI9XFxcIkVudGVyIGEgbnVtYmVyXFxcIlxcbiAgICBkYXRhLWNhbGxiYWNrPVxcXCJjaGFuZ2VkX3NtYXJ0X2NoYXRfbW9kZWxcXFwiXFxuICA+PC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJzZXR0aW5nLWNvbXBvbmVudFxcXCJcXG4gICAgZGF0YS1uYW1lPVxcXCJBUEkgS2V5XFxcIlxcbiAgICBkYXRhLXR5cGU9XFxcInRleHRcXFwiXFxuICAgIGRhdGEtc2V0dGluZz1cXFwiY3VzdG9tX2FwaS5hcGlfa2V5XFxcIlxcbiAgICBkYXRhLWRlc2NyaXB0aW9uPVxcXCJBUEkgS2V5IGZvciB0aGUgY3VzdG9tIHNlcnZlciBzZW50IGFzIGEgaGVhZGVyIChiZWFyZXIgdG9rZW4pLlxcXCJcXG4gICAgZGF0YS1wbGFjZWhvbGRlcj1cXFwiRW50ZXIgYW4gQVBJIEtleVxcXCJcXG4gICAgZGF0YS1idXR0b249XFxcIlNhdmVcXFwiXFxuICAgIGRhdGEtY2FsbGJhY2s9XFxcInRlc3RfY2hhdF9hcGlfa2V5XFxcIlxcbiAgPjwvZGl2PlxcbjwlIH0gJT5cIixcbiAgXCJzbWFydF9jaGF0X3N5c3RlbV9tc2dcIjogXCI8ZGl2IGNsYXNzPVxcXCJzYy08JT0gcm9sZSAlPlxcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJcXFwiIGRhdGEtY29udGVudD1cXFwiPCU9IGNvbnRlbnQgJT5cXFwiPlxcbiAgICA8c3Bhbj48JT0gY29udGVudCAlPjwvc3Bhbj5cXG4gIDwvZGl2PlxcbjwvZGl2PlwiLFxuICBcInNtYXJ0X2Nvbm5lY3Rpb25zXCI6IFwiPGRpdiBjbGFzcz1cXFwic2MtdG9wLWJhclxcXCI+XFxuICA8cCBjbGFzcz1cXFwic2MtY29udGV4dFxcXCI+XFxuICAgIDwlLSBjdXJyZW50X3BhdGggJT5cXG4gICAgPCUtIHRoaXMubm90ZXMgJT4gKDwlLSB0aGlzLmJsb2NrcyAlPilcXG4gIDwvcD5cXG4gIDxidXR0b24gY2xhc3M9XFxcInNjLWZvbGQtYWxsXFxcIj48JS0gdGhpcy5nZXRfaWNvbignZm9sZC12ZXJ0aWNhbCcpICU+PC9idXR0b24+XFxuICA8YnV0dG9uIGNsYXNzPVxcXCJzYy11bmZvbGQtYWxsXFxcIj48JS0gdGhpcy5nZXRfaWNvbigndW5mb2xkLXZlcnRpY2FsJykgJT48L2J1dHRvbj5cXG4gIDxidXR0b24gY2xhc3M9XFxcInNjLXNlYXJjaC1idXR0b25cXFwiIHN0eWxlPVxcXCJkaXNwbGF5OiBub25lO1xcXCI+PCUtIHRoaXMuZ2V0X2ljb24oJ3NlYXJjaCcpICU+PC9idXR0b24+XFxuICA8YnV0dG9uIHRpdGxlPVxcXCJTZXR0aW5nc1xcXCI+PCUtIHRoaXMuZ2V0X2ljb24oJ2dlYXInKSAlPjwvYnV0dG9uPlxcbjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcInNjLWxpc3RcXFwiPlxcbiAgPCUgZm9yIChsZXQgcmVzdWx0IG9mIHJlc3VsdHMpIHsgJT5cXG4gIDxkaXYgY2xhc3M9XFxcInNlYXJjaC1yZXN1bHQ8JS0gIXRoaXMuc2V0dGluZ3MuZXhwYW5kZWRfdmlldyA/ICcgc2MtY29sbGFwc2VkJyA6ICcnICU+XFxcIiBkYXRhLXBhdGg9XFxcIjwlLSByZXN1bHQucGF0aCAlPlxcXCI+XFxuICAgIDxzcGFuIGNsYXNzPVxcXCJoZWFkZXJcXFwiPlxcbiAgICAgIDwlLSB0aGlzLmdldF9pY29uKCdyaWdodC10cmlhbmdsZScpICU+XFxuICAgICAgPGEgY2xhc3M9XFxcInNlYXJjaC1yZXN1bHQtZmlsZS10aXRsZVxcXCIgdGl0bGU9XFxcIjwlLSByZXN1bHQucGF0aCAlPlxcXCIgZHJhZ2dhYmxlPVxcXCJ0cnVlXFxcIj5cXG4gICAgICAgIDxzbWFsbD48JS0gW3Jlc3VsdC5zY29yZT8udG9GaXhlZCgyKSwgcmVzdWx0Lm5hbWVdLmpvaW4oJyB8ICcpICU+PC9zbWFsbD5cXG4gICAgICA8L2E+XFxuICAgIDwvc3Bhbj5cXG4gICAgPHVsIGRyYWdnYWJsZT1cXFwidHJ1ZVxcXCI+XFxuICAgICAgPGxpIGNsYXNzPVxcXCJzZWFyY2gtcmVzdWx0LWZpbGUtdGl0bGVcXFwiIHRpdGxlPVxcXCI8JS0gcmVzdWx0LnBhdGggJT5cXFwiIGRhdGEtY29sbGVjdGlvbj1cXFwiPCU9IHJlc3VsdC5jb2xsZWN0aW9uX25hbWUgJT5cXFwiPjwvbGk+XFxuICAgIDwvdWw+XFxuICA8L2Rpdj5cXG4gIDwlIH0gJT5cXG48L2Rpdj5cXG48ZGl2IGlkPVxcXCJzZXR0aW5nc1xcXCI+PC9kaXY+XFxuPCUtIHRoaXMuYXR0cmlidXRpb24gJT5cIixcbiAgXCJzbWFydF9lbWJlZF9zZXR0aW5nc1wiOiBcIjxkaXYgY2xhc3M9XFxcInNldHRpbmctY29tcG9uZW50XFxcIlxcbiAgZGF0YS1uYW1lPVxcXCJOb3RlcyBFbWJlZGRpbmcgTW9kZWxcXFwiXFxuICBkYXRhLXNldHRpbmc9XFxcInNtYXJ0X25vdGVzX2VtYmVkX21vZGVsXFxcIlxcbiAgZGF0YS10eXBlPVxcXCJkcm9wZG93blxcXCJcXG4gIGRhdGEtZGVzY3JpcHRpb249XFxcIlNlbGVjdCBhIG1vZGVsIHRvIHVzZSBmb3IgZW1iZWRkaW5nIHlvdXIgbm90ZXMuXFxcIlxcbiAgPCUtIGVtYmVkZGluZ19tb2RlbHMubWFwKChtb2RlbCwgaSkgPT4gYGRhdGEtb3B0aW9uLSR7aSArIDF9PVxcXCIke21vZGVsLmtleX18JHttb2RlbC5uYW1lfSAoJHttb2RlbC5kZXNjcmlwdGlvbn0pXFxcImApLmpvaW4oJ1xcXFxuJykgJT5cXG4gIGRhdGEtY2FsbGJhY2s9XFxcInJlc3RhcnRfcGx1Z2luXFxcIlxcbj48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJzZXR0aW5nLWNvbXBvbmVudFxcXCJcXG4gIGRhdGEtbmFtZT1cXFwiQmxvY2tzIEVtYmVkZGluZyBNb2RlbFxcXCJcXG4gIGRhdGEtc2V0dGluZz1cXFwic21hcnRfYmxvY2tzX2VtYmVkX21vZGVsXFxcIlxcbiAgZGF0YS10eXBlPVxcXCJkcm9wZG93blxcXCJcXG4gIGRhdGEtZGVzY3JpcHRpb249XFxcIlNlbGVjdCBhIG1vZGVsIHRvIHVzZSBmb3IgZW1iZWRkaW5nIHlvdXIgYmxvY2tzLlxcXCJcXG4gIGRhdGEtb3B0aW9uLTA9XFxcIk5vbmV8Tm9uZVxcXCJcXG4gIDwlLSBlbWJlZGRpbmdfbW9kZWxzLm1hcCgobW9kZWwsIGkpID0+IGBkYXRhLW9wdGlvbi0ke2kgKyAxfT1cXFwiJHttb2RlbC5rZXl9fCR7bW9kZWwubmFtZX0gKCR7bW9kZWwuZGVzY3JpcHRpb259KVxcXCJgKS5qb2luKCdcXFxcbicpICU+XFxuICBkYXRhLWNhbGxiYWNrPVxcXCJyZXN0YXJ0X3BsdWdpblxcXCJcXG4+PC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwic2V0dGluZy1jb21wb25lbnRcXFwiXFxuICBkYXRhLW5hbWU9XFxcIk1pbmltdW0gRW1iZWRkaW5nIExlbmd0aFxcXCJcXG4gIGRhdGEtZGVzY3JpcHRpb249XFxcIk1pbmltdW0gbGVuZ3RoIG9mIG5vdGUgdG8gZW1iZWQuXFxcIlxcbiAgZGF0YS10eXBlPVxcXCJudW1iZXJcXFwiXFxuICBkYXRhLXNldHRpbmc9XFxcImVtYmVkX2lucHV0X21pbl9jaGFyc1xcXCJcXG4gIGRhdGEtcGxhY2Vob2xkZXI9XFxcIkVudGVyIGEgbnVtYmVyXFxcIlxcbiAgZGF0YS1jYWxsYmFjaz1cXFwicmVsb2FkX2VudlxcXCJcXG4+PC9kaXY+XFxuPCUgaWYoIXNldHRpbmdzLnNtYXJ0X25vdGVzX2VtYmVkX21vZGVsLmluY2x1ZGVzKCcvJykgfHwgIXNldHRpbmdzLnNtYXJ0X2Jsb2Nrc19lbWJlZF9tb2RlbC5pbmNsdWRlcygnLycpKSB7ICU+XFxuPGRpdiBjbGFzcz1cXFwic2V0dGluZy1jb21wb25lbnRcXFwiXFxuICBkYXRhLW5hbWU9XFxcIk9wZW5BSSBBUEkgS2V5IGZvciBlbWJlZGRpbmdzXFxcIlxcbiAgZGF0YS10eXBlPVxcXCJ0ZXh0XFxcIlxcbiAgZGF0YS1zZXR0aW5nPVxcXCJhcGlfa2V5XFxcIlxcbiAgZGF0YS1wbGFjZWhvbGRlcj1cXFwiRW50ZXIgeW91ciBPcGVuQUkgQVBJIEtleVxcXCJcXG4gIGRhdGEtYnV0dG9uPVxcXCJTYXZlXFxcIlxcbiAgZGF0YS1jYWxsYmFjaz1cXFwidGVzdF9hcGlfa2V5X29wZW5haV9lbWJlZGRpbmdzXFxcIlxcbj48L2Rpdj5cXG48JSB9ICU+XFxuPCUgaWYoc2V0dGluZ3Muc21hcnRfbm90ZXNfZW1iZWRfbW9kZWwuaW5jbHVkZXMoJy8nKSB8fCBzZXR0aW5ncy5zbWFydF9ibG9ja3NfZW1iZWRfbW9kZWwuaW5jbHVkZXMoJy8nKSkgeyAlPlxcbjxkaXYgY2xhc3M9XFxcInNldHRpbmctY29tcG9uZW50XFxcIlxcbiAgZGF0YS1uYW1lPVxcXCJMb2NhbCBFbWJlZGRpbmcgTWF4IFRva2Vuc1xcXCJcXG4gIGRhdGEtZGVzY3JpcHRpb249XFxcIlJlZHVjZSBtYXggdG9rZW5zIGRlcGVuZGluZyBvbiBhdmFpbGFibGUgcmVzb3VyY2VzIChDUFUsIFJBTSkuXFxcIiBcXG4gIGRhdGEtdHlwZT1cXFwiZHJvcGRvd25cXFwiXFxuICBkYXRhLXNldHRpbmc9XFxcImxvY2FsX2VtYmVkZGluZ19tYXhfdG9rZW5zXFxcIlxcbiAgZGF0YS1vcHRpb24tMT1cXFwiNTEyXFxcIlxcbiAgZGF0YS1vcHRpb24tMj1cXFwiMTAyNFxcXCJcXG4gIGRhdGEtb3B0aW9uLTM9XFxcIjIwNDh8MjA0OCAoZGVmYXVsdClcXFwiXFxuICBkYXRhLW9wdGlvbi00PVxcXCI0MDk2XFxcIlxcbiAgZGF0YS1vcHRpb24tNT1cXFwiODE5MlxcXCJcXG4gIGRhdGEtY2FsbGJhY2s9XFxcInJlbG9hZF9lbnZcXFwiXFxuPjwvZGl2PlxcblxcbjxkaXYgY2xhc3M9XFxcInNldHRpbmctY29tcG9uZW50XFxcIlxcbiAgZGF0YS1uYW1lPVxcXCJDb25uZWN0IHRvIFNtYXJ0IENvbm5lY3RcXFwiXFxuICBkYXRhLWRlc2NyaXB0aW9uPVxcXCI8YSBocmVmPSdodHRwczovL2dpdGh1Yi5jb20vYnJpYW5wZXRyby9zbWFydC1jb25uZWN0Jz5TbWFydCBDb25uZWN0PC9hPiBpcyBmcmVlIHRvIHVzZSBmb3IgZmFzdGVyIGxvY2FsIGVtYmVkZGluZ3MuXFxcIlxcbiAgZGF0YS10eXBlPVxcXCJidXR0b25cXFwiXFxuICBkYXRhLWNhbGxiYWNrPVxcXCJjb25uZWN0X3RvX3NtYXJ0X2Nvbm5lY3RcXFwiXFxuPjwvZGl2PlxcbjwlIH0gJT5cXG48ZGl2IGNsYXNzPVxcXCJzZXR0aW5nLWNvbXBvbmVudFxcXCJcXG4gIGRhdGEtbmFtZT1cXFwiU2hvdyBGdWxsIFBhdGhcXFwiXFxuICBkYXRhLWRlc2NyaXB0aW9uPVxcXCJTaG93IGZ1bGwgcGF0aCBpbiB2aWV3LlxcXCJcXG4gIGRhdGEtdHlwZT1cXFwidG9nZ2xlXFxcIlxcbiAgZGF0YS1zZXR0aW5nPVxcXCJzaG93X2Z1bGxfcGF0aFxcXCJcXG4gIGRhdGEtY2FsbGJhY2s9XFxcInJlZnJlc2hfc21hcnRfdmlld1xcXCJcXG4+PC9kaXY+XCIsXG4gIFwic21hcnRfc2V0dGluZ3NcIjogXCI8aDE+U21hcnQgQ29ubmVjdGlvbnM8L2gxPlxcbjwlIGlmKHRoaXMuZW52LnBsdWdpbi5FQVJMWV9BQ0NFU1MgJiYgdGhpcy5lbnYucGx1Z2luLm9ic2lkaWFuLlBsYXRmb3JtLmlzTW9iaWxlICYmICF0aGlzLmVudi5wbHVnaW4uc2V0dGluZ3MuZW5hYmxlX21vYmlsZSkgeyAlPlxcbjxkaXYgZGF0YS1jYWxsb3V0LW1ldGFkYXRhPVxcXCJcXFwiIGRhdGEtY2FsbG91dC1mb2xkPVxcXCJcXFwiIGRhdGEtY2FsbG91dD1cXFwid2FybmluZ1xcXCIgY2xhc3M9XFxcImNhbGxvdXRcXFwiPjxkaXYgY2xhc3M9XFxcImNhbGxvdXQtdGl0bGVcXFwiPjxkaXYgY2xhc3M9XFxcImNhbGxvdXQtaWNvblxcXCI+PHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCIyNFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIiBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcImN1cnJlbnRDb2xvclxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIyXFxcIiBzdHJva2UtbGluZWNhcD1cXFwicm91bmRcXFwiIHN0cm9rZS1saW5lam9pbj1cXFwicm91bmRcXFwiIGNsYXNzPVxcXCJzdmctaWNvbiBsdWNpZGUtYWxlcnQtdHJpYW5nbGVcXFwiPjxwYXRoIGQ9XFxcIm0yMS43MyAxOC04LTE0YTIgMiAwIDAgMC0zLjQ4IDBsLTggMTRBMiAyIDAgMCAwIDQgMjFoMTZhMiAyIDAgMCAwIDEuNzMtM1pcXFwiPjwvcGF0aD48cGF0aCBkPVxcXCJNMTIgOXY0XFxcIj48L3BhdGg+PHBhdGggZD1cXFwiTTEyIDE3aC4wMVxcXCI+PC9wYXRoPjwvc3ZnPjwvZGl2PjxkaXYgY2xhc3M9XFxcImNhbGxvdXQtdGl0bGUtaW5uZXJcXFwiPk1vYmlsZSBpcyBESVNBQkxFRC48L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJjYWxsb3V0LWNvbnRlbnRcXFwiPlxcbjxwPlRvZ2dsZSBcXFwiRW5hYmxlIG1vYmlsZVxcXCIgc2V0dGluZyB0byBhY3RpdmF0ZSBtb2JpbGUuPC9wPlxcbjwvZGl2PjwvZGl2PlxcbjwlIH0gJT5cXG48ZGl2IGRhdGEtY2FsbG91dC1tZXRhZGF0YT1cXFwiXFxcIiBkYXRhLWNhbGxvdXQtZm9sZD1cXFwiXFxcIiBkYXRhLWNhbGxvdXQ9XFxcImluZm9cXFwiIGNsYXNzPVxcXCJjYWxsb3V0XFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcImNhbGxvdXQtdGl0bGVcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjYWxsb3V0LWljb25cXFwiPjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB3aWR0aD1cXFwiMjRcXFwiIGhlaWdodD1cXFwiMjRcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNCAyNFxcXCJcXG4gICAgICAgIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiY3VycmVudENvbG9yXFxcIiBzdHJva2Utd2lkdGg9XFxcIjJcXFwiIHN0cm9rZS1saW5lY2FwPVxcXCJyb3VuZFxcXCIgc3Ryb2tlLWxpbmVqb2luPVxcXCJyb3VuZFxcXCJcXG4gICAgICAgIGNsYXNzPVxcXCJzdmctaWNvbiBsdWNpZGUtaW5mb1xcXCI+XFxuICAgICAgICA8Y2lyY2xlIGN4PVxcXCIxMlxcXCIgY3k9XFxcIjEyXFxcIiByPVxcXCIxMFxcXCI+PC9jaXJjbGU+XFxuICAgICAgICA8cGF0aCBkPVxcXCJNMTIgMTZ2LTRcXFwiPjwvcGF0aD5cXG4gICAgICAgIDxwYXRoIGQ9XFxcIk0xMiA4aC4wMVxcXCI+PC9wYXRoPlxcbiAgICAgIDwvc3ZnPjwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjYWxsb3V0LXRpdGxlLWlubmVyXFxcIj5cXG4gICAgICA8YmxvY2txdW90ZT5cXG4gICAgICAgIDxwPjxiPlVzZXIgQWdyZWVtZW50OjwvYj4gQnkgdXNpbmcgU21hcnQgQ29ubmVjdGlvbnMgeW91IGFncmVlIHRvIHNoYXJlIGhvdyBpdCBoZWxwcyB5b3Ugd2l0aCBhdCBsZWFzdCBvbmUgb3RoZXIgcGVyc29uXFxuICAgICAgICAgIFx1RDgzRFx1REUwQVx1RDgzQ1x1REYzNDwvcD5cXG4gICAgICA8L2Jsb2NrcXVvdGU+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwic2Mtc3VwcG9ydGVyc1xcXCI+XFxuICA8aDE+U3VwcG9ydGVyIENvbW11bml0eTwvaDE+XFxuICA8JSBpZighdGhpcy5lbnYucGx1Z2luLkVBUkxZX0FDQ0VTUyl7ICU+XFxuICA8cD5UaGUgc3VjY2VzcyBvZiBTbWFydCBDb25uZWN0aW9ucyBpcyBhIGRpcmVjdCByZXN1bHQgb2Ygb3VyIGNvbW11bml0eSBvZiBzdXBwb3J0ZXJzIHdobyBnZW5lcm91c2x5IGZ1bmQgYW5kIGV2YWx1YXRlIG5ldyBmZWF0dXJlcy4gVGhlaXIgdW53YXZlcmluZyBjb21taXRtZW50IHRvIG91ciBwcml2YWN5LWZvY3VzZWQsIG9wZW4tc291cmNlIHNvZnR3YXJlIGJlbmVmaXRzIGFsbC4gVG9nZXRoZXIsIHdlIGNhbiBjb250aW51ZSB0byBpbm5vdmF0ZSBhbmQgbWFrZSBhIHBvc2l0aXZlIGltcGFjdCBvbiB0aGUgd29ybGQuPC9wPlxcbiAgPHA+PGI+U3VwcG9ydGVyIGJlbmVmaXRzIGluY2x1ZGU6PC9iPjwvcD5cXG4gIDx1bD5cXG4gICAgPGxpPkVhcmx5IGFjY2VzcyB0byBuZXcgJmFtcDsgZXhwZXJpbWVudGFsIGZlYXR1cmVzOlxcbiAgICAgIDx1bD5cXG4gICAgICAgIDxsaT5FYXJseSBhY2Nlc3MgdG8gbmV3IHZlcnNpb25zIGVuYWJsZXMgc3VwcG9ydGVycyB0byBoZWxwIGVuc3VyZSBuZXcgZmVhdHVyZXMgYXJlIHJlYWR5IGZvciB0aGUgYnJvYWRlciBjb21tdW5pdHkuPC9saT5cXG4gICAgICAgIDxsaT48aT5BdmFpbGFibGUgaW4gdjIuMiAoRWFybHkgUmVsZWFzZSk6PC9pPjx1bD5cXG4gICAgICAgICAgPGxpPlx1RDgzRFx1RERCQ1x1RkUwRiBNdWx0aW1vZGFsIFNtYXJ0IENoYXQgKGltYWdlcyk8L2xpPlxcbiAgICAgICAgICA8bGk+XHVEODNEXHVEQ0YyIE1vYmlsZSBjb21wYXRpYmlsaXR5PC9saT5cXG4gICAgICAgIDwvdWw+PC9saT5cXG4gICAgICAgIDxsaT48aT5Db21pbmcgc29vbjo8L2k+PHVsPlxcbiAgICAgICAgICA8bGk+UmUtcmFua2luZyBpbiB0aGUgU21hcnQgVmlldzwvbGk+XFxuICAgICAgICAgIDxsaT5BY3Rpb25zIGluIHRoZSBTbWFydCBDaGF0PC9saT5cXG4gICAgICAgICAgPGxpPkFkdmFuY2VkIGZpbHRlcnMgaW4gdGhlIFNtYXJ0IFZpZXc8L2xpPlxcbiAgICAgICAgPC91bD48L2xpPlxcbiAgICAgIDwvdWw+XFxuICAgIDwvbGk+XFxuICAgIDxsaT5BY2Nlc3MgdG8gdGhlIHN1cHBvcnRlci1vbmx5IDxhIGhyZWY9XFxcImh0dHBzOi8vY2hhdC5zbWFydGNvbm5lY3Rpb25zLmFwcFxcXCI+cHJpdmF0ZSBjaGF0PC9hPjpcXG4gICAgICA8dWw+XFxuICAgICAgICA8bGk+PGk+Q29tbXVuaXR5OjwvaT5cXG4gICAgICAgICAgPHVsPlxcbiAgICAgICAgICAgIDxsaT5Bc2sgcXVlc3Rpb25zIGFuZCBzaGFyZSBpbnNpZ2h0cyB3aXRoIG90aGVyIHN1cHBvcnRlcnMuPC9saT5cXG4gICAgICAgICAgPC91bD5cXG4gICAgICAgIDwvbGk+XFxuICAgICAgICA8bGk+PGk+SGVscCAmYW1wOyBTdXBwb3J0IChwcmlvcml0eSk6PC9pPlxcbiAgICAgICAgICA8dWw+XFxuICAgICAgICAgICAgPGxpPlN3aWZ0LCB0b3AtcHJpb3JpdHkgc3VwcG9ydCBpbiB0aGUgPGEgaHJlZj1cXFwiaHR0cHM6Ly9jaGF0LnNtYXJ0Y29ubmVjdGlvbnMuYXBwXFxcIj5TdXBwb3J0ZXIgQ2hhdDwvYT4uPC9saT5cXG4gICAgICAgICAgPC91bD5cXG4gICAgICAgIDwvbGk+XFxuICAgICAgICA8bGk+PGk+RmVhdHVyZSBSZXF1ZXN0cyAocHJpb3JpdHkpOjwvaT5cXG4gICAgICAgICAgPHVsPlxcbiAgICAgICAgICAgIDxsaT5JbmZsdWVuY2UgdGhlIGZ1dHVyZSBvZiBTbWFydCBDb25uZWN0aW9ucyB3aXRoIHByaW9yaXR5IGZlYXR1cmUgcmVxdWVzdHMgaW4gdGhlIDxhIGhyZWY9XFxcImh0dHBzOi8vY2hhdC5zbWFydGNvbm5lY3Rpb25zLmFwcFxcXCI+U3VwcG9ydGVyIENoYXQ8L2E+LjwvbGk+XFxuICAgICAgICAgIDwvdWw+XFxuICAgICAgICA8L2xpPlxcbiAgICAgICAgPGxpPjxpPkluc2lkZXIgVXBkYXRlczo8L2k+XFxuICAgICAgICAgIDx1bD5cXG4gICAgICAgICAgICA8bGk+TGVhcm4gYWJvdXQgdGhlIGxhdGVzdCBmZWF0dXJlcyAmYW1wOyBpbXByb3ZlbWVudHMgYmVmb3JlIHRoZXkgYXJlIGFubm91bmNlZC48L2xpPlxcbiAgICAgICAgICA8L3VsPlxcbiAgICAgICAgPC9saT5cXG4gICAgICA8L3VsPlxcbiAgICA8L2xpPlxcbiAgICA8bGk+PGI+Rm9yIGEgdmVyeSBsaW1pdGVkIHRpbWU6PC9iPiBFYXJseSBhY2Nlc3MgdG8gU21hcnQgQ29ubmVjdDogVXNlIENoYXRHUFQgd2l0aCB5b3VyIG5vdGVzIDxpPndpdGhvdXQ8L2k+IHVwbG9hZGluZyB5b3VyIG5vdGVzIHRvIHRoZSBjbG91ZCB1c2luZyA8YSBocmVmPVxcXCJodHRwczovL2NoYXQub3BlbmFpLmNvbS9nL2ctOVhiMW1SSllsLXNtYXJ0LWNvbm5lY3Qtb2JzaWRpYW5cXFwiPlNtYXJ0IENvbm5lY3QgLSBPYnNpZGlhbjwvYT4gR1BULjwvbGk+XFxuICA8L3VsPlxcbiAgPCUgfSAlPlxcbiAgPGRpdiBjbGFzcz1cXFwic2V0dGluZy1jb21wb25lbnRcXFwiXFxuICAgIGRhdGEtbmFtZT1cXFwiU3VwcG9ydGVyIExpY2Vuc2UgS2V5XFxcIlxcbiAgICBkYXRhLXR5cGU9XFxcInRleHRcXFwiXFxuICAgIGRhdGEtc2V0dGluZz1cXFwibGljZW5zZV9rZXlcXFwiXFxuICAgIGRhdGEtZGVzY3JpcHRpb249XFxcIk5vdGU6IHRoaXMgaXMgbm90IHJlcXVpcmVkIHRvIHVzZSBTbWFydCBDb25uZWN0aW9ucy5cXFwiXFxuICAgIGRhdGEtcGxhY2Vob2xkZXI9XFxcIkVudGVyIHlvdXIgbGljZW5zZV9rZXlcXFwiXFxuICA+PC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJzZXR0aW5nLWNvbXBvbmVudFxcXCJcXG4gICAgZGF0YS1uYW1lPVxcXCJTbWFydCBDb25uZWN0IC0gT2JzaWRpYW4gR1BUXFxcIlxcbiAgICBkYXRhLWJ0bi10ZXh0PVxcXCJPcGVuIEdQVFxcXCJcXG4gICAgZGF0YS1kZXNjcmlwdGlvbj0nQ2hhdCB3aXRoIHlvdXIgbm90ZXMgaW4gQ2hhdEdQVCB3aXRob3V0IHVwbG9hZGluZyB5b3VyIG5vdGVzIHRvIHRoZSBjbG91ZCEnXFxuICAgIGRhdGEtdHlwZT1cXFwiYnV0dG9uXFxcIlxcbiAgICBkYXRhLWhyZWY9XFxcImh0dHBzOi8vY2hhdC5vcGVuYWkuY29tL2cvZy05WGIxbVJKWWwtc21hcnQtY29ubmVjdGlvbnMtMlxcXCJcXG4gID48L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFxcInNldHRpbmctY29tcG9uZW50XFxcIlxcbiAgICBkYXRhLW5hbWU9XFxcIkVuYWJsZSBNb2JpbGUgKEVYUEVSSU1FTlRBTClcXFwiXFxuICAgIGRhdGEtZGVzY3JpcHRpb249XFxcIkVuYWJsZSBtb2JpbGUgc3VwcG9ydCBmb3IgU21hcnQgQ29ubmVjdGlvbnMuXFxcIlxcbiAgICBkYXRhLXR5cGU9XFxcInRvZ2dsZVxcXCJcXG4gICAgPCUtIHRoaXMuZW52LnBsdWdpbi5FQVJMWV9BQ0NFU1MgPyAnJyA6ICdkYXRhLWRpc2FibGVkPXRydWUnICU+XFxuICAgIGRhdGEtc2V0dGluZz1cXFwiZW5hYmxlX21vYmlsZVxcXCJcXG4gICAgZGF0YS1jYWxsYmFjaz1cXFwidG9nZ2xlX21vYmlsZVxcXCJcXG4gID48L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFxcInNldHRpbmctY29tcG9uZW50XFxcIlxcbiAgICBkYXRhLW5hbWU9XFxcIk9wZW4gU3VwcG9ydGVyIENvbW11bml0eSBDaGF0XFxcIlxcbiAgICBkYXRhLWJ0bi10ZXh0PVxcXCJPcGVuIENoYXRcXFwiXFxuICAgIGRhdGEtZGVzY3JpcHRpb249J0pvaW4gdGhlIHN1cHBvcnRlciBjb21tdW5pdHkgY2hhdC4nXFxuICAgIGRhdGEtdHlwZT1cXFwiYnV0dG9uXFxcIlxcbiAgICBkYXRhLWhyZWY9XFxcImh0dHBzOi8vY2hhdC5zbWFydGNvbm5lY3Rpb25zLmFwcFxcXCJcXG4gID48L2Rpdj5cXG4gIDwlIGlmKCF0aGlzLmVudi5wbHVnaW4uRUFSTFlfQUNDRVNTKXsgJT5cXG4gIDxkaXYgY2xhc3M9XFxcInNldHRpbmctY29tcG9uZW50XFxcIlxcbiAgICBkYXRhLW5hbWU9XFxcIlVwZ3JhZGUgdG8gRWFybHkgQWNjZXNzIFZlcnNpb24gKHYyLjIpXFxcIlxcbiAgICBkYXRhLWRlc2NyaXB0aW9uPVxcXCJVcGdyYWRlIHRvIHYyLjIgKEVhcmx5IEFjY2VzcykgdG8gYWNjZXNzIG5ldyBmZWF0dXJlcyBhbmQgaW1wcm92ZW1lbnRzLlxcXCJcXG4gICAgZGF0YS10eXBlPVxcXCJidXR0b25cXFwiXFxuICAgIGRhdGEtYnRuLXRleHQ9XFxcIlVwZ3JhZGUgdG8gdjIuMlxcXCJcXG4gICAgZGF0YS1jYWxsYmFjaz1cXFwidXBncmFkZV90b19lYXJseV9hY2Nlc3NcXFwiXFxuICA+PC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJzZXR0aW5nLWNvbXBvbmVudFxcXCJcXG4gICAgZGF0YS1uYW1lPVxcXCJCZWNvbWUgYSBTdXBwb3J0ZXJcXFwiXFxuICAgIGRhdGEtZGVzY3JpcHRpb249XFxcIkJlY29tZSBhIFN1cHBvcnRlclxcXCJcXG4gICAgZGF0YS10eXBlPVxcXCJidXR0b25cXFwiXFxuICAgIGRhdGEtaHJlZj1cXFwiaHR0cHM6Ly9idXkuc3RyaXBlLmNvbS85QVE3c1dlbVQ0OHUxTEdjTjRcXFwiXFxuICA+PC9kaXY+XFxuICA8JSB9ICU+XFxuPC9kaXY+XFxuPGgxPlNtYXJ0IFZpZXcgJiBFbWJlZGRpbmdzPC9oMT5cXG48cD5Ob3RlcyBhYm91dCBlbWJlZGRpbmcgbW9kZWxzOjwvcD5cXG48dWw+XFxuICA8bGk+TG9jYWwgbW9kZWwgY29tcGF0aWJpbGl0eSBkZXBlbmRzIG9uIGF2YWlsYWJsZSBDUFUgYW5kIFJBTS4gVHJ5IHJlZHVjaW5nIHRoZSBtYXggdG9rZW5zIChjb250ZXh0KSBpZiBhIGxvY2FsIG1vZGVsIGlmIGZhaWxpbmcuPC9saT5cXG4gIDxsaT5BUEkgbW9kZWxzIGFyZSBub3QgZGVwZW5kZW50IG9uIGxvY2FsIGNvbXB1dGUsIGJ1dCB0aGV5IHJlcXVpcmUgYW4gQVBJIGtleSBhbmQgc2VuZCB5b3VyIG5vdGVzIHRvIHRoaXJkLXBhcnR5IHNlcnZlcnMgZm9yIHByb2Nlc3NpbmcuPC9saT5cXG48L3VsPlxcbjwlLSBzbWFydF9lbWJlZF9zZXR0aW5ncyAlPlxcbjxoMT5TbWFydCBDaGF0PC9oMT5cXG48JS0gc21hcnRfY2hhdF9zZXR0aW5ncyAlPlxcbjxoMz5TeXN0ZW0gUHJvbXB0czwvaDM+XFxuPGRpdiBjbGFzcz1cXFwic2V0dGluZy1jb21wb25lbnRcXFwiXFxuICBkYXRhLW5hbWU9XFxcIlN5c3RlbSBQcm9tcHRzIEZvbGRlclxcXCJcXG4gIGRhdGEtZGVzY3JpcHRpb249XFxcIkZvbGRlciB0byBzdG9yZSBzeXN0ZW0gcHJvbXB0cy4gQXZhaWxhYmxlIGluIGNoYXQgYnkgdHlwaW5nICdAJ1xcXCJcXG4gIGRhdGEtdHlwZT1cXFwidGV4dFxcXCJcXG4gIGRhdGEtc2V0dGluZz1cXFwic3lzdGVtX3Byb21wdHNfZm9sZGVyXFxcIlxcbiAgZGF0YS1wbGFjZWhvbGRlcj1cXFwiRW50ZXIgYSBmb2xkZXIgbmFtZVxcXCJcXG4gIGRhdGEtY2FsbGJhY2s9XFxcInVwZGF0ZV9zeXN0ZW1fcHJvbXB0c19mb2xkZXJcXFwiXFxuICBkYXRhLWJ1dHRvbj1cXFwiU2F2ZVxcXCJcXG4+PC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwic2V0dGluZy1jb21wb25lbnRcXFwiXFxuICBkYXRhLW5hbWU9XFxcIkRlZmF1bHQgTGFuZ3VhZ2VcXFwiXFxuICBkYXRhLXNldHRpbmc9XFxcImxhbmd1YWdlXFxcIlxcbiAgZGF0YS10eXBlPVxcXCJkcm9wZG93blxcXCJcXG4gIGRhdGEtZGVzY3JpcHRpb249XFxcIkRlZmF1bHQgbGFuZ3VhZ2UgdG8gdXNlIGZvciBTbWFydCBDaGF0LiBDaGFuZ2VzIHdoaWNoIHNlbGYtcmVmZXJlbnRpYWwgcHJvbm91bnMgd2lsbCB0cmlnZ2VyIGxvb2t1cCBvZiB5b3VyIG5vdGVzLlxcXCJcXG4gIGRhdGEtb3B0aW9uLTE9XFxcImVufEVuZ2xpc2hcXFwiXFxuICBkYXRhLW9wdGlvbi0yPVxcXCJlc3xTcGFuaXNoXFxcIlxcbiAgZGF0YS1vcHRpb24tMz1cXFwiZnJ8RnJlbmNoXFxcIlxcbiAgZGF0YS1vcHRpb24tND1cXFwiZGV8R2VybWFuXFxcIlxcbiAgZGF0YS1vcHRpb24tNT1cXFwiaXR8SXRhbGlhblxcXCJcXG4gIGRhdGEtY2FsbGJhY2s9XFxcInVwZGF0ZV9sYW5ndWFnZVxcXCJcXG4+PC9kaXY+XFxuPHNwYW4gaWQ9XFxcInNlbGYtcmVmZXJlbnRpYWwtcHJvbm91bnNcXFwiPkN1cnJlbnQ6IG15LCBJLCBtZSwgbWluZSwgb3VyLCBvdXJzLCB1cywgd2U8L3NwYW4+XFxuPGgxPkV4Y2x1c2lvbnM8L2gxPlxcbjxwIGlkPVxcXCJmaWxlLWNvdW50c1xcXCI+SW5jbHVkZWQgZmlsZXM6IDwlPSBpbmNsdWRlZF9maWxlcyAlPiAvIFRvdGFsIGZpbGVzOiA8JT0gdG90YWxfZmlsZXMgJT48L3A+XFxuPGRpdiBjbGFzcz1cXFwic2V0dGluZy1jb21wb25lbnRcXFwiXFxuICBkYXRhLW5hbWU9XFxcIkZpbGUgRXhjbHVzaW9uc1xcXCJcXG4gIGRhdGEtZGVzY3JpcHRpb249XFxcIidFeGNsdWRlZCBmaWxlJyBtYXRjaGVycyBzZXBhcmF0ZWQgYnkgYSBjb21tYS5cXFwiXFxuICBkYXRhLXR5cGU9XFxcInRleHRcXFwiXFxuICBkYXRhLXNldHRpbmc9XFxcImZpbGVfZXhjbHVzaW9uc1xcXCJcXG4gIGRhdGEtcGxhY2Vob2xkZXI9XFxcImRyYXdpbmdzLHByb21wdHMvbG9nc1xcXCJcXG4gIGRhdGEtY2FsbGJhY2s9XFxcInVwZGF0ZV9leGNsdXNpb25zXFxcIlxcbj48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJzZXR0aW5nLWNvbXBvbmVudFxcXCJcXG4gIGRhdGEtbmFtZT1cXFwiRm9sZGVyIEV4Y2x1c2lvbnNcXFwiXFxuICBkYXRhLWRlc2NyaXB0aW9uPVxcXCInRXhjbHVkZWQgZm9sZGVyJyBtYXRjaGVycyBzZXBhcmF0ZWQgYnkgYSBjb21tYS5cXFwiXFxuICBkYXRhLXR5cGU9XFxcInRleHRcXFwiXFxuICBkYXRhLXNldHRpbmc9XFxcImZvbGRlcl9leGNsdXNpb25zXFxcIlxcbiAgZGF0YS1wbGFjZWhvbGRlcj1cXFwiZHJhd2luZ3MscHJvbXB0cy9sb2dzXFxcIlxcbiAgZGF0YS1jYWxsYmFjaz1cXFwidXBkYXRlX2V4Y2x1c2lvbnNcXFwiXFxuPjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcInNldHRpbmctY29tcG9uZW50XFxcIlxcbiAgZGF0YS1uYW1lPVxcXCJFeGNsdWRlIGFsbCB0b3AtbGV2ZWwgZm9sZGVyc1xcXCJcXG4gIGRhdGEtZGVzY3JpcHRpb249XFxcIlNldCBmb2xkZXIgZXhjbHVzaW9ucyB0byBleGNsdWRlIGFsbCB0b3AtbGV2ZWwgZm9sZGVycy5cXFwiXFxuICBkYXRhLXR5cGU9XFxcImJ1dHRvblxcXCJcXG4gIGRhdGEtY2FsbGJhY2s9XFxcImV4Y2x1ZGVfYWxsX3RvcF9sZXZlbF9mb2xkZXJzXFxcIlxcbj48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJzZXR0aW5nLWNvbXBvbmVudFxcXCJcXG4gIGRhdGEtbmFtZT1cXFwiSGVhZGluZyBFeGNsdXNpb25zXFxcIlxcbiAgZGF0YS1kZXNjcmlwdGlvbj1cXFwiJ0V4Y2x1ZGVkIGhlYWRlcicgbWF0Y2hlcnMgc2VwYXJhdGVkIGJ5IGEgY29tbWEuIFdvcmtzIGZvciAnYmxvY2tzJyBvbmx5LlxcXCJcXG4gIGRhdGEtdHlwZT1cXFwidGV4dFxcXCJcXG4gIGRhdGEtc2V0dGluZz1cXFwiZXhjbHVkZWRfaGVhZGluZ3NcXFwiXFxuICBkYXRhLXBsYWNlaG9sZGVyPVxcXCJkcmF3aW5ncyxwcm9tcHRzL2xvZ3NcXFwiXFxuPjwvZGl2PlxcbjxoMz5EYXRhIE1hbmFnZW1lbnQ8L2gzPlxcbjxkaXYgY2xhc3M9XFxcInNldHRpbmctY29tcG9uZW50XFxcIlxcbiAgZGF0YS1uYW1lPVxcXCJSZWZyZXNoIE5vdGVzXFxcIlxcbiAgZGF0YS1kZXNjcmlwdGlvbj1cXFwiQ2xlYXIgbm90ZXMgZGF0YSBhbmQgcmVwcm9jZXNzLlxcXCJcXG4gIGRhdGEtdHlwZT1cXFwiYnV0dG9uXFxcIlxcbiAgZGF0YS1jYWxsYmFjaz1cXFwicmVmcmVzaF9ub3Rlc1xcXCJcXG4+PC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwic2V0dGluZy1jb21wb25lbnRcXFwiXFxuICBkYXRhLW5hbWU9XFxcIlNtYXJ0IENvbm5lY3Rpb25zIEZvbGRlclxcXCJcXG4gIGRhdGEtZGVzY3JpcHRpb249XFxcIkZvbGRlciB0byBzdG9yZSBTbWFydCBDb25uZWN0aW9ucyBkYXRhLlxcXCJcXG4gIGRhdGEtdHlwZT1cXFwidGV4dFxcXCJcXG4gIGRhdGEtc2V0dGluZz1cXFwic21hcnRfY29ubmVjdGlvbnNfZm9sZGVyXFxcIlxcbiAgZGF0YS1wbGFjZWhvbGRlcj1cXFwiRW50ZXIgYSBmb2xkZXIgbmFtZVxcXCJcXG4gIGRhdGEtY2FsbGJhY2s9XFxcInVwZGF0ZV9zbWFydF9jb25uZWN0aW9uc19mb2xkZXJcXFwiXFxuICBkYXRhLWJ1dHRvbj1cXFwicmVuYW1lXFxcIlxcbj48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJzZXR0aW5nLWNvbXBvbmVudFxcXCJcXG4gIGRhdGEtbmFtZT1cXFwiU21hcnQgQ2hhdCBIaXN0b3J5IEZvbGRlclxcXCJcXG4gIGRhdGEtZGVzY3JpcHRpb249XFxcIkZvbGRlciB0byBzdG9yZSBTbWFydCBDaGF0IGhpc3RvcnkuXFxcIlxcbiAgZGF0YS10eXBlPVxcXCJ0ZXh0XFxcIlxcbiAgZGF0YS1zZXR0aW5nPVxcXCJzbWFydF9jaGF0X2ZvbGRlclxcXCJcXG4gIGRhdGEtcGxhY2Vob2xkZXI9XFxcIkVudGVyIGEgZm9sZGVyIG5hbWVcXFwiXFxuICBkYXRhLWNhbGxiYWNrPVxcXCJ1cGRhdGVfc21hcnRfY2hhdF9mb2xkZXJcXFwiXFxuICBkYXRhLWJ1dHRvbj1cXFwicmVuYW1lXFxcIlxcbj48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJzZXR0aW5nLWNvbXBvbmVudFxcXCJcXG4gIGRhdGEtbmFtZT1cXFwiRW1iZWRkaW5nIGZpbGUgcGVyIG5vdGUgKEVYUEVSSU1FTlRBTClcXFwiXFxuICBkYXRhLWRlc2NyaXB0aW9uPVxcXCJTYXZlIGVtYmVkZGluZyBkYXRhIGluIGEgc2VwYXJhdGUgZmlsZSBwZXIgbm90ZS5cXFwiXFxuICBkYXRhLXR5cGU9XFxcInRvZ2dsZVxcXCJcXG4gIGRhdGEtc2V0dGluZz1cXFwiZW1iZWRkaW5nX2ZpbGVfcGVyX25vdGVcXFwiXFxuICBkYXRhLWNhbGxiYWNrPVxcXCJyZXN0YXJ0X3BsdWdpblxcXCJcXG4+PC9kaXY+XFxuPGgxPkZvcmNlIFJlZnJlc2g8L2gxPlxcbjxkaXYgY2xhc3M9XFxcInNldHRpbmctY29tcG9uZW50XFxcIlxcbiAgZGF0YS1uYW1lPVxcXCJmb3JjZV9yZWZyZXNoXFxcIlxcbiAgZGF0YS1kZXNjcmlwdGlvbj1cXFwiV0FSTklORzogRE8gTk9UIHVzZSB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UgYXJlIGRvaW5nISBUaGlzIHdpbGwgZGVsZXRlIGFsbCBvZiB5b3VyIGN1cnJlbnQgZW1iZWRkaW5ncyBmcm9tIE9wZW5BSSBhbmQgdHJpZ2dlciByZXByb2Nlc3Npbmcgb2YgeW91ciBlbnRpcmUgdmF1bHQhXFxcIlxcbiAgZGF0YS1jb25maXJtPVxcXCJBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gRm9yY2UgUmVmcmVzaD8gQnkgY2xpY2tpbmcgeWVzIHlvdSBjb25maXJtIHRoYXQgeW91IHVuZGVyc3RhbmQgdGhlIGNvbnNlcXVlbmNlcyBvZiB0aGlzIGFjdGlvbi5cXFwiXFxuICBkYXRhLXR5cGU9XFxcImJ1dHRvblxcXCJcXG4gIGRhdGEtY2FsbGJhY2s9XFxcImZvcmNlX3JlZnJlc2hcXFwiXFxuPjwvZGl2PlxcbjxoMT5NdXRlZCBOb3RpY2VzPC9oMT5cXG48JSBpZihtdXRlZF9ub3RpY2VzICYmIE9iamVjdC5rZXlzKG11dGVkX25vdGljZXMpLmxlbmd0aCkgeyAlPlxcbiAgPCUgZm9yKGNvbnN0IG5vdGljZSBpbiBtdXRlZF9ub3RpY2VzKSB7ICU+XFxuICAgIDxkaXYgY2xhc3M9XFxcInNldHRpbmctY29tcG9uZW50XFxcIlxcbiAgICAgIGRhdGEtbmFtZT1cXFwiPCU9IG5vdGljZSAlPlxcXCJcXG4gICAgICBkYXRhLXNldHRpbmc9XFxcIm11dGVkX25vdGljZXMuPCU9IG5vdGljZSAlPlxcXCJcXG4gICAgICBkYXRhLXR5cGU9XFxcImJ1dHRvblxcXCJcXG4gICAgICBkYXRhLWJ0bi10ZXh0PVxcXCJVbm11dGVcXFwiXFxuICAgICAgZGF0YS1jYWxsYmFjaz1cXFwidW5tdXRlX25vdGljZVxcXCJcXG4gICAgPjwvZGl2PlxcbiAgPCUgfSAlPlxcbjwlIH0gZWxzZSB7ICU+XFxuICA8cD5ObyBtdXRlZCBub3RpY2VzLjwvcD5cXG48JSB9ICU+XFxuPGhyPlxcbjxoNSBuYW1lPVxcXCJvZy1ncHRcXFwiIGlkPVxcXCJvZy1ncHRcXFwiPlRoZSBPcmlnaW5hbCBTbWFydCBDb25uZWN0aW9ucyBHUFQ8L2g1PlxcbjxkaXYgZGF0YS1jYWxsb3V0LW1ldGFkYXRhPVxcXCJcXFwiIGRhdGEtY2FsbG91dC1mb2xkPVxcXCJcXFwiIGRhdGEtY2FsbG91dD1cXFwid2FybmluZ1xcXCIgY2xhc3M9XFxcImNhbGxvdXRcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwiY2FsbG91dC10aXRsZVxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImNhbGxvdXQtaWNvblxcXCI+PHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCIyNFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIlxcbiAgICAgICAgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCJjdXJyZW50Q29sb3JcXFwiIHN0cm9rZS13aWR0aD1cXFwiMlxcXCIgc3Ryb2tlLWxpbmVjYXA9XFxcInJvdW5kXFxcIiBzdHJva2UtbGluZWpvaW49XFxcInJvdW5kXFxcIlxcbiAgICAgICAgY2xhc3M9XFxcInN2Zy1pY29uIGx1Y2lkZS1hbGVydC10cmlhbmdsZVxcXCI+XFxuICAgICAgICA8cGF0aCBkPVxcXCJtMjEuNzMgMTgtOC0xNGEyIDIgMCAwIDAtMy40OCAwbC04IDE0QTIgMiAwIDAgMCA0IDIxaDE2YTIgMiAwIDAgMCAxLjczLTNaXFxcIj48L3BhdGg+XFxuICAgICAgICA8cGF0aCBkPVxcXCJNMTIgOXY0XFxcIj48L3BhdGg+XFxuICAgICAgICA8cGF0aCBkPVxcXCJNMTIgMTdoLjAxXFxcIj48L3BhdGg+XFxuICAgICAgPC9zdmc+PC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcImNhbGxvdXQtdGl0bGUtaW5uZXJcXFwiPjxwPjxpPlRoaXMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uPC9pPiBQbGVhc2UgdXNlIHRoZSA8YSBocmVmPVxcXCJodHRwczovL2NoYXQub3BlbmFpLmNvbS9nL2ctOVhiMW1SSllsLXNtYXJ0LWNvbm5lY3Qtb2JzaWRpYW5cXFwiPlNtYXJ0IENvbm5lY3QgLSBPYnNpZGlhbjwvYT4gR1BUIGZvciBtb3JlIGFkdmFuY2VkIGZlYXR1cmVzIGxpa2UgY3JlYXRpbmcgbm90ZXMgYW5kIGVtYmVkZGluZyBzZWFyY2guPC9wPjwvZGl2PlxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuPHA+VGhpcyBHUFQgY2FuIGJyb3dzZXIgZm9sZGVycyBhbmQgcmVhZCBub3Rlcy4gSXQgcmVxdWlyZXMgbWFudWFsbHkgc3luY2hyb25pemF0aW9uIGZvciB5b3VyIG5vdGVzIHRvIGJlIGFjY2Vzc2libGUgYnkgQ2hhdEdQVC48L3A+XFxuPGRpdiBjbGFzcz1cXFwic2V0dGluZy1jb21wb25lbnRcXFwiXFxuICBkYXRhLW5hbWU9XFxcIkNoYXRHUFQgSW50ZWdyYXRpb24gKHN1cHBvcnRlci1vbmx5KVxcXCJcXG4gIGRhdGEtYnRuLXRleHQ9XFxcIlN5bmMgTm90ZXNcXFwiXFxuICBkYXRhLWRlc2NyaXB0aW9uPVxcXCJTeW5jIHlvdXIgbm90ZXMgZm9yIHVzZSB3aXRoIHRoZSBTbWFydCBDb25uZWN0aW9ucyBHUFQgYW5kIENoYXRHUFQgUGx1Z2luLiBSZXNwZWN0cyB5b3VyIGZpbGUgYW5kIGZvbGRlciBleGNsdXNpb24gc2V0dGluZ3MuIFJlcXVpcmVkIHRvIHVzZSB0aGUgU21hcnQgQ29ubmVjdGlvbnMgR1BULlxcXCJcXG4gIGRhdGEtdHlwZT1cXFwiYnV0dG9uXFxcIlxcbiAgZGF0YS1jYWxsYmFjaz1cXFwic3luY19mb3JfY2hhdGdwdFxcXCJcXG4+PC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwic2V0dGluZy1jb21wb25lbnRcXFwiXFxuICBkYXRhLW5hbWU9XFxcIk9wZW4gU21hcnQgQ29ubmVjdGlvbnMgR1BUXFxcIlxcbiAgZGF0YS1idG4tdGV4dD1cXFwiT3BlblxcXCJcXG4gIGRhdGEtZGVzY3JpcHRpb249J0NoYXQgd2l0aCB5b3VyIG5vdGVzIGluIENoYXRHUFQuIFJlcXVpcmVzIGEgQ2hhdEdQVCBQbHVzIGFjY291bnQuJ1xcbiAgZGF0YS10eXBlPVxcXCJidXR0b25cXFwiXFxuICBkYXRhLWhyZWY9XFxcImh0dHBzOi8vY2hhdC5vcGVuYWkuY29tL2cvZy1TbEREcDA3Ym0tc21hcnQtY29ubmVjdGlvbnMtZm9yLW9ic2lkaWFuXFxcIlxcbj48L2Rpdj5cXG48aHI+XFxuPCUgaWYodGhpcy5lbnYucGx1Z2luLkVBUkxZX0FDQ0VTUyl7ICU+XFxuPGRpdiBjbGFzcz1cXFwic2V0dGluZy1jb21wb25lbnRcXFwiXFxuICBkYXRhLW5hbWU9XFxcIlJldmVydCB0byBTdGFibGUgUmVsZWFzZVxcXCJcXG4gIGRhdGEtYnRuLXRleHQ9XFxcIlJldmVydFxcXCJcXG4gIGRhdGEtZGVzY3JpcHRpb249J1JldmVydCB0byB0aGUgc3RhYmxlIHJlbGVhc2Ugb2YgU21hcnQgQ29ubmVjdGlvbnMuIFJlcXVpcmVzIFxcXCJDaGVjayBmb3IgVXBkYXRlc1xcXCIgYW5kIHRoZW4gXFxcIlVwZGF0ZSBQbHVnaW5cXFwiIHRvIGNvbXBsZXRlIHRoZSBwcm9jZXNzLidcXG4gIGRhdGEtdHlwZT1cXFwiYnV0dG9uXFxcIlxcbiAgZGF0YS1jYWxsYmFjaz1cXFwicmV2ZXJ0X3RvX3N0YWJsZV9yZWxlYXNlXFxcIlxcbj48L2Rpdj5cXG48JSB9ICU+XFxuXCJcbn0iLCAiKGZ1bmN0aW9uKGYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIiYmdHlwZW9mIG1vZHVsZSE9PVwidW5kZWZpbmVkXCIpe21vZHVsZS5leHBvcnRzPWYoKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXSxmKX1lbHNle3ZhciBnO2lmKHR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiKXtnPXdpbmRvd31lbHNlIGlmKHR5cGVvZiBnbG9iYWwhPT1cInVuZGVmaW5lZFwiKXtnPWdsb2JhbH1lbHNlIGlmKHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIil7Zz1zZWxmfWVsc2V7Zz10aGlzfWcuZWpzPWYoKX19KShmdW5jdGlvbigpe3ZhciBkZWZpbmUsbW9kdWxlLGV4cG9ydHM7cmV0dXJuIGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSgpKHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcInVzZSBzdHJpY3RcIjt2YXIgZnM9cmVxdWlyZShcImZzXCIpO3ZhciBwYXRoPXJlcXVpcmUoXCJwYXRoXCIpO3ZhciB1dGlscz1yZXF1aXJlKFwiLi91dGlsc1wiKTt2YXIgc2NvcGVPcHRpb25XYXJuZWQ9ZmFsc2U7dmFyIF9WRVJTSU9OX1NUUklORz1yZXF1aXJlKFwiLi4vcGFja2FnZS5qc29uXCIpLnZlcnNpb247dmFyIF9ERUZBVUxUX09QRU5fREVMSU1JVEVSPVwiPFwiO3ZhciBfREVGQVVMVF9DTE9TRV9ERUxJTUlURVI9XCI+XCI7dmFyIF9ERUZBVUxUX0RFTElNSVRFUj1cIiVcIjt2YXIgX0RFRkFVTFRfTE9DQUxTX05BTUU9XCJsb2NhbHNcIjt2YXIgX05BTUU9XCJlanNcIjt2YXIgX1JFR0VYX1NUUklORz1cIig8JSV8JSU+fDwlPXw8JS18PCVffDwlI3w8JXwlPnwtJT58XyU+KVwiO3ZhciBfT1BUU19QQVNTQUJMRV9XSVRIX0RBVEE9W1wiZGVsaW1pdGVyXCIsXCJzY29wZVwiLFwiY29udGV4dFwiLFwiZGVidWdcIixcImNvbXBpbGVEZWJ1Z1wiLFwiY2xpZW50XCIsXCJfd2l0aFwiLFwicm1XaGl0ZXNwYWNlXCIsXCJzdHJpY3RcIixcImZpbGVuYW1lXCIsXCJhc3luY1wiXTt2YXIgX09QVFNfUEFTU0FCTEVfV0lUSF9EQVRBX0VYUFJFU1M9X09QVFNfUEFTU0FCTEVfV0lUSF9EQVRBLmNvbmNhdChcImNhY2hlXCIpO3ZhciBfQk9NPS9eXFx1RkVGRi87dmFyIF9KU19JREVOVElGSUVSPS9eW2EtekEtWl8kXVswLTlhLXpBLVpfJF0qJC87ZXhwb3J0cy5jYWNoZT11dGlscy5jYWNoZTtleHBvcnRzLmZpbGVMb2FkZXI9ZnMucmVhZEZpbGVTeW5jO2V4cG9ydHMubG9jYWxzTmFtZT1fREVGQVVMVF9MT0NBTFNfTkFNRTtleHBvcnRzLnByb21pc2VJbXBsPW5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzO1wiKSgpLlByb21pc2U7ZXhwb3J0cy5yZXNvbHZlSW5jbHVkZT1mdW5jdGlvbihuYW1lLGZpbGVuYW1lLGlzRGlyKXt2YXIgZGlybmFtZT1wYXRoLmRpcm5hbWU7dmFyIGV4dG5hbWU9cGF0aC5leHRuYW1lO3ZhciByZXNvbHZlPXBhdGgucmVzb2x2ZTt2YXIgaW5jbHVkZVBhdGg9cmVzb2x2ZShpc0Rpcj9maWxlbmFtZTpkaXJuYW1lKGZpbGVuYW1lKSxuYW1lKTt2YXIgZXh0PWV4dG5hbWUobmFtZSk7aWYoIWV4dCl7aW5jbHVkZVBhdGgrPVwiLmVqc1wifXJldHVybiBpbmNsdWRlUGF0aH07ZnVuY3Rpb24gcmVzb2x2ZVBhdGhzKG5hbWUscGF0aHMpe3ZhciBmaWxlUGF0aDtpZihwYXRocy5zb21lKGZ1bmN0aW9uKHYpe2ZpbGVQYXRoPWV4cG9ydHMucmVzb2x2ZUluY2x1ZGUobmFtZSx2LHRydWUpO3JldHVybiBmcy5leGlzdHNTeW5jKGZpbGVQYXRoKX0pKXtyZXR1cm4gZmlsZVBhdGh9fWZ1bmN0aW9uIGdldEluY2x1ZGVQYXRoKHBhdGgsb3B0aW9ucyl7dmFyIGluY2x1ZGVQYXRoO3ZhciBmaWxlUGF0aDt2YXIgdmlld3M9b3B0aW9ucy52aWV3czt2YXIgbWF0Y2g9L15bQS1aYS16XSs6XFxcXHxeXFwvLy5leGVjKHBhdGgpO2lmKG1hdGNoJiZtYXRjaC5sZW5ndGgpe3BhdGg9cGF0aC5yZXBsYWNlKC9eXFwvKi8sXCJcIik7aWYoQXJyYXkuaXNBcnJheShvcHRpb25zLnJvb3QpKXtpbmNsdWRlUGF0aD1yZXNvbHZlUGF0aHMocGF0aCxvcHRpb25zLnJvb3QpfWVsc2V7aW5jbHVkZVBhdGg9ZXhwb3J0cy5yZXNvbHZlSW5jbHVkZShwYXRoLG9wdGlvbnMucm9vdHx8XCIvXCIsdHJ1ZSl9fWVsc2V7aWYob3B0aW9ucy5maWxlbmFtZSl7ZmlsZVBhdGg9ZXhwb3J0cy5yZXNvbHZlSW5jbHVkZShwYXRoLG9wdGlvbnMuZmlsZW5hbWUpO2lmKGZzLmV4aXN0c1N5bmMoZmlsZVBhdGgpKXtpbmNsdWRlUGF0aD1maWxlUGF0aH19aWYoIWluY2x1ZGVQYXRoJiZBcnJheS5pc0FycmF5KHZpZXdzKSl7aW5jbHVkZVBhdGg9cmVzb2x2ZVBhdGhzKHBhdGgsdmlld3MpfWlmKCFpbmNsdWRlUGF0aCYmdHlwZW9mIG9wdGlvbnMuaW5jbHVkZXIhPT1cImZ1bmN0aW9uXCIpe3Rocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgdGhlIGluY2x1ZGUgZmlsZSBcIicrb3B0aW9ucy5lc2NhcGVGdW5jdGlvbihwYXRoKSsnXCInKX19cmV0dXJuIGluY2x1ZGVQYXRofWZ1bmN0aW9uIGhhbmRsZUNhY2hlKG9wdGlvbnMsdGVtcGxhdGUpe3ZhciBmdW5jO3ZhciBmaWxlbmFtZT1vcHRpb25zLmZpbGVuYW1lO3ZhciBoYXNUZW1wbGF0ZT1hcmd1bWVudHMubGVuZ3RoPjE7aWYob3B0aW9ucy5jYWNoZSl7aWYoIWZpbGVuYW1lKXt0aHJvdyBuZXcgRXJyb3IoXCJjYWNoZSBvcHRpb24gcmVxdWlyZXMgYSBmaWxlbmFtZVwiKX1mdW5jPWV4cG9ydHMuY2FjaGUuZ2V0KGZpbGVuYW1lKTtpZihmdW5jKXtyZXR1cm4gZnVuY31pZighaGFzVGVtcGxhdGUpe3RlbXBsYXRlPWZpbGVMb2FkZXIoZmlsZW5hbWUpLnRvU3RyaW5nKCkucmVwbGFjZShfQk9NLFwiXCIpfX1lbHNlIGlmKCFoYXNUZW1wbGF0ZSl7aWYoIWZpbGVuYW1lKXt0aHJvdyBuZXcgRXJyb3IoXCJJbnRlcm5hbCBFSlMgZXJyb3I6IG5vIGZpbGUgbmFtZSBvciB0ZW1wbGF0ZSBcIitcInByb3ZpZGVkXCIpfXRlbXBsYXRlPWZpbGVMb2FkZXIoZmlsZW5hbWUpLnRvU3RyaW5nKCkucmVwbGFjZShfQk9NLFwiXCIpfWZ1bmM9ZXhwb3J0cy5jb21waWxlKHRlbXBsYXRlLG9wdGlvbnMpO2lmKG9wdGlvbnMuY2FjaGUpe2V4cG9ydHMuY2FjaGUuc2V0KGZpbGVuYW1lLGZ1bmMpfXJldHVybiBmdW5jfWZ1bmN0aW9uIHRyeUhhbmRsZUNhY2hlKG9wdGlvbnMsZGF0YSxjYil7dmFyIHJlc3VsdDtpZighY2Ipe2lmKHR5cGVvZiBleHBvcnRzLnByb21pc2VJbXBsPT1cImZ1bmN0aW9uXCIpe3JldHVybiBuZXcgZXhwb3J0cy5wcm9taXNlSW1wbChmdW5jdGlvbihyZXNvbHZlLHJlamVjdCl7dHJ5e3Jlc3VsdD1oYW5kbGVDYWNoZShvcHRpb25zKShkYXRhKTtyZXNvbHZlKHJlc3VsdCl9Y2F0Y2goZXJyKXtyZWplY3QoZXJyKX19KX1lbHNle3Rocm93IG5ldyBFcnJvcihcIlBsZWFzZSBwcm92aWRlIGEgY2FsbGJhY2sgZnVuY3Rpb25cIil9fWVsc2V7dHJ5e3Jlc3VsdD1oYW5kbGVDYWNoZShvcHRpb25zKShkYXRhKX1jYXRjaChlcnIpe3JldHVybiBjYihlcnIpfWNiKG51bGwscmVzdWx0KX19ZnVuY3Rpb24gZmlsZUxvYWRlcihmaWxlUGF0aCl7cmV0dXJuIGV4cG9ydHMuZmlsZUxvYWRlcihmaWxlUGF0aCl9ZnVuY3Rpb24gaW5jbHVkZUZpbGUocGF0aCxvcHRpb25zKXt2YXIgb3B0cz11dGlscy5zaGFsbG93Q29weSh1dGlscy5jcmVhdGVOdWxsUHJvdG9PYmpXaGVyZVBvc3NpYmxlKCksb3B0aW9ucyk7b3B0cy5maWxlbmFtZT1nZXRJbmNsdWRlUGF0aChwYXRoLG9wdHMpO2lmKHR5cGVvZiBvcHRpb25zLmluY2x1ZGVyPT09XCJmdW5jdGlvblwiKXt2YXIgaW5jbHVkZXJSZXN1bHQ9b3B0aW9ucy5pbmNsdWRlcihwYXRoLG9wdHMuZmlsZW5hbWUpO2lmKGluY2x1ZGVyUmVzdWx0KXtpZihpbmNsdWRlclJlc3VsdC5maWxlbmFtZSl7b3B0cy5maWxlbmFtZT1pbmNsdWRlclJlc3VsdC5maWxlbmFtZX1pZihpbmNsdWRlclJlc3VsdC50ZW1wbGF0ZSl7cmV0dXJuIGhhbmRsZUNhY2hlKG9wdHMsaW5jbHVkZXJSZXN1bHQudGVtcGxhdGUpfX19cmV0dXJuIGhhbmRsZUNhY2hlKG9wdHMpfWZ1bmN0aW9uIHJldGhyb3coZXJyLHN0cixmbG5tLGxpbmVubyxlc2Mpe3ZhciBsaW5lcz1zdHIuc3BsaXQoXCJcXG5cIik7dmFyIHN0YXJ0PU1hdGgubWF4KGxpbmVuby0zLDApO3ZhciBlbmQ9TWF0aC5taW4obGluZXMubGVuZ3RoLGxpbmVubyszKTt2YXIgZmlsZW5hbWU9ZXNjKGZsbm0pO3ZhciBjb250ZXh0PWxpbmVzLnNsaWNlKHN0YXJ0LGVuZCkubWFwKGZ1bmN0aW9uKGxpbmUsaSl7dmFyIGN1cnI9aStzdGFydCsxO3JldHVybihjdXJyPT1saW5lbm8/XCIgPj4gXCI6XCIgICAgXCIpK2N1cnIrXCJ8IFwiK2xpbmV9KS5qb2luKFwiXFxuXCIpO2Vyci5wYXRoPWZpbGVuYW1lO2Vyci5tZXNzYWdlPShmaWxlbmFtZXx8XCJlanNcIikrXCI6XCIrbGluZW5vK1wiXFxuXCIrY29udGV4dCtcIlxcblxcblwiK2Vyci5tZXNzYWdlO3Rocm93IGVycn1mdW5jdGlvbiBzdHJpcFNlbWkoc3RyKXtyZXR1cm4gc3RyLnJlcGxhY2UoLzsoXFxzKiQpLyxcIiQxXCIpfWV4cG9ydHMuY29tcGlsZT1mdW5jdGlvbiBjb21waWxlKHRlbXBsYXRlLG9wdHMpe3ZhciB0ZW1wbDtpZihvcHRzJiZvcHRzLnNjb3BlKXtpZighc2NvcGVPcHRpb25XYXJuZWQpe2NvbnNvbGUud2FybihcImBzY29wZWAgb3B0aW9uIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBFSlMgM1wiKTtzY29wZU9wdGlvbldhcm5lZD10cnVlfWlmKCFvcHRzLmNvbnRleHQpe29wdHMuY29udGV4dD1vcHRzLnNjb3BlfWRlbGV0ZSBvcHRzLnNjb3BlfXRlbXBsPW5ldyBUZW1wbGF0ZSh0ZW1wbGF0ZSxvcHRzKTtyZXR1cm4gdGVtcGwuY29tcGlsZSgpfTtleHBvcnRzLnJlbmRlcj1mdW5jdGlvbih0ZW1wbGF0ZSxkLG8pe3ZhciBkYXRhPWR8fHV0aWxzLmNyZWF0ZU51bGxQcm90b09ialdoZXJlUG9zc2libGUoKTt2YXIgb3B0cz1vfHx1dGlscy5jcmVhdGVOdWxsUHJvdG9PYmpXaGVyZVBvc3NpYmxlKCk7aWYoYXJndW1lbnRzLmxlbmd0aD09Mil7dXRpbHMuc2hhbGxvd0NvcHlGcm9tTGlzdChvcHRzLGRhdGEsX09QVFNfUEFTU0FCTEVfV0lUSF9EQVRBKX1yZXR1cm4gaGFuZGxlQ2FjaGUob3B0cyx0ZW1wbGF0ZSkoZGF0YSl9O2V4cG9ydHMucmVuZGVyRmlsZT1mdW5jdGlvbigpe3ZhciBhcmdzPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7dmFyIGZpbGVuYW1lPWFyZ3Muc2hpZnQoKTt2YXIgY2I7dmFyIG9wdHM9e2ZpbGVuYW1lOmZpbGVuYW1lfTt2YXIgZGF0YTt2YXIgdmlld09wdHM7aWYodHlwZW9mIGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoLTFdPT1cImZ1bmN0aW9uXCIpe2NiPWFyZ3MucG9wKCl9aWYoYXJncy5sZW5ndGgpe2RhdGE9YXJncy5zaGlmdCgpO2lmKGFyZ3MubGVuZ3RoKXt1dGlscy5zaGFsbG93Q29weShvcHRzLGFyZ3MucG9wKCkpfWVsc2V7aWYoZGF0YS5zZXR0aW5ncyl7aWYoZGF0YS5zZXR0aW5ncy52aWV3cyl7b3B0cy52aWV3cz1kYXRhLnNldHRpbmdzLnZpZXdzfWlmKGRhdGEuc2V0dGluZ3NbXCJ2aWV3IGNhY2hlXCJdKXtvcHRzLmNhY2hlPXRydWV9dmlld09wdHM9ZGF0YS5zZXR0aW5nc1tcInZpZXcgb3B0aW9uc1wiXTtpZih2aWV3T3B0cyl7dXRpbHMuc2hhbGxvd0NvcHkob3B0cyx2aWV3T3B0cyl9fXV0aWxzLnNoYWxsb3dDb3B5RnJvbUxpc3Qob3B0cyxkYXRhLF9PUFRTX1BBU1NBQkxFX1dJVEhfREFUQV9FWFBSRVNTKX1vcHRzLmZpbGVuYW1lPWZpbGVuYW1lfWVsc2V7ZGF0YT11dGlscy5jcmVhdGVOdWxsUHJvdG9PYmpXaGVyZVBvc3NpYmxlKCl9cmV0dXJuIHRyeUhhbmRsZUNhY2hlKG9wdHMsZGF0YSxjYil9O2V4cG9ydHMuVGVtcGxhdGU9VGVtcGxhdGU7ZXhwb3J0cy5jbGVhckNhY2hlPWZ1bmN0aW9uKCl7ZXhwb3J0cy5jYWNoZS5yZXNldCgpfTtmdW5jdGlvbiBUZW1wbGF0ZSh0ZXh0LG9wdHMpe29wdHM9b3B0c3x8dXRpbHMuY3JlYXRlTnVsbFByb3RvT2JqV2hlcmVQb3NzaWJsZSgpO3ZhciBvcHRpb25zPXV0aWxzLmNyZWF0ZU51bGxQcm90b09ialdoZXJlUG9zc2libGUoKTt0aGlzLnRlbXBsYXRlVGV4dD10ZXh0O3RoaXMubW9kZT1udWxsO3RoaXMudHJ1bmNhdGU9ZmFsc2U7dGhpcy5jdXJyZW50TGluZT0xO3RoaXMuc291cmNlPVwiXCI7b3B0aW9ucy5jbGllbnQ9b3B0cy5jbGllbnR8fGZhbHNlO29wdGlvbnMuZXNjYXBlRnVuY3Rpb249b3B0cy5lc2NhcGV8fG9wdHMuZXNjYXBlRnVuY3Rpb258fHV0aWxzLmVzY2FwZVhNTDtvcHRpb25zLmNvbXBpbGVEZWJ1Zz1vcHRzLmNvbXBpbGVEZWJ1ZyE9PWZhbHNlO29wdGlvbnMuZGVidWc9ISFvcHRzLmRlYnVnO29wdGlvbnMuZmlsZW5hbWU9b3B0cy5maWxlbmFtZTtvcHRpb25zLm9wZW5EZWxpbWl0ZXI9b3B0cy5vcGVuRGVsaW1pdGVyfHxleHBvcnRzLm9wZW5EZWxpbWl0ZXJ8fF9ERUZBVUxUX09QRU5fREVMSU1JVEVSO29wdGlvbnMuY2xvc2VEZWxpbWl0ZXI9b3B0cy5jbG9zZURlbGltaXRlcnx8ZXhwb3J0cy5jbG9zZURlbGltaXRlcnx8X0RFRkFVTFRfQ0xPU0VfREVMSU1JVEVSO29wdGlvbnMuZGVsaW1pdGVyPW9wdHMuZGVsaW1pdGVyfHxleHBvcnRzLmRlbGltaXRlcnx8X0RFRkFVTFRfREVMSU1JVEVSO29wdGlvbnMuc3RyaWN0PW9wdHMuc3RyaWN0fHxmYWxzZTtvcHRpb25zLmNvbnRleHQ9b3B0cy5jb250ZXh0O29wdGlvbnMuY2FjaGU9b3B0cy5jYWNoZXx8ZmFsc2U7b3B0aW9ucy5ybVdoaXRlc3BhY2U9b3B0cy5ybVdoaXRlc3BhY2U7b3B0aW9ucy5yb290PW9wdHMucm9vdDtvcHRpb25zLmluY2x1ZGVyPW9wdHMuaW5jbHVkZXI7b3B0aW9ucy5vdXRwdXRGdW5jdGlvbk5hbWU9b3B0cy5vdXRwdXRGdW5jdGlvbk5hbWU7b3B0aW9ucy5sb2NhbHNOYW1lPW9wdHMubG9jYWxzTmFtZXx8ZXhwb3J0cy5sb2NhbHNOYW1lfHxfREVGQVVMVF9MT0NBTFNfTkFNRTtvcHRpb25zLnZpZXdzPW9wdHMudmlld3M7b3B0aW9ucy5hc3luYz1vcHRzLmFzeW5jO29wdGlvbnMuZGVzdHJ1Y3R1cmVkTG9jYWxzPW9wdHMuZGVzdHJ1Y3R1cmVkTG9jYWxzO29wdGlvbnMubGVnYWN5SW5jbHVkZT10eXBlb2Ygb3B0cy5sZWdhY3lJbmNsdWRlIT1cInVuZGVmaW5lZFwiPyEhb3B0cy5sZWdhY3lJbmNsdWRlOnRydWU7aWYob3B0aW9ucy5zdHJpY3Qpe29wdGlvbnMuX3dpdGg9ZmFsc2V9ZWxzZXtvcHRpb25zLl93aXRoPXR5cGVvZiBvcHRzLl93aXRoIT1cInVuZGVmaW5lZFwiP29wdHMuX3dpdGg6dHJ1ZX10aGlzLm9wdHM9b3B0aW9uczt0aGlzLnJlZ2V4PXRoaXMuY3JlYXRlUmVnZXgoKX1UZW1wbGF0ZS5tb2Rlcz17RVZBTDpcImV2YWxcIixFU0NBUEVEOlwiZXNjYXBlZFwiLFJBVzpcInJhd1wiLENPTU1FTlQ6XCJjb21tZW50XCIsTElURVJBTDpcImxpdGVyYWxcIn07VGVtcGxhdGUucHJvdG90eXBlPXtjcmVhdGVSZWdleDpmdW5jdGlvbigpe3ZhciBzdHI9X1JFR0VYX1NUUklORzt2YXIgZGVsaW09dXRpbHMuZXNjYXBlUmVnRXhwQ2hhcnModGhpcy5vcHRzLmRlbGltaXRlcik7dmFyIG9wZW49dXRpbHMuZXNjYXBlUmVnRXhwQ2hhcnModGhpcy5vcHRzLm9wZW5EZWxpbWl0ZXIpO3ZhciBjbG9zZT11dGlscy5lc2NhcGVSZWdFeHBDaGFycyh0aGlzLm9wdHMuY2xvc2VEZWxpbWl0ZXIpO3N0cj1zdHIucmVwbGFjZSgvJS9nLGRlbGltKS5yZXBsYWNlKC88L2csb3BlbikucmVwbGFjZSgvPi9nLGNsb3NlKTtyZXR1cm4gbmV3IFJlZ0V4cChzdHIpfSxjb21waWxlOmZ1bmN0aW9uKCl7dmFyIHNyYzt2YXIgZm47dmFyIG9wdHM9dGhpcy5vcHRzO3ZhciBwcmVwZW5kZWQ9XCJcIjt2YXIgYXBwZW5kZWQ9XCJcIjt2YXIgZXNjYXBlRm49b3B0cy5lc2NhcGVGdW5jdGlvbjt2YXIgY3Rvcjt2YXIgc2FuaXRpemVkRmlsZW5hbWU9b3B0cy5maWxlbmFtZT9KU09OLnN0cmluZ2lmeShvcHRzLmZpbGVuYW1lKTpcInVuZGVmaW5lZFwiO2lmKCF0aGlzLnNvdXJjZSl7dGhpcy5nZW5lcmF0ZVNvdXJjZSgpO3ByZXBlbmRlZCs9JyAgdmFyIF9fb3V0cHV0ID0gXCJcIjtcXG4nK1wiICBmdW5jdGlvbiBfX2FwcGVuZChzKSB7IGlmIChzICE9PSB1bmRlZmluZWQgJiYgcyAhPT0gbnVsbCkgX19vdXRwdXQgKz0gcyB9XFxuXCI7aWYob3B0cy5vdXRwdXRGdW5jdGlvbk5hbWUpe2lmKCFfSlNfSURFTlRJRklFUi50ZXN0KG9wdHMub3V0cHV0RnVuY3Rpb25OYW1lKSl7dGhyb3cgbmV3IEVycm9yKFwib3V0cHV0RnVuY3Rpb25OYW1lIGlzIG5vdCBhIHZhbGlkIEpTIGlkZW50aWZpZXIuXCIpfXByZXBlbmRlZCs9XCIgIHZhciBcIitvcHRzLm91dHB1dEZ1bmN0aW9uTmFtZStcIiA9IF9fYXBwZW5kO1wiK1wiXFxuXCJ9aWYob3B0cy5sb2NhbHNOYW1lJiYhX0pTX0lERU5USUZJRVIudGVzdChvcHRzLmxvY2Fsc05hbWUpKXt0aHJvdyBuZXcgRXJyb3IoXCJsb2NhbHNOYW1lIGlzIG5vdCBhIHZhbGlkIEpTIGlkZW50aWZpZXIuXCIpfWlmKG9wdHMuZGVzdHJ1Y3R1cmVkTG9jYWxzJiZvcHRzLmRlc3RydWN0dXJlZExvY2Fscy5sZW5ndGgpe3ZhciBkZXN0cnVjdHVyaW5nPVwiICB2YXIgX19sb2NhbHMgPSAoXCIrb3B0cy5sb2NhbHNOYW1lK1wiIHx8IHt9KSxcXG5cIjtmb3IodmFyIGk9MDtpPG9wdHMuZGVzdHJ1Y3R1cmVkTG9jYWxzLmxlbmd0aDtpKyspe3ZhciBuYW1lPW9wdHMuZGVzdHJ1Y3R1cmVkTG9jYWxzW2ldO2lmKCFfSlNfSURFTlRJRklFUi50ZXN0KG5hbWUpKXt0aHJvdyBuZXcgRXJyb3IoXCJkZXN0cnVjdHVyZWRMb2NhbHNbXCIraStcIl0gaXMgbm90IGEgdmFsaWQgSlMgaWRlbnRpZmllci5cIil9aWYoaT4wKXtkZXN0cnVjdHVyaW5nKz1cIixcXG4gIFwifWRlc3RydWN0dXJpbmcrPW5hbWUrXCIgPSBfX2xvY2Fscy5cIituYW1lfXByZXBlbmRlZCs9ZGVzdHJ1Y3R1cmluZytcIjtcXG5cIn1pZihvcHRzLl93aXRoIT09ZmFsc2Upe3ByZXBlbmRlZCs9XCIgIHdpdGggKFwiK29wdHMubG9jYWxzTmFtZStcIiB8fCB7fSkge1wiK1wiXFxuXCI7YXBwZW5kZWQrPVwiICB9XCIrXCJcXG5cIn1hcHBlbmRlZCs9XCIgIHJldHVybiBfX291dHB1dDtcIitcIlxcblwiO3RoaXMuc291cmNlPXByZXBlbmRlZCt0aGlzLnNvdXJjZSthcHBlbmRlZH1pZihvcHRzLmNvbXBpbGVEZWJ1Zyl7c3JjPVwidmFyIF9fbGluZSA9IDFcIitcIlxcblwiK1wiICAsIF9fbGluZXMgPSBcIitKU09OLnN0cmluZ2lmeSh0aGlzLnRlbXBsYXRlVGV4dCkrXCJcXG5cIitcIiAgLCBfX2ZpbGVuYW1lID0gXCIrc2FuaXRpemVkRmlsZW5hbWUrXCI7XCIrXCJcXG5cIitcInRyeSB7XCIrXCJcXG5cIit0aGlzLnNvdXJjZStcIn0gY2F0Y2ggKGUpIHtcIitcIlxcblwiK1wiICByZXRocm93KGUsIF9fbGluZXMsIF9fZmlsZW5hbWUsIF9fbGluZSwgZXNjYXBlRm4pO1wiK1wiXFxuXCIrXCJ9XCIrXCJcXG5cIn1lbHNle3NyYz10aGlzLnNvdXJjZX1pZihvcHRzLmNsaWVudCl7c3JjPVwiZXNjYXBlRm4gPSBlc2NhcGVGbiB8fCBcIitlc2NhcGVGbi50b1N0cmluZygpK1wiO1wiK1wiXFxuXCIrc3JjO2lmKG9wdHMuY29tcGlsZURlYnVnKXtzcmM9XCJyZXRocm93ID0gcmV0aHJvdyB8fCBcIityZXRocm93LnRvU3RyaW5nKCkrXCI7XCIrXCJcXG5cIitzcmN9fWlmKG9wdHMuc3RyaWN0KXtzcmM9J1widXNlIHN0cmljdFwiO1xcbicrc3JjfWlmKG9wdHMuZGVidWcpe2NvbnNvbGUubG9nKHNyYyl9aWYob3B0cy5jb21waWxlRGVidWcmJm9wdHMuZmlsZW5hbWUpe3NyYz1zcmMrXCJcXG5cIitcIi8vIyBzb3VyY2VVUkw9XCIrc2FuaXRpemVkRmlsZW5hbWUrXCJcXG5cIn10cnl7aWYob3B0cy5hc3luYyl7dHJ5e2N0b3I9bmV3IEZ1bmN0aW9uKFwicmV0dXJuIChhc3luYyBmdW5jdGlvbigpe30pLmNvbnN0cnVjdG9yO1wiKSgpfWNhdGNoKGUpe2lmKGUgaW5zdGFuY2VvZiBTeW50YXhFcnJvcil7dGhyb3cgbmV3IEVycm9yKFwiVGhpcyBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IGFzeW5jL2F3YWl0XCIpfWVsc2V7dGhyb3cgZX19fWVsc2V7Y3Rvcj1GdW5jdGlvbn1mbj1uZXcgY3RvcihvcHRzLmxvY2Fsc05hbWUrXCIsIGVzY2FwZUZuLCBpbmNsdWRlLCByZXRocm93XCIsc3JjKX1jYXRjaChlKXtpZihlIGluc3RhbmNlb2YgU3ludGF4RXJyb3Ipe2lmKG9wdHMuZmlsZW5hbWUpe2UubWVzc2FnZSs9XCIgaW4gXCIrb3B0cy5maWxlbmFtZX1lLm1lc3NhZ2UrPVwiIHdoaWxlIGNvbXBpbGluZyBlanNcXG5cXG5cIjtlLm1lc3NhZ2UrPVwiSWYgdGhlIGFib3ZlIGVycm9yIGlzIG5vdCBoZWxwZnVsLCB5b3UgbWF5IHdhbnQgdG8gdHJ5IEVKUy1MaW50OlxcblwiO2UubWVzc2FnZSs9XCJodHRwczovL2dpdGh1Yi5jb20vUnlhblppbS9FSlMtTGludFwiO2lmKCFvcHRzLmFzeW5jKXtlLm1lc3NhZ2UrPVwiXFxuXCI7ZS5tZXNzYWdlKz1cIk9yLCBpZiB5b3UgbWVhbnQgdG8gY3JlYXRlIGFuIGFzeW5jIGZ1bmN0aW9uLCBwYXNzIGBhc3luYzogdHJ1ZWAgYXMgYW4gb3B0aW9uLlwifX10aHJvdyBlfXZhciByZXR1cm5lZEZuPW9wdHMuY2xpZW50P2ZuOmZ1bmN0aW9uIGFub255bW91cyhkYXRhKXt2YXIgaW5jbHVkZT1mdW5jdGlvbihwYXRoLGluY2x1ZGVEYXRhKXt2YXIgZD11dGlscy5zaGFsbG93Q29weSh1dGlscy5jcmVhdGVOdWxsUHJvdG9PYmpXaGVyZVBvc3NpYmxlKCksZGF0YSk7aWYoaW5jbHVkZURhdGEpe2Q9dXRpbHMuc2hhbGxvd0NvcHkoZCxpbmNsdWRlRGF0YSl9cmV0dXJuIGluY2x1ZGVGaWxlKHBhdGgsb3B0cykoZCl9O3JldHVybiBmbi5hcHBseShvcHRzLmNvbnRleHQsW2RhdGF8fHV0aWxzLmNyZWF0ZU51bGxQcm90b09ialdoZXJlUG9zc2libGUoKSxlc2NhcGVGbixpbmNsdWRlLHJldGhyb3ddKX07aWYob3B0cy5maWxlbmFtZSYmdHlwZW9mIE9iamVjdC5kZWZpbmVQcm9wZXJ0eT09PVwiZnVuY3Rpb25cIil7dmFyIGZpbGVuYW1lPW9wdHMuZmlsZW5hbWU7dmFyIGJhc2VuYW1lPXBhdGguYmFzZW5hbWUoZmlsZW5hbWUscGF0aC5leHRuYW1lKGZpbGVuYW1lKSk7dHJ5e09iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXR1cm5lZEZuLFwibmFtZVwiLHt2YWx1ZTpiYXNlbmFtZSx3cml0YWJsZTpmYWxzZSxlbnVtZXJhYmxlOmZhbHNlLGNvbmZpZ3VyYWJsZTp0cnVlfSl9Y2F0Y2goZSl7fX1yZXR1cm4gcmV0dXJuZWRGbn0sZ2VuZXJhdGVTb3VyY2U6ZnVuY3Rpb24oKXt2YXIgb3B0cz10aGlzLm9wdHM7aWYob3B0cy5ybVdoaXRlc3BhY2Upe3RoaXMudGVtcGxhdGVUZXh0PXRoaXMudGVtcGxhdGVUZXh0LnJlcGxhY2UoL1tcXHJcXG5dKy9nLFwiXFxuXCIpLnJlcGxhY2UoL15cXHMrfFxccyskL2dtLFwiXCIpfXRoaXMudGVtcGxhdGVUZXh0PXRoaXMudGVtcGxhdGVUZXh0LnJlcGxhY2UoL1sgXFx0XSo8JV8vZ20sXCI8JV9cIikucmVwbGFjZSgvXyU+WyBcXHRdKi9nbSxcIl8lPlwiKTt2YXIgc2VsZj10aGlzO3ZhciBtYXRjaGVzPXRoaXMucGFyc2VUZW1wbGF0ZVRleHQoKTt2YXIgZD10aGlzLm9wdHMuZGVsaW1pdGVyO3ZhciBvPXRoaXMub3B0cy5vcGVuRGVsaW1pdGVyO3ZhciBjPXRoaXMub3B0cy5jbG9zZURlbGltaXRlcjtpZihtYXRjaGVzJiZtYXRjaGVzLmxlbmd0aCl7bWF0Y2hlcy5mb3JFYWNoKGZ1bmN0aW9uKGxpbmUsaW5kZXgpe3ZhciBjbG9zaW5nO2lmKGxpbmUuaW5kZXhPZihvK2QpPT09MCYmbGluZS5pbmRleE9mKG8rZCtkKSE9PTApe2Nsb3Npbmc9bWF0Y2hlc1tpbmRleCsyXTtpZighKGNsb3Npbmc9PWQrY3x8Y2xvc2luZz09XCItXCIrZCtjfHxjbG9zaW5nPT1cIl9cIitkK2MpKXt0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIG1hdGNoaW5nIGNsb3NlIHRhZyBmb3IgXCInK2xpbmUrJ1wiLicpfX1zZWxmLnNjYW5MaW5lKGxpbmUpfSl9fSxwYXJzZVRlbXBsYXRlVGV4dDpmdW5jdGlvbigpe3ZhciBzdHI9dGhpcy50ZW1wbGF0ZVRleHQ7dmFyIHBhdD10aGlzLnJlZ2V4O3ZhciByZXN1bHQ9cGF0LmV4ZWMoc3RyKTt2YXIgYXJyPVtdO3ZhciBmaXJzdFBvczt3aGlsZShyZXN1bHQpe2ZpcnN0UG9zPXJlc3VsdC5pbmRleDtpZihmaXJzdFBvcyE9PTApe2Fyci5wdXNoKHN0ci5zdWJzdHJpbmcoMCxmaXJzdFBvcykpO3N0cj1zdHIuc2xpY2UoZmlyc3RQb3MpfWFyci5wdXNoKHJlc3VsdFswXSk7c3RyPXN0ci5zbGljZShyZXN1bHRbMF0ubGVuZ3RoKTtyZXN1bHQ9cGF0LmV4ZWMoc3RyKX1pZihzdHIpe2Fyci5wdXNoKHN0cil9cmV0dXJuIGFycn0sX2FkZE91dHB1dDpmdW5jdGlvbihsaW5lKXtpZih0aGlzLnRydW5jYXRlKXtsaW5lPWxpbmUucmVwbGFjZSgvXig/OlxcclxcbnxcXHJ8XFxuKS8sXCJcIik7dGhpcy50cnVuY2F0ZT1mYWxzZX1pZighbGluZSl7cmV0dXJuIGxpbmV9bGluZT1saW5lLnJlcGxhY2UoL1xcXFwvZyxcIlxcXFxcXFxcXCIpO2xpbmU9bGluZS5yZXBsYWNlKC9cXG4vZyxcIlxcXFxuXCIpO2xpbmU9bGluZS5yZXBsYWNlKC9cXHIvZyxcIlxcXFxyXCIpO2xpbmU9bGluZS5yZXBsYWNlKC9cIi9nLCdcXFxcXCInKTt0aGlzLnNvdXJjZSs9JyAgICA7IF9fYXBwZW5kKFwiJytsaW5lKydcIiknK1wiXFxuXCJ9LHNjYW5MaW5lOmZ1bmN0aW9uKGxpbmUpe3ZhciBzZWxmPXRoaXM7dmFyIGQ9dGhpcy5vcHRzLmRlbGltaXRlcjt2YXIgbz10aGlzLm9wdHMub3BlbkRlbGltaXRlcjt2YXIgYz10aGlzLm9wdHMuY2xvc2VEZWxpbWl0ZXI7dmFyIG5ld0xpbmVDb3VudD0wO25ld0xpbmVDb3VudD1saW5lLnNwbGl0KFwiXFxuXCIpLmxlbmd0aC0xO3N3aXRjaChsaW5lKXtjYXNlIG8rZDpjYXNlIG8rZCtcIl9cIjp0aGlzLm1vZGU9VGVtcGxhdGUubW9kZXMuRVZBTDticmVhaztjYXNlIG8rZCtcIj1cIjp0aGlzLm1vZGU9VGVtcGxhdGUubW9kZXMuRVNDQVBFRDticmVhaztjYXNlIG8rZCtcIi1cIjp0aGlzLm1vZGU9VGVtcGxhdGUubW9kZXMuUkFXO2JyZWFrO2Nhc2UgbytkK1wiI1wiOnRoaXMubW9kZT1UZW1wbGF0ZS5tb2Rlcy5DT01NRU5UO2JyZWFrO2Nhc2UgbytkK2Q6dGhpcy5tb2RlPVRlbXBsYXRlLm1vZGVzLkxJVEVSQUw7dGhpcy5zb3VyY2UrPScgICAgOyBfX2FwcGVuZChcIicrbGluZS5yZXBsYWNlKG8rZCtkLG8rZCkrJ1wiKScrXCJcXG5cIjticmVhaztjYXNlIGQrZCtjOnRoaXMubW9kZT1UZW1wbGF0ZS5tb2Rlcy5MSVRFUkFMO3RoaXMuc291cmNlKz0nICAgIDsgX19hcHBlbmQoXCInK2xpbmUucmVwbGFjZShkK2QrYyxkK2MpKydcIiknK1wiXFxuXCI7YnJlYWs7Y2FzZSBkK2M6Y2FzZVwiLVwiK2QrYzpjYXNlXCJfXCIrZCtjOmlmKHRoaXMubW9kZT09VGVtcGxhdGUubW9kZXMuTElURVJBTCl7dGhpcy5fYWRkT3V0cHV0KGxpbmUpfXRoaXMubW9kZT1udWxsO3RoaXMudHJ1bmNhdGU9bGluZS5pbmRleE9mKFwiLVwiKT09PTB8fGxpbmUuaW5kZXhPZihcIl9cIik9PT0wO2JyZWFrO2RlZmF1bHQ6aWYodGhpcy5tb2RlKXtzd2l0Y2godGhpcy5tb2RlKXtjYXNlIFRlbXBsYXRlLm1vZGVzLkVWQUw6Y2FzZSBUZW1wbGF0ZS5tb2Rlcy5FU0NBUEVEOmNhc2UgVGVtcGxhdGUubW9kZXMuUkFXOmlmKGxpbmUubGFzdEluZGV4T2YoXCIvL1wiKT5saW5lLmxhc3RJbmRleE9mKFwiXFxuXCIpKXtsaW5lKz1cIlxcblwifX1zd2l0Y2godGhpcy5tb2RlKXtjYXNlIFRlbXBsYXRlLm1vZGVzLkVWQUw6dGhpcy5zb3VyY2UrPVwiICAgIDsgXCIrbGluZStcIlxcblwiO2JyZWFrO2Nhc2UgVGVtcGxhdGUubW9kZXMuRVNDQVBFRDp0aGlzLnNvdXJjZSs9XCIgICAgOyBfX2FwcGVuZChlc2NhcGVGbihcIitzdHJpcFNlbWkobGluZSkrXCIpKVwiK1wiXFxuXCI7YnJlYWs7Y2FzZSBUZW1wbGF0ZS5tb2Rlcy5SQVc6dGhpcy5zb3VyY2UrPVwiICAgIDsgX19hcHBlbmQoXCIrc3RyaXBTZW1pKGxpbmUpK1wiKVwiK1wiXFxuXCI7YnJlYWs7Y2FzZSBUZW1wbGF0ZS5tb2Rlcy5DT01NRU5UOmJyZWFrO2Nhc2UgVGVtcGxhdGUubW9kZXMuTElURVJBTDp0aGlzLl9hZGRPdXRwdXQobGluZSk7YnJlYWt9fWVsc2V7dGhpcy5fYWRkT3V0cHV0KGxpbmUpfX1pZihzZWxmLm9wdHMuY29tcGlsZURlYnVnJiZuZXdMaW5lQ291bnQpe3RoaXMuY3VycmVudExpbmUrPW5ld0xpbmVDb3VudDt0aGlzLnNvdXJjZSs9XCIgICAgOyBfX2xpbmUgPSBcIit0aGlzLmN1cnJlbnRMaW5lK1wiXFxuXCJ9fX07ZXhwb3J0cy5lc2NhcGVYTUw9dXRpbHMuZXNjYXBlWE1MO2V4cG9ydHMuX19leHByZXNzPWV4cG9ydHMucmVuZGVyRmlsZTtleHBvcnRzLlZFUlNJT049X1ZFUlNJT05fU1RSSU5HO2V4cG9ydHMubmFtZT1fTkFNRTtpZih0eXBlb2Ygd2luZG93IT1cInVuZGVmaW5lZFwiKXt3aW5kb3cuZWpzPWV4cG9ydHN9fSx7XCIuLi9wYWNrYWdlLmpzb25cIjo2LFwiLi91dGlsc1wiOjIsZnM6MyxwYXRoOjR9XSwyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcInVzZSBzdHJpY3RcIjt2YXIgcmVnRXhwQ2hhcnM9L1t8XFxcXHt9KClbXFxdXiQrKj8uXS9nO3ZhciBoYXNPd25Qcm9wZXJ0eT1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O3ZhciBoYXNPd249ZnVuY3Rpb24ob2JqLGtleSl7cmV0dXJuIGhhc093blByb3BlcnR5LmFwcGx5KG9iaixba2V5XSl9O2V4cG9ydHMuZXNjYXBlUmVnRXhwQ2hhcnM9ZnVuY3Rpb24oc3RyaW5nKXtpZighc3RyaW5nKXtyZXR1cm5cIlwifXJldHVybiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlZ0V4cENoYXJzLFwiXFxcXCQmXCIpfTt2YXIgX0VOQ09ERV9IVE1MX1JVTEVTPXtcIiZcIjpcIiZhbXA7XCIsXCI8XCI6XCImbHQ7XCIsXCI+XCI6XCImZ3Q7XCIsJ1wiJzpcIiYjMzQ7XCIsXCInXCI6XCImIzM5O1wifTt2YXIgX01BVENIX0hUTUw9L1smPD4nXCJdL2c7ZnVuY3Rpb24gZW5jb2RlX2NoYXIoYyl7cmV0dXJuIF9FTkNPREVfSFRNTF9SVUxFU1tjXXx8Y312YXIgZXNjYXBlRnVuY1N0cj1cInZhciBfRU5DT0RFX0hUTUxfUlVMRVMgPSB7XFxuXCIrJyAgICAgIFwiJlwiOiBcIiZhbXA7XCJcXG4nKycgICAgLCBcIjxcIjogXCImbHQ7XCJcXG4nKycgICAgLCBcIj5cIjogXCImZ3Q7XCJcXG4nKycgICAgLCBcXCdcIlxcJzogXCImIzM0O1wiXFxuJysnICAgICwgXCJcXCdcIjogXCImIzM5O1wiXFxuJytcIiAgICB9XFxuXCIrXCIgICwgX01BVENIX0hUTUwgPSAvWyY8PidcXFwiXS9nO1xcblwiK1wiZnVuY3Rpb24gZW5jb2RlX2NoYXIoYykge1xcblwiK1wiICByZXR1cm4gX0VOQ09ERV9IVE1MX1JVTEVTW2NdIHx8IGM7XFxuXCIrXCJ9O1xcblwiO2V4cG9ydHMuZXNjYXBlWE1MPWZ1bmN0aW9uKG1hcmt1cCl7cmV0dXJuIG1hcmt1cD09dW5kZWZpbmVkP1wiXCI6U3RyaW5nKG1hcmt1cCkucmVwbGFjZShfTUFUQ0hfSFRNTCxlbmNvZGVfY2hhcil9O2Z1bmN0aW9uIGVzY2FwZVhNTFRvU3RyaW5nKCl7cmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaXMpK1wiO1xcblwiK2VzY2FwZUZ1bmNTdHJ9dHJ5e2lmKHR5cGVvZiBPYmplY3QuZGVmaW5lUHJvcGVydHk9PT1cImZ1bmN0aW9uXCIpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmVzY2FwZVhNTCxcInRvU3RyaW5nXCIse3ZhbHVlOmVzY2FwZVhNTFRvU3RyaW5nfSl9ZWxzZXtleHBvcnRzLmVzY2FwZVhNTC50b1N0cmluZz1lc2NhcGVYTUxUb1N0cmluZ319Y2F0Y2goZXJyKXtjb25zb2xlLndhcm4oXCJVbmFibGUgdG8gc2V0IGVzY2FwZVhNTC50b1N0cmluZyAoaXMgdGhlIEZ1bmN0aW9uIHByb3RvdHlwZSBmcm96ZW4/KVwiKX1leHBvcnRzLnNoYWxsb3dDb3B5PWZ1bmN0aW9uKHRvLGZyb20pe2Zyb209ZnJvbXx8e307aWYodG8hPT1udWxsJiZ0byE9PXVuZGVmaW5lZCl7Zm9yKHZhciBwIGluIGZyb20pe2lmKCFoYXNPd24oZnJvbSxwKSl7Y29udGludWV9aWYocD09PVwiX19wcm90b19fXCJ8fHA9PT1cImNvbnN0cnVjdG9yXCIpe2NvbnRpbnVlfXRvW3BdPWZyb21bcF19fXJldHVybiB0b307ZXhwb3J0cy5zaGFsbG93Q29weUZyb21MaXN0PWZ1bmN0aW9uKHRvLGZyb20sbGlzdCl7bGlzdD1saXN0fHxbXTtmcm9tPWZyb218fHt9O2lmKHRvIT09bnVsbCYmdG8hPT11bmRlZmluZWQpe2Zvcih2YXIgaT0wO2k8bGlzdC5sZW5ndGg7aSsrKXt2YXIgcD1saXN0W2ldO2lmKHR5cGVvZiBmcm9tW3BdIT1cInVuZGVmaW5lZFwiKXtpZighaGFzT3duKGZyb20scCkpe2NvbnRpbnVlfWlmKHA9PT1cIl9fcHJvdG9fX1wifHxwPT09XCJjb25zdHJ1Y3RvclwiKXtjb250aW51ZX10b1twXT1mcm9tW3BdfX19cmV0dXJuIHRvfTtleHBvcnRzLmNhY2hlPXtfZGF0YTp7fSxzZXQ6ZnVuY3Rpb24oa2V5LHZhbCl7dGhpcy5fZGF0YVtrZXldPXZhbH0sZ2V0OmZ1bmN0aW9uKGtleSl7cmV0dXJuIHRoaXMuX2RhdGFba2V5XX0scmVtb3ZlOmZ1bmN0aW9uKGtleSl7ZGVsZXRlIHRoaXMuX2RhdGFba2V5XX0scmVzZXQ6ZnVuY3Rpb24oKXt0aGlzLl9kYXRhPXt9fX07ZXhwb3J0cy5oeXBoZW5Ub0NhbWVsPWZ1bmN0aW9uKHN0cil7cmV0dXJuIHN0ci5yZXBsYWNlKC8tW2Etel0vZyxmdW5jdGlvbihtYXRjaCl7cmV0dXJuIG1hdGNoWzFdLnRvVXBwZXJDYXNlKCl9KX07ZXhwb3J0cy5jcmVhdGVOdWxsUHJvdG9PYmpXaGVyZVBvc3NpYmxlPWZ1bmN0aW9uKCl7aWYodHlwZW9mIE9iamVjdC5jcmVhdGU9PVwiZnVuY3Rpb25cIil7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5jcmVhdGUobnVsbCl9fWlmKCEoe19fcHJvdG9fXzpudWxsfWluc3RhbmNlb2YgT2JqZWN0KSl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJue19fcHJvdG9fXzpudWxsfX19cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJue319fSgpfSx7fV0sMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7fSx7fV0sNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHByb2Nlc3Mpe2Z1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KHBhcnRzLGFsbG93QWJvdmVSb290KXt2YXIgdXA9MDtmb3IodmFyIGk9cGFydHMubGVuZ3RoLTE7aT49MDtpLS0pe3ZhciBsYXN0PXBhcnRzW2ldO2lmKGxhc3Q9PT1cIi5cIil7cGFydHMuc3BsaWNlKGksMSl9ZWxzZSBpZihsYXN0PT09XCIuLlwiKXtwYXJ0cy5zcGxpY2UoaSwxKTt1cCsrfWVsc2UgaWYodXApe3BhcnRzLnNwbGljZShpLDEpO3VwLS19fWlmKGFsbG93QWJvdmVSb290KXtmb3IoO3VwLS07dXApe3BhcnRzLnVuc2hpZnQoXCIuLlwiKX19cmV0dXJuIHBhcnRzfWV4cG9ydHMucmVzb2x2ZT1mdW5jdGlvbigpe3ZhciByZXNvbHZlZFBhdGg9XCJcIixyZXNvbHZlZEFic29sdXRlPWZhbHNlO2Zvcih2YXIgaT1hcmd1bWVudHMubGVuZ3RoLTE7aT49LTEmJiFyZXNvbHZlZEFic29sdXRlO2ktLSl7dmFyIHBhdGg9aT49MD9hcmd1bWVudHNbaV06cHJvY2Vzcy5jd2QoKTtpZih0eXBlb2YgcGF0aCE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5nc1wiKX1lbHNlIGlmKCFwYXRoKXtjb250aW51ZX1yZXNvbHZlZFBhdGg9cGF0aCtcIi9cIityZXNvbHZlZFBhdGg7cmVzb2x2ZWRBYnNvbHV0ZT1wYXRoLmNoYXJBdCgwKT09PVwiL1wifXJlc29sdmVkUGF0aD1ub3JtYWxpemVBcnJheShmaWx0ZXIocmVzb2x2ZWRQYXRoLnNwbGl0KFwiL1wiKSxmdW5jdGlvbihwKXtyZXR1cm4hIXB9KSwhcmVzb2x2ZWRBYnNvbHV0ZSkuam9pbihcIi9cIik7cmV0dXJuKHJlc29sdmVkQWJzb2x1dGU/XCIvXCI6XCJcIikrcmVzb2x2ZWRQYXRofHxcIi5cIn07ZXhwb3J0cy5ub3JtYWxpemU9ZnVuY3Rpb24ocGF0aCl7dmFyIGlzQWJzb2x1dGU9ZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpLHRyYWlsaW5nU2xhc2g9c3Vic3RyKHBhdGgsLTEpPT09XCIvXCI7cGF0aD1ub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdChcIi9cIiksZnVuY3Rpb24ocCl7cmV0dXJuISFwfSksIWlzQWJzb2x1dGUpLmpvaW4oXCIvXCIpO2lmKCFwYXRoJiYhaXNBYnNvbHV0ZSl7cGF0aD1cIi5cIn1pZihwYXRoJiZ0cmFpbGluZ1NsYXNoKXtwYXRoKz1cIi9cIn1yZXR1cm4oaXNBYnNvbHV0ZT9cIi9cIjpcIlwiKStwYXRofTtleHBvcnRzLmlzQWJzb2x1dGU9ZnVuY3Rpb24ocGF0aCl7cmV0dXJuIHBhdGguY2hhckF0KDApPT09XCIvXCJ9O2V4cG9ydHMuam9pbj1mdW5jdGlvbigpe3ZhciBwYXRocz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMCk7cmV0dXJuIGV4cG9ydHMubm9ybWFsaXplKGZpbHRlcihwYXRocyxmdW5jdGlvbihwLGluZGV4KXtpZih0eXBlb2YgcCE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudHMgdG8gcGF0aC5qb2luIG11c3QgYmUgc3RyaW5nc1wiKX1yZXR1cm4gcH0pLmpvaW4oXCIvXCIpKX07ZXhwb3J0cy5yZWxhdGl2ZT1mdW5jdGlvbihmcm9tLHRvKXtmcm9tPWV4cG9ydHMucmVzb2x2ZShmcm9tKS5zdWJzdHIoMSk7dG89ZXhwb3J0cy5yZXNvbHZlKHRvKS5zdWJzdHIoMSk7ZnVuY3Rpb24gdHJpbShhcnIpe3ZhciBzdGFydD0wO2Zvcig7c3RhcnQ8YXJyLmxlbmd0aDtzdGFydCsrKXtpZihhcnJbc3RhcnRdIT09XCJcIilicmVha312YXIgZW5kPWFyci5sZW5ndGgtMTtmb3IoO2VuZD49MDtlbmQtLSl7aWYoYXJyW2VuZF0hPT1cIlwiKWJyZWFrfWlmKHN0YXJ0PmVuZClyZXR1cm5bXTtyZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LGVuZC1zdGFydCsxKX12YXIgZnJvbVBhcnRzPXRyaW0oZnJvbS5zcGxpdChcIi9cIikpO3ZhciB0b1BhcnRzPXRyaW0odG8uc3BsaXQoXCIvXCIpKTt2YXIgbGVuZ3RoPU1hdGgubWluKGZyb21QYXJ0cy5sZW5ndGgsdG9QYXJ0cy5sZW5ndGgpO3ZhciBzYW1lUGFydHNMZW5ndGg9bGVuZ3RoO2Zvcih2YXIgaT0wO2k8bGVuZ3RoO2krKyl7aWYoZnJvbVBhcnRzW2ldIT09dG9QYXJ0c1tpXSl7c2FtZVBhcnRzTGVuZ3RoPWk7YnJlYWt9fXZhciBvdXRwdXRQYXJ0cz1bXTtmb3IodmFyIGk9c2FtZVBhcnRzTGVuZ3RoO2k8ZnJvbVBhcnRzLmxlbmd0aDtpKyspe291dHB1dFBhcnRzLnB1c2goXCIuLlwiKX1vdXRwdXRQYXJ0cz1vdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtyZXR1cm4gb3V0cHV0UGFydHMuam9pbihcIi9cIil9O2V4cG9ydHMuc2VwPVwiL1wiO2V4cG9ydHMuZGVsaW1pdGVyPVwiOlwiO2V4cG9ydHMuZGlybmFtZT1mdW5jdGlvbihwYXRoKXtpZih0eXBlb2YgcGF0aCE9PVwic3RyaW5nXCIpcGF0aD1wYXRoK1wiXCI7aWYocGF0aC5sZW5ndGg9PT0wKXJldHVyblwiLlwiO3ZhciBjb2RlPXBhdGguY2hhckNvZGVBdCgwKTt2YXIgaGFzUm9vdD1jb2RlPT09NDc7dmFyIGVuZD0tMTt2YXIgbWF0Y2hlZFNsYXNoPXRydWU7Zm9yKHZhciBpPXBhdGgubGVuZ3RoLTE7aT49MTstLWkpe2NvZGU9cGF0aC5jaGFyQ29kZUF0KGkpO2lmKGNvZGU9PT00Nyl7aWYoIW1hdGNoZWRTbGFzaCl7ZW5kPWk7YnJlYWt9fWVsc2V7bWF0Y2hlZFNsYXNoPWZhbHNlfX1pZihlbmQ9PT0tMSlyZXR1cm4gaGFzUm9vdD9cIi9cIjpcIi5cIjtpZihoYXNSb290JiZlbmQ9PT0xKXtyZXR1cm5cIi9cIn1yZXR1cm4gcGF0aC5zbGljZSgwLGVuZCl9O2Z1bmN0aW9uIGJhc2VuYW1lKHBhdGgpe2lmKHR5cGVvZiBwYXRoIT09XCJzdHJpbmdcIilwYXRoPXBhdGgrXCJcIjt2YXIgc3RhcnQ9MDt2YXIgZW5kPS0xO3ZhciBtYXRjaGVkU2xhc2g9dHJ1ZTt2YXIgaTtmb3IoaT1wYXRoLmxlbmd0aC0xO2k+PTA7LS1pKXtpZihwYXRoLmNoYXJDb2RlQXQoaSk9PT00Nyl7aWYoIW1hdGNoZWRTbGFzaCl7c3RhcnQ9aSsxO2JyZWFrfX1lbHNlIGlmKGVuZD09PS0xKXttYXRjaGVkU2xhc2g9ZmFsc2U7ZW5kPWkrMX19aWYoZW5kPT09LTEpcmV0dXJuXCJcIjtyZXR1cm4gcGF0aC5zbGljZShzdGFydCxlbmQpfWV4cG9ydHMuYmFzZW5hbWU9ZnVuY3Rpb24ocGF0aCxleHQpe3ZhciBmPWJhc2VuYW1lKHBhdGgpO2lmKGV4dCYmZi5zdWJzdHIoLTEqZXh0Lmxlbmd0aCk9PT1leHQpe2Y9Zi5zdWJzdHIoMCxmLmxlbmd0aC1leHQubGVuZ3RoKX1yZXR1cm4gZn07ZXhwb3J0cy5leHRuYW1lPWZ1bmN0aW9uKHBhdGgpe2lmKHR5cGVvZiBwYXRoIT09XCJzdHJpbmdcIilwYXRoPXBhdGgrXCJcIjt2YXIgc3RhcnREb3Q9LTE7dmFyIHN0YXJ0UGFydD0wO3ZhciBlbmQ9LTE7dmFyIG1hdGNoZWRTbGFzaD10cnVlO3ZhciBwcmVEb3RTdGF0ZT0wO2Zvcih2YXIgaT1wYXRoLmxlbmd0aC0xO2k+PTA7LS1pKXt2YXIgY29kZT1wYXRoLmNoYXJDb2RlQXQoaSk7aWYoY29kZT09PTQ3KXtpZighbWF0Y2hlZFNsYXNoKXtzdGFydFBhcnQ9aSsxO2JyZWFrfWNvbnRpbnVlfWlmKGVuZD09PS0xKXttYXRjaGVkU2xhc2g9ZmFsc2U7ZW5kPWkrMX1pZihjb2RlPT09NDYpe2lmKHN0YXJ0RG90PT09LTEpc3RhcnREb3Q9aTtlbHNlIGlmKHByZURvdFN0YXRlIT09MSlwcmVEb3RTdGF0ZT0xfWVsc2UgaWYoc3RhcnREb3QhPT0tMSl7cHJlRG90U3RhdGU9LTF9fWlmKHN0YXJ0RG90PT09LTF8fGVuZD09PS0xfHxwcmVEb3RTdGF0ZT09PTB8fHByZURvdFN0YXRlPT09MSYmc3RhcnREb3Q9PT1lbmQtMSYmc3RhcnREb3Q9PT1zdGFydFBhcnQrMSl7cmV0dXJuXCJcIn1yZXR1cm4gcGF0aC5zbGljZShzdGFydERvdCxlbmQpfTtmdW5jdGlvbiBmaWx0ZXIoeHMsZil7aWYoeHMuZmlsdGVyKXJldHVybiB4cy5maWx0ZXIoZik7dmFyIHJlcz1bXTtmb3IodmFyIGk9MDtpPHhzLmxlbmd0aDtpKyspe2lmKGYoeHNbaV0saSx4cykpcmVzLnB1c2goeHNbaV0pfXJldHVybiByZXN9dmFyIHN1YnN0cj1cImFiXCIuc3Vic3RyKC0xKT09PVwiYlwiP2Z1bmN0aW9uKHN0cixzdGFydCxsZW4pe3JldHVybiBzdHIuc3Vic3RyKHN0YXJ0LGxlbil9OmZ1bmN0aW9uKHN0cixzdGFydCxsZW4pe2lmKHN0YXJ0PDApc3RhcnQ9c3RyLmxlbmd0aCtzdGFydDtyZXR1cm4gc3RyLnN1YnN0cihzdGFydCxsZW4pfX0pLmNhbGwodGhpcyxyZXF1aXJlKFwiX3Byb2Nlc3NcIikpfSx7X3Byb2Nlc3M6NX1dLDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe3ZhciBwcm9jZXNzPW1vZHVsZS5leHBvcnRzPXt9O3ZhciBjYWNoZWRTZXRUaW1lb3V0O3ZhciBjYWNoZWRDbGVhclRpbWVvdXQ7ZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpe3Rocm93IG5ldyBFcnJvcihcInNldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9ZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCgpe3Rocm93IG5ldyBFcnJvcihcImNsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKX0oZnVuY3Rpb24oKXt0cnl7aWYodHlwZW9mIHNldFRpbWVvdXQ9PT1cImZ1bmN0aW9uXCIpe2NhY2hlZFNldFRpbWVvdXQ9c2V0VGltZW91dH1lbHNle2NhY2hlZFNldFRpbWVvdXQ9ZGVmYXVsdFNldFRpbW91dH19Y2F0Y2goZSl7Y2FjaGVkU2V0VGltZW91dD1kZWZhdWx0U2V0VGltb3V0fXRyeXtpZih0eXBlb2YgY2xlYXJUaW1lb3V0PT09XCJmdW5jdGlvblwiKXtjYWNoZWRDbGVhclRpbWVvdXQ9Y2xlYXJUaW1lb3V0fWVsc2V7Y2FjaGVkQ2xlYXJUaW1lb3V0PWRlZmF1bHRDbGVhclRpbWVvdXR9fWNhdGNoKGUpe2NhY2hlZENsZWFyVGltZW91dD1kZWZhdWx0Q2xlYXJUaW1lb3V0fX0pKCk7ZnVuY3Rpb24gcnVuVGltZW91dChmdW4pe2lmKGNhY2hlZFNldFRpbWVvdXQ9PT1zZXRUaW1lb3V0KXtyZXR1cm4gc2V0VGltZW91dChmdW4sMCl9aWYoKGNhY2hlZFNldFRpbWVvdXQ9PT1kZWZhdWx0U2V0VGltb3V0fHwhY2FjaGVkU2V0VGltZW91dCkmJnNldFRpbWVvdXQpe2NhY2hlZFNldFRpbWVvdXQ9c2V0VGltZW91dDtyZXR1cm4gc2V0VGltZW91dChmdW4sMCl9dHJ5e3JldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwwKX1jYXRjaChlKXt0cnl7cmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLGZ1biwwKX1jYXRjaChlKXtyZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsZnVuLDApfX19ZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcil7aWYoY2FjaGVkQ2xlYXJUaW1lb3V0PT09Y2xlYXJUaW1lb3V0KXtyZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcil9aWYoKGNhY2hlZENsZWFyVGltZW91dD09PWRlZmF1bHRDbGVhclRpbWVvdXR8fCFjYWNoZWRDbGVhclRpbWVvdXQpJiZjbGVhclRpbWVvdXQpe2NhY2hlZENsZWFyVGltZW91dD1jbGVhclRpbWVvdXQ7cmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpfXRyeXtyZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcil9Y2F0Y2goZSl7dHJ5e3JldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLG1hcmtlcil9Y2F0Y2goZSl7cmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsbWFya2VyKX19fXZhciBxdWV1ZT1bXTt2YXIgZHJhaW5pbmc9ZmFsc2U7dmFyIGN1cnJlbnRRdWV1ZTt2YXIgcXVldWVJbmRleD0tMTtmdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKXtpZighZHJhaW5pbmd8fCFjdXJyZW50UXVldWUpe3JldHVybn1kcmFpbmluZz1mYWxzZTtpZihjdXJyZW50UXVldWUubGVuZ3RoKXtxdWV1ZT1jdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKX1lbHNle3F1ZXVlSW5kZXg9LTF9aWYocXVldWUubGVuZ3RoKXtkcmFpblF1ZXVlKCl9fWZ1bmN0aW9uIGRyYWluUXVldWUoKXtpZihkcmFpbmluZyl7cmV0dXJufXZhciB0aW1lb3V0PXJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtkcmFpbmluZz10cnVlO3ZhciBsZW49cXVldWUubGVuZ3RoO3doaWxlKGxlbil7Y3VycmVudFF1ZXVlPXF1ZXVlO3F1ZXVlPVtdO3doaWxlKCsrcXVldWVJbmRleDxsZW4pe2lmKGN1cnJlbnRRdWV1ZSl7Y3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpfX1xdWV1ZUluZGV4PS0xO2xlbj1xdWV1ZS5sZW5ndGh9Y3VycmVudFF1ZXVlPW51bGw7ZHJhaW5pbmc9ZmFsc2U7cnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpfXByb2Nlc3MubmV4dFRpY2s9ZnVuY3Rpb24oZnVuKXt2YXIgYXJncz1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKTtpZihhcmd1bWVudHMubGVuZ3RoPjEpe2Zvcih2YXIgaT0xO2k8YXJndW1lbnRzLmxlbmd0aDtpKyspe2FyZ3NbaS0xXT1hcmd1bWVudHNbaV19fXF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLGFyZ3MpKTtpZihxdWV1ZS5sZW5ndGg9PT0xJiYhZHJhaW5pbmcpe3J1blRpbWVvdXQoZHJhaW5RdWV1ZSl9fTtmdW5jdGlvbiBJdGVtKGZ1bixhcnJheSl7dGhpcy5mdW49ZnVuO3RoaXMuYXJyYXk9YXJyYXl9SXRlbS5wcm90b3R5cGUucnVuPWZ1bmN0aW9uKCl7dGhpcy5mdW4uYXBwbHkobnVsbCx0aGlzLmFycmF5KX07cHJvY2Vzcy50aXRsZT1cImJyb3dzZXJcIjtwcm9jZXNzLmJyb3dzZXI9dHJ1ZTtwcm9jZXNzLmVudj17fTtwcm9jZXNzLmFyZ3Y9W107cHJvY2Vzcy52ZXJzaW9uPVwiXCI7cHJvY2Vzcy52ZXJzaW9ucz17fTtmdW5jdGlvbiBub29wKCl7fXByb2Nlc3Mub249bm9vcDtwcm9jZXNzLmFkZExpc3RlbmVyPW5vb3A7cHJvY2Vzcy5vbmNlPW5vb3A7cHJvY2Vzcy5vZmY9bm9vcDtwcm9jZXNzLnJlbW92ZUxpc3RlbmVyPW5vb3A7cHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnM9bm9vcDtwcm9jZXNzLmVtaXQ9bm9vcDtwcm9jZXNzLnByZXBlbmRMaXN0ZW5lcj1ub29wO3Byb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lcj1ub29wO3Byb2Nlc3MubGlzdGVuZXJzPWZ1bmN0aW9uKG5hbWUpe3JldHVybltdfTtwcm9jZXNzLmJpbmRpbmc9ZnVuY3Rpb24obmFtZSl7dGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcIil9O3Byb2Nlc3MuY3dkPWZ1bmN0aW9uKCl7cmV0dXJuXCIvXCJ9O3Byb2Nlc3MuY2hkaXI9ZnVuY3Rpb24oZGlyKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWRcIil9O3Byb2Nlc3MudW1hc2s9ZnVuY3Rpb24oKXtyZXR1cm4gMH19LHt9XSw2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXttb2R1bGUuZXhwb3J0cz17bmFtZTpcImVqc1wiLGRlc2NyaXB0aW9uOlwiRW1iZWRkZWQgSmF2YVNjcmlwdCB0ZW1wbGF0ZXNcIixrZXl3b3JkczpbXCJ0ZW1wbGF0ZVwiLFwiZW5naW5lXCIsXCJlanNcIl0sdmVyc2lvbjpcIjMuMS45XCIsYXV0aG9yOlwiTWF0dGhldyBFZXJuaXNzZSA8bWRlQGZsZWVnaXgub3JnPiAoaHR0cDovL2ZsZWVnaXgub3JnKVwiLGxpY2Vuc2U6XCJBcGFjaGUtMi4wXCIsYmluOntlanM6XCIuL2Jpbi9jbGkuanNcIn0sbWFpbjpcIi4vbGliL2Vqcy5qc1wiLGpzZGVsaXZyOlwiZWpzLm1pbi5qc1wiLHVucGtnOlwiZWpzLm1pbi5qc1wiLHJlcG9zaXRvcnk6e3R5cGU6XCJnaXRcIix1cmw6XCJnaXQ6Ly9naXRodWIuY29tL21kZS9lanMuZ2l0XCJ9LGJ1Z3M6XCJodHRwczovL2dpdGh1Yi5jb20vbWRlL2Vqcy9pc3N1ZXNcIixob21lcGFnZTpcImh0dHBzOi8vZ2l0aHViLmNvbS9tZGUvZWpzXCIsZGVwZW5kZW5jaWVzOntqYWtlOlwiXjEwLjguNVwifSxkZXZEZXBlbmRlbmNpZXM6e2Jyb3dzZXJpZnk6XCJeMTYuNS4xXCIsZXNsaW50OlwiXjYuOC4wXCIsXCJnaXQtZGlyZWN0b3J5LWRlcGxveVwiOlwiXjEuNS4xXCIsanNkb2M6XCJeNC4wLjJcIixcImxydS1jYWNoZVwiOlwiXjQuMC4xXCIsbW9jaGE6XCJeMTAuMi4wXCIsXCJ1Z2xpZnktanNcIjpcIl4zLjMuMTZcIn0sZW5naW5lczp7bm9kZTpcIj49MC4xMC4wXCJ9LHNjcmlwdHM6e3Rlc3Q6XCJtb2NoYSAtdSB0ZGRcIn19fSx7fV19LHt9LFsxXSkoMSl9KTtcbiIsICJ7XG4gIFwiZW5cIjoge1xuICAgIFwicHJvbm91bnNcIjogW1wibXlcIiwgXCJJXCIsIFwibWVcIiwgXCJtaW5lXCIsIFwib3VyXCIsIFwib3Vyc1wiLCBcInVzXCIsIFwid2VcIl0sXG4gICAgXCJwcm9tcHRcIjogXCJCYXNlZCBvbiB5b3VyIG5vdGVzXCIsXG4gICAgXCJpbml0aWFsX21lc3NhZ2VcIjogXCJIaSwgSSdtIENoYXRHUFQgd2l0aCBhY2Nlc3MgdG8geW91ciBub3RlcyB2aWEgU21hcnQgQ29ubmVjdGlvbnMuIEFzayBtZSBhIHF1ZXN0aW9uIGFib3V0IHlvdXIgbm90ZXMgYW5kIEknbGwgdHJ5IHRvIGFuc3dlciBpdC5cIlxuICB9LFxuICBcImVzXCI6IHtcbiAgICBcInByb25vdW5zXCI6IFtcIm1pXCIsIFwieW9cIiwgXCJtXHUwMEVEXCIsIFwidFx1MDBGQVwiXSxcbiAgICBcInByb21wdFwiOiBcIkJhc1x1MDBFMW5kb3NlIGVuIHN1cyBub3Rhc1wiLFxuICAgIFwiaW5pdGlhbF9tZXNzYWdlXCI6IFwiSG9sYSwgc295IENoYXRHUFQgY29uIGFjY2VzbyBhIHR1cyBhcHVudGVzIGEgdHJhdlx1MDBFOXMgZGUgU21hcnQgQ29ubmVjdGlvbnMuIEhhem1lIHVuYSBwcmVndW50YSBzb2JyZSB0dXMgYXB1bnRlcyBlIGludGVudGFyXHUwMEU5IHJlc3BvbmRlcnRlLlwiXG4gIH0sXG4gIFwiZnJcIjoge1xuICAgIFwicHJvbm91bnNcIjogW1wibWVcIiwgXCJtb25cIiwgXCJtYVwiLCBcIm1lc1wiLCBcIm1vaVwiLCBcIm5vdXNcIiwgXCJub3RyZVwiLCBcIm5vc1wiLCBcImplXCIsIFwiaidcIiwgXCJtJ1wiXSxcbiAgICBcInByb21wdFwiOiBcIkQnYXByXHUwMEU4cyB2b3Mgbm90ZXNcIixcbiAgICBcImluaXRpYWxfbWVzc2FnZVwiOiBcIkJvbmpvdXIsIGplIHN1aXMgQ2hhdEdQVCBldCBqJ2FpIGFjY1x1MDBFOHMgXHUwMEUwIHZvcyBub3RlcyB2aWEgU21hcnQgQ29ubmVjdGlvbnMuIFBvc2V6LW1vaSB1bmUgcXVlc3Rpb24gc3VyIHZvcyBub3RlcyBldCBqJ2Vzc2FpZXJhaSBkJ3kgclx1MDBFOXBvbmRyZS5cIlxuICB9LFxuICBcImRlXCI6IHtcbiAgICBcInByb25vdW5zXCI6IFtcIm1laW5cIiwgXCJtZWluZVwiLCBcIm1laW5lblwiLCBcIm1laW5lclwiLCBcIm1laW5lc1wiLCBcIm1pclwiLCBcInVuc1wiLCBcInVuc2VyXCIsIFwidW5zZXJlblwiLCBcInVuc2VyZXJcIiwgXCJ1bnNlcmVzXCJdLFxuICAgIFwicHJvbXB0XCI6IFwiQmFzaWVyZW5kIGF1ZiBJaHJlbiBOb3RpemVuXCIsXG4gICAgXCJpbml0aWFsX21lc3NhZ2VcIjogXCJIYWxsbywgaWNoIGJpbiBDaGF0R1BUIHVuZCBoYWJlIFx1MDBGQ2JlciBTbWFydCBDb25uZWN0aW9ucyBadWdhbmcgenUgSWhyZW4gTm90aXplbi4gU3RlbGxlbiBTaWUgbWlyIGVpbmUgRnJhZ2UgenUgSWhyZW4gTm90aXplbiB1bmQgaWNoIHdlcmRlIHZlcnN1Y2hlbiwgc2llIHp1IGJlYW50d29ydGVuLlwiXG4gIH0sXG4gIFwiaXRcIjoge1xuICAgIFwicHJvbm91bnNcIjogW1wibWlvXCIsIFwibWlhXCIsIFwibWllaVwiLCBcIm1pZVwiLCBcIm5vaVwiLCBcIm5vc3Ryb1wiLCBcIm5vc3RyaVwiLCBcIm5vc3RyYVwiLCBcIm5vc3RyZVwiXSxcbiAgICBcInByb21wdFwiOiBcIlN1bGxhIGJhc2UgZGVnbGkgYXBwdW50aVwiLFxuICAgIFwiaW5pdGlhbF9tZXNzYWdlXCI6IFwiQ2lhbywgc29ubyBDaGF0R1BUIGUgaG8gYWNjZXNzbyBhaSB0dW9pIGFwcHVudGkgdHJhbWl0ZSBTbWFydCBDb25uZWN0aW9ucy4gRmF0ZW1pIHVuYSBkb21hbmRhIHN1aSB2b3N0cmkgYXBwdW50aSBlIGNlcmNoZXJcdTAwRjIgZGkgcmlzcG9uZGVydmkuXCJcbiAgfVxufSIsICIvKipcbiAqIEFudGhyb3BpY0FkYXB0ZXIgY2xhc3MgcHJvdmlkZXMgbWV0aG9kcyB0byBhZGFwdCB0aGUgY2hhdCBtb2RlbCBpbnRlcmFjdGlvbnMgc3BlY2lmaWNhbGx5IGZvciB0aGUgQW50aHJvcGljIG1vZGVsLlxuICogSXQgaW5jbHVkZXMgbWV0aG9kcyB0byBwcmVwYXJlIHJlcXVlc3QgYm9kaWVzLCBjb3VudCBhbmQgZXN0aW1hdGUgdG9rZW5zLCBhbmQgaGFuZGxlIHRvb2wgY2FsbHMgYW5kIG1lc3NhZ2VzLlxuICovXG5jbGFzcyBBbnRocm9waWNBZGFwdGVyIHtcbiAgLyoqXG4gICAqIFByZXBhcmVzIHRoZSByZXF1ZXN0IGJvZHkgZm9yIHRoZSBBbnRocm9waWMgQVBJIGJ5IGNvbnZlcnRpbmcgQ2hhdE1MIGZvcm1hdCB0byBhIGZvcm1hdCBjb21wYXRpYmxlIHdpdGggQW50aHJvcGljLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIFRoZSBvcHRpb25zIG9iamVjdCBjb250YWluaW5nIG1lc3NhZ2VzIGFuZCBvdGhlciBwYXJhbWV0ZXJzIGluIENoYXRNTCBmb3JtYXQuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSByZXF1ZXN0IGJvZHkgZm9ybWF0dGVkIGZvciB0aGUgQW50aHJvcGljIEFQSS5cbiAgICovXG4gIHByZXBhcmVfcmVxdWVzdF9ib2R5KG9wdHMpIHsgcmV0dXJuIGNoYXRtbF90b19hbnRocm9waWMob3B0cyk7IH1cbiAgLyoqXG4gICAqIENvdW50cyB0aGUgdG9rZW5zIGluIHRoZSBpbnB1dCBieSBlc3RpbWF0aW5nIHRoZW0sIGFzIHRoZSBBbnRocm9waWMgbW9kZWwgZG9lcyBub3QgcHJvdmlkZSBhIGRpcmVjdCBtZXRob2QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gaW5wdXQgLSBUaGUgaW5wdXQgdGV4dCBvciBvYmplY3QgdG8gY291bnQgdG9rZW5zIGluLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxudW1iZXI+fSBUaGUgZXN0aW1hdGVkIG51bWJlciBvZiB0b2tlbnMgaW4gdGhlIGlucHV0LlxuICAgKi9cbiAgYXN5bmMgY291bnRfdG9rZW5zKGlucHV0KSB7XG4gICAgLy8gQ3VycmVudGx5LCB0aGUgQW50aHJvcGljIG1vZGVsIGRvZXMgbm90IHByb3ZpZGUgYSB3YXkgdG8gY291bnQgdG9rZW5zXG4gICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVfdG9rZW5zKGlucHV0KTtcbiAgfVxuICAvKipcbiAgICogRXN0aW1hdGVzIHRoZSBudW1iZXIgb2YgdG9rZW5zIGluIHRoZSBpbnB1dCBiYXNlZCBvbiBhIHJvdWdoIGF2ZXJhZ2UgdG9rZW4gc2l6ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBpbnB1dCAtIFRoZSBpbnB1dCB0ZXh0IG9yIG9iamVjdCB0byBlc3RpbWF0ZSB0b2tlbnMgaW4uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBlc3RpbWF0ZWQgbnVtYmVyIG9mIHRva2Vucy5cbiAgICovXG4gIGVzdGltYXRlX3Rva2VucyhpbnB1dCl7XG4gICAgaWYodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JykgaW5wdXQgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgLy8gTm90ZTogVGhlIGRpdmlzaW9uIGJ5IDYgaXMgYSByb3VnaCBlc3RpbWF0ZSBiYXNlZCBvbiBvYnNlcnZlZCBhdmVyYWdlIHRva2VuIHNpemUuXG4gICAgcmV0dXJuIE1hdGguY2VpbChpbnB1dC5sZW5ndGggLyA2KTsgLy8gVXNlIE1hdGguY2VpbCBmb3IgYSBtb3JlIGFjY3VyYXRlIGNvdW50XG4gIH1cbiAgLyoqXG4gICAqIEV4dHJhY3RzIHRoZSBmaXJzdCB0b29sIGNhbGwgZnJvbSB0aGUgSlNPTiByZXNwb25zZSBjb250ZW50LlxuICAgKiBAcGFyYW0ge09iamVjdH0ganNvbiAtIFRoZSBKU09OIHJlc3BvbnNlIGZyb20gd2hpY2ggdG8gZXh0cmFjdCB0aGUgdG9vbCBjYWxsLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9IFRoZSBmaXJzdCB0b29sIGNhbGwgZm91bmQsIG9yIG51bGwgaWYgbm9uZSBleGlzdC5cbiAgICovXG4gIGdldF90b29sX2NhbGwoanNvbil7XG4gICAgcmV0dXJuIGpzb24uY29udGVudC5maW5kKG1zZyA9PiBtc2cudHlwZSA9PT0gJ3Rvb2xfdXNlJyk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgaW5wdXQgY29udGVudCBvZiBhIHRvb2wgY2FsbC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHRvb2xfY2FsbCAtIFRoZSB0b29sIGNhbGwgb2JqZWN0IGZyb20gd2hpY2ggdG8gZXh0cmFjdCB0aGUgaW5wdXQuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBpbnB1dCBvZiB0aGUgdG9vbCBjYWxsLlxuICAgKi9cbiAgZ2V0X3Rvb2xfY2FsbF9jb250ZW50KHRvb2xfY2FsbCl7XG4gICAgcmV0dXJuIHRvb2xfY2FsbC5pbnB1dDtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBuYW1lIG9mIHRoZSB0b29sIGZyb20gYSB0b29sIGNhbGwgb2JqZWN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gdG9vbF9jYWxsIC0gVGhlIHRvb2wgY2FsbCBvYmplY3QgZnJvbSB3aGljaCB0byBleHRyYWN0IHRoZSBuYW1lLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgdG9vbC5cbiAgICovXG4gIGdldF90b29sX25hbWUodG9vbF9jYWxsKXtcbiAgICByZXR1cm4gdG9vbF9jYWxsLm5hbWU7XG4gIH1cbiAgLyoqXG4gICAqIEV4dHJhY3RzIHRoZSBmaXJzdCBtZXNzYWdlIGZyb20gdGhlIEpTT04gcmVzcG9uc2UgY29udGVudC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGpzb24gLSBUaGUgSlNPTiByZXNwb25zZSBmcm9tIHdoaWNoIHRvIGV4dHJhY3QgdGhlIG1lc3NhZ2UuXG4gICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH0gVGhlIGZpcnN0IG1lc3NhZ2UgZm91bmQsIG9yIG51bGwgaWYgbm9uZSBleGlzdC5cbiAgICovXG4gIGdldF9tZXNzYWdlKGpzb24peyByZXR1cm4ganNvbi5jb250ZW50Py5bMF07IH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgY29udGVudCBvZiB0aGUgZmlyc3QgbWVzc2FnZSBmcm9tIHRoZSBKU09OIHJlc3BvbnNlLlxuICAgKiBAcGFyYW0ge09iamVjdH0ganNvbiAtIFRoZSBKU09OIHJlc3BvbnNlIGZyb20gd2hpY2ggdG8gZXh0cmFjdCB0aGUgbWVzc2FnZSBjb250ZW50LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IFRoZSBjb250ZW50IG9mIHRoZSBmaXJzdCBtZXNzYWdlLCBvciBudWxsIGlmIG5vIG1lc3NhZ2UgaXMgZm91bmQuXG4gICAqL1xuICBnZXRfbWVzc2FnZV9jb250ZW50KGpzb24pIHsgcmV0dXJuIHRoaXMuZ2V0X21lc3NhZ2UoanNvbik/Llt0aGlzLmdldF9tZXNzYWdlKGpzb24pPy50eXBlXTsgfVxufVxuZXhwb3J0cy5BbnRocm9waWNBZGFwdGVyID0gQW50aHJvcGljQWRhcHRlcjtcbi8vIGh0dHBzOi8vZG9jcy5hbnRocm9waWMuY29tL2NsYXVkZS9yZWZlcmVuY2UvbWVzc2FnZXNfcG9zdFxuLyoqXG4gKiBDb252ZXJ0IGEgQ2hhdE1MIG9iamVjdCB0byBhbiBBbnRocm9waWMgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIFRoZSBDaGF0TUwgb2JqZWN0XG4gKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiBjb252ZXJ0cyBhIENoYXRNTCBvYmplY3QgdG8gYW4gQW50aHJvcGljIG9iamVjdC4gSXQgZmlsdGVycyBvdXQgc3lzdGVtIG1lc3NhZ2VzIGFuZCBhZGRzIGEgc3lzdGVtIG1lc3NhZ2UgcHJpb3IgdG8gdGhlIGxhc3QgdXNlciBtZXNzYWdlLlxuICogQHJldHVybnMge09iamVjdH0gLSBUaGUgQW50aHJvcGljIG9iamVjdFxuICovXG5mdW5jdGlvbiBjaGF0bWxfdG9fYW50aHJvcGljKG9wdHMpIHtcbiAgY29uc3QgbWVzc2FnZXMgPSBvcHRzLm1lc3NhZ2VzXG4gICAgLmZpbHRlcihtc2cgPT4gbXNnLnJvbGUgIT09ICdzeXN0ZW0nKVxuICAgIC5tYXAobSA9PiB7XG4gICAgICBpZih0eXBlb2YgbS5jb250ZW50ID09PSAnc3RyaW5nJykgcmV0dXJuIHsgcm9sZTogbS5yb2xlLCBjb250ZW50OiBtLmNvbnRlbnQgfTtcbiAgICAgIGlmKEFycmF5LmlzQXJyYXkobS5jb250ZW50KSl7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBtLmNvbnRlbnQubWFwKGMgPT4ge1xuICAgICAgICAgIGlmKGMudHlwZSA9PT0gJ3RleHQnKSByZXR1cm4ge3R5cGU6ICd0ZXh0JywgdGV4dDogYy50ZXh0fTtcbiAgICAgICAgICBpZihjLnR5cGUgPT09ICdpbWFnZV91cmwnKXtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlX3VybCA9IGMuaW1hZ2VfdXJsLnVybDtcbiAgICAgICAgICAgIGxldCBtZWRpYV90eXBlID0gaW1hZ2VfdXJsLnNwbGl0KFwiOlwiKVsxXS5zcGxpdChcIjtcIilbMF07XG4gICAgICAgICAgICBpZihtZWRpYV90eXBlID09PSAnaW1hZ2UvanBnJykgbWVkaWFfdHlwZSA9ICdpbWFnZS9qcGVnJztcbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogJ2ltYWdlJywgc291cmNlOiB7dHlwZTogJ2Jhc2U2NCcsIG1lZGlhX3R5cGU6IG1lZGlhX3R5cGUsIGRhdGE6IGltYWdlX3VybC5zcGxpdChcIixcIilbMV19fTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyByb2xlOiBtLnJvbGUsIGNvbnRlbnQgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtO1xuICAgIH0pXG4gIDtcbiAgY29uc3QgeyBtb2RlbCwgbWF4X3Rva2VucywgdGVtcGVyYXR1cmUsIHRvb2xzLCB9ID0gb3B0cztcbiAgLy8gRE86IGhhbmRsZWQgYmV0dGVyIChTbWFydCBDb25uZWN0aW9ucyBzcGVjaWZpYylcbiAgLy8gZ2V0IGluZGV4IG9mIGxhc3Qgc3lzdGVtIG1lc3NhZ2VcbiAgY29uc3QgbGFzdF9zeXN0ZW1faWR4ID0gb3B0cy5tZXNzYWdlcy5maW5kTGFzdEluZGV4KG1zZyA9PiBtc2cucm9sZSA9PT0gJ3N5c3RlbScgJiYgbXNnLmNvbnRlbnQuaW5jbHVkZXMoJy0tLUJFR0lOJykpO1xuICBpZiAobGFzdF9zeXN0ZW1faWR4ID4gLTEpIHtcbiAgICBjb25zdCBzeXN0ZW1fcHJvbXB0ID0gJzxjb250ZXh0PlxcbicgKyBvcHRzLm1lc3NhZ2VzW2xhc3Rfc3lzdGVtX2lkeF0uY29udGVudCArICdcXG48L2NvbnRleHQ+XFxuJztcbiAgICBtZXNzYWdlc1ttZXNzYWdlcy5sZW5ndGggLSAxXS5jb250ZW50ID0gc3lzdGVtX3Byb21wdCArIG1lc3NhZ2VzW21lc3NhZ2VzLmxlbmd0aCAtIDFdLmNvbnRlbnQ7XG4gIH1cbiAgY29uc29sZS5sb2cobWVzc2FnZXMpO1xuICBjb25zdCBvdXQgPSB7XG4gICAgbWVzc2FnZXMsXG4gICAgbW9kZWwsXG4gICAgbWF4X3Rva2VucyxcbiAgICB0ZW1wZXJhdHVyZSxcbiAgfVxuICBpZih0b29scyl7XG4gICAgb3V0LnRvb2xzID0gdG9vbHMubWFwKHRvb2wgPT4gKHtcbiAgICAgIG5hbWU6IHRvb2wuZnVuY3Rpb24ubmFtZSxcbiAgICAgIGRlc2NyaXB0aW9uOiB0b29sLmZ1bmN0aW9uLmRlc2NyaXB0aW9uLFxuICAgICAgaW5wdXRfc2NoZW1hOiB0b29sLmZ1bmN0aW9uLnBhcmFtZXRlcnMsXG4gICAgfSkpO1xuICAgIC8vIGFkZCBcIlVzZSB0aGUgJHt0b29sLm5hbWV9IHRvb2xcIiB0byB0aGUgbGFzdCB1c2VyIG1lc3NhZ2VcbiAgICBjb25zdCB0b29sX3Byb21wdCA9IGBVc2UgdGhlIFwiJHtvdXQudG9vbHNbMF0ubmFtZX1cIiB0b29sIWA7XG4gICAgY29uc3QgbGFzdF91c2VyX2lkeCA9IG91dC5tZXNzYWdlcy5maW5kTGFzdEluZGV4KG1zZyA9PiBtc2cucm9sZSA9PT0gJ3VzZXInKTtcbiAgICBvdXQubWVzc2FnZXNbbGFzdF91c2VyX2lkeF0uY29udGVudCArPSAnXFxuJyArIHRvb2xfcHJvbXB0O1xuICAgIG91dC5zeXN0ZW0gPSBgUmVxdWlyZWQ6IHVzZSB0aGUgXCIke291dC50b29sc1swXS5uYW1lfVwiIHRvb2whYDtcbiAgfVxuICAvLyBETzogaGFuZGxlZCBiZXR0ZXIgKFNtYXJ0IENvbm5lY3Rpb25zIHNwZWNpZmljKVxuICAvLyBpZiBzeXN0ZW0gbWVzc2FnZSBleGlzdHMgcHJpb3IgdG8gbGFzdF9zeXN0ZW1faWR4IEFORCBkb2VzIG5vdCBpbmNsdWRlIFwiLS0tQkVHSU5cIiB0aGVuIGFkZCB0byBib2R5LnN5c3RlbVxuICBjb25zdCBsYXN0X25vbl9jb250ZXh0X3N5c3RlbV9pZHggPSBvcHRzLm1lc3NhZ2VzLmZpbmRMYXN0SW5kZXgobXNnID0+IG1zZy5yb2xlID09PSAnc3lzdGVtJyAmJiAhbXNnLmNvbnRlbnQuaW5jbHVkZXMoJy0tLUJFR0lOJykpO1xuICBpZihsYXN0X25vbl9jb250ZXh0X3N5c3RlbV9pZHggPiAtMSkgb3V0LnN5c3RlbSA9IG9wdHMubWVzc2FnZXNbbGFzdF9ub25fY29udGV4dF9zeXN0ZW1faWR4XS5jb250ZW50O1xuICByZXR1cm4gb3V0O1xufVxuZXhwb3J0cy5jaGF0bWxfdG9fYW50aHJvcGljID0gY2hhdG1sX3RvX2FudGhyb3BpYztcblxuIiwgIi8qKlxuICogQ29oZXJlQWRhcHRlciBjbGFzcyBpcyBkZXNpZ25lZCB0byBhZGFwdCB0aGUgU21hcnRDaGF0TW9kZWwncyBpbnRlcmFjdGlvbiB3aXRoIHRoZSBDb2hlcmUgQVBJLlxuICogSXQgcHJvdmlkZXMgbWV0aG9kcyB0byBwcmVwYXJlIHJlcXVlc3QgYm9kaWVzLCBoYW5kbGUgc3RyZWFtaW5nIGRhdGEsIGFuZCBleHRyYWN0IG1lc3NhZ2UgY29udGVudCBmcm9tIHJlc3BvbnNlcy5cbiAqL1xuY2xhc3MgQ29oZXJlQWRhcHRlciB7XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIENoYXRNTCBvYmplY3QgdG8gYSBmb3JtYXQgc3VpdGFibGUgZm9yIGEgcmVxdWVzdCB0byB0aGUgQ29oZXJlIEFQSS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGNoYXRtbCAtIFRoZSBDaGF0TUwgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNoYXQgaGlzdG9yeSBhbmQgb3RoZXIgcGFyYW1ldGVycy5cbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIHJlcXVlc3QgYm9keSBmb3JtYXR0ZWQgZm9yIHRoZSBDb2hlcmUgQVBJLlxuICAgKi9cbiAgcHJlcGFyZV9yZXF1ZXN0X2JvZHkoY2hhdG1sKSB7IHJldHVybiBjaGF0bWxfdG9fY29oZXJlKGNoYXRtbCk7IH1cblxuICAvKipcbiAgICogRXh0cmFjdHMgdGhlIG1lc3NhZ2UgY29udGVudCBmcm9tIGEgSlNPTiByZXNwb25zZSBmcm9tIHRoZSBDb2hlcmUgQVBJLlxuICAgKiBAcGFyYW0ge09iamVjdH0ganNvbiAtIFRoZSBKU09OIHJlc3BvbnNlIG9iamVjdCBmcm9tIHdoaWNoIHRvIGV4dHJhY3QgdGhlIHRleHQgY29udGVudC5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGV4dHJhY3RlZCB0ZXh0IGNvbnRlbnQgZnJvbSB0aGUgcmVzcG9uc2UuXG4gICAqL1xuICBnZXRfbWVzc2FnZV9jb250ZW50KGpzb24pIHsgcmV0dXJuIGpzb24udGV4dDsgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzZXMgc3RyZWFtaW5nIGRhdGEgcmVjZWl2ZWQgZnJvbSB0aGUgQ29oZXJlIEFQSSBhbmQgZXh0cmFjdHMgdGV4dCBjaHVua3MuXG4gICAqIFRoaXMgbWV0aG9kIGhhbmRsZXMgdGhlIGFjY3VtdWxhdGlvbiBvZiB0ZXh0IGRhdGEgb3ZlciBtdWx0aXBsZSBldmVudHMgYW5kIG1hbmFnZXMgdGhlIHN0YXRlIG9mIHRoZSBzdHJlYW0uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIFRoZSBldmVudCBvYmplY3QgY29udGFpbmluZyBzdHJlYW1pbmcgZGF0YS5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGFjY3VtdWxhdGVkIHRleHQgY2h1bmsgZXh0cmFjdGVkIGZyb20gdGhlIHN0cmVhbS5cbiAgICovXG4gIGdldF90ZXh0X2NodW5rX2Zyb21fc3RyZWFtKGV2ZW50KSB7XG4gICAgaWYoIXRoaXMubGFzdF9saW5lX2luZGV4KSB0aGlzLmxhc3RfbGluZV9pbmRleCA9IDA7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMubGFzdF9saW5lX3RpbWVvdXQpO1xuICAgIHRoaXMubGFzdF9saW5lX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5sYXN0X2xpbmVfaW5kZXggPSAwO1xuICAgIH0sIDEwMDAwKTtcbiAgICBjb25zdCBkYXRhID0gZXZlbnQuc291cmNlLnhoci5yZXNwb25zZVRleHQ7XG4gICAgLy8gc3BsaXQgYnkgbmV3bGluZSBhbmQgZ2V0IGxhc3RcbiAgICBjb25zdCBsaW5lcyA9IGRhdGEuc3BsaXQoJ1xcbicpLnNsaWNlKHRoaXMubGFzdF9saW5lX2luZGV4KTtcbiAgICBjb25zb2xlLmxvZyhsaW5lcyk7XG4gICAgdGhpcy5sYXN0X2xpbmVfaW5kZXggKz0gbGluZXMubGVuZ3RoO1xuICAgIGNvbnN0IHRleHRfY2h1bmsgPSBsaW5lc1xuICAgICAgICAuZmlsdGVyKChsaW5lKSA9PiBsaW5lLnRyaW0oKSAhPT0gJycpXG4gICAgICAgIC5tYXAoKGxpbmUpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGxpbmUpO1xuICAgICAgICAgICAgY29uc3QganNvbiA9IEpTT04ucGFyc2UobGluZSk7XG4gICAgICAgICAgICBpZihqc29uLmV2ZW50X3R5cGUgPT09ICdzdHJlYW0tZW5kJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdzdHJlYW0tZW5kJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmRfb2Zfc3RyZWFtID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRfb2Zfc3RyZWFtID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSwgMzAwMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGpzb24udGV4dDtcbiAgICAgICAgfSlcbiAgICAgICAgLmpvaW4oJycpO1xuICAgIGNvbnNvbGUubG9nKHRleHRfY2h1bmspO1xuICAgIHJldHVybiB0ZXh0X2NodW5rO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgdGhlIGVuZCBvZiB0aGUgc3RyZWFtIGhhcyBiZWVuIHJlYWNoZWQgYmFzZWQgb24gdGhlIGV2ZW50IGRhdGEuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIFRoZSBldmVudCBvYmplY3QgdGhhdCBtYXkgaW5kaWNhdGUgdGhlIGVuZCBvZiB0aGUgc3RyZWFtLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZW5kIG9mIHRoZSBzdHJlYW0gaXMgaW5kaWNhdGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc19lbmRfb2Zfc3RyZWFtKGV2ZW50KSB7IHJldHVybiB0aGlzLmVuZF9vZl9zdHJlYW07IH1cbn1cbmV4cG9ydHMuQ29oZXJlQWRhcHRlciA9IENvaGVyZUFkYXB0ZXI7XG5cbi8qKlxuICogQ29udmVydHMgYSBDaGF0TUwgb2JqZWN0IGludG8gYSBmb3JtYXQgc3VpdGFibGUgZm9yIHRoZSBDb2hlcmUgQVBJLlxuICogVGhpcyBmdW5jdGlvbiBwcmVwYXJlcyB0aGUgZGF0YSBieSBzdHJ1Y3R1cmluZyBpdCBhY2NvcmRpbmcgdG8gdGhlIHJlcXVpcmVtZW50cyBvZiB0aGUgQ29oZXJlIEFQSSxcbiAqIGluY2x1ZGluZyB0aGUgbW9kZWwgdG8gdXNlLCB0aGUgY2hhdCBoaXN0b3J5IGV4Y2x1ZGluZyB0aGUgbGFzdCB1c2VyIG1lc3NhZ2UsIGFuZCB0aGUgbGFzdCBtZXNzYWdlIHNlcGFyYXRlbHkuXG4gKiBcbiAqIEBwYXJhbSB7T2JqZWN0fSBjaGF0bWwgLSBUaGUgQ2hhdE1MIG9iamVjdCBjb250YWluaW5nIHRoZSBtb2RlbCwgbWVzc2FnZXMsIGFuZCBvdGhlciBwYXJhbWV0ZXJzIGxpa2UgdGVtcGVyYXR1cmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZm9ybWF0dGVkIG9iamVjdCBmb3IgdGhlIENvaGVyZSBBUEkgcmVxdWVzdCwgY29udGFpbmluZyB0aGUgbW9kZWwsIGNoYXQgaGlzdG9yeSwgbGFzdCBtZXNzYWdlLCBhbmQgdGVtcGVyYXR1cmUuXG4gKi9cbmZ1bmN0aW9uIGNoYXRtbF90b19jb2hlcmUoY2hhdG1sKSB7XG4gICAgY29uc3QgY29oZXJlID0ge1xuICAgICAgICBtb2RlbDogY2hhdG1sLm1vZGVsLFxuICAgICAgICAvLyBza2lwIGxhc3QgdXNlciBtZXNzYWdlXG4gICAgICAgIGNoYXRfaGlzdG9yeTogY2hhdG1sLm1lc3NhZ2VzXG4gICAgICAgICAgICAuc2xpY2UoMCwgLTEpXG4gICAgICAgICAgICAubWFwKChtZXNzYWdlKSA9PiAoe1xuICAgICAgICAgICAgICAgIHJvbGU6IG1lc3NhZ2Uucm9sZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBwYXJzZV9tZXNzYWdlX2NvbnRlbnRfdG9fc3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICAgICAgfSkpXG4gICAgICAgICxcbiAgICAgICAgbWVzc2FnZTogcGFyc2VfbWVzc2FnZV9jb250ZW50X3RvX3N0cmluZyhjaGF0bWwubWVzc2FnZXNbY2hhdG1sLm1lc3NhZ2VzLmxlbmd0aCAtIDFdKSxcbiAgICAgICAgdGVtcGVyYXR1cmU6IGNoYXRtbC50ZW1wZXJhdHVyZSxcbiAgICAgICAgLy8gc3RyZWFtOiBjaGF0bWwuc3RyZWFtIC8vIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkXG4gICAgfTtcbiAgICByZXR1cm4gY29oZXJlO1xufVxuZXhwb3J0cy5jaGF0bWxfdG9fY29oZXJlID0gY2hhdG1sX3RvX2NvaGVyZTtcblxuZnVuY3Rpb24gcGFyc2VfbWVzc2FnZV9jb250ZW50X3RvX3N0cmluZyhtZXNzYWdlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkobWVzc2FnZS5jb250ZW50KSA/IG1lc3NhZ2UuY29udGVudC5maWx0ZXIoYyA9PiBjLnR5cGUgPT09ICd0ZXh0JykubWFwKGMgPT4gYy50ZXh0KS5qb2luKCdcXG4nKSA6IG1lc3NhZ2UuY29udGVudDtcbn1cblxuIiwgIi8qKlxuICogR2VtaW5pQWRhcHRlciBjbGFzcyBwcm92aWRlcyBtZXRob2RzIHRvIGFkYXB0IHRoZSBjaGF0IG1vZGVsIGludGVyYWN0aW9ucyBzcGVjaWZpY2FsbHkgZm9yIHRoZSBHZW1pbmkgbW9kZWwuXG4gKiBJdCBpbmNsdWRlcyBtZXRob2RzIHRvIHByZXBhcmUgcmVxdWVzdCBib2RpZXMsIGhhbmRsZSB0b29sIGNhbGxzIGFuZCBtZXNzYWdlcywgYW5kIG1hbmFnZSBzdHJlYW1pbmcgcmVzcG9uc2VzLlxuICovXG5jbGFzcyBHZW1pbmlBZGFwdGVyIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBHZW1pbmlBZGFwdGVyIGluc3RhbmNlIHdpdGggYSBzcGVjaWZpZWQgbW9kZWwgY29uZmlndXJhdGlvbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsIC0gVGhlIG1vZGVsIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgKi9cbiAgY29uc3RydWN0b3IobW9kZWwpIHsgdGhpcy5tb2RlbCA9IG1vZGVsOyB9XG5cbiAgLyoqXG4gICAqIFByZXBhcmVzIHRoZSByZXF1ZXN0IGJvZHkgZm9yIHRoZSBHZW1pbmkgQVBJIGJ5IGNvbnZlcnRpbmcgQ2hhdE1MIGZvcm1hdCB0byBhIGZvcm1hdCBjb21wYXRpYmxlIHdpdGggR2VtaW5pLlxuICAgKiBAcGFyYW0ge09iamVjdH0gYm9keSAtIFRoZSBvcHRpb25zIG9iamVjdCBjb250YWluaW5nIG1lc3NhZ2VzIGFuZCBvdGhlciBwYXJhbWV0ZXJzIGluIENoYXRNTCBmb3JtYXQuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSByZXF1ZXN0IGJvZHkgZm9ybWF0dGVkIGZvciB0aGUgR2VtaW5pIEFQSS5cbiAgICovXG4gIHByZXBhcmVfcmVxdWVzdF9ib2R5KGJvZHkpIHsgcmV0dXJuIGNoYXRtbF90b19nZW1pbmkoYm9keSk7IH1cblxuICAvKipcbiAgICogRXh0cmFjdHMgdGhlIGZpcnN0IHRvb2wgY2FsbCBmcm9tIHRoZSBKU09OIHJlc3BvbnNlIGNvbnRlbnQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBqc29uIC0gVGhlIEpTT04gcmVzcG9uc2UgZnJvbSB3aGljaCB0byBleHRyYWN0IHRoZSB0b29sIGNhbGwuXG4gICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH0gVGhlIGZpcnN0IHRvb2wgY2FsbCBmb3VuZCwgb3IgbnVsbCBpZiBub25lIGV4aXN0LlxuICAgKi9cbiAgZ2V0X3Rvb2xfY2FsbChqc29uKSB7IHJldHVybiBqc29uLmNhbmRpZGF0ZXM/LlswXT8uY29udGVudD8ucGFydHM/LlswXT8uZnVuY3Rpb25DYWxsOyB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgbmFtZSBvZiB0aGUgdG9vbCBmcm9tIGEgdG9vbCBjYWxsIG9iamVjdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHRvb2xfY2FsbCAtIFRoZSB0b29sIGNhbGwgb2JqZWN0IGZyb20gd2hpY2ggdG8gZXh0cmFjdCB0aGUgbmFtZS5cbiAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBUaGUgbmFtZSBvZiB0aGUgdG9vbCwgb3IgbnVsbCBpZiBub3QgYXZhaWxhYmxlLlxuICAgKi9cbiAgZ2V0X3Rvb2xfbmFtZSh0b29sX2NhbGwpIHsgcmV0dXJuIHRvb2xfY2FsbD8ubmFtZTsgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGlucHV0IGNvbnRlbnQgb2YgYSB0b29sIGNhbGwuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0b29sX2NhbGwgLSBUaGUgdG9vbCBjYWxsIG9iamVjdCBmcm9tIHdoaWNoIHRvIGV4dHJhY3QgdGhlIGlucHV0LlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9IFRoZSBpbnB1dCBvZiB0aGUgdG9vbCBjYWxsLCBvciBudWxsIGlmIG5vdCBhdmFpbGFibGUuXG4gICAqL1xuICBnZXRfdG9vbF9jYWxsX2NvbnRlbnQodG9vbF9jYWxsKSB7IHJldHVybiB0b29sX2NhbGw/LmFyZ3M7IH1cblxuICAvKipcbiAgICogRXh0cmFjdHMgdGhlIGZpcnN0IG1lc3NhZ2UgZnJvbSB0aGUgSlNPTiByZXNwb25zZSBjb250ZW50LlxuICAgKiBAcGFyYW0ge09iamVjdH0ganNvbiAtIFRoZSBKU09OIHJlc3BvbnNlIGZyb20gd2hpY2ggdG8gZXh0cmFjdCB0aGUgbWVzc2FnZS5cbiAgICogQHJldHVybnMge09iamVjdHxudWxsfSBUaGUgZmlyc3QgbWVzc2FnZSBmb3VuZCwgb3IgbnVsbCBpZiBub25lIGV4aXN0LlxuICAgKi9cbiAgZ2V0X21lc3NhZ2UoanNvbikgeyByZXR1cm4ganNvbi5jYW5kaWRhdGVzPy5bMF07IH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBjb250ZW50IG9mIHRoZSBmaXJzdCBtZXNzYWdlIGZyb20gdGhlIEpTT04gcmVzcG9uc2UuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBqc29uIC0gVGhlIEpTT04gcmVzcG9uc2UgZnJvbSB3aGljaCB0byBleHRyYWN0IHRoZSBtZXNzYWdlIGNvbnRlbnQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gVGhlIGNvbnRlbnQgb2YgdGhlIGZpcnN0IG1lc3NhZ2UsIG9yIG51bGwgaWYgbm8gbWVzc2FnZSBpcyBmb3VuZC5cbiAgICovXG4gIGdldF9tZXNzYWdlX2NvbnRlbnQoanNvbikgeyByZXR1cm4gdGhpcy5nZXRfbWVzc2FnZShqc29uKT8uY29udGVudD8ucGFydHMubWFwKHBhcnQgPT4gcGFydC50ZXh0KS5qb2luKCcnKTsgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGVzY2FwZWQgbmV3bGluZXMgaW4gYSBzdHJlYW1pbmcgdGV4dCBjaHVuay5cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gVGhlIHN0cmVhbWluZyBldmVudCBjb250YWluaW5nIHRoZSBkYXRhLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgdGV4dCBjaHVuayB3aXRoIGVzY2FwZWQgbmV3bGluZXMgcmVwbGFjZWQuXG4gICAqL1xuICBnZXRfdGV4dF9jaHVua19mcm9tX3N0cmVhbShldmVudCkgeyByZXR1cm4gZXZlbnQuZGF0YS5yZXBsYWNlKC9cXFxcbi9nLCAnXFxuJyk7IH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiB0aGUgc3RyZWFtaW5nIHJlc3BvbnNlIGhhcyBlbmRlZCBiYXNlZCBvbiB0aGUgcmVhZHlTdGF0ZSBvZiB0aGUgWE1MSHR0cFJlcXVlc3QuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIFRoZSBzdHJlYW1pbmcgZXZlbnQuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBzdHJlYW0gaGFzIGVuZGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc19lbmRfb2Zfc3RyZWFtKGV2ZW50KSB7IHJldHVybiBldmVudC5zb3VyY2UueGhyLnJlYWR5U3RhdGUgPT09IDQ7IH1cblxuICAvKipcbiAgICogQ291bnRzIHRoZSB0b2tlbnMgaW4gdGhlIGlucHV0IGJ5IG1ha2luZyBhbiBBUEkgcmVxdWVzdCB0byB0aGUgR2VtaW5pIHRva2VuIGNvdW50aW5nIGVuZHBvaW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGlucHV0IC0gVGhlIGlucHV0IHRleHQgb3Igb2JqZWN0IHRvIGNvdW50IHRva2VucyBpbi5cbiAgICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyPn0gVGhlIHRvdGFsIG51bWJlciBvZiB0b2tlbnMgaW4gdGhlIGlucHV0LlxuICAgKi9cbiAgYXN5bmMgY291bnRfdG9rZW5zKGlucHV0KSB7XG4gICAgY29uc3QgcmVxID0ge1xuICAgICAgdXJsOiBgaHR0cHM6Ly9nZW5lcmF0aXZlbGFuZ3VhZ2UuZ29vZ2xlYXBpcy5jb20vdjFiZXRhL21vZGVscy9nZW1pbmktcHJvOmNvdW50VG9rZW5zP2tleT0ke3RoaXMubW9kZWwuYXBpX2tleX1gLFxuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICB9O1xuICAgIGxldCBib2R5O1xuICAgIGlmKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIGJvZHkgPSBjaGF0bWxfdG9fZ2VtaW5pKHsgbWVzc2FnZXM6IFt7IHJvbGU6ICd1c2VyJywgY29udGVudDogaW5wdXQgfV0gfSk7XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIGJvZHkgPSBjaGF0bWxfdG9fZ2VtaW5pKHsgbWVzc2FnZXM6IGlucHV0IH0pO1xuICAgIGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcpIGJvZHkgPSBjaGF0bWxfdG9fZ2VtaW5pKGlucHV0KTtcbiAgICBlbHNlIHJldHVybiBjb25zb2xlLmVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgY291bnRfdG9rZW5zXCIsIGlucHV0KTtcbiAgICBkZWxldGUgYm9keS5nZW5lcmF0aW9uQ29uZmlnO1xuICAgIGRlbGV0ZSBib2R5LnNhZmV0eVNldHRpbmdzO1xuICAgIHJlcS5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG4gICAgY29uc3QgcmVzcCA9IGF3YWl0IHRoaXMubW9kZWwucmVxdWVzdF9hZGFwdGVyKHJlcSk7XG4gICAgcmV0dXJuIHJlc3A/Lmpzb24/LnRvdGFsVG9rZW5zO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHRlciBmb3IgdGhlIHN0YW5kYXJkIEFQSSBlbmRwb2ludCB3aXRoIHRoZSBBUEkga2V5IGFwcGVuZGVkLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIGVuZHBvaW50IFVSTCBmb3Igbm9uLXN0cmVhbWluZyByZXF1ZXN0cy5cbiAgICovXG4gIGdldCBlbmRwb2ludCgpIHsgcmV0dXJuIHRoaXMubW9kZWwuY29uZmlnLmVuZHBvaW50LnJlcGxhY2UoJ01PREVMX05BTUUnLCB0aGlzLm1vZGVsLm1vZGVsX25hbWUpICsgXCI/a2V5PVwiICsgdGhpcy5tb2RlbC5hcGlfa2V5OyB9XG5cbiAgLyoqXG4gICAqIEdldHRlciBmb3IgdGhlIHN0cmVhbWluZyBBUEkgZW5kcG9pbnQgd2l0aCB0aGUgQVBJIGtleSBhcHBlbmRlZC5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGZvcm1hdHRlZCBlbmRwb2ludCBVUkwgZm9yIHN0cmVhbWluZyByZXF1ZXN0cy5cbiAgICovXG4gIGdldCBlbmRwb2ludF9zdHJlYW1pbmcoKSB7IHJldHVybiB0aGlzLm1vZGVsLmNvbmZpZy5lbmRwb2ludF9zdHJlYW1pbmcucmVwbGFjZSgnTU9ERUxfTkFNRScsIHRoaXMubW9kZWwubW9kZWxfbmFtZSkgKyBcIj9rZXk9XCIgKyB0aGlzLm1vZGVsLmFwaV9rZXk7IH1cbn1cbmV4cG9ydHMuR2VtaW5pQWRhcHRlciA9IEdlbWluaUFkYXB0ZXI7XG5cbi8qKlxuICogQ29udmVydCBhIENoYXRNTCBvYmplY3QgdG8gYSBHZW1pbmkgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIFRoZSBDaGF0TUwgb2JqZWN0XG4gKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiBjb252ZXJ0cyBhIENoYXRNTCBvYmplY3QgdG8gYSBHZW1pbmkgb2JqZWN0LiBJdCBmaWx0ZXJzIG91dCBzeXN0ZW0gbWVzc2FnZXMgYW5kIGFkZHMgYSBzeXN0ZW0gbWVzc2FnZSBwcmlvciB0byB0aGUgbGFzdCB1c2VyIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSAtIFRoZSBHZW1pbmkgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGNoYXRtbF90b19nZW1pbmkob3B0cykge1xuICAvLyAvLyBkZWVwIGNvcHkgbWVzc2FnZXNcbiAgLy8gY29uc3QgbWVzc2FnZXMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9wdHMubWVzc2FnZXMpKS5maWx0ZXIobXNnID0+IG1zZy5yb2xlICE9PSAnc3lzdGVtJyk7XG4gIC8vIC8vIG1lcmdlIHN5c3RlbSByb2xlcyBpbnRvbSBzdWJzZXF1ZW50IHVzZXIgcm9sZXNcbiAgLy8gb3B0cy5tZXNzYWdlcy5mb3JFYWNoKChtc2csIGkpID0+IHtcbiAgLy8gICBpZiAobXNnLnJvbGUgPT09ICdzeXN0ZW0nKSB7XG4gIC8vICAgICBpZiAoIW1lc3NhZ2VzW2kgKyAxXSkgcmV0dXJuIGNvbnNvbGUuZXJyb3IoXCJTeXN0ZW0gbWVzc2FnZSB3aXRob3V0IHN1YnNlcXVlbnQgdXNlciBtZXNzYWdlXCIpO1xuICAvLyAgICAgY29uc3Qgc3lzdGVtX3Byb21wdCA9ICctLS1CRUdJTiBJTVBPUlRBTlQgQ09OVEVYVC0tLVxcbicgKyBtc2cuY29udGVudCArICdcXG4tLS1FTkQgSU1QT1JUQU5UIENPTlRFWFQtLS1cXG5cXG4nO1xuICAvLyAgICAgbWVzc2FnZXNbaSArIDFdLmNvbnRlbnQgPSBzeXN0ZW1fcHJvbXB0ICsgKG1lc3NhZ2VzW2kgKyAxXS5jb250ZW50IHx8ICcnKTtcbiAgLy8gICB9XG4gIC8vIH0pO1xuICBjb25zdCBtZXNzYWdlcyA9IG9wdHMubWVzc2FnZXMuZmlsdGVyKG1zZyA9PiBtc2cucm9sZSAhPT0gJ3N5c3RlbScpO1xuICAvLyBETzogaGFuZGxlZCBiZXR0ZXIgKFNtYXJ0IENvbm5lY3Rpb25zIHNwZWNpZmljKVxuICAvLyBnZXQgaW5kZXggb2YgbGFzdCBzeXN0ZW0gbWVzc2FnZVxuICBjb25zdCBsYXN0X3N5c3RlbV9pZHggPSBvcHRzLm1lc3NhZ2VzLmZpbmRMYXN0SW5kZXgobXNnID0+IG1zZy5yb2xlID09PSAnc3lzdGVtJyAmJiBtc2cuY29udGVudC5pbmNsdWRlcygnLS0tQkVHSU4nKSk7XG4gIGlmIChsYXN0X3N5c3RlbV9pZHggPiAtMSkge1xuICAgIGNvbnN0IHN5c3RlbV9wcm9tcHQgPSAnLS0tQkVHSU4gSU1QT1JUQU5UIENPTlRFWFQtLS1cXG4nICsgb3B0cy5tZXNzYWdlc1tsYXN0X3N5c3RlbV9pZHhdLmNvbnRlbnQgKyAnXFxuLS0tRU5EIElNUE9SVEFOVCBDT05URVhULS0tXFxuXFxuJztcbiAgICBtZXNzYWdlc1ttZXNzYWdlcy5sZW5ndGggLSAxXS5jb250ZW50ID0gc3lzdGVtX3Byb21wdCArIG1lc3NhZ2VzW21lc3NhZ2VzLmxlbmd0aCAtIDFdLmNvbnRlbnQ7XG4gIH1cbiAgY29uc3QgYm9keSA9IHtcbiAgICBjb250ZW50czogbWVzc2FnZXNcbiAgICAgIC5maWx0ZXIobXNnID0+IG1zZy5yb2xlICE9PSAnc3lzdGVtJykgLy8gZmlsdGVyIG91dCBzeXN0ZW0gbWVzc2FnZXNcbiAgICAgIC5tYXAobXNnID0+IHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IHt9O1xuICAgICAgICBjb250ZW50LnJvbGUgPSBtc2cucm9sZSA9PT0gJ2Fzc2lzdGFudCcgPyAnbW9kZWwnIDogbXNnLnJvbGU7XG4gICAgICAgIGNvbnRlbnQucGFydHMgPSAhQXJyYXkuaXNBcnJheShtc2cuY29udGVudCkgPyBbe3RleHQ6IG1zZy5jb250ZW50fV0gOiBtc2cuY29udGVudC5tYXAoYyA9PiB7XG4gICAgICAgICAgaWYoYy50eXBlID09PSAndGV4dCcpe1xuICAgICAgICAgICAgcmV0dXJuIHt0ZXh0OiBjLnRleHR9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihjLnR5cGUgPT09ICdpbWFnZV91cmwnKXtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlX3VybCA9IGMuaW1hZ2VfdXJsLnVybDtcbiAgICAgICAgICAgIGxldCBtaW1lX3R5cGUgPSBpbWFnZV91cmwuc3BsaXQoXCI6XCIpWzFdLnNwbGl0KFwiO1wiKVswXTtcbiAgICAgICAgICAgIGlmKG1pbWVfdHlwZSA9PT0gJ2ltYWdlL2pwZycpIG1pbWVfdHlwZSA9ICdpbWFnZS9qcGVnJztcbiAgICAgICAgICAgIHJldHVybiB7aW5saW5lX2RhdGE6IHttaW1lX3R5cGU6IG1pbWVfdHlwZSwgZGF0YTogaW1hZ2VfdXJsLnNwbGl0KFwiLFwiKVsxXX19O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgICAoe1xuICAgICAgICAgIHJvbGU6IG1zZy5yb2xlID09PSAnYXNzaXN0YW50JyA/ICdtb2RlbCcgOiBtc2cucm9sZSxcbiAgICAgICAgICBwYXJ0czogQXJyYXkuaXNBcnJheShtc2cuY29udGVudCkgPyBbe3RleHQ6IG1zZy5jb250ZW50LmZpbHRlcihjID0+IGMudHlwZSA9PT0gJ3RleHQnKS5tYXAoYyA9PiBjLnRleHQpLmpvaW4oJ1xcbicpfV0gOiBbeyB0ZXh0OiBtc2cuY29udGVudCB9XVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICAsXG4gICAgZ2VuZXJhdGlvbkNvbmZpZzoge1xuICAgICAgdGVtcGVyYXR1cmU6IG9wdHMudGVtcGVyYXR1cmUgfHwgMC45LFxuICAgICAgdG9wSzogb3B0cy50b3BLIHx8IDEsXG4gICAgICB0b3BQOiBvcHRzLnRvcFAgfHwgMSxcbiAgICAgIG1heE91dHB1dFRva2Vuczogb3B0cy5tYXhfdG9rZW5zIHx8IDIwNDgsXG4gICAgICBzdG9wU2VxdWVuY2VzOiBvcHRzLnN0b3BTZXF1ZW5jZXMgfHwgW10sXG4gICAgICBjYW5kaWRhdGVfY291bnQ6IG9wdHMubiB8fCAxLFxuICAgIH0sXG4gICAgc2FmZXR5U2V0dGluZ3M6IFtcbiAgICAgIHtcbiAgICAgICAgY2F0ZWdvcnk6IFwiSEFSTV9DQVRFR09SWV9IQVJBU1NNRU5UXCIsXG4gICAgICAgIHRocmVzaG9sZDogXCJCTE9DS19OT05FXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNhdGVnb3J5OiBcIkhBUk1fQ0FURUdPUllfSEFURV9TUEVFQ0hcIixcbiAgICAgICAgdGhyZXNob2xkOiBcIkJMT0NLX05PTkVcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2F0ZWdvcnk6IFwiSEFSTV9DQVRFR09SWV9TRVhVQUxMWV9FWFBMSUNJVFwiLFxuICAgICAgICB0aHJlc2hvbGQ6IFwiQkxPQ0tfTk9ORVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjYXRlZ29yeTogXCJIQVJNX0NBVEVHT1JZX0RBTkdFUk9VU19DT05URU5UXCIsXG4gICAgICAgIHRocmVzaG9sZDogXCJCTE9DS19OT05FXCJcbiAgICAgIH1cbiAgICBdXG4gIH07XG4gIGNvbnN0IHN5c3RlbV9pbnN0cnVjdGlvbnMgPSBvcHRzLm1lc3NhZ2VzLmZpbHRlcihtc2cgPT4gbXNnLnJvbGUgPT09ICdzeXN0ZW0nICYmICFtc2cuY29udGVudC5pbmNsdWRlcygnLS0tQkVHSU4nKSk7XG4gIGlmKHN5c3RlbV9pbnN0cnVjdGlvbnMubGVuZ3RoID4gMCkgYm9keS5zeXN0ZW1JbnN0cnVjdGlvbiA9IHsgcGFydHM6IHN5c3RlbV9pbnN0cnVjdGlvbnMubWFwKG1zZyA9PiAoeyB0ZXh0OiBtc2cuY29udGVudCB9KSkgfTtcbiAgaWYob3B0cy50b29scyl7XG4gICAgYm9keS50b29scyA9IFt7XG4gICAgICBmdW5jdGlvbl9kZWNsYXJhdGlvbnM6IG9wdHMudG9vbHMubWFwKHRvb2wgPT4gKHtcbiAgICAgICAgbmFtZTogdG9vbC5mdW5jdGlvbi5uYW1lLFxuICAgICAgICBkZXNjcmlwdGlvbjogdG9vbC5mdW5jdGlvbi5kZXNjcmlwdGlvbixcbiAgICAgICAgcGFyYW1ldGVyczogdG9vbC5mdW5jdGlvbi5wYXJhbWV0ZXJzLFxuICAgICAgfSkpXG4gICAgfV07XG4gICAgYm9keS50b29sX2NvbmZpZyA9IHtcbiAgICAgIGZ1bmN0aW9uX2NhbGxpbmdfY29uZmlnOiB7XG4gICAgICAgIG1vZGU6IFwiQU5ZXCJcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHRvb2xfcHJvbXB0ID0gYFVzZSB0aGUgXCIke2JvZHkudG9vbHNbMF0uZnVuY3Rpb25fZGVjbGFyYXRpb25zWzBdLm5hbWV9XCIgdG9vbCFgO1xuICAgIGNvbnN0IGxhc3RfdXNlcl9pZHggPSBib2R5LmNvbnRlbnRzLmZpbmRMYXN0SW5kZXgobXNnID0+IG1zZy5yb2xlID09PSAndXNlcicpO1xuICAgIGJvZHkuY29udGVudHNbbGFzdF91c2VyX2lkeF0ucGFydHNbMF0udGV4dCArPSAnXFxuJyArIHRvb2xfcHJvbXB0O1xuICB9XG4gIHJldHVybiBib2R5O1xufVxuZXhwb3J0cy5jaGF0bWxfdG9fZ2VtaW5pID0gY2hhdG1sX3RvX2dlbWluaTsiLCAiY29uc3QgeyBBbnRocm9waWNBZGFwdGVyIH0gPSByZXF1aXJlKCcuL2FkYXB0ZXJzL2FudGhyb3BpYycpO1xuY29uc3QgeyBDb2hlcmVBZGFwdGVyIH0gPSByZXF1aXJlKCcuL2FkYXB0ZXJzL2NvaGVyZScpO1xuY29uc3QgeyBHZW1pbmlBZGFwdGVyIH0gPSByZXF1aXJlKCcuL2FkYXB0ZXJzL2dlbWluaScpO1xuZXhwb3J0cy5BbnRocm9waWMgPSBBbnRocm9waWNBZGFwdGVyO1xuZXhwb3J0cy5Db2hlcmUgPSBDb2hlcmVBZGFwdGVyO1xuZXhwb3J0cy5HZW1pbmkgPSBHZW1pbmlBZGFwdGVyO1xuXG4iLCAie1xuICBcIm9wZW5haVwiOiB7XG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIk9wZW5BSVwiLFxuICAgIFwidHlwZVwiOiBcIkFQSVwiLFxuICAgIFwiZW5kcG9pbnRcIjogXCJodHRwczovL2FwaS5vcGVuYWkuY29tL3YxL2NoYXQvY29tcGxldGlvbnNcIixcbiAgICBcInN0cmVhbWluZ1wiOiB0cnVlLFxuICAgIFwiYWN0aW9uc1wiOiB0cnVlLFxuICAgIFwiZmV0Y2hfbW9kZWxzXCI6IHRydWUsXG4gICAgXCJkZWZhdWx0X21vZGVsXCI6IFwiZ3B0LTMuNS10dXJib1wiLFxuICAgIFwic2lnbnVwX3VybFwiOiBcImh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9hcGkta2V5c1wiXG4gIH0sXG4gIFwiZ29vZ2xlX2dlbWluaVwiOiB7XG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkdvb2dsZSBHZW1pbmlcIixcbiAgICBcInR5cGVcIjogXCJBUElcIixcbiAgICBcImFwaV9rZXlfaGVhZGVyXCI6IFwibm9uZVwiLFxuICAgIFwiZW5kcG9pbnRcIjogXCJodHRwczovL2dlbmVyYXRpdmVsYW5ndWFnZS5nb29nbGVhcGlzLmNvbS92MWJldGEvbW9kZWxzL01PREVMX05BTUU6Z2VuZXJhdGVDb250ZW50XCIsXG4gICAgXCJlbmRwb2ludF9zdHJlYW1pbmdcIjogXCJodHRwczovL2dlbmVyYXRpdmVsYW5ndWFnZS5nb29nbGVhcGlzLmNvbS92MWJldGEvbW9kZWxzL01PREVMX05BTUU6c3RyZWFtR2VuZXJhdGVDb250ZW50XCIsXG4gICAgXCJzdHJlYW1pbmdcIjogdHJ1ZSxcbiAgICBcImFjdGlvbnNcIjogdHJ1ZSxcbiAgICBcImFkYXB0ZXJcIjogXCJHZW1pbmlcIixcbiAgICBcImZldGNoX21vZGVsc1wiOiB0cnVlLFxuICAgIFwiZGVmYXVsdF9tb2RlbFwiOiBcImdlbWluaS0xLjAtcHJvXCIsXG4gICAgXCJzaWdudXBfdXJsXCI6IFwiaHR0cHM6Ly9haS5nb29nbGUuZGV2L1wiXG4gIH0sXG4gIFwib3Blbl9yb3V0ZXJcIjoge1xuICAgIFwiZGVzY3JpcHRpb25cIjogXCJPcGVuIFJvdXRlclwiLFxuICAgIFwidHlwZVwiOiBcIkFQSVwiLFxuICAgIFwiZW5kcG9pbnRcIjogXCJodHRwczovL29wZW5yb3V0ZXIuYWkvYXBpL3YxL2NoYXQvY29tcGxldGlvbnNcIixcbiAgICBcInN0cmVhbWluZ1wiOiB0cnVlLFxuICAgIFwiZmV0Y2hfbW9kZWxzXCI6IHRydWUsXG4gICAgXCJkZWZhdWx0X21vZGVsXCI6IFwibWlzdHJhbGFpL21pc3RyYWwtN2ItaW5zdHJ1Y3Q6ZnJlZVwiLFxuICAgIFwic2lnbnVwX3VybFwiOiBcImh0dHBzOi8vYWNjb3VudHMub3BlbnJvdXRlci5haS9zaWduLXVwP3JlZGlyZWN0X3VybD1odHRwcyUzQSUyRiUyRm9wZW5yb3V0ZXIuYWklMkZrZXlzXCJcbiAgfSxcbiAgXCJjb2hlcmVcIjoge1xuICAgIFwiZGVzY3JpcHRpb25cIjogXCJDb2hlcmUgQ29tbWFuZC1SXCIsXG4gICAgXCJ0eXBlXCI6IFwiQVBJXCIsXG4gICAgXCJlbmRwb2ludFwiOiBcImh0dHBzOi8vYXBpLmNvaGVyZS5haS92MS9jaGF0XCIsXG4gICAgXCJzdHJlYW1pbmdcIjogZmFsc2UsXG4gICAgXCJhZGFwdGVyXCI6IFwiQ29oZXJlXCIsXG4gICAgXCJmZXRjaF9tb2RlbHNcIjogdHJ1ZSxcbiAgICBcImRlZmF1bHRfbW9kZWxcIjogXCJjb21tYW5kLXJcIixcbiAgICBcInNpZ251cF91cmxcIjogXCJodHRwczovL2Rhc2hib2FyZC5jb2hlcmUuY29tL3dlbGNvbWUvcmVnaXN0ZXI/cmVkaXJlY3RfdXJpPSUyRmFwaS1rZXlzXCJcbiAgfSxcbiAgXCJhbnRocm9waWNcIjoge1xuICAgIFwiZGVzY3JpcHRpb25cIjogXCJBbnRocm9waWMgQ2xhdWRlXCIsXG4gICAgXCJ0eXBlXCI6IFwiQVBJXCIsXG4gICAgXCJlbmRwb2ludFwiOiBcImh0dHBzOi8vYXBpLmFudGhyb3BpYy5jb20vdjEvbWVzc2FnZXNcIixcbiAgICBcInN0cmVhbWluZ1wiOiBmYWxzZSxcbiAgICBcImFwaV9rZXlfaGVhZGVyXCI6IFwieC1hcGkta2V5XCIsXG4gICAgXCJoZWFkZXJzXCI6IHtcbiAgICAgIFwiYW50aHJvcGljLXZlcnNpb25cIjogXCIyMDIzLTA2LTAxXCIsXG4gICAgICBcImFudGhyb3BpYy1iZXRhXCI6IFwidG9vbHMtMjAyNC0wNC0wNFwiXG4gICAgfSxcbiAgICBcImFkYXB0ZXJcIjogXCJBbnRocm9waWNcIixcbiAgICBcImFjdGlvbnNcIjogdHJ1ZSxcbiAgICBcImZldGNoX21vZGVsc1wiOiB0cnVlLFxuICAgIFwiZGVmYXVsdF9tb2RlbFwiOiBcImNsYXVkZS0zLXNvbm5ldC0yMDI0MDIyOVwiLFxuICAgIFwic2lnbnVwX3VybFwiOiBcImh0dHBzOi8vY29uc29sZS5hbnRocm9waWMuY29tL2xvZ2luP3JldHVyblRvPSUyRnNldHRpbmdzJTJGa2V5c1wiXG4gIH0sXG4gIFwiY3VzdG9tX2xvY2FsXCI6IHtcbiAgICBcIm1vZGVsX25hbWVcIjogXCJjdXN0b21fbG9jYWxcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQ3VzdG9tIExvY2FsIChPcGVuQUkgZm9ybWF0KVwiLFxuICAgIFwidHlwZVwiOiBcIkFQSVwiXG4gIH0sXG4gIFwiY3VzdG9tX2FwaVwiOiB7XG4gICAgXCJtb2RlbF9uYW1lXCI6IFwiY3VzdG9tX2FwaVwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJDdXN0b20gQVBJIChPcGVuQUkgZm9ybWF0KVwiLFxuICAgIFwidHlwZVwiOiBcIkFQSVwiXG4gIH1cbn1cblxuIiwgIi8qKlxuICAgY29uc3QgdG9vbHNfZXhhbXBsZSA9IFtcbiAgICB7XG4gICAgICBcInR5cGVcIjogXCJmdW5jdGlvblwiLFxuICAgICAgXCJmdW5jdGlvblwiOiB7XG4gICAgICAgIFwibmFtZVwiOiBcImdldF9jdXJyZW50X3dlYXRoZXJcIixcbiAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkdldCB0aGUgY3VycmVudCB3ZWF0aGVyIGluIGEgZ2l2ZW4gbG9jYXRpb25cIixcbiAgICAgICAgXCJwYXJhbWV0ZXJzXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgICAgICAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiB7XG4gICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIGNpdHkgYW5kIHN0YXRlLCBlLmcuIFNhbiBGcmFuY2lzY28sIENBXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ1bml0XCI6IHtcInR5cGVcIjogXCJzdHJpbmdcIiwgXCJlbnVtXCI6IFtcImNlbHNpdXNcIiwgXCJmYWhyZW5oZWl0XCJdfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVxdWlyZWRcIjogW1wibG9jYXRpb25cIl0sXG4gICAgICAgIH0sXG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIixcbiAgICBcImZ1bmN0aW9uXCI6IHtcbiAgICAgIFwibmFtZVwiOiBcImxvb2t1cFwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlNlbWFudGljIHNlYXJjaFwiLFxuICAgICAgXCJwYXJhbWV0ZXJzXCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gICAgICAgIFwicHJvcGVydGllc1wiOiB7XG4gICAgICAgICAgXCJoeXBvdGhldGljYWxzXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICAgICAgICBcIml0ZW1zXCI6IHtcInR5cGVcIjogXCJzdHJpbmdcIn1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbl07XG4gKi9cbi8qKlxuICogVmFsaWRhdGVzIGEgdG9vbCBjYWxsIGFnYWluc3QgaXRzIHNwZWNpZmljYXRpb24gdG8gZW5zdXJlIGFsbCBwYXJhbWV0ZXJzIGFyZSBjb3JyZWN0LlxuICogVGhpcyBmdW5jdGlvbiBjaGVja3MgaWYgYWxsIHByb3ZpZGVkIGtleXMgaW4gdGhlIHRvb2wgY2FsbCBjb250ZW50IG1hdGNoIHRoZSBleHBlY3RlZCB0eXBlcyxcbiAqIGhhbmRsZXMgdHlwZSBjb2VyY2lvbiBmb3IgbnVtZXJpYyB2YWx1ZXMsIHZhbGlkYXRlcyBhZ2FpbnN0IGVudW1zLCBhbmQgZW5zdXJlcyBhbGwgcmVxdWlyZWRcbiAqIHBhcmFtZXRlcnMgYXJlIHByZXNlbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRvb2wgLSBUaGUgdG9vbCBvYmplY3QgY29udGFpbmluZyB0aGUgZnVuY3Rpb24gc3BlY2lmaWNhdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSB0b29sX2NhbGxfY29udGVudCAtIFRoZSBhY3R1YWwgcGFyYW1ldGVycyBwYXNzZWQgdG8gdGhlIHRvb2wgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBSZXR1cm5zIHRydWUgaWYgdGhlIHRvb2wgY2FsbCBpcyB2YWxpZC5cbiAqIEB0aHJvd3Mge0Vycm9yfSAtIFRocm93cyBhbiBlcnJvciBpZiBhbnkgdmFsaWRhdGlvbiBmYWlscy5cbiAqL1xuZnVuY3Rpb24gaXNfdmFsaWRfdG9vbF9jYWxsKHRvb2wsIHRvb2xfY2FsbF9jb250ZW50KSB7XG4gIGNvbnN0IHByb3BzID0gdG9vbC5mdW5jdGlvbi5wYXJhbWV0ZXJzLnByb3BlcnRpZXM7XG4gIGlmIChPYmplY3Qua2V5cyh0b29sX2NhbGxfY29udGVudCkubGVuZ3RoID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdG9vbCBjYWxsOiBvYmplY3QgaXMgZW1wdHlgKTtcbiAgLy8gY2hlY2sgaWYgYWxsIGtleXMgYXJlIGluIHRvb2wgc3BlY1xuICBPYmplY3QuZW50cmllcyh0b29sX2NhbGxfY29udGVudCkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgaWYgKCFwcm9wc1trZXldKSB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdG9vbCBjYWxsOiBtaXNzaW5nIGtleSAke2tleX0gaW4gdG9vbCBzcGVjYCwgcHJvcHMpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiBwcm9wc1trZXldLnR5cGUgPT09ICdhcnJheScpIHtcbiAgICAgIC8vIGNoZWNrIGlmIGFsbCBpdGVtcyBpbiB0aGUgYXJyYXkgYXJlIG9mIHRoZSBzYW1lIHR5cGVcbiAgICAgIGNvbnN0IGl0ZW1UeXBlID0gdHlwZW9mIHZhbHVlWzBdO1xuICAgICAgaWYgKCF2YWx1ZS5ldmVyeShpdGVtID0+IHR5cGVvZiBpdGVtID09PSBpdGVtVHlwZSkpIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0b29sIGNhbGw6IGFycmF5IGl0ZW1zIGFyZSBub3Qgb2YgdGhlIHNhbWUgdHlwZWApO1xuICAgICAgLy8gY2hlY2sgaWYgdGhlIGFycmF5IGl0ZW1zIGFyZSBvZiB0aGUgc2FtZSB0eXBlIGFzIHRoZSBzcGVjXG4gICAgICBpZiAocHJvcHNba2V5XS5pdGVtcy50eXBlICE9PSBpdGVtVHlwZSkgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRvb2wgY2FsbDogYXJyYXkgaXRlbXMgYXJlIG5vdCBvZiB0aGUgc2FtZSB0eXBlIGFzIHRoZSBzcGVjYCk7XG4gICAgfSBlbHNlIGlmIChwcm9wc1trZXldLnR5cGUgIT09IHR5cGVvZiB2YWx1ZSkge1xuICAgICAgaWYgKHByb3BzW2tleV0udHlwZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBjaGVjayBpZiB2YWx1ZSBpcyBhIHZhbGlkIG51bWJlclxuICAgICAgICBpZiAoaXNOYU4oTnVtYmVyKHZhbHVlKSkpIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0b29sIGNhbGw6IHZhbHVlICR7dmFsdWV9IGlzIG5vdCBhIHZhbGlkIG51bWJlcmApO1xuICAgICAgICB0b29sX2NhbGxfY29udGVudFtrZXldID0gTnVtYmVyKHZhbHVlKTsgLy8gY29lcmNlIHRvIG51bWJlciAoc2hvdWxkIG11dGF0ZSB0b29sX2NhbGxfY29udGVudClcbiAgICAgIH0gZWxzZSB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdG9vbCBjYWxsOiB2YWx1ZSAke3ZhbHVlfSBpcyBub3Qgb2YgdHlwZSAke3Byb3BzW2tleV0udHlwZX1gKTtcbiAgICB9XG4gICAgaWYgKHByb3BzW2tleV0uZW51bSAmJiAhcHJvcHNba2V5XS5lbnVtLmluY2x1ZGVzKHZhbHVlKSkgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRvb2wgY2FsbDogdmFsdWUgJHt2YWx1ZX0gaXMgbm90IGluIGVudW0gJHtwcm9wc1trZXldLmVudW19YCk7XG4gIH0pO1xuICAvLyBjaGVjayBpZiBhbGwgcmVxdWlyZWQga2V5cyBhcmUgcHJlc2VudFxuICB0b29sLmZ1bmN0aW9uLnBhcmFtZXRlcnMucmVxdWlyZWQ/LmZvckVhY2goa2V5ID0+IHtcbiAgICBpZiAoIXRvb2xfY2FsbF9jb250ZW50W2tleV0pIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0b29sIGNhbGw6IG1pc3NpbmcgcmVxdWlyZWQga2V5ICR7a2V5fWApO1xuICB9KTtcbiAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmlzX3ZhbGlkX3Rvb2xfY2FsbCA9IGlzX3ZhbGlkX3Rvb2xfY2FsbDtcbiIsICJjbGFzcyBTbWFydFN0cmVhbWVyIHtcbiAgY29uc3RydWN0b3IodXJsLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICBtZXRob2QgPSAnR0VUJyxcbiAgICAgIGhlYWRlcnMgPSB7fSxcbiAgICAgIGJvZHkgPSBudWxsLFxuICAgICAgd2l0aENyZWRlbnRpYWxzID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcblxuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLndpdGhDcmVkZW50aWFscyA9IHdpdGhDcmVkZW50aWFscztcbiAgICB0aGlzLmxpc3RlbmVycyA9IHt9O1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9IHRoaXMuQ09OTkVDVElORztcbiAgICB0aGlzLnByb2dyZXNzID0gMDtcbiAgICB0aGlzLmNodW5rID0gJyc7XG4gICAgdGhpcy5sYXN0X2V2ZW50X2lkID0gJyc7XG4gICAgdGhpcy54aHIgPSBudWxsO1xuICAgIHRoaXMuRklFTERfU0VQQVJBVE9SID0gJzonO1xuICAgIHRoaXMuSU5JVElBTElaSU5HID0gLTE7XG4gICAgdGhpcy5DT05ORUNUSU5HID0gMDtcbiAgICB0aGlzLk9QRU4gPSAxO1xuICAgIHRoaXMuQ0xPU0VEID0gMjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50IHR5cGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciAtIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkLlxuICAgKi9cbiAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgIGlmICghdGhpcy5saXN0ZW5lcnNbdHlwZV0pIHRoaXMubGlzdGVuZXJzW3R5cGVdID0gW107XG4gICAgaWYgKCF0aGlzLmxpc3RlbmVyc1t0eXBlXS5pbmNsdWRlcyhsaXN0ZW5lcikpIHRoaXMubGlzdGVuZXJzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW4gZXZlbnQgbGlzdGVuZXIgZnJvbSB0aGUgU21hcnRTdHJlYW1lciBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgdHlwZSBvZiBldmVudCB0byByZW1vdmUgdGhlIGxpc3RlbmVyIGZyb20uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIC0gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIHJlbW92ZS5cbiAgICovXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAoIXRoaXMubGlzdGVuZXJzW3R5cGVdKSByZXR1cm47XG4gICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0gPSB0aGlzLmxpc3RlbmVyc1t0eXBlXS5maWx0ZXIoKGNhbGxiYWNrKSA9PiBjYWxsYmFjayAhPT0gbGlzdGVuZXIpO1xuICAgIGlmICh0aGlzLmxpc3RlbmVyc1t0eXBlXS5sZW5ndGggPT09IDApIGRlbGV0ZSB0aGlzLmxpc3RlbmVyc1t0eXBlXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGFuIGV2ZW50IHRvIHRoZSBhcHByb3ByaWF0ZSBldmVudCBoYW5kbGVycy5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgdG8gYmUgZGlzcGF0Y2hlZC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IC0gUmV0dXJucyB0cnVlIGlmIHRoZSBldmVudCB3YXMgc3VjY2Vzc2Z1bGx5IGRpc3BhdGNoZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGRpc3BhdGNoRXZlbnQoZXZlbnQpIHtcbiAgICBpZiAoIWV2ZW50KSByZXR1cm4gdHJ1ZTtcbiAgICBldmVudC5zb3VyY2UgPSB0aGlzO1xuICAgIGNvbnN0IG9uSGFuZGxlciA9ICdvbicgKyBldmVudC50eXBlO1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcywgb25IYW5kbGVyKSkge1xuICAgICAgdGhpc1tvbkhhbmRsZXJdLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMubGlzdGVuZXJzW2V2ZW50LnR5cGVdKSB7XG4gICAgICB0aGlzLmxpc3RlbmVyc1tldmVudC50eXBlXS5mb3JFYWNoKChjYWxsYmFjaykgPT4ge1xuICAgICAgICBjYWxsYmFjayhldmVudCk7XG4gICAgICAgIHJldHVybiAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWF0ZXMgdGhlIHN0cmVhbWluZyBwcm9jZXNzLlxuICAgKi9cbiAgc3RyZWFtKCkge1xuICAgIHRoaXMuI3NldFJlYWR5U3RhdGUodGhpcy5DT05ORUNUSU5HKTtcbiAgICB0aGlzLnhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHRoaXMueGhyLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgdGhpcy4jb25TdHJlYW1Qcm9ncmVzcy5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLnhoci5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpcy4jb25TdHJlYW1Mb2FkZWQuYmluZCh0aGlzKSk7XG4gICAgdGhpcy54aHIuYWRkRXZlbnRMaXN0ZW5lcigncmVhZHlzdGF0ZWNoYW5nZScsIHRoaXMuI2NoZWNrU3RyZWFtQ2xvc2VkLmJpbmQodGhpcykpO1xuICAgIHRoaXMueGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpcy4jb25TdHJlYW1GYWlsdXJlLmJpbmQodGhpcykpO1xuICAgIHRoaXMueGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgdGhpcy4jb25TdHJlYW1BYm9ydC5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLnhoci5vcGVuKHRoaXMubWV0aG9kLCB0aGlzLnVybCk7XG4gICAgZm9yIChjb25zdCBoZWFkZXIgaW4gdGhpcy5oZWFkZXJzKSB7XG4gICAgICB0aGlzLnhoci5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlciwgdGhpcy5oZWFkZXJzW2hlYWRlcl0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5sYXN0X2V2ZW50X2lkKSB0aGlzLnhoci5zZXRSZXF1ZXN0SGVhZGVyKCdMYXN0LUV2ZW50LUlEJywgdGhpcy5sYXN0X2V2ZW50X2lkKTtcbiAgICB0aGlzLnhoci53aXRoQ3JlZGVudGlhbHMgPSB0aGlzLndpdGhDcmVkZW50aWFscztcbiAgICB0aGlzLnhoci5zZW5kKHRoaXMuYm9keSk7XG4gIH1cbiAgLyoqXG4gICAqIEVuZHMgdGhlIHN0cmVhbWVyIGNvbm5lY3Rpb24uXG4gICAqIEFib3J0cyB0aGUgY3VycmVudCBYSFIgcmVxdWVzdCBhbmQgc2V0cyB0aGUgcmVhZHkgc3RhdGUgdG8gQ0xPU0VELlxuICAgKi9cbiAgZW5kKCkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IHRoaXMuQ0xPU0VEKSByZXR1cm47XG4gICAgdGhpcy54aHIuYWJvcnQoKTtcbiAgICB0aGlzLnhociA9IG51bGw7XG4gICAgdGhpcy4jc2V0UmVhZHlTdGF0ZSh0aGlzLkNMT1NFRCk7XG4gIH1cblxuICAvLyBwcml2YXRlIG1ldGhvZHNcbiAgI3NldFJlYWR5U3RhdGUoc3RhdGUpIHtcbiAgICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudCgncmVhZHlTdGF0ZUNoYW5nZScpO1xuICAgIGV2ZW50LnJlYWR5U3RhdGUgPSBzdGF0ZTtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBzdGF0ZTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9XG4gICNvblN0cmVhbUZhaWx1cmUoZSkge1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdlcnJvcicpO1xuICAgIGV2ZW50LmRhdGEgPSBlLmN1cnJlbnRUYXJnZXQucmVzcG9uc2U7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB0aGlzLmVuZCgpO1xuICB9XG4gICNvblN0cmVhbUFib3J0KGUpIHtcbiAgICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnYWJvcnQnKTtcbiAgICB0aGlzLmVuZCgpO1xuICB9XG4gICNvblN0cmVhbVByb2dyZXNzKGUpIHtcbiAgICBpZiAoIXRoaXMueGhyKSByZXR1cm47XG4gICAgaWYgKHRoaXMueGhyLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICB0aGlzLiNvblN0cmVhbUZhaWx1cmUoZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IHRoaXMuQ09OTkVDVElORykge1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnb3BlbicpKTtcbiAgICAgIHRoaXMuI3NldFJlYWR5U3RhdGUodGhpcy5PUEVOKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IHRoaXMueGhyLnJlc3BvbnNlVGV4dC5zdWJzdHJpbmcodGhpcy5wcm9ncmVzcyk7XG4gICAgdGhpcy5wcm9ncmVzcyArPSBkYXRhLmxlbmd0aDtcbiAgICAvLyBkYXRhLnNwbGl0KC8oXFxyXFxufFxccnxcXG4pezJ9L2cpLmZvckVhY2goKHBhcnQpID0+IHtcbiAgICBkYXRhLnNwbGl0KC8oXFxyXFxufFxccnxcXG4pL2cpLmZvckVhY2goKHBhcnQpID0+IHtcbiAgICAgIGlmIChwYXJ0LnRyaW0oKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHRoaXMuI3BhcnNlRXZlbnRDaHVuayh0aGlzLmNodW5rLnRyaW0oKSkpO1xuICAgICAgICB0aGlzLmNodW5rID0gJyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNodW5rICs9IHBhcnQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgI29uU3RyZWFtTG9hZGVkKGUpIHtcbiAgICB0aGlzLiNvblN0cmVhbVByb2dyZXNzKGUpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh0aGlzLiNwYXJzZUV2ZW50Q2h1bmsodGhpcy5jaHVuaykpO1xuICAgIHRoaXMuY2h1bmsgPSAnJztcbiAgfVxuICAjcGFyc2VFdmVudENodW5rKGNodW5rKSB7XG4gICAgaWYgKCFjaHVuayB8fCBjaHVuay5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGUgPSB7IGlkOiBudWxsLCByZXRyeTogbnVsbCwgZGF0YTogJycsIGV2ZW50OiAnbWVzc2FnZScsIHRleHQ6ICcnIH07XG4gICAgY2h1bmsuc3BsaXQoLyhcXHJcXG58XFxyfFxcbikvKS5mb3JFYWNoKChsaW5lKSA9PiB7XG4gICAgICAvLyBsaW5lID0gbGluZS50cmltUmlnaHQoKTtcbiAgICAgIGxpbmUgPSBsaW5lLnRyaW0oKTtcbiAgICAgIGNvbnN0IGluZGV4ID0gbGluZS5pbmRleE9mKHRoaXMuRklFTERfU0VQQVJBVE9SKTtcbiAgICAgIGlmIChpbmRleCA8PSAwKSByZXR1cm47XG4gICAgICAvLyBjb25zdCBmaWVsZCA9IGxpbmUuc3Vic3RyaW5nKDAsIGluZGV4KTtcbiAgICAgIC8vIGFsc28gcmVtb3ZlIHF1b3Rlc1xuICAgICAgY29uc3QgZmllbGQgPSBsaW5lLnN1YnN0cmluZygwLCBpbmRleCkucmVwbGFjZSgvXlwifFwiJC9nLCAnJyk7XG4gICAgICBpZighWydpZCcsICdyZXRyeScsICdkYXRhJywgJ2V2ZW50JywgJ3RleHQnXS5pbmNsdWRlcyhmaWVsZCkpIHJldHVybjtcbiAgICAgIC8vIGlmICghKGZpZWxkIGluIGUpKSByZXR1cm47XG4gICAgICAvLyBjb25zdCB2YWx1ZSA9IGxpbmUuc3Vic3RyaW5nKGluZGV4ICsgMSkudHJpbUxlZnQoKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gbGluZS5zdWJzdHJpbmcoaW5kZXggKyAxKS50cmltKCkucmVwbGFjZSgvXlwifFwiJC9nLCAnJyk7XG4gICAgICAvLyBpZiAoZmllbGQgPT09ICdkYXRhJykgZVtmaWVsZF0gKz0gdmFsdWU7XG4gICAgICAvLyBlbHNlIGVbZmllbGRdID0gdmFsdWU7XG4gICAgICBlLmRhdGEgKz0gdmFsdWU7XG4gICAgfSk7XG4gICAgaWYgKGUuaWQpIHRoaXMubGFzdF9ldmVudF9pZCA9IGUuaWQ7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoZS5ldmVudCB8fCAnbWVzc2FnZScpO1xuICAgIGV2ZW50LmlkID0gZS5pZDtcbiAgICBldmVudC5kYXRhID0gZS5kYXRhIHx8ICcnO1xuICAgIGV2ZW50Lmxhc3RfZXZlbnRfaWQgPSB0aGlzLmxhc3RfZXZlbnRfaWQ7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG4gICNjaGVja1N0cmVhbUNsb3NlZCgpIHtcbiAgICBpZiAoIXRoaXMueGhyKSByZXR1cm47XG4gICAgaWYgKHRoaXMueGhyLnJlYWR5U3RhdGUgPT09IFhNTEh0dHBSZXF1ZXN0LkRPTkUpIHRoaXMuI3NldFJlYWR5U3RhdGUodGhpcy5DTE9TRUQpO1xuICB9XG5cbn1cblxuZXhwb3J0cy5TbWFydFN0cmVhbWVyID0gU21hcnRTdHJlYW1lcjtcbiIsICJhc3luYyBmdW5jdGlvbiBmZXRjaF9vcGVuX3JvdXRlcl9tb2RlbHMoKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnaHR0cHM6Ly9vcGVucm91dGVyLmFpL2FwaS92MS9tb2RlbHMnKTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05ldHdvcmsgcmVzcG9uc2Ugd2FzIG5vdCBvaycpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIGNvbnNvbGUubG9nKCdNb2RlbCBkYXRhIHJldHJpZXZlZDonLCBkYXRhKTtcbiAgICByZXR1cm4gZGF0YS5kYXRhXG4gICAgICAvLyAuZmlsdGVyKG1vZGVsID0+ICFtb2RlbC5pZC5pbmNsdWRlcygnaW5zdHJ1Y3QnKSlcbiAgICAgIC5tYXAobW9kZWwgPT4gKHtcbiAgICAgICAgbW9kZWxfbmFtZTogbW9kZWwuaWQsXG4gICAgICAgIGtleTogbW9kZWwuaWQsXG4gICAgICAgIG1heF9pbnB1dF90b2tlbnM6IG1vZGVsLmNvbnRleHRfbGVuZ3RoLFxuICAgICAgICBkZXNjcmlwdGlvbjogbW9kZWwubmFtZSxcbiAgICAgICAgYWN0aW9uczogbW9kZWwuZGVzY3JpcHRpb24uaW5jbHVkZXMoJ3Rvb2wgdXNlJykgfHwgbW9kZWwuZGVzY3JpcHRpb24uaW5jbHVkZXMoJ2Z1bmN0aW9uIGNhbGwnKSxcbiAgICAgICAgbXVsdGltb2RhbDogbW9kZWwuYXJjaGl0ZWN0dXJlLm1vZGFsaXR5ID09PSAnbXVsdGltb2RhbCcsXG4gICAgICAgIHJhdzogbW9kZWxcbiAgICAgIH0pKVxuICAgIDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggbW9kZWwgZGF0YTonLCBlcnJvcik7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5leHBvcnRzLmZldGNoX29wZW5fcm91dGVyX21vZGVscyA9IGZldGNoX29wZW5fcm91dGVyX21vZGVsczsiLCAiY29uc3QgbW9kZWxfY29udGV4dCA9IHtcbiAgXCJncHQtMy41LXR1cmJvXCI6IHtcbiAgICBcImNvbnRleHRcIjogMTYzODUsXG4gICAgXCJtYXhfb3V0XCI6IDQwOTZcbiAgfSxcbiAgXCJncHQtMy41LXR1cmJvLTAxMjVcIjoge1xuICAgIFwiY29udGV4dFwiOiAxNjM4NSxcbiAgICBcIm1heF9vdXRcIjogNDA5NlxuICB9LFxuICBcImdwdC0zLjUtdHVyYm8tMDMwMVwiOiB7XG4gICAgXCJjb250ZXh0XCI6IDQwOTcsXG4gICAgXCJtYXhfb3V0XCI6IDQwOTdcbiAgfSxcbiAgXCJncHQtMy41LXR1cmJvLTA2MTNcIjoge1xuICAgIFwiY29udGV4dFwiOiA0MDk3LFxuICAgIFwibWF4X291dFwiOiA0MDk3XG4gIH0sXG4gIFwiZ3B0LTMuNS10dXJiby0xMTA2XCI6IHtcbiAgICBcImNvbnRleHRcIjogMTYzODUsXG4gICAgXCJtYXhfb3V0XCI6IDQwOTZcbiAgfSxcbiAgXCJncHQtMy41LXR1cmJvLTE2a1wiOiB7XG4gICAgXCJjb250ZXh0XCI6IDE2Mzg1LFxuICAgIFwibWF4X291dFwiOiAxNjM4NVxuICB9LFxuICBcImdwdC0zLjUtdHVyYm8tMTZrLTA2MTNcIjoge1xuICAgIFwiY29udGV4dFwiOiAxNjM4NSxcbiAgICBcIm1heF9vdXRcIjogMTYzODVcbiAgfSxcbiAgXCJncHQtNFwiOiB7XG4gICAgXCJjb250ZXh0XCI6IDgxOTIsXG4gICAgXCJtYXhfb3V0XCI6IDgxOTJcbiAgfSxcbiAgXCJncHQtNC0wMTI1LXByZXZpZXdcIjoge1xuICAgIFwiY29udGV4dFwiOiAxMjgwMDAsXG4gICAgXCJtYXhfb3V0XCI6IDQwOTZcbiAgfSxcbiAgXCJncHQtNC0wMzE0XCI6IHtcbiAgICBcImNvbnRleHRcIjogODE5MixcbiAgICBcIm1heF9vdXRcIjogODE5MlxuICB9LFxuICBcImdwdC00LTA2MTNcIjoge1xuICAgIFwiY29udGV4dFwiOiA4MTkyLFxuICAgIFwibWF4X291dFwiOiA4MTkyXG4gIH0sXG4gIFwiZ3B0LTQtMTEwNi1wcmV2aWV3XCI6IHtcbiAgICBcImNvbnRleHRcIjogMTI4MDAwLFxuICAgIFwibWF4X291dFwiOiA0MDk2XG4gIH0sXG4gIFwiZ3B0LTQtMTEwNi12aXNpb24tcHJldmlld1wiOiB7XG4gICAgXCJjb250ZXh0XCI6IDEyODAwMCxcbiAgICBcIm1heF9vdXRcIjogNDA5NlxuICB9LFxuICBcImdwdC00LTMya1wiOiB7XG4gICAgXCJjb250ZXh0XCI6IDMyNzY4LFxuICAgIFwibWF4X291dFwiOiAzMjc2OFxuICB9LFxuICBcImdwdC00LTMyay0wMzE0XCI6IHtcbiAgICBcImNvbnRleHRcIjogMzI3NjgsXG4gICAgXCJtYXhfb3V0XCI6IDMyNzY4XG4gIH0sXG4gIFwiZ3B0LTQtMzJrLTA2MTNcIjoge1xuICAgIFwiY29udGV4dFwiOiAzMjc2OCxcbiAgICBcIm1heF9vdXRcIjogMzI3NjhcbiAgfSxcbiAgXCJncHQtNC10dXJib1wiOiB7XG4gICAgXCJjb250ZXh0XCI6IDEyODAwMCxcbiAgICBcIm1heF9vdXRcIjogNDA5NlxuICB9LFxuICBcImdwdC00LXR1cmJvLTIwMjQtMDQtMDlcIjoge1xuICAgIFwiY29udGV4dFwiOiAxMjgwMDAsXG4gICAgXCJtYXhfb3V0XCI6IDQwOTZcbiAgfSxcbiAgXCJncHQtNC10dXJiby1wcmV2aWV3XCI6IHtcbiAgICBcImNvbnRleHRcIjogMTI4MDAwLFxuICAgIFwibWF4X291dFwiOiA0MDk2XG4gIH0sXG4gIFwiZ3B0LTQtdmlzaW9uLXByZXZpZXdcIjoge1xuICAgIFwiY29udGV4dFwiOiAxMjgwMDAsXG4gICAgXCJtYXhfb3V0XCI6IDQwOTZcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hfb3BlbmFpX21vZGVscyhhcGlfa2V5KSB7XG4gIGlmICghYXBpX2tleSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ05vIEFQSSBrZXkgcHJvdmlkZWQnKTtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCdodHRwczovL2FwaS5vcGVuYWkuY29tL3YxL21vZGVscycsIHtcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7YXBpX2tleX1gLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05ldHdvcmsgcmVzcG9uc2Ugd2FzIG5vdCBvaycpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIGNvbnNvbGUubG9nKCdNb2RlbCBkYXRhIHJldHJpZXZlZDonLCBkYXRhKTtcbiAgICByZXR1cm4gZGF0YS5kYXRhXG4gICAgICAuZmlsdGVyKG1vZGVsID0+IG1vZGVsLmlkLnN0YXJ0c1dpdGgoJ2dwdC0nKSAmJiAhbW9kZWwuaWQuaW5jbHVkZXMoJy1pbnN0cnVjdCcpKVxuICAgICAgLm1hcChtb2RlbCA9PiB7XG4gICAgICAgIGNvbnN0IG91dCA9IHtcbiAgICAgICAgICBtb2RlbF9uYW1lOiBtb2RlbC5pZCwgXG4gICAgICAgICAga2V5OiBtb2RlbC5pZCxcbiAgICAgICAgICBtdWx0aW1vZGFsOiBtb2RlbC5pZC5pbmNsdWRlcygndmlzaW9uJykgfHwgbW9kZWwuaWQuaW5jbHVkZXMoJ2dwdC00LXR1cmJvJylcbiAgICAgICAgfTtcbiAgICAgICAgaWYobW9kZWxfY29udGV4dFttb2RlbC5pZF0pIHtcbiAgICAgICAgICBvdXQubWF4X2lucHV0X3Rva2VucyA9IG1vZGVsX2NvbnRleHRbbW9kZWwuaWRdLmNvbnRleHQ7XG4gICAgICAgICAgb3V0LmRlc2NyaXB0aW9uID0gYGNvbnRleHQ6ICR7bW9kZWxfY29udGV4dFttb2RlbC5pZF0uY29udGV4dH0sIG91dHB1dDogJHttb2RlbF9jb250ZXh0W21vZGVsLmlkXS5tYXhfb3V0fWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgIH0pXG4gICAgO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBtb2RlbCBkYXRhOicsIGVycm9yKTtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cbmV4cG9ydHMuZmV0Y2hfb3BlbmFpX21vZGVscyA9IGZldGNoX29wZW5haV9tb2RlbHM7IiwgImFzeW5jIGZ1bmN0aW9uIGZldGNoX2dvb2dsZV9nZW1pbmlfbW9kZWxzKGFwaV9rZXkpIHtcbiAgaWYgKCFhcGlfa2V5KSB7XG4gICAgY29uc29sZS5lcnJvcignTm8gQVBJIGtleSBwcm92aWRlZCcpO1xuICAgIHJldHVybiBbXTtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJ2h0dHBzOi8vZ2VuZXJhdGl2ZWxhbmd1YWdlLmdvb2dsZWFwaXMuY29tL3YxYmV0YS9tb2RlbHM/a2V5PScgKyBhcGlfa2V5KTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05ldHdvcmsgcmVzcG9uc2Ugd2FzIG5vdCBvaycpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIGNvbnNvbGUubG9nKCdNb2RlbCBkYXRhIHJldHJpZXZlZDonLCBkYXRhKTtcbiAgICByZXR1cm4gZGF0YS5tb2RlbHNcbiAgICAgIC5maWx0ZXIobW9kZWwgPT4gbW9kZWwubmFtZS5zdGFydHNXaXRoKCdtb2RlbHMvZ2VtaW5pJykpXG4gICAgICAubWFwKG1vZGVsID0+IHtcbiAgICAgICAgY29uc3Qgb3V0ID0ge1xuICAgICAgICAgIG1vZGVsX25hbWU6IG1vZGVsLm5hbWUuc3BsaXQoJy8nKS5wb3AoKSwgXG4gICAgICAgICAga2V5OiBtb2RlbC5uYW1lLnNwbGl0KCcvJykucG9wKCksXG4gICAgICAgICAgbWF4X2lucHV0X3Rva2VuczogbW9kZWwuaW5wdXRUb2tlbkxpbWl0LFxuICAgICAgICAgIG1heF9vdXRwdXRfdG9rZW5zOiBtb2RlbC5tYXhPdXRwdXRUb2tlbnMsXG4gICAgICAgICAgZGVzY3JpcHRpb246IG1vZGVsLmRlc2NyaXB0aW9uLFxuICAgICAgICAgIG11bHRpbW9kYWw6IG1vZGVsLm5hbWUuaW5jbHVkZXMoJ3Zpc2lvbicpIHx8IG1vZGVsLmRlc2NyaXB0aW9uLmluY2x1ZGVzKCdtdWx0aW1vZGFsJyksXG4gICAgICAgICAgcmF3OiBtb2RlbFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGZldGNoIG1vZGVsIGRhdGE6JywgZXJyb3IpO1xuICAgIHJldHVybiBbXTtcbiAgfVxufVxuZXhwb3J0cy5mZXRjaF9nb29nbGVfZ2VtaW5pX21vZGVscyA9IGZldGNoX2dvb2dsZV9nZW1pbmlfbW9kZWxzOyIsICIvLyBjdXJsIC0tcmVxdWVzdCBHRVQgXFxcbi8vICAgLS11cmwgaHR0cHM6Ly9hcGkuY29oZXJlLmFpL3YxL21vZGVscyBcXFxuLy8gICAtLWhlYWRlciAnYWNjZXB0OiBhcHBsaWNhdGlvbi9qc29uJyBcXFxuLy8gICAtLWhlYWRlciBcIkF1dGhvcml6YXRpb246IGJlYXJlciAkQ09fQVBJX0tFWVwiXG5cbmFzeW5jIGZ1bmN0aW9uIGZldGNoX2NvaGVyZV9tb2RlbHMoYXBpX2tleSkge1xuICBpZiAoIWFwaV9rZXkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdObyBBUEkga2V5IHByb3ZpZGVkJyk7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnaHR0cHM6Ly9hcGkuY29oZXJlLmFpL3YxL21vZGVscycsIHtcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7YXBpX2tleX1gLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05ldHdvcmsgcmVzcG9uc2Ugd2FzIG5vdCBvaycpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIGNvbnNvbGUubG9nKCdNb2RlbCBkYXRhIHJldHJpZXZlZDonLCBkYXRhKTtcbiAgICByZXR1cm4gZGF0YS5tb2RlbHNcbiAgICAgIC5maWx0ZXIobW9kZWwgPT4gbW9kZWwubmFtZS5zdGFydHNXaXRoKCdjb21tYW5kLScpKVxuICAgICAgLm1hcChtb2RlbCA9PiB7XG4gICAgICAgIGNvbnN0IG91dCA9IHtcbiAgICAgICAgICBtb2RlbF9uYW1lOiBtb2RlbC5uYW1lLFxuICAgICAgICAgIGtleTogbW9kZWwubmFtZSxcbiAgICAgICAgICBtYXhfaW5wdXRfdG9rZW5zOiBtb2RlbC5jb250ZXh0X2xlbmd0aCxcbiAgICAgICAgICB0b2tlbml6ZXJfdXJsOiBtb2RlbC50b2tlbml6ZXJfdXJsLFxuICAgICAgICAgIGZpbmV0dW5lZDogbW9kZWwuZmluZXR1bmVkLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgTWF4IGlucHV0IHRva2VuczogJHttb2RlbC5jb250ZXh0X2xlbmd0aH0sIEZpbmV0dW5lZDogJHttb2RlbC5maW5ldHVuZWR9YFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGZldGNoIG1vZGVsIGRhdGE6JywgZXJyb3IpO1xuICAgIHJldHVybiBbXTtcbiAgfVxufVxuZXhwb3J0cy5mZXRjaF9jb2hlcmVfbW9kZWxzID0gZmV0Y2hfY29oZXJlX21vZGVscztcblxuIiwgIi8vIGZha2UgaXQgYmVjYXVzZSBhbnRocm9waWMgZG9lc24ndCBoYXZlIG1vZGVsIGxpc3QgQVBJIGVuZHBvaW50XG5hc3luYyBmdW5jdGlvbiBmZXRjaF9hbnRocm9waWNfbW9kZWxzKCkge1xuICByZXR1cm4gW3tcbiAgICBcImtleVwiOiBcImNsYXVkZS0zLW9wdXMtMjAyNDAyMjlcIixcbiAgICBcIm1vZGVsX25hbWVcIjogXCJjbGF1ZGUtMy1vcHVzLTIwMjQwMjI5XCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkFudGhyb3BpYydzIENsYXVkZSBPcHVzXCIsXG4gICAgXCJtYXhfaW5wdXRfdG9rZW5zXCI6IDIwMDAwMCxcbiAgICBcIm1heF9vdXRwdXRfdG9rZW5zXCI6IDQwMDAsXG4gICAgXCJtdWx0aW1vZGFsXCI6IHRydWVcbiAgfSxcbiAge1xuICAgIGtleTogXCJjbGF1ZGUtMy1zb25uZXQtMjAyNDAyMjlcIixcbiAgICBcIm1vZGVsX25hbWVcIjogXCJjbGF1ZGUtMy1zb25uZXQtMjAyNDAyMjlcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQW50aHJvcGljJ3MgQ2xhdWRlIFNvbm5ldFwiLFxuICAgIFwibWF4X2lucHV0X3Rva2Vuc1wiOiAyMDAwMDAsXG4gICAgXCJtYXhfb3V0cHV0X3Rva2Vuc1wiOiA0MDAwLFxuICAgIFwibXVsdGltb2RhbFwiOiB0cnVlXG4gIH0sXG4gIHtcbiAgICBrZXk6IFwiY2xhdWRlLTMtaGFpa3UtMjAyNDAzMDdcIixcbiAgICBcIm1vZGVsX25hbWVcIjogXCJjbGF1ZGUtMy1oYWlrdS0yMDI0MDMwN1wiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJBbnRocm9waWMncyBDbGF1ZGUgSGFpa3VcIixcbiAgICBcIm1heF9pbnB1dF90b2tlbnNcIjogMjAwMDAwLFxuICAgIFwibWF4X291dHB1dF90b2tlbnNcIjogNDAwMCxcbiAgICBcIm11bHRpbW9kYWxcIjogdHJ1ZVxuICB9XTtcbn1cbmV4cG9ydHMuZmV0Y2hfYW50aHJvcGljX21vZGVscyA9IGZldGNoX2FudGhyb3BpY19tb2RlbHM7XG5cbiIsICJjb25zdCB7IGZldGNoX29wZW5fcm91dGVyX21vZGVscyB9ID0gcmVxdWlyZSgnLi9vcGVuX3JvdXRlcicpO1xuY29uc3QgeyBmZXRjaF9vcGVuYWlfbW9kZWxzIH0gPSByZXF1aXJlKCcuL29wZW5haScpO1xuY29uc3QgeyBmZXRjaF9nb29nbGVfZ2VtaW5pX21vZGVscyB9ID0gcmVxdWlyZSgnLi9nb29nbGVfZ2VtaW5pJyk7XG5jb25zdCB7IGZldGNoX2NvaGVyZV9tb2RlbHMgfSA9IHJlcXVpcmUoJy4vY29oZXJlJyk7XG5jb25zdCB7IGZldGNoX2FudGhyb3BpY19tb2RlbHMgfSA9IHJlcXVpcmUoJy4vYW50aHJvcGljJyk7XG5leHBvcnRzLm9wZW5fcm91dGVyID0gZmV0Y2hfb3Blbl9yb3V0ZXJfbW9kZWxzO1xuZXhwb3J0cy5vcGVuYWkgPSBmZXRjaF9vcGVuYWlfbW9kZWxzO1xuZXhwb3J0cy5nb29nbGVfZ2VtaW5pID0gZmV0Y2hfZ29vZ2xlX2dlbWluaV9tb2RlbHM7XG5leHBvcnRzLmNvaGVyZSA9IGZldGNoX2NvaGVyZV9tb2RlbHM7XG5leHBvcnRzLmFudGhyb3BpYyA9IGZldGNoX2FudGhyb3BpY19tb2RlbHM7XG5cbiIsICIvLyBDb3B5cmlnaHQgKGMpIEJyaWFuIEpvc2VwaCBQZXRyb1xuXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbi8vIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbi8vIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xuLy8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuLy8gaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4vLyBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4vLyBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFXG4vLyBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OXG4vLyBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cbi8vIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5jb25zdCBhZGFwdGVycyA9IHJlcXVpcmUoJy4vYWRhcHRlcnMnKTtcbmNvbnN0IHBsYXRmb3JtcyA9IHJlcXVpcmUoJy4vcGxhdGZvcm1zLmpzb24nKTtcbmNvbnN0IHsgaXNfdmFsaWRfdG9vbF9jYWxsIH0gPSByZXF1aXJlKCcuL3V0aWxzL2lzX3ZhbGlkX3Rvb2xfY2FsbCcpO1xuY29uc3QgeyBTbWFydFN0cmVhbWVyIH0gPSByZXF1aXJlKCcuL3N0cmVhbWVyJyk7XG5jb25zdCBmZXRjaF9tb2RlbHMgPSByZXF1aXJlKFwiLi9tb2RlbHMvZmV0Y2hcIik7XG4vKipcbiAqIFNtYXJ0Q2hhdE1vZGVsIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdGllcyB0byBoYW5kbGUgY2hhdCBpbnRlcmFjdGlvbnMgd2l0aCB2YXJpb3VzIG1vZGVscyBhbmQgYWRhcHRlcnMuXG4gKiBJdCBzdXBwb3J0cyBzdHJlYW1pbmcgYW5kIG5vbi1zdHJlYW1pbmcgcmVzcG9uc2VzLCB0b29sIGNhbGxzLCBhbmQgY3VzdG9taXphdGlvbnMgdGhyb3VnaCBvcHRpb25zLlxuICovXG5jbGFzcyBTbWFydENoYXRNb2RlbCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGFuIGluc3RhbmNlIG9mIFNtYXJ0Q2hhdE1vZGVsIHdpdGggc3BlY2lmaWVkIGVudmlyb25tZW50LCBtb2RlbCBrZXksIGFuZCBvcHRpb25zLlxuICAgKiBAcGFyYW0ge09iamVjdH0gbWFpbiAtIFRoZSBtYWluIGVudmlyb25tZW50IGNvbnRleHQsIHR5cGljYWxseSBjb250YWluaW5nIGNvbmZpZ3VyYXRpb25zIGFuZCBzdGF0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBsYXRmb3JtX2tleSAtIEtleSB0byBzZWxlY3QgdGhlIHNwZWNpZmljIG1vZGVsIGNvbmZpZ3VyYXRpb24gZnJvbSBtb2RlbHMuanNvbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsX2NvbmZpZyAtIE9wdGlvbmFsIHBhcmFtZXRlcnMgdG8gb3ZlcnJpZGUgbW9kZWwgY29uZmlndXJhdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihtYWluLCBwbGF0Zm9ybV9rZXksIG1vZGVsX2NvbmZpZz17fSkge1xuICAgIHRoaXMuZW52ID0gbWFpbjtcbiAgICB0aGlzLm1haW4gPSB0aGlzLmVudjsgLy8gREVQUkVDQVRFRFxuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgLi4uKHBsYXRmb3Jtc1twbGF0Zm9ybV9rZXldIHx8IHt9KSxcbiAgICAgIC4uLm1vZGVsX2NvbmZpZywgLy8gb3ZlcnJpZGUgZGVmYXVsdCBwbGF0Zm9ybSBjb25maWdcbiAgICB9XG4gICAgdGhpcy5wbGF0Zm9ybV9rZXkgPSBwbGF0Zm9ybV9rZXk7XG4gICAgdGhpcy5hY3RpdmVfc3RyZWFtID0gbnVsbDtcbiAgICB0aGlzLl9yZXF1ZXN0X2FkYXB0ZXIgPSBudWxsO1xuICAgIHRoaXMucGxhdGZvcm1zID0gcGxhdGZvcm1zO1xuICAgIGlmKHRoaXMuY29uZmlnLmFkYXB0ZXIpIHRoaXMuYWRhcHRlciA9IG5ldyBhZGFwdGVyc1t0aGlzLmNvbmZpZy5hZGFwdGVyXSh0aGlzKTtcbiAgICBjb25zb2xlLmxvZyh0aGlzLmFkYXB0ZXIpO1xuICB9XG4gIHN0YXRpYyBnZXQgbW9kZWxzKCkgeyByZXR1cm4gcGxhdGZvcm1zOyB9XG4gIGdldCBkZWZhdWx0X29wdHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRlbXBlcmF0dXJlOiAwLjMsXG4gICAgICB0b3BfcDogMSxcbiAgICAgIHByZXNlbmNlX3BlbmFsdHk6IDAsXG4gICAgICBmcmVxdWVuY3lfcGVuYWx0eTogMCxcbiAgICAgIG46IDEsXG4gICAgICBtb2RlbDogdGhpcy5tb2RlbF9uYW1lLFxuICAgICAgbWF4X3Rva2VuczogdGhpcy5tYXhfb3V0cHV0X3Rva2VucyxcbiAgICB9O1xuICB9XG4gIGFzeW5jIHJlcXVlc3RfbWlkZGxld2FyZXMob3B0cykgeyByZXR1cm4gb3B0czsgfVxuICAvKipcbiAgICogQ29tcGxldGVzIHRoZSBjaGF0IGludGVyYWN0aW9uIGJ5IHByb2Nlc3NpbmcgdGhlIHByb3ZpZGVkIG9wdGlvbnMsIG1ha2luZyBhbiBBUEkgcmVxdWVzdCwgYW5kIGhhbmRsaW5nIHRoZSByZXNwb25zZS5cbiAgICogVGhpcyBtZXRob2Qgc3VwcG9ydHMgYm90aCBzdHJlYW1pbmcgYW5kIG5vbi1zdHJlYW1pbmcgcmVzcG9uc2VzLCBhbmQgY2FuIGhhbmRsZSB0b29sIGNhbGxzIGlmIHNwZWNpZmllZCBpbiB0aGUgcmVzcG9uc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSBjaGF0IGNvbXBsZXRpb24gd2hpY2ggbWF5IGluY2x1ZGUgc2V0dGluZ3MgbGlrZSB0ZW1wZXJhdHVyZSwgbWF4IHRva2VucywgZXRjLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlbmRlciAtIEZsYWcgdG8gZGV0ZXJtaW5lIGlmIHRoZSByZXNwb25zZSBzaG91bGQgYmUgcmVuZGVyZWQgaW4gdGhlIFVJLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmd8dm9pZD59IC0gUmV0dXJucyB0aGUgY2hhdCByZXNwb25zZSBjb250ZW50IG9yIGhhbmRsZXMgdG9vbCBvdXRwdXRzIHJlY3Vyc2l2ZWx5LiBJbiBjYXNlIG9mIGVycm9ycywgaXQgbWF5IHJldHVybiBhbiBlcnJvciBtZXNzYWdlLlxuICAgKi9cbiAgYXN5bmMgY29tcGxldGUob3B0cz17fSwgcmVuZGVyPXRydWUpIHtcbiAgICBpZighdGhpcy5iYXNlX21vZGVsX2NvbmZpZyl7XG4gICAgICB0aGlzLmJhc2VfbW9kZWxfY29uZmlnID0gYXdhaXQgdGhpcy5nZXRfYmFzZV9tb2RlbF9jb25maWcoKTtcbiAgICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgICAuLi50aGlzLmJhc2VfbW9kZWxfY29uZmlnLFxuICAgICAgICAuLi50aGlzLmNvbmZpZyxcbiAgICAgIH07XG4gICAgfVxuICAgIG9wdHMgPSB7XG4gICAgICAuLi50aGlzLmRlZmF1bHRfb3B0cyxcbiAgICAgIG1lc3NhZ2VzOiAoYXdhaXQgdGhpcy5jdXJyZW50Py5nZXRfY2hhdF9tbCgpKT8ubWVzc2FnZXMgfHwgW10sXG4gICAgICAuLi5vcHRzLFxuICAgIH07XG4gICAgaWYob3B0cy5zdHJlYW0gIT09IGZhbHNlICYmIHRoaXMuY29uZmlnLnN0cmVhbWluZyAmJiAhdGhpcy5jdXJyZW50LnRvb2xfY2hvaWNlKSBvcHRzLnN0cmVhbSA9IHRydWU7IC8vIG5vIHN0cmVhbWluZyBpZiB0b29sX2Nob2ljZSBpcyBzZXRcbiAgICBlbHNlIG9wdHMuc3RyZWFtID0gZmFsc2U7XG4gICAgb3B0cyA9IGF3YWl0IHRoaXMucmVxdWVzdF9taWRkbGV3YXJlcyhKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9wdHMpKSk7XG4gICAgY29uc3QgcmVxID0ge1xuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3RoaXMuYXBpX2tleX1gXG4gICAgICB9LFxuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICB9O1xuICAgIGlmICh0aGlzLmNvbmZpZy5oZWFkZXJzKSByZXEuaGVhZGVycyA9IHsgLi4ucmVxLmhlYWRlcnMsIC4uLnRoaXMuY29uZmlnLmhlYWRlcnMgfTtcbiAgICBpZiAodGhpcy5jb25maWcuYXBpX2tleV9oZWFkZXIpIHtcbiAgICAgIGlmKHRoaXMuY29uZmlnLmFwaV9rZXlfaGVhZGVyICE9PSAnbm9uZScpIHJlcS5oZWFkZXJzW3RoaXMuY29uZmlnLmFwaV9rZXlfaGVhZGVyXSA9IHRoaXMuYXBpX2tleTtcbiAgICAgIGRlbGV0ZSByZXEuaGVhZGVycy5BdXRob3JpemF0aW9uO1xuICAgIH1cbiAgICAvLyBib2R5IGNvbnN0YW50IHN0b3JlcyBjaGF0bWwgZm9yIGxhdGVyXG4gICAgY29uc3QgYm9keSA9IHR5cGVvZiB0aGlzLmVudi5hY3Rpb25zPy5wcmVwYXJlX3JlcXVlc3RfYm9keSA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMuZW52LmFjdGlvbnMucHJlcGFyZV9yZXF1ZXN0X2JvZHkob3B0cykgOiB7IC4uLm9wdHMgfTtcbiAgICAvLyBhZGFwdGVyIGNhbiBtb2RpZnkgYm9keSBiYXNlZCBvbiBwbGF0Zm9ybVxuICAgIHJlcS5ib2R5ID0gSlNPTi5zdHJpbmdpZnkodHlwZW9mIHRoaXMuYWRhcHRlcj8ucHJlcGFyZV9yZXF1ZXN0X2JvZHkgPT09ICdmdW5jdGlvbicgPyB0aGlzLmFkYXB0ZXIucHJlcGFyZV9yZXF1ZXN0X2JvZHkoYm9keSkgOiBib2R5KTtcbiAgICBjb25zb2xlLmxvZyhyZXEpO1xuICAgIHRyeSB7XG4gICAgICBpZihvcHRzLnN0cmVhbSkgcmV0dXJuIGF3YWl0IHRoaXMuc3RyZWFtKHJlcSk7XG4gICAgICAvLyBIQU5ETEUgTk9OLVNUUkVBTUlORyAoaW5jbHVkZXMgYWxsIGZ1bmN0aW9uIGNhbGxzKVxuICAgICAgY29uc3QgcmVzcF9qc29uID0gYXdhaXQgdGhpcy5yZXF1ZXN0KHJlcSk7XG4gICAgICBpZihyZXNwX2pzb24uZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihyZXNwX2pzb24uZXJyb3IpO1xuICAgICAgICBpZihyZW5kZXIpIHRoaXMuZG9uZV9oYW5kbGVyKFwiKkFQSSBFcnJvci4gU2VlIGNvbnNvbGUgbG9ncyBmb3IgZGV0YWlscy4qXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBpZiBpcyB0b29sX2NhbGwsIGhhbmRsZSB0b29sX2NhbGwgYW5kIHJldHVyblxuICAgICAgY29uc3QgdG9vbF9jYWxsID0gdGhpcy5nZXRfdG9vbF9jYWxsKHJlc3BfanNvbik7XG4gICAgICBpZih0b29sX2NhbGwpe1xuICAgICAgICB0aGlzLmVudi5jaGF0cy5jdXJyZW50LnRvb2xfY2hvaWNlID0gbnVsbDsgLy8gSU1QT1JUQU5UOiBwcmV2ZW50IGluZmluaXRlIGxvb3BcbiAgICAgICAgLy8gaWYgKHRoaXMuY3VycmVudC50b29sX2Nob2ljZSAhPT0gXCJhdXRvXCIpIHRoaXMuY3VycmVudC50b29sX2Nob2ljZSA9IG51bGw7IC8vIHJlbW92ZSB0b29sX2Nob2ljZSBmcm9tIGN1cnJlbnQgaWYgbm90IGF1dG8gKHByZXZlbnQgaW5maW5pdGUgbG9vcClcbiAgICAgICAgY29uc3QgdG9vbF9uYW1lID0gdGhpcy5nZXRfdG9vbF9uYW1lKHRvb2xfY2FsbCk7XG4gICAgICAgIGNvbnN0IHRvb2xfY2FsbF9jb250ZW50ID0gdGhpcy5nZXRfdG9vbF9jYWxsX2NvbnRlbnQodG9vbF9jYWxsKTtcbiAgICAgICAgY29uc3QgdG9vbCA9IGJvZHkudG9vbHMuZmluZCgodCkgPT4gdC5mdW5jdGlvbi5uYW1lID09PSB0b29sX25hbWUpOyAvLyBwbGF0Zm9ybS1hZ25vc3RpY1xuICAgICAgICBpZihpc192YWxpZF90b29sX2NhbGwodG9vbCwgdG9vbF9jYWxsX2NvbnRlbnQpKXtcbiAgICAgICAgICBhd2FpdCB0aGlzLmN1cnJlbnQuYWRkX21lc3NhZ2UoeyByb2xlOiAnYXNzaXN0YW50JywgdG9vbF9jYWxsczogW3tcbiAgICAgICAgICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgICAgICAgIG5hbWU6IHRvb2xfbmFtZSxcbiAgICAgICAgICAgICAgYXJndW1lbnRzOiBKU09OLnN0cmluZ2lmeSh0b29sX2NhbGxfY29udGVudCksXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfV0gfSk7XG4gICAgICAgICAgY29uc3QgdG9vbF9oYW5kbGVyID0gdGhpcy5nZXRfdG9vbF9oYW5kbGVyKHRvb2xfbmFtZSk7XG4gICAgICAgICAgaWYoIXRvb2xfaGFuZGxlcikgcmV0dXJuIGNvbnNvbGUuZXJyb3IoYFRvb2wgJHt0b29sX25hbWV9IG5vdCBmb3VuZGApO1xuICAgICAgICAgIGNvbnN0IHRvb2xfb3V0cHV0ID0gYXdhaXQgdG9vbF9oYW5kbGVyKHRoaXMuZW52LCB0b29sX2NhbGxfY29udGVudCk7XG4gICAgICAgICAgaWYodG9vbF9vdXRwdXQpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY3VycmVudC5hZGRfdG9vbF9vdXRwdXQodG9vbF9uYW1lLCB0b29sX291dHB1dCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZSh7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAvLyBETzogdXNlIHRvb2wgc3BlY3MgdG8gY29lcmNlIHRvb2xfY2FsbCB0byBtYXRjaCB0b29sLmZ1bmN0aW9uLnBhcmFtZXRlcnNcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBJbnZhbGlkIHRvb2wgY2FsbDogJHt0b29sX2NhbGx9YCk7XG4gICAgICAgICAgaWYocmVuZGVyKSB0aGlzLmRvbmVfaGFuZGxlcihcIipJbnZhbGlkIHRvb2wgY2FsbC4gU2VlIGNvbnNvbGUgbG9ncyBmb3IgZGV0YWlscy4qXCIpO1xuICAgICAgICAgIHJldHVybiBcIipJbnZhbGlkIHRvb2wgY2FsbC4gU2VlIGNvbnNvbGUgbG9ncyBmb3IgZGV0YWlscy4qXCI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYocmVuZGVyKSB0aGlzLmRvbmVfaGFuZGxlcih0aGlzLmdldF9tZXNzYWdlX2NvbnRlbnQocmVzcF9qc29uKSk7XG4gICAgICByZXR1cm4gdGhpcy5nZXRfbWVzc2FnZV9jb250ZW50KHJlc3BfanNvbik7XG4gICAgICAvLyBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAvLyBuZXcgTm90aWNlKGBTbWFydCBDb25uZWN0aW9ucyBBUEkgRXJyb3IgOjogJHtlcnJ9YCk7XG4gICAgfVxuICB9XG4gIC8vIEhBTkRMRSBUT09MU1xuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSB0b29sIGhhbmRsZXIgZnVuY3Rpb24gYmFzZWQgb24gdGhlIHRvb2wgbmFtZSBmcm9tIHRoZSBlbnZpcm9ubWVudCdzIGFjdGlvbnMuXG4gICAqIFRoaXMgbWV0aG9kIGNhbiBiZSBvdmVycmlkZGVuIHRvIHVzZSBjdXN0b20gbG9naWMgZm9yIGhhbmRsaW5nIHRvb2xzLlxuICAgKiBcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvb2xfbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSB0b29sIGZvciB3aGljaCB0aGUgaGFuZGxlciBpcyB0byBiZSByZXRyaWV2ZWQuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gVGhlIGhhbmRsZXIgZnVuY3Rpb24gZm9yIHRoZSBzcGVjaWZpZWQgdG9vbC5cbiAgICovXG4gIGdldF90b29sX2hhbmRsZXIodG9vbF9uYW1lKSB7IHJldHVybiB0aGlzLmVudi5hY3Rpb25zLmFjdGlvbnNbdG9vbF9uYW1lXS5oYW5kbGVyOyB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3RzIHRoZSB0b29sIGNhbGwgaW5mb3JtYXRpb24gZnJvbSBhIEpTT04gcmVzcG9uc2UuIFRoaXMgbWV0aG9kIHN1cHBvcnRzIGFkYXB0ZXItc3BlY2lmaWMgbG9naWMuXG4gICAqIElmIG5vIGFkYXB0ZXIgbWV0aG9kIGlzIHByb3ZpZGVkLCBpdCBkZWZhdWx0cyB0byB0aGUgZXhwZWN0ZWQgT3BlbkFJIEpTT04gZm9ybWF0LlxuICAgKiBcbiAgICogQHBhcmFtIHtPYmplY3R9IGpzb24gLSBUaGUgSlNPTiByZXNwb25zZSBmcm9tIHdoaWNoIHRvIGV4dHJhY3QgdGhlIHRvb2wgY2FsbC5cbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIGZpcnN0IHRvb2wgY2FsbCBmb3VuZCBpbiB0aGUgcmVzcG9uc2UuXG4gICAqL1xuICBnZXRfdG9vbF9jYWxsKGpzb24pIHtcbiAgICBpZih0eXBlb2YgdGhpcy5hZGFwdGVyPy5nZXRfdG9vbF9jYWxsID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpcy5hZGFwdGVyLmdldF90b29sX2NhbGwoanNvbik7XG4gICAgcmV0dXJuIGpzb24uY2hvaWNlcz8uWzBdLm1lc3NhZ2UudG9vbF9jYWxscz8uWzBdOyAvLyBPcGVuQUkgZm9ybWF0XG4gIH0gXG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgdGhlIHRvb2wgbmFtZSBmcm9tIGEgdG9vbCBjYWxsIG9iamVjdC4gU3VwcG9ydHMgYWRhcHRlci1zcGVjaWZpYyBpbXBsZW1lbnRhdGlvbnMuXG4gICAqIERlZmF1bHRzIHRvIGV4dHJhY3RpbmcgdGhlIG5hbWUgZGlyZWN0bHkgZnJvbSB0aGUgdG9vbCBjYWxsIHN0cnVjdHVyZS5cbiAgICogXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0b29sX2NhbGwgLSBUaGUgdG9vbCBjYWxsIG9iamVjdCBmcm9tIHdoaWNoIHRvIGV4dHJhY3QgdGhlIHRvb2wgbmFtZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIHRvb2wuXG4gICAqL1xuICBnZXRfdG9vbF9uYW1lKHRvb2xfY2FsbCkge1xuICAgIGlmKHR5cGVvZiB0aGlzLmFkYXB0ZXI/LmdldF90b29sX25hbWUgPT09ICdmdW5jdGlvbicpIHJldHVybiB0aGlzLmFkYXB0ZXIuZ2V0X3Rvb2xfbmFtZSh0b29sX2NhbGwpO1xuICAgIHJldHVybiB0b29sX2NhbGwuZnVuY3Rpb24ubmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0cyB0aGUgdG9vbCBjYWxsIGNvbnRlbnQgZnJvbSBhIHRvb2wgY2FsbCBvYmplY3QuIFN1cHBvcnRzIGFkYXB0ZXItc3BlY2lmaWMgbG9naWMuXG4gICAqIERlZmF1bHRzIHRvIHBhcnNpbmcgdGhlICdhcmd1bWVudHMnIGZpZWxkIG9mIHRoZSB0b29sIGNhbGwgZnVuY3Rpb24gYXMgSlNPTi5cbiAgICogXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0b29sX2NhbGwgLSBUaGUgdG9vbCBjYWxsIG9iamVjdCBmcm9tIHdoaWNoIHRvIGV4dHJhY3QgdGhlIGNvbnRlbnQuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBwYXJzZWQgYXJndW1lbnRzIG9mIHRoZSB0b29sIGNhbGwuXG4gICAqL1xuICBnZXRfdG9vbF9jYWxsX2NvbnRlbnQodG9vbF9jYWxsKSB7XG4gICAgaWYodHlwZW9mIHRoaXMuYWRhcHRlcj8uZ2V0X3Rvb2xfY2FsbF9jb250ZW50ID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpcy5hZGFwdGVyLmdldF90b29sX2NhbGxfY29udGVudCh0b29sX2NhbGwpO1xuICAgIHJldHVybiBKU09OLnBhcnNlKHRvb2xfY2FsbC5mdW5jdGlvbi5hcmd1bWVudHMpO1xuICB9XG5cbiAgLy8gSEFORExFIE1FU1NBR0VTXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIG1lc3NhZ2Ugb2JqZWN0IGZyb20gYSBKU09OIHJlc3BvbnNlLiBTdXBwb3J0cyBhZGFwdGVyLXNwZWNpZmljIGltcGxlbWVudGF0aW9ucy5cbiAgICogRGVmYXVsdHMgdG8gaGFuZGxpbmcgYm90aCBPcGVuQUkgYW5kIE9sbGFtYSBmb3JtYXRzIGJ5IGNoZWNraW5nIGZvciBtZXNzYWdlIHN0cnVjdHVyZXMgaW4gJ2Nob2ljZXMnLlxuICAgKiBcbiAgICogQHBhcmFtIHtPYmplY3R9IGpzb24gLSBUaGUgSlNPTiByZXNwb25zZSBmcm9tIHdoaWNoIHRvIGV4dHJhY3QgdGhlIG1lc3NhZ2UuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBtZXNzYWdlIG9iamVjdCBleHRyYWN0ZWQgZnJvbSB0aGUgcmVzcG9uc2UuXG4gICAqL1xuICBnZXRfbWVzc2FnZShqc29uKSB7XG4gICAgaWYodHlwZW9mIHRoaXMuYWRhcHRlcj8uZ2V0X21lc3NhZ2UgPT09ICdmdW5jdGlvbicpIHJldHVybiB0aGlzLmFkYXB0ZXIuZ2V0X21lc3NhZ2UoanNvbik7XG4gICAgcmV0dXJuIGpzb24uY2hvaWNlcz8uWzBdLm1lc3NhZ2UgfHwganNvbi5tZXNzYWdlOyAvLyBzdXBwb3J0cyBPcGVuQUkgYW5kIE9sbGFtYVxuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3RzIHRoZSBjb250ZW50IG9mIGEgbWVzc2FnZSBmcm9tIGEgSlNPTiByZXNwb25zZS4gU3VwcG9ydHMgYWRhcHRlci1zcGVjaWZpYyBpbXBsZW1lbnRhdGlvbnMuXG4gICAqIFRoaXMgbWV0aG9kIHJlbGllcyBvbiBgZ2V0X21lc3NhZ2VgIHRvIGZpcnN0IHJldHJpZXZlIHRoZSBtZXNzYWdlIG9iamVjdC5cbiAgICogXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBqc29uIC0gVGhlIEpTT04gcmVzcG9uc2UgZnJvbSB3aGljaCB0byBleHRyYWN0IHRoZSBtZXNzYWdlIGNvbnRlbnQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb250ZW50IG9mIHRoZSBtZXNzYWdlLlxuICAgKi9cbiAgZ2V0X21lc3NhZ2VfY29udGVudChqc29uKSB7XG4gICAgaWYodHlwZW9mIHRoaXMuYWRhcHRlcj8uZ2V0X21lc3NhZ2VfY29udGVudCA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXMuYWRhcHRlci5nZXRfbWVzc2FnZV9jb250ZW50KGpzb24pO1xuICAgIHJldHVybiB0aGlzLmdldF9tZXNzYWdlKGpzb24pLmNvbnRlbnQ7XG4gIH1cblxuICBhc3luYyByZXF1ZXN0KHJlcSl7XG4gICAgcmVxLnVybCA9IHRoaXMuZW5kcG9pbnQ7XG4gICAgcmVxLnRocm93ID0gZmFsc2U7XG4gICAgLy8gaGFuZGxlIGZhbGxiYWNrIHRvIGZldGNoIChhbGxvd3MgZm9yIG92ZXJ3cml0aW5nIGluIGNoaWxkIGNsYXNzZXMpXG4gICAgY29uc3QgcmVzcCA9IHRoaXMuX3JlcXVlc3RfYWRhcHRlciA/IGF3YWl0IHRoaXMuX3JlcXVlc3RfYWRhcHRlcihyZXEpIDogYXdhaXQgZmV0Y2godGhpcy5lbmRwb2ludCwgcmVxKTtcbiAgICBjb25zb2xlLmxvZyhyZXNwKTtcbiAgICBjb25zdCByZXNwX2pzb24gPSBhd2FpdCB0aGlzLmdldF9yZXNwX2pzb24ocmVzcCk7XG4gICAgY29uc29sZS5sb2cocmVzcF9qc29uKTtcbiAgICByZXR1cm4gcmVzcF9qc29uO1xuICB9XG4gIGFzeW5jIGdldF9yZXNwX2pzb24ocmVzcCkgeyByZXR1cm4gKHR5cGVvZiByZXNwLmpzb24gPT09ICdmdW5jdGlvbicpID8gYXdhaXQgcmVzcC5qc29uKCkgOiBhd2FpdCByZXNwLmpzb247IH1cbiAgZ2V0IHJlcXVlc3RfYWRhcHRlcigpeyByZXR1cm4gdGhpcy5fcmVxdWVzdF9hZGFwdGVyOyB9XG5cbiAgYXN5bmMgc3RyZWFtKHJlcSkge1xuICAgIGNvbnNvbGUubG9nKFwiU3RyZWFtaW5nIFJlcXVlc3Q6IFwiKTtcbiAgICBjb25zb2xlLmxvZyhyZXEpO1xuICAgIGNvbnN0IGZ1bGxfdGV4dCA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwic3RyZWFtXCIsIG9wdHMpO1xuICAgICAgICB0aGlzLmFjdGl2ZV9zdHJlYW0gPSBuZXcgU21hcnRTdHJlYW1lcih0aGlzLmVuZHBvaW50X3N0cmVhbWluZywgcmVxKTtcbiAgICAgICAgbGV0IGN1cnJfdGV4dCA9IFwiXCI7XG4gICAgICAgIHRoaXMuYWN0aXZlX3N0cmVhbS5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZSkgPT4ge1xuICAgICAgICAgIGlmKHRoaXMuaXNfZW5kX29mX3N0cmVhbShlKSkge1xuICAgICAgICAgICAgdGhpcy5zdG9wX3N0cmVhbSgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoY3Vycl90ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHRleHRfY2h1bmsgPSB0aGlzLmdldF90ZXh0X2NodW5rX2Zyb21fc3RyZWFtKGUpO1xuICAgICAgICAgIGlmKCF0ZXh0X2NodW5rKSByZXR1cm47XG4gICAgICAgICAgY3Vycl90ZXh0ICs9IHRleHRfY2h1bms7XG4gICAgICAgICAgdGhpcy5jaHVua19oYW5kbGVyKHRleHRfY2h1bmspOyAvLyBjYWxsIHRoZSBjaHVuayBoYW5kbGVyIGlmIGl0IGV4aXN0c1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gdW5uZWNlc3Nhcnk/XG4gICAgICAgIHRoaXMuYWN0aXZlX3N0cmVhbS5hZGRFdmVudExpc3RlbmVyKFwicmVhZHlzdGF0ZWNoYW5nZVwiLCAoZSkgPT4ge1xuICAgICAgICAgIGlmIChlLnJlYWR5U3RhdGUgPj0gMikgY29uc29sZS5sb2coXCJSZWFkeVN0YXRlOiBcIiArIGUucmVhZHlTdGF0ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFjdGl2ZV9zdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIChlKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICB0aGlzLmRvbmVfaGFuZGxlcihcIipBUEkgRXJyb3IuIFNlZSBjb25zb2xlIGxvZ3MgZm9yIGRldGFpbHMuKlwiKTtcbiAgICAgICAgICB0aGlzLnN0b3Bfc3RyZWFtKCk7XG4gICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hY3RpdmVfc3RyZWFtLnN0cmVhbSgpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgdGhpcy5zdG9wX3N0cmVhbSgpO1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmRvbmVfaGFuZGxlcihmdWxsX3RleHQpOyAvLyBoYW5kbGVkIGluIGNvbXBsZXRlKClcbiAgICByZXR1cm4gZnVsbF90ZXh0O1xuICB9XG4gIGdldF90ZXh0X2NodW5rX2Zyb21fc3RyZWFtKGV2ZW50KSB7XG4gICAgaWYodHlwZW9mIHRoaXMuYWRhcHRlcj8uZ2V0X3RleHRfY2h1bmtfZnJvbV9zdHJlYW0gPT09ICdmdW5jdGlvbicpIHJldHVybiB0aGlzLmFkYXB0ZXIuZ2V0X3RleHRfY2h1bmtfZnJvbV9zdHJlYW0oZXZlbnQpO1xuICAgIGxldCByZXNwID0gbnVsbDtcbiAgICBsZXQgdGV4dF9jaHVuayA9ICcnO1xuICAgIC8vIERPOiBpcyB0aGlzIHRyeS9jYXRjaCBzdGlsbCBuZWNlc3Nhcnk/XG4gICAgdHJ5IHtcbiAgICAgIHJlc3AgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuICAgICAgdGV4dF9jaHVuayA9IHJlc3AuY2hvaWNlc1swXS5kZWx0YS5jb250ZW50O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgIGNvbnNvbGUubG9nKGV2ZW50LmRhdGEpO1xuICAgICAgaWYgKGV2ZW50LmRhdGEuaW5kZXhPZignfXsnKSA+IC0xKSBldmVudC5kYXRhID0gZXZlbnQuZGF0YS5yZXBsYWNlKC99ey9nLCAnfSx7Jyk7XG4gICAgICByZXNwID0gSlNPTi5wYXJzZShgWyR7ZXZlbnQuZGF0YX1dYCk7XG4gICAgICByZXNwLmZvckVhY2goKHIpID0+IHtcbiAgICAgICAgaWYgKHIuY2hvaWNlcykgdGV4dF9jaHVuayArPSByLmNob2ljZXNbMF0uZGVsdGEuY29udGVudDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dF9jaHVuaztcbiAgfVxuICBpc19lbmRfb2Zfc3RyZWFtKGV2ZW50KSB7XG4gICAgaWYodHlwZW9mIHRoaXMuYWRhcHRlcj8uaXNfZW5kX29mX3N0cmVhbSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXMuYWRhcHRlci5pc19lbmRfb2Zfc3RyZWFtKGV2ZW50KTtcbiAgICByZXR1cm4gZXZlbnQuZGF0YSA9PT0gXCJbRE9ORV1cIjsgLy8gdXNlIGRlZmF1bHQgT3BlbkFJIGZvcm1hdFxuICB9XG5cbiAgc3RvcF9zdHJlYW0oKSB7XG4gICAgaWYgKHRoaXMuYWN0aXZlX3N0cmVhbSkge1xuICAgICAgdGhpcy5hY3RpdmVfc3RyZWFtLmVuZCgpO1xuICAgICAgdGhpcy5hY3RpdmVfc3RyZWFtID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgZG9uZV9oYW5kbGVyKGZ1bGxfc3RyKSB7XG4gICAgLy8gU2hvdWxkIGhhbmRsZTpcbiAgICAvLyAxLiBBZGQgbWVzc2FnZSB0byBjdXJyZW50IGNoYXQgaGlzdG9yeVxuICAgIC8vIDIuIFVwZGF0ZSBjaGF0IFVJXG4gICAgaWYodHlwZW9mIHRoaXMubWFpbi5kb25lX2hhbmRsZXIgPT09ICdmdW5jdGlvbicpIHRoaXMubWFpbi5kb25lX2hhbmRsZXIoZnVsbF9zdHIpO1xuICB9XG4gIGNodW5rX2hhbmRsZXIodGV4dF9jaHVuaykge1xuICAgIC8vIFNob3VsZCBoYW5kbGU6XG4gICAgLy8gMS4gVXBkYXRlIGNoYXQgVUlcbiAgICBpZih0eXBlb2YgdGhpcy5tYWluLmNodW5rX2hhbmRsZXIgPT09ICdmdW5jdGlvbicpIHRoaXMubWFpbi5jaHVua19oYW5kbGVyKHRleHRfY2h1bmspO1xuICB9XG4gIGFzeW5jIGNvdW50X3Rva2VucyhpbnB1dCkge1xuICAgIGlmKHR5cGVvZiB0aGlzLmFkYXB0ZXI/LmNvdW50X3Rva2VucyA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGF3YWl0IHRoaXMuYWRhcHRlci5jb3VudF90b2tlbnMoaW5wdXQpO1xuICAgIHJldHVybiB0aGlzLmVzdGltYXRlX3Rva2VucyhpbnB1dCk7XG4gIH1cbiAgZXN0aW1hdGVfdG9rZW5zKGlucHV0KSB7XG4gICAgaWYodHlwZW9mIHRoaXMuYWRhcHRlcj8uZXN0aW1hdGVfdG9rZW5zID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpcy5hZGFwdGVyLmVzdGltYXRlX3Rva2VucyhpbnB1dCk7XG4gICAgaWYodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JykgaW5wdXQgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgcmV0dXJuIGlucHV0Lmxlbmd0aCAvIDQ7XG4gIH1cbiAgYXN5bmMgdGVzdF9hcGlfa2V5KCkge1xuICAgIGNvbnNvbGUubG9nKHRoaXMuYXBpX2tleSk7XG4gICAgdHJ5e1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgbWVzc2FnZXM6IFtcbiAgICAgICAgICB7IHJvbGU6IFwidXNlclwiLCBjb250ZW50OiBcIkhlbGxvXCIgfSxcbiAgICAgICAgXSxcbiAgICAgICAgdGVtcGVyYXR1cmU6IDAsXG4gICAgICAgIG1heF90b2tlbnM6IDEwMCxcbiAgICAgICAgc3RyZWFtOiBmYWxzZSxcbiAgICAgICAgbjogMSxcbiAgICAgIH07XG4gICAgICBpZih0aGlzLmNvbmZpZy5mZXRjaF9tb2RlbHMpIHtcbiAgICAgICAgcmVxdWVzdC5tb2RlbCA9IHRoaXMuY29uZmlnLmRlZmF1bHRfbW9kZWw7XG4gICAgICB9XG4gICAgICBjb25zdCByZXNwID0gYXdhaXQgdGhpcy5jb21wbGV0ZShyZXF1ZXN0LCBmYWxzZSk7XG4gICAgICBjb25zb2xlLmxvZyhyZXNwKTtcbiAgICAgIGlmKCFyZXNwKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9Y2F0Y2goZXJyKXtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZ2V0X21vZGVscygpIHtcbiAgICAvLyBjb25zdCBmeF9uYW1lID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MuY2hhdF9tb2RlbF9wbGF0Zm9ybV9rZXk7XG4gICAgaWYodGhpcy5wbGF0Zm9ybXNbdGhpcy5wbGF0Zm9ybV9rZXldPy5mZXRjaF9tb2RlbHMgJiYgdHlwZW9mIGZldGNoX21vZGVsc1t0aGlzLnBsYXRmb3JtX2tleV0gPT09IFwiZnVuY3Rpb25cIil7XG4gICAgICBjb25zdCBtb2RlbHMgPSBhd2FpdCBmZXRjaF9tb2RlbHNbdGhpcy5wbGF0Zm9ybV9rZXldKHRoaXMuYXBpX2tleSk7XG4gICAgICBpZihtb2RlbHMpIHtcbiAgICAgICAgLy8gc29ydCBhbHBoYWJldGljYWxseSBieSBtb2RlbCBuYW1lXG4gICAgICAgIG1vZGVscy5zb3J0KChhLCBiKSA9PiBhLm1vZGVsX25hbWUubG9jYWxlQ29tcGFyZShiLm1vZGVsX25hbWUpKTtcbiAgICAgICAgcmV0dXJuIG1vZGVscztcbiAgICAgIH1lbHNlIGNvbnNvbGUuZXJyb3IoYE5vIG1vZGVscyBmb3VuZCBmb3IgJHt0aGlzLnBsYXRmb3JtX2tleX1gLCBtb2RlbHMpO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cbiAgYXN5bmMgZ2V0X2Jhc2VfbW9kZWxfY29uZmlnKCkge1xuICAgIGNvbnN0IG1vZGVscyA9IGF3YWl0IHRoaXMuZ2V0X21vZGVscygpO1xuICAgIHJldHVybiBtb2RlbHMuZmluZCgobSkgPT4gbS5rZXkgPT09IHRoaXMubW9kZWxfbmFtZSk7XG4gIH1cbiAgLy8gZ2V0dGVyc1xuICBnZXQgYXBpX2tleSgpIHsgcmV0dXJuIHRoaXMuY29uZmlnLmFwaV9rZXk7IH1cbiAgZ2V0IGN1cnJlbnQoKSB7IHJldHVybiB0aGlzLmVudi5jaGF0cz8uY3VycmVudDsgfVxuICAvLyB1c2UgZW5kcG9pbnQgb2YgY29tYmluZSBwcm90b2NvbCwgaG9zdG5hbWUsIHBvcnQsIGFuZCBwYXRoXG4gIGdldCBlbmRwb2ludCgpIHtcbiAgICBpZih0eXBlb2YgdGhpcy5hZGFwdGVyPy5lbmRwb2ludCAhPT0gJ3VuZGVmaW5lZCcpIHJldHVybiB0aGlzLmFkYXB0ZXIuZW5kcG9pbnQucmVwbGFjZSgnTU9ERUxfTkFNRScsIHRoaXMubW9kZWxfbmFtZSk7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmVuZHBvaW50IHx8IHRoaXMuY29uZmlnLnByb3RvY29sICsgXCI6Ly9cIiArIHRoaXMuY29uZmlnLmhvc3RuYW1lICsgKHRoaXMuY29uZmlnLnBvcnQgPyBcIjpcIiArIHRoaXMuY29uZmlnLnBvcnQgOiBcIlwiKSArIHRoaXMuZW5kcG9pbnRfcGF0aDtcbiAgfVxuICBnZXQgZW5kcG9pbnRfc3RyZWFtaW5nKCkge1xuICAgIGlmKHR5cGVvZiB0aGlzLmFkYXB0ZXI/LmVuZHBvaW50X3N0cmVhbWluZyAhPT0gJ3VuZGVmaW5lZCcpIHJldHVybiB0aGlzLmFkYXB0ZXIuZW5kcG9pbnRfc3RyZWFtaW5nLnJlcGxhY2UoJ01PREVMX05BTUUnLCB0aGlzLm1vZGVsX25hbWUpO1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5lbmRwb2ludF9zdHJlYW1pbmcgfHwgdGhpcy5lbmRwb2ludDtcbiAgfVxuICBnZXQgZW5kcG9pbnRfcGF0aCgpIHsgcmV0dXJuIHRoaXMuY29uZmlnLnBhdGguc3RhcnRzV2l0aCgnLycpID8gdGhpcy5jb25maWcucGF0aCA6ICcvJyArIHRoaXMuY29uZmlnLnBhdGg7IH1cbiAgZ2V0IG1heF9pbnB1dF90b2tlbnMoKSB7IHJldHVybiB0aGlzLmNvbmZpZy5tYXhfaW5wdXRfdG9rZW5zOyB9XG4gIGdldCBtYXhfb3V0cHV0X3Rva2VucygpIHsgcmV0dXJuIHRoaXMuY29uZmlnLm1heF9vdXRwdXRfdG9rZW5zOyB9XG4gIGdldCBtb2RlbF9uYW1lKCkgeyByZXR1cm4gdGhpcy5jb25maWcubW9kZWxfbmFtZSB8fCB0aGlzLmNvbmZpZy5kZWZhdWx0X21vZGVsOyB9XG4gIGdldCBtdWx0aW1vZGFsKCkgeyByZXR1cm4gdHlwZW9mIHRoaXMuYWRhcHRlcj8ubXVsdGltb2RhbCAhPT0gJ3VuZGVmaW5lZCcgPyB0aGlzLmFkYXB0ZXIubXVsdGltb2RhbCA6IHRoaXMuY29uZmlnLm11bHRpbW9kYWw7IH1cbn1cbmV4cG9ydHMuU21hcnRDaGF0TW9kZWwgPSBTbWFydENoYXRNb2RlbDtcblxuIiwgImNvbnN0IFNjVHJhbnNsYXRpb25zID0gcmVxdWlyZShcIi4vU2NUcmFuc2xhdGlvbnNcIik7XG5jb25zdCB7IFNtYXJ0Q2hhdE1vZGVsIH0gPSByZXF1aXJlKFwic21hcnQtY2hhdC1tb2RlbFwiKTtcbmNsYXNzIFNjQ2hhdE1vZGVsIGV4dGVuZHMgU21hcnRDaGF0TW9kZWwge1xuICBhc3luYyBkb25lX2hhbmRsZXIoZnVsbF9zdHIpIHtcbiAgICBhd2FpdCB0aGlzLmVudi5jaGF0X3VpLm5ld19tZXNzYWdlKGZ1bGxfc3RyLCBcImFzc2lzdGFudFwiKTtcbiAgICB0aGlzLmVudi5jaGF0cy5jdXJyZW50LmFkZF9tZXNzYWdlKHsgcm9sZTogXCJhc3Npc3RhbnRcIiwgY29udGVudDogZnVsbF9zdHIgfSk7XG4gICAgdGhpcy5lbnYuY2hhdF91aS5jbGVhcl9zdHJlYW1pbmdfdXgoKTsgLy8gcmVkdW5kYW50IHdoZW4gc3RyZWFtaW5nLCBmb3IgY29tcGxldGlvbiB0ZXN0aW5nXG4gIH1cbiAgYXN5bmMgY2h1bmtfaGFuZGxlcih0ZXh0X2NodW5rKSB7XG4gICAgYXdhaXQgdGhpcy5lbnYuY2hhdF91aS5uZXdfbWVzc2FnZSh0ZXh0X2NodW5rLCBcImFzc2lzdGFudFwiLCB0cnVlKTtcbiAgfVxuICBhc3luYyByZXF1ZXN0X21pZGRsZXdhcmVzKG9wdHMpIHtcbiAgICAvLyBjb252ZXJ0IGNvbnRleHQgY29kZWJsb2NrcyB0byBwcm9tcHQgY29udGV4dFxuICAgIGF3YWl0IFByb21pc2UuYWxsKG9wdHMubWVzc2FnZXMubWFwKGFzeW5jIChtc2csIGkpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRleHRfc3RhcnQgPSBcImBgYHNjLWNvbnRleHRcIjtcbiAgICAgIC8vIHJlcGxhY2UgbG9va3VwIHRvb2wgY2FsbCB3aXRoIGNvbnRleHQgY29kZWJsb2NrIChwcmlvciB0byByZW5kZXJpbmcgY29udGV4dCBjb2RlYmxvY2sgYXMgcHJvbXB0IGNvbnRleHQpXG4gICAgICBpZiAobXNnLnJvbGUgPT09IFwidG9vbFwiICYmIG1zZy50b29sX2NhbGxfaWQgPT09IFwibG9va3VwXCIpIHtcbiAgICAgICAgbXNnLnJvbGUgPSBcInN5c3RlbVwiO1xuICAgICAgICBtc2cuY29udGVudCA9IGNvbnRleHRfc3RhcnQgKyBcIlxcblwiICsgSlNPTi5wYXJzZShtc2cuY29udGVudCkubWFwKGMgPT4gYy5wYXRoKS5qb2luKCdcXG4nKSArIFwiXFxuYGBgXCI7XG4gICAgICB9XG4gICAgICBpZiAobXNnLnJvbGUgPT09IFwic3lzdGVtXCIgJiYgbXNnLmNvbnRlbnQuaW5jbHVkZXMoY29udGV4dF9zdGFydCkpIHtcbiAgICAgICAgY29uc3QgY29udGV4dF9zdGFydF9pID0gbXNnLmNvbnRlbnQuaW5kZXhPZihjb250ZXh0X3N0YXJ0KSArIGNvbnRleHRfc3RhcnQubGVuZ3RoO1xuICAgICAgICBjb25zdCBjb250ZXh0X2VuZF9pID0gbXNnLmNvbnRlbnQuc3Vic3RyaW5nKGNvbnRleHRfc3RhcnRfaSkuaW5kZXhPZihcImBgYFwiKTtcbiAgICAgICAgY29uc3QgcmF3X2NvbnRlbnRzID0gbXNnLmNvbnRlbnQuc3Vic3RyaW5nKGNvbnRleHRfc3RhcnRfaSwgY29udGV4dF9zdGFydF9pICsgY29udGV4dF9lbmRfaSk7XG4gICAgICAgIGNvbnN0IGVudGl0aWVzID0gdGhpcy5lbnYucGx1Z2luLmdldF9lbnRpdGllc19mcm9tX2NvbnRleHRfY29kZWJsb2NrKHJhd19jb250ZW50cyk7XG4gICAgICAgIGxldCBjb250ZXh0ID0gW107XG4gICAgICAgIGxldCB0b2tlbnMgPSBbXTtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoZW50aXRpZXMubWFwKGFzeW5jIChlbnRpdHksIGkpID0+IHtcbiAgICAgICAgICBpZiAoIWVudGl0eT8uZ2V0X2FzX2NvbnRleHQpIHJldHVybiBjb25zb2xlLmxvZyhlbnRpdHkpO1xuICAgICAgICAgIGNvbnRleHRbaV0gPSBhd2FpdCBlbnRpdHkuZ2V0X2FzX2NvbnRleHQoeyBpIH0pO1xuICAgICAgICAgIHRva2Vuc1tpXSA9IGF3YWl0IHRoaXMuY291bnRfdG9rZW5zKGNvbnRleHRbaV0pO1xuICAgICAgICB9KSk7XG4gICAgICAgIGxldCB0b3RhbF90b2tlbnMgPSAwO1xuICAgICAgICBsZXQgY3QgPSAwO1xuICAgICAgICBjb250ZXh0ID0gY29udGV4dFxuICAgICAgICAgIC5yZWR1Y2UoKGFjYywgYywgaSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFjKSByZXR1cm4gYWNjO1xuICAgICAgICAgICAgaWYgKHRvdGFsX3Rva2VucyArIHRva2Vuc1tpXSA+IHRoaXMubWF4X2lucHV0X3Rva2VucykgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIHRvdGFsX3Rva2VucyArPSB0b2tlbnNbaV07XG4gICAgICAgICAgICBjdCsrO1xuICAgICAgICAgICAgaWYgKGFjYykgYWNjICs9ICdcXG4nO1xuICAgICAgICAgICAgcmV0dXJuIGFjYyArIGM7XG4gICAgICAgICAgfSwgJycpO1xuICAgICAgICBtc2cuY29udGVudCA9IHRoaXMuZ2V0X3Byb21wdF9jb250ZXh0X3ByZWZpeCh7IGN0IH0pICsgJ1xcbicgKyBjb250ZXh0O1xuICAgICAgfVxuICAgICAgY29uc3Qgc3lzX3N0YXJ0ID0gXCJgYGBzYy1zeXN0ZW1cIjtcbiAgICAgIGlmIChtc2cucm9sZSA9PT0gXCJzeXN0ZW1cIiAmJiBtc2cuY29udGVudC5pbmNsdWRlcyhzeXNfc3RhcnQpKSB7XG4gICAgICAgIGNvbnN0IHN5c19zdGFydF9pID0gbXNnLmNvbnRlbnQuaW5kZXhPZihzeXNfc3RhcnQpICsgc3lzX3N0YXJ0Lmxlbmd0aDtcbiAgICAgICAgY29uc3Qgc3lzX2VuZF9pID0gbXNnLmNvbnRlbnQuc3Vic3RyaW5nKHN5c19zdGFydF9pKS5pbmRleE9mKFwiYGBgXCIpO1xuICAgICAgICBjb25zdCBzeXNfcHJvbXB0cyA9IG1zZy5jb250ZW50LnN1YnN0cmluZyhzeXNfc3RhcnRfaSwgc3lzX3N0YXJ0X2kgKyBzeXNfZW5kX2kpLnNwbGl0KCdcXG4nKS5maWx0ZXIobG4gPT4gbG4udHJpbSgpKTtcbiAgICAgICAgY29uc29sZS5sb2coc3lzX3Byb21wdHMpO1xuICAgICAgICBtc2cuY29udGVudCA9IFwiXCI7XG4gICAgICAgIGZvciAoY29uc3Qgc3lzX3Byb21wdCBvZiBzeXNfcHJvbXB0cykge1xuICAgICAgICAgIGNvbnN0IHRmaWxlID0gdGhpcy5lbnYuc3lzdGVtX3Byb21wdHMuZmluZChmaWxlID0+IGZpbGUuYmFzZW5hbWUgPT09IHN5c19wcm9tcHQpO1xuICAgICAgICAgIGNvbnN0IG5vdGVfY29udGVudCA9IGF3YWl0IHRoaXMuZW52LnBsdWdpbi5icmFpbi5jYWNoZWRfcmVhZCh0ZmlsZSk7XG4gICAgICAgICAgaWYgKG1zZy5jb250ZW50KSBtc2cuY29udGVudCArPSAnXFxuJztcbiAgICAgICAgICBtc2cuY29udGVudCArPSBub3RlX2NvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtc2c7XG4gICAgfSkpO1xuICAgIC8vIHJlbW92ZSBhc3Npc3RhbnQgbWVzc2FnZXMgd2l0aG91dCBjb250ZW50IChpbmNsdWRpbmcgdG9vbCBjYWxscylcbiAgICBvcHRzLm1lc3NhZ2VzID0gb3B0cy5tZXNzYWdlcy5maWx0ZXIobXNnID0+IG1zZy5yb2xlICE9PSBcImFzc2lzdGFudFwiIHx8IG1zZy5jb250ZW50KTtcbiAgICBjb25zb2xlLmxvZyhvcHRzLm1lc3NhZ2VzKTtcbiAgICByZXR1cm4gb3B0cztcbiAgfVxuICBnZXRfcHJvbXB0X2NvbnRleHRfcHJlZml4KHBhcmFtcyA9IHt9KSB7XG4gICAgcmV0dXJuIGBBbnRpY2lwYXRlIHRoZSB0eXBlIG9mIGFuc3dlciBkZXNpcmVkIGJ5IHRoZSB1c2VyLmBcbiAgICAgICsgYCBJbWFnaW5lIHRoZSBmb2xsb3dpbmcke3BhcmFtcy5jdCA/IFwiIFwiICsgcGFyYW1zLmN0IDogXCJcIn0gbm90ZXMgd2VyZSB3cml0dGVuIGJ5IHRoZSB1c2VyIGFuZCBjb250YWluIGFsbCB0aGUgbmVjZXNzYXJ5IGluZm9ybWF0aW9uIHRvIGFuc3dlciB0aGUgdXNlcidzIHF1ZXN0aW9uLmBcbiAgICAgICsgYCBCZWdpbiByZXNwb25zZXMgd2l0aCBcIiR7U2NUcmFuc2xhdGlvbnNbdGhpcy5lbnYucGx1Z2luLnNldHRpbmdzLmxhbmd1YWdlXS5wcm9tcHR9Li4uXCJgO1xuICB9XG59XG5leHBvcnRzLlNjQ2hhdE1vZGVsID0gU2NDaGF0TW9kZWw7XG4iLCAiZnVuY3Rpb24gbWVzc2FnZV9jb250ZW50X2FycmF5X3RvX21hcmtkb3duKGNvbnRlbnQpIHtcbiAgbGV0IG1hcmtkb3duID0gJyc7XG4gIGNvbnRlbnQuZm9yRWFjaCgoYywgaSkgPT4ge1xuICAgIGlmIChjLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgaWYgKGMudGV4dC5zdGFydHNXaXRoKCdJbWFnZSBjYXB0aW9uOiAnKSkge1xuICAgICAgICAvLyBpZiBsYXN0IGNvbnRlbnQgaXMgaW1hZ2VfdXJsLCBhZGQgdGhlIGltYWdlX3VybCB0byB0aGUgbWFya2Rvd25cbiAgICAgICAgaWYgKGNvbnRlbnRbaSAtIDFdPy50eXBlID09PSAnaW1hZ2VfdXJsJykge1xuICAgICAgICAgIG1hcmtkb3duID0gbWFya2Rvd24uc3BsaXQoJ1xcbicpLnNsaWNlKDAsIC0yKS5qb2luKCdcXG4nKTtcbiAgICAgICAgICBtYXJrZG93biArPSBgXFxuIVske2MudGV4dC5zcGxpdCgnOicpWzFdLnRyaW0oKX1dKCR7Y29udGVudFtpIC0gMV0uaW1hZ2VfdXJsLnVybH0pYDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXJrZG93biArPSBgJHtjLnRleHR9YDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFya2Rvd24gKz0gYCR7Yy50ZXh0fWA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjLnR5cGUgPT09ICdpbWFnZV91cmwnKSBtYXJrZG93biArPSBgIVtdKCR7Yy5pbWFnZV91cmwudXJsfSlgO1xuICAgIG1hcmtkb3duICs9ICdcXG4nO1xuICB9KTtcbiAgcmV0dXJuIG1hcmtkb3duLnRyaW0oKTtcbn1cbmV4cG9ydHMubWVzc2FnZV9jb250ZW50X2FycmF5X3RvX21hcmtkb3duID0gbWVzc2FnZV9jb250ZW50X2FycmF5X3RvX21hcmtkb3duO1xuIiwgImNvbnN0IHsgbWVzc2FnZV9jb250ZW50X2FycmF5X3RvX21hcmtkb3duIH0gPSByZXF1aXJlKFwiLi4vc21hcnQtY2hhdHMvdXRpbHMvbWVzc2FnZV9jb250ZW50X2FycmF5X3RvX21hcmtkb3duXCIpO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSB1c2VyIGludGVyZmFjZSBmb3IgU21hcnRDaGF0LlxuICogVGhpcyBjbGFzcyBoYW5kbGVzIHRoZSByZW5kZXJpbmcgYW5kIGludGVyYWN0aW9uIGxvZ2ljIGZvciB0aGUgY2hhdCBpbnRlcmZhY2UuXG4gKi9cbmNsYXNzIFNtYXJ0Q2hhdHNVSSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFNtYXJ0Q2hhdHNVSS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGVudiAtIFRoZSBlbnZpcm9ubWVudCBvYmplY3QgY29udGFpbmluZyBjb25maWd1cmF0aW9ucyBhbmQgdXRpbGl0aWVzLlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgLSBUaGUgSFRNTCBjb250YWluZXIgZWxlbWVudCBmb3IgdGhlIGNoYXQgVUkuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbnYsIGNvbnRhaW5lcikge1xuICAgIHRoaXMuZW52ID0gZW52O1xuICAgIHRoaXMubWFpbiA9IHRoaXMuZW52OyAvLyBERVBSRUNBVEVEXG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy50ZW1wbGF0ZXMgPSB0aGlzLmVudi50ZW1wbGF0ZXM7XG4gIH1cblxuICAvKipcbiAgICogUHJvdmlkZXMgYSBjb250ZXh0IGZvciB0aGUgdmlldyByZW5kZXJpbmcuIFNob3VsZCBiZSBvdmVycmlkZGVuIGluIHN1YmNsYXNzZXMuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBjb250ZXh0IG9iamVjdCBmb3IgdGhlIHZpZXcuXG4gICAqL1xuICBnZXQgdmlld19jb250ZXh0KCkgeyByZXR1cm4geyAvKiBvdmVycmlkZSAqLyB9OyB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGVtcGxhdGVzIHVzaW5nIHRoZSBlbnZpcm9ubWVudCdzIHJlbmRlcmluZyBlbmdpbmUuXG4gICAqIEBwYXJhbSB7Li4uYW55fSBhcmdzIC0gQXJndW1lbnRzIGluY2x1ZGluZyB0ZW1wbGF0ZSBhbmQgZGF0YSB0byByZW5kZXIuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IFRoZSByZW5kZXJlZCBIVE1MIHN0cmluZy5cbiAgICovXG4gIGFzeW5jIHJlbmRlciguLi5hcmdzKSB7IHJldHVybiBhd2FpdCB0aGlzLmVudi5lanMucmVuZGVyKC4uLmFyZ3MpOyB9XG5cbiAgLyoqXG4gICAqIERpc3BsYXlzIGEgbm90aWNlIG1lc3NhZ2UgaW4gdGhlIGNvbnNvbGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gVGhlIG1lc3NhZ2UgdG8gZGlzcGxheS5cbiAgICovXG4gIHNob3dfbm90aWNlKG1lc3NhZ2UpIHsgY29uc29sZS5sb2cobWVzc2FnZSk7IH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNoYXQgVUkgYnkgY2xlYXJpbmcgdGhlIGNvbnRhaW5lciBhbmQgcmVuZGVyaW5nIHRoZSBpbml0aWFsIGNoYXQgdGVtcGxhdGUuXG4gICAqL1xuICBhc3luYyBpbml0KCkge1xuICAgIGNvbnNvbGUubG9nKFwiaW5pdCBTbWFydENoYXRSZW5kZXJlclwiKTtcbiAgICBjb25zb2xlLmxvZyh0aGlzLmNvbnRhaW5lcik7XG4gICAgdGhpcy5jb250YWluZXIuaW5uZXJIVE1MID0gXCJcIjtcbiAgICBjb25zb2xlLmxvZyh0aGlzLmVudi5jaGF0cy5jdXJyZW50KTtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5nZXRfdmlld19kYXRhKCk7XG4gICAgdGhpcy5jb250YWluZXIuaW5uZXJIVE1MID0gYXdhaXQgdGhpcy5yZW5kZXIodGhpcy50ZW1wbGF0ZXMuc21hcnRfY2hhdCwgZGF0YSwgeyBjb250ZXh0OiB0aGlzLnZpZXdfY29udGV4dCwgcm1XaGl0ZXNwYWNlOiB0cnVlIH0pO1xuICAgIHRoaXMucG9zdF9wcm9jZXNzKCk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBuZXcgdXNlciBtZXNzYWdlcywgdXBkYXRlcyB0aGUgVUksIGFuZCB0cmlnZ2VycyByZW5kZXJpbmcgb2YgdHlwaW5nIGluZGljYXRvci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJfaW5wdXQgLSBUaGUgdXNlcidzIGlucHV0IG1lc3NhZ2UuXG4gICAqL1xuICBhc3luYyBuZXdfdXNlcl9tZXNzYWdlKHVzZXJfaW5wdXQpIHtcbiAgICBhd2FpdCB0aGlzLm5ld19tZXNzYWdlKHVzZXJfaW5wdXQsIFwidXNlclwiKTtcbiAgICB0aGlzLnNldF9zdHJlYW1pbmdfdXgoKTtcbiAgICBhd2FpdCB0aGlzLnJlbmRlcl9kb3Rkb3Rkb3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQb3N0LWluaXRpYWxpemF0aW9uIHByb2Nlc3NpbmcsIHN1Y2ggYXMgYWRkaW5nIGxpc3RlbmVycyBhbmQgcHJvY2Vzc2luZyBtZXNzYWdlcy5cbiAgICovXG4gIGFzeW5jIHBvc3RfcHJvY2VzcygpIHtcbiAgICB0aGlzLmFkZF9saXN0ZW5lcnMoKTtcbiAgICB0aGlzLm1lc3NhZ2VzLmZvckVhY2godGhpcy5tZXNzYWdlX3Bvc3RfcHJvY2Vzcy5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQbGFjZWhvbGRlciBmb3IgYWRkaW5nIGxpc3RlbmVycy4gU2hvdWxkIGJlIG92ZXJyaWRkZW4gaW4gc3ViY2xhc3Nlcy5cbiAgICovXG4gIGFkZF9saXN0ZW5lcnMoKSB7IH1cblxuICAvKipcbiAgICogUGxhY2Vob2xkZXIgZm9yIG1lc3NhZ2UgcG9zdC1wcm9jZXNzaW5nLiBTaG91bGQgYmUgb3ZlcnJpZGRlbiBpbiBzdWJjbGFzc2VzLlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBtc2dfZWxtIC0gVGhlIG1lc3NhZ2UgZWxlbWVudCB0byBwcm9jZXNzLlxuICAgKi9cbiAgbWVzc2FnZV9wb3N0X3Byb2Nlc3MobXNnX2VsbSkgeyB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB2aWV3IGRhdGEgZm9yIHJlbmRlcmluZyB0aGUgY2hhdCBpbnRlcmZhY2UuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEFuIG9iamVjdCBjb250YWluaW5nIGRhdGEgZm9yIHRoZSB2aWV3LlxuICAgKi9cbiAgYWRkX21lc3NhZ2VfbGlzdGVuZXJzKG1zZ19lbG0pIHsgfSAvLyBPVkVSUklERVxuICBhc3luYyBnZXRfdmlld19kYXRhKCkge1xuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICBuYW1lOiB0aGlzLmVudi5jaGF0cy5jdXJyZW50Py5uYW1lIHx8IFwiVU5USVRMRUQgQ0hBVFwiLFxuICAgICAgbWVzc2FnZXM6IGF3YWl0IHRoaXMuZW52LmNoYXRzLmN1cnJlbnQuZ2V0X21lc3NhZ2VzX2h0bWwoKSxcbiAgICB9O1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgaW5wdXQgbGlzdGVuZXJzIHRvIHRoZSBjaGF0IGZvcm0gZm9yIGhhbmRsaW5nIHNwZWNpYWwga2V5cyBhbmQgc2VuZGluZyBtZXNzYWdlcy5cbiAgICovXG4gIGFkZF9jaGF0X2lucHV0X2xpc3RlbmVycygpIHtcbiAgICBjb25zdCBjaGF0X2lucHV0ID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcihcIi5zYy1jaGF0LWZvcm1cIik7XG4gICAgY29uc3QgdGV4dGFyZWEgPSBjaGF0X2lucHV0LnF1ZXJ5U2VsZWN0b3IoXCJ0ZXh0YXJlYVwiKTtcbiAgICBjaGF0X2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIChlKSA9PiB7XG4gICAgICBpZiAoZS5rZXkgPT09IFwiRW50ZXJcIiAmJiBlLnNoaWZ0S2V5KSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKHRoaXMucHJldmVudF9pbnB1dCkge1xuICAgICAgICAgIHRoaXMuc2hvd19ub3RpY2UoXCJXYWl0IHVudGlsIGN1cnJlbnQgcmVzcG9uc2UgaXMgZmluaXNoZWQuXCIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBnZXQgdGV4dCBmcm9tIHRleHRhcmVhXG4gICAgICAgIGxldCB1c2VyX2lucHV0ID0gdGV4dGFyZWEudmFsdWU7XG4gICAgICAgIC8vIGNsZWFyIHRleHRhcmVhXG4gICAgICAgIHRleHRhcmVhLnZhbHVlID0gXCJcIjtcbiAgICAgICAgLy8gaW5pdGlhdGUgcmVzcG9uc2UgZnJvbSBhc3Npc3RhbnRcbiAgICAgICAgdGhpcy5lbnYuY2hhdHMuY3VycmVudC5uZXdfdXNlcl9tZXNzYWdlKHVzZXJfaW5wdXQpO1xuICAgICAgfVxuICAgICAgdGV4dGFyZWEuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuICAgICAgdGV4dGFyZWEuc3R5bGUuaGVpZ2h0ID0gKHRleHRhcmVhLnNjcm9sbEhlaWdodCkgKyAncHgnO1xuICAgIH0pO1xuICAgIGNvbnN0IGFib3J0X2J1dHRvbiA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIjc2MtYWJvcnQtYnV0dG9uXCIpO1xuICAgIGFib3J0X2J1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgLy8gYWJvcnQgY3VycmVudCByZXNwb25zZVxuICAgICAgdGhpcy5lbnYuY2hhdF9tb2RlbC5zdG9wX3N0cmVhbSgpO1xuICAgICAgdGhpcy5jbGVhcl9zdHJlYW1pbmdfdXgoKTtcbiAgICB9KTtcbiAgICBjb25zdCBidXR0b24gPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiI3NjLXNlbmQtYnV0dG9uXCIpO1xuICAgIC8vIGFkZCBldmVudCBsaXN0ZW5lciB0byBidXR0b25cbiAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnByZXZlbnRfaW5wdXQpIHtcbiAgICAgICAgdGhpcy5zaG93X25vdGljZShcIldhaXQgdW50aWwgY3VycmVudCByZXNwb25zZSBpcyBmaW5pc2hlZC5cIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIGdldCB0ZXh0IGZyb20gdGV4dGFyZWFcbiAgICAgIGxldCB1c2VyX2lucHV0ID0gdGV4dGFyZWEudmFsdWU7XG4gICAgICAvLyBjbGVhciB0ZXh0YXJlYVxuICAgICAgdGV4dGFyZWEudmFsdWUgPSBcIlwiO1xuICAgICAgLy8gaW5pdGlhdGUgcmVzcG9uc2UgZnJvbSBhc3Npc3RhbnRcbiAgICAgIHRoaXMuZW52LmNoYXRzLmN1cnJlbnQubmV3X3VzZXJfbWVzc2FnZSh1c2VyX2lucHV0KTtcbiAgICB9KTtcbiAgfVxuICAvLyByZW5kZXIgbWVzc2FnZVxuICBhc3luYyBuZXdfbWVzc2FnZShjb250ZW50LCByb2xlID0gXCJhc3Npc3RhbnRcIiwgYXBwZW5kX2xhc3QgPSBmYWxzZSkge1xuICAgIC8vIGlmIGRvdGRvdGRvdCBpbnRlcnZhbCBpcyBzZXQsIHRoZW4gY2xlYXIgaXRcbiAgICBpZiAodGhpcy5kb3Rkb3Rkb3RfaW50ZXJ2YWwpIHtcbiAgICAgIGlmKCF0aGlzLmxhc3RfbXNnKSB0aGlzLm1lc3NhZ2VfY29udGFpbmVyLmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLCBhd2FpdCB0aGlzLmdldF9tZXNzYWdlX2h0bWwocm9sZSwgY29udGVudCkpO1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmRvdGRvdGRvdF9pbnRlcnZhbCk7XG4gICAgICB0aGlzLmRvdGRvdGRvdF9pbnRlcnZhbCA9IG51bGw7XG4gICAgICB0aGlzLmxhc3RfbXNnX2NvbnRlbnQuaW5uZXJIVE1MID0gJyc7IC8vIGNsZWFyIGxhc3QgbWVzc2FnZVxuICAgICAgdGhpcy5sYXN0X21zZy5kYXRhc2V0LmNvbnRlbnQgPSBcIlwiO1xuICAgIH1cbiAgICBpZih0aGlzLmxhc3RfbXNnICYmICF0aGlzLmxhc3RfbXNnLmRhdGFzZXQuY29udGVudCkgdGhpcy5sYXN0X21zZy5kYXRhc2V0LmNvbnRlbnQgPSBcIlwiO1xuICAgIGlmIChhcHBlbmRfbGFzdCkge1xuICAgICAgdGhpcy5sYXN0X21zZ19jb250ZW50LmlubmVySFRNTCArPSBjb250ZW50O1xuICAgICAgdGhpcy5sYXN0X21zZy5kYXRhc2V0LmNvbnRlbnQgKz0gY29udGVudDtcbiAgICAgIGlmIChjb250ZW50LmluZGV4T2YoJ1xcbicpID4gLTEpIHRoaXMucmVuZGVyX21kX2FzX2h0bWwodGhpcy5sYXN0X21zZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmxhc3RfZnJvbSAhPT0gcm9sZSkge1xuICAgICAgICBjb25zdCBodG1sID0gYXdhaXQgdGhpcy5nZXRfbWVzc2FnZV9odG1sKHJvbGUsIGNvbnRlbnQpO1xuICAgICAgICB0aGlzLm1lc3NhZ2VfY29udGFpbmVyLmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLCBodG1sKTsgLy8gYXBwZW5kIGh0bWwgdG8gdGhpcy5tZXNzYWdlX2NvbnRhaW5lciB3aGlsZSBwcmVzZXJ2aW5nIG90aGVyIGVsZW1lbnRzIGluIHRoaXMubWVzc2FnZV9jb250YWluZXIuXG4gICAgICAgIHRoaXMubGFzdF9mcm9tID0gcm9sZTsgLy8gc2V0IGxhc3QgZnJvbVxuICAgICAgICB0aGlzLmxhc3RfbXNnLmRhdGFzZXQuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxhc3RfbXNnX2NvbnRlbnQuaW5uZXJIVE1MID0gY29udGVudDtcbiAgICAgICAgdGhpcy5sYXN0X21zZy5kYXRhc2V0LmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgfVxuICAgICAgdGhpcy5tZXNzYWdlX3Bvc3RfcHJvY2Vzcyh0aGlzLmxhc3RfbXNnKTtcbiAgICB9XG4gICAgdGhpcy5tZXNzYWdlX2NvbnRhaW5lci5zY3JvbGxUb3AgPSB0aGlzLm1lc3NhZ2VfY29udGFpbmVyLnNjcm9sbEhlaWdodDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgSFRNTCBmb3IgYSBtZXNzYWdlIGJhc2VkIG9uIHRoZSByb2xlIGFuZCBjb250ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcm9sZSAtIFRoZSByb2xlIG9mIHRoZSBtZXNzYWdlIHNlbmRlci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnQgLSBUaGUgY29udGVudCBvZiB0aGUgbWVzc2FnZS5cbiAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gVGhlIEhUTUwgc3RyaW5nIGZvciB0aGUgbWVzc2FnZS5cbiAgICovXG4gIGFzeW5jIGdldF9tZXNzYWdlX2h0bWwocm9sZSwgY29udGVudCkge1xuICAgIGlmKEFycmF5LmlzQXJyYXkoY29udGVudCkpIGNvbnRlbnQgPSBtZXNzYWdlX2NvbnRlbnRfYXJyYXlfdG9fbWFya2Rvd24oY29udGVudCk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucmVuZGVyKHRoaXMudGVtcGxhdGVzLnNtYXJ0X2NoYXRfbXNnLCB7IHJvbGUsIGNvbnRlbnQgfSwgeyBjb250ZXh0OiB0aGlzLnZpZXdfY29udGV4dCwgcm1XaGl0ZXNwYWNlOiB0cnVlIH0pO1xuICB9XG5cbiAgYXN5bmMgZ2V0X3N5c3RlbV9tZXNzYWdlX2h0bWwobXNnKSB7XG4gICAgbGV0IHsgY29udGVudCwgcm9sZSB9ID0gbXNnO1xuICAgIGlmKGNvbnRlbnQuaW5jbHVkZXMoJ2BgYHNjLXN5c3RlbScpKSB7XG4gICAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC9gYGBzYy1zeXN0ZW18YGBgL2csIFwiXCIpLnRyaW0oKTtcbiAgICAgIGNvbnRlbnQgPSBcInN5c3RlbSBwcm9tcHRzOiBcIiArIGNvbnRlbnQuc3BsaXQoJ1xcbicpLmZpbHRlcihsbiA9PiBsbi50cmltKCkpLmpvaW4oJywgJyk7XG4gICAgfVxuICAgIGlmKGNvbnRlbnQuaW5jbHVkZXMoJ2BgYHNjLWNvbnRleHQnKSkge1xuICAgICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgvYGBgc2MtY29udGV4dHxgYGAvZywgXCJcIikudHJpbSgpO1xuICAgICAgY29udGVudCA9IFwiY29udGV4dDogXCIgKyBjb250ZW50LnNwbGl0KCdcXG4nKS5maWx0ZXIobG4gPT4gbG4udHJpbSgpKS5qb2luKCcsICcpO1xuICAgICAgaWYoY29udGVudC5sZW5ndGggPiAxMDApIGNvbnRlbnQgPSBjb250ZW50LnN1YnN0cmluZygwLCAxMDApICsgXCIuLi5cIjtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucmVuZGVyKHRoaXMudGVtcGxhdGVzLnNtYXJ0X2NoYXRfc3lzdGVtX21zZywgeyBjb250ZW50LCByb2xlIH0sIHsgY29udGV4dDogdGhpcy52aWV3X2NvbnRleHQsIHJtV2hpdGVzcGFjZTogdHJ1ZSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnRzIHNlbGVjdGVkIHRleHQgZnJvbSBhIHN1Z2dlc3Rpb24gbW9kYWwgaW50byB0aGUgY2hhdCBpbnB1dC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGluc2VydF90ZXh0IC0gVGhlIHRleHQgdG8gaW5zZXJ0LlxuICAgKi9cbiAgaW5zZXJ0X3NlbGVjdGlvbihpbnNlcnRfdGV4dCkge1xuICAgIGNvbnN0IHRleHRhcmVhID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcihcIi5zYy1jaGF0LWZvcm0gdGV4dGFyZWFcIik7XG4gICAgbGV0IGNhcmV0X3BvcyA9IHRleHRhcmVhLnNlbGVjdGlvblN0YXJ0O1xuICAgIGxldCB0ZXh0X2JlZm9yZSA9IHRleHRhcmVhLnZhbHVlLnN1YnN0cmluZygwLCBjYXJldF9wb3MpO1xuICAgIGxldCB0ZXh0X2FmdGVyID0gdGV4dGFyZWEudmFsdWUuc3Vic3RyaW5nKGNhcmV0X3BvcywgdGV4dGFyZWEudmFsdWUubGVuZ3RoKTtcbiAgICB0ZXh0YXJlYS52YWx1ZSA9IHRleHRfYmVmb3JlICsgaW5zZXJ0X3RleHQgKyB0ZXh0X2FmdGVyO1xuICAgIHRleHRhcmVhLnNlbGVjdGlvblN0YXJ0ID0gY2FyZXRfcG9zICsgaW5zZXJ0X3RleHQubGVuZ3RoO1xuICAgIHRleHRhcmVhLnNlbGVjdGlvbkVuZCA9IGNhcmV0X3BvcyArIGluc2VydF90ZXh0Lmxlbmd0aDtcbiAgICB0ZXh0YXJlYS5mb2N1cygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSB0eXBpbmcgaW5kaWNhdG9yIChcIi4uLlwiKSBhbmQgc2V0cyBhbiBpbnRlcnZhbCB0byBhbmltYXRlIGl0LlxuICAgKi9cbiAgYXN5bmMgcmVuZGVyX2RvdGRvdGRvdCgpIHtcbiAgICBpZiAodGhpcy5kb3Rkb3Rkb3RfaW50ZXJ2YWwpIGNsZWFySW50ZXJ2YWwodGhpcy5kb3Rkb3Rkb3RfaW50ZXJ2YWwpO1xuICAgIGF3YWl0IHRoaXMubmV3X21lc3NhZ2UoXCIuLi5cIiwgXCJhc3Npc3RhbnRcIik7XG4gICAgbGV0IGRvdHMgPSAwO1xuICAgIGNvbnN0IGN1cnJfbXNnID0gdGhpcy5sYXN0X21zZ19jb250ZW50O1xuICAgIGN1cnJfbXNnLmlubmVySFRNTCA9ICcuLi4nO1xuICAgIHRoaXMuZG90ZG90ZG90X2ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgZG90cysrO1xuICAgICAgaWYgKGRvdHMgPiAzKSBkb3RzID0gMTtcbiAgICAgIGN1cnJfbXNnLmlubmVySFRNTCA9ICcuJy5yZXBlYXQoZG90cyk7XG4gICAgfSwgNTAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBtZXNzYWdlIGNvbnRhaW5lciBlbGVtZW50LlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IFRoZSBtZXNzYWdlIGNvbnRhaW5lci5cbiAgICovXG4gIGdldCBtZXNzYWdlX2NvbnRhaW5lcigpIHsgcmV0dXJuIHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIuc2MtbWVzc2FnZS1jb250YWluZXJcIik7IH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbGFzdCBtZXNzYWdlIGNvbnRlbnQgZWxlbWVudC5cbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSBUaGUgbGFzdCBtZXNzYWdlIGNvbnRlbnQgZWxlbWVudC5cbiAgICovXG4gIGdldCBsYXN0X21zZygpIHsgcmV0dXJuIHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIuc2MtbWVzc2FnZS1jb250YWluZXJcIikubGFzdEVsZW1lbnRDaGlsZC5xdWVyeVNlbGVjdG9yKFwiLnNjLW1lc3NhZ2UtY29udGVudFwiKTsgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsYXN0IG1lc3NhZ2UgY29udGVudCBzcGFuIGVsZW1lbnQuXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gVGhlIGxhc3QgbWVzc2FnZSBjb250ZW50IHNwYW4gZWxlbWVudC5cbiAgICovXG4gIGdldCBsYXN0X21zZ19jb250ZW50KCkgeyByZXR1cm4gdGhpcy5sYXN0X21zZy5xdWVyeVNlbGVjdG9yKFwic3Bhbjpub3QoLnNjLW1zZy1idXR0b24pXCIpOyB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIG1lc3NhZ2UgY29udGVudCBlbGVtZW50cy5cbiAgICogQHJldHVybnMge05vZGVMaXN0T2Y8SFRNTEVsZW1lbnQ+fSBBIE5vZGVMaXN0IG9mIG1lc3NhZ2UgY29udGVudCBlbGVtZW50cy5cbiAgICovXG4gIGdldCBtZXNzYWdlcygpIHsgcmV0dXJuIHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuc2MtbWVzc2FnZS1jb250YWluZXIgLnNjLW1lc3NhZ2UtY29udGVudFwiKTsgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB1c2VyIGludGVyZmFjZSB0byBhIFwic3RyZWFtaW5nXCIgbW9kZSwgZGlzYWJsaW5nIGlucHV0IGFuZCBzaG93aW5nIGFuIGFib3J0IGJ1dHRvbi5cbiAgICovXG4gIHNldF9zdHJlYW1pbmdfdXgoKSB7XG4gICAgdGhpcy5wcmV2ZW50X2lucHV0ID0gdHJ1ZTtcbiAgICAvLyBoaWRlIHNlbmQgYnV0dG9uXG4gICAgaWYgKHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIjc2Mtc2VuZC1idXR0b25cIikpXG4gICAgICB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiI3NjLXNlbmQtYnV0dG9uXCIpLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAvLyBzaG93IGFib3J0IGJ1dHRvblxuICAgIGlmICh0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiI3NjLWFib3J0LWJ1dHRvblwiKSlcbiAgICAgIHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIjc2MtYWJvcnQtYnV0dG9uXCIpLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXRzIHRoZSB1c2VyIGludGVyZmFjZSBmcm9tIFwic3RyZWFtaW5nXCIgbW9kZSB0byBub3JtYWwuXG4gICAqL1xuICB1bnNldF9zdHJlYW1pbmdfdXgoKSB7XG4gICAgdGhpcy5wcmV2ZW50X2lucHV0ID0gZmFsc2U7XG4gICAgLy8gc2hvdyBzZW5kIGJ1dHRvbiwgcmVtb3ZlIGRpc3BsYXkgbm9uZVxuICAgIGlmICh0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiI3NjLXNlbmQtYnV0dG9uXCIpKVxuICAgICAgdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcihcIiNzYy1zZW5kLWJ1dHRvblwiKS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcbiAgICAvLyBoaWRlIGFib3J0IGJ1dHRvblxuICAgIGlmICh0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiI3NjLWFib3J0LWJ1dHRvblwiKSlcbiAgICAgIHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIjc2MtYWJvcnQtYnV0dG9uXCIpLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgYW55IHN0cmVhbWluZyB1c2VyIGludGVyZmFjZSBlZmZlY3RzLCBzdWNoIGFzIGludGVydmFscyBhbmQgdGVtcG9yYXJ5IGVsZW1lbnRzLlxuICAgKi9cbiAgY2xlYXJfc3RyZWFtaW5nX3V4KCkge1xuICAgIHRoaXMudW5zZXRfc3RyZWFtaW5nX3V4KCk7XG4gICAgaWYgKHRoaXMuZG90ZG90ZG90X2ludGVydmFsKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuZG90ZG90ZG90X2ludGVydmFsKTtcbiAgICAgIHRoaXMuZG90ZG90ZG90X2ludGVydmFsID0gbnVsbDtcbiAgICAgIC8vIHJlbW92ZSBwYXJlbnQgb2YgYWN0aXZlX2VsbVxuICAgICAgdGhpcy5hY3RpdmVfZWxtLnBhcmVudEVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICB0aGlzLmFjdGl2ZV9lbG0gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUvc2V0IHRleHQgaW4gY2hhdF9pbnB1dFxuICAgKi9cbiAgc2V0X2NoYXRfaW5wdXRfdGV4dCh0ZXh0KXtcbiAgICBjb25zdCB0ZXh0YXJlYSA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIuc2MtY2hhdC1mb3JtIHRleHRhcmVhXCIpO1xuICAgIHRleHRhcmVhLnZhbHVlID0gdGV4dDtcbiAgfVxufVxuZXhwb3J0cy5TbWFydENoYXRzVUkgPSBTbWFydENoYXRzVUk7XG5cbiIsICJjb25zdCB7IEl0ZW1WaWV3IH0gPSByZXF1aXJlKFwib2JzaWRpYW5cIik7XG5jb25zdCB2aWV3cyA9IHJlcXVpcmUoXCIuLi9idWlsZC92aWV3cy5qc29uXCIpO1xuY29uc3QgZWpzID0gcmVxdWlyZShcIi4uL2Vqcy5taW5cIik7XG5cbi8vIGhhbmRsZSByZW5kZXJpbmcgRUpTIHZpZXdzXG5jbGFzcyBTbWFydE9ic2lkaWFuVmlldyBleHRlbmRzIEl0ZW1WaWV3IHtcbiAgY29uc3RydWN0b3IobGVhZiwgcGx1Z2luKSB7XG4gICAgc3VwZXIobGVhZik7XG4gICAgdGhpcy5hcHAgPSBwbHVnaW4uYXBwO1xuICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBwbHVnaW4uc2V0dGluZ3M7XG4gICAgdGhpcy50ZW1wbGF0ZXMgPSB2aWV3cztcbiAgICB0aGlzLmVqcyA9IGVqcztcbiAgfVxuICByZW5kZXJfdGVtcGxhdGUodGVtcGxhdGVfbmFtZSwgZGF0YSkge1xuICAgIC8vIGNvbnNvbGUubG9nKFwicmVuZGVyaW5nIHRlbXBsYXRlXCIsIHRlbXBsYXRlX25hbWUpO1xuICAgIGlmICghdGhpcy50ZW1wbGF0ZXNbdGVtcGxhdGVfbmFtZV0pIHRocm93IG5ldyBFcnJvcihgVGVtcGxhdGUgJyR7dGVtcGxhdGVfbmFtZX0nIG5vdCBmb3VuZC5gKTtcbiAgICByZXR1cm4gZWpzLnJlbmRlcih0aGlzLnRlbXBsYXRlc1t0ZW1wbGF0ZV9uYW1lXSwgZGF0YSwgeyBjb250ZXh0OiB0aGlzLnZpZXdfY29udGV4dCB9KTtcbiAgfVxuICBnZXQgdmlld19jb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICAvLyBhcHA6IHRoaXMucGx1Z2luLmFwcCxcbiAgICAgIGF0dHJpYnV0aW9uOiB0aGlzLnRlbXBsYXRlcy5hdHRyaWJ1dGlvbixcbiAgICAgIGdldF9pY29uOiB0aGlzLmdldF9pY29uLmJpbmQodGhpcyksXG4gICAgICBzZXR0aW5nczogdGhpcy5wbHVnaW4uc2V0dGluZ3MsXG4gICAgfTtcbiAgfVxuICBnZXRfaWNvbihuYW1lKSB7IHJldHVybiB0aGlzLnBsdWdpbi5vYnNpZGlhbi5nZXRJY29uKG5hbWUpLm91dGVySFRNTDsgfVxuICBzdGF0aWMgZ2V0IHZpZXdfdHlwZSgpIHsgfVxuICBzdGF0aWMgZ2V0X2xlYWYod29ya3NwYWNlKSB7IHJldHVybiB3b3Jrc3BhY2UuZ2V0TGVhdmVzT2ZUeXBlKHRoaXMudmlld190eXBlKT8uZmluZCgobGVhZikgPT4gbGVhZi52aWV3IGluc3RhbmNlb2YgdGhpcyk7IH1cbiAgc3RhdGljIGdldF92aWV3KHdvcmtzcGFjZSkgeyByZXR1cm4gdGhpcy5nZXRfbGVhZih3b3Jrc3BhY2UpPy52aWV3OyB9XG4gIHN0YXRpYyBvcGVuKHdvcmtzcGFjZSwgYWN0aXZlID0gdHJ1ZSkge1xuICAgIGlmICh0aGlzLmdldF9sZWFmKHdvcmtzcGFjZSkpIHRoaXMuZ2V0X2xlYWYod29ya3NwYWNlKS5zZXRWaWV3U3RhdGUoeyB0eXBlOiB0aGlzLnZpZXdfdHlwZSwgYWN0aXZlIH0pO1xuICAgIGVsc2Ugd29ya3NwYWNlLmdldFJpZ2h0TGVhZihmYWxzZSkuc2V0Vmlld1N0YXRlKHsgdHlwZTogdGhpcy52aWV3X3R5cGUsIGFjdGl2ZSB9KTtcbiAgICBpZih3b3Jrc3BhY2UucmlnaHRTcGxpdC5jb2xsYXBzZWQpIHdvcmtzcGFjZS5yaWdodFNwbGl0LnRvZ2dsZSgpO1xuICB9XG4gIHN0YXRpYyBpc19vcGVuKHdvcmtzcGFjZSkgeyByZXR1cm4gdGhpcy5nZXRfbGVhZih3b3Jrc3BhY2UpPy52aWV3IGluc3RhbmNlb2YgdGhpczsgfVxufVxuZXhwb3J0cy5TbWFydE9ic2lkaWFuVmlldyA9IFNtYXJ0T2JzaWRpYW5WaWV3O1xuIiwgImNvbnN0IHsgU21hcnRPYnNpZGlhblZpZXcgfSA9IHJlcXVpcmUoXCIuL3NtYXJ0X29ic2lkaWFuX3ZpZXdcIik7XG5jbGFzcyBTY0NoYXRWaWV3IGV4dGVuZHMgU21hcnRPYnNpZGlhblZpZXcge1xuICBjb25zdHJ1Y3RvcihsZWFmLCBwbHVnaW4pIHtcbiAgICBzdXBlcihsZWFmLCBwbHVnaW4pO1xuICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xuICAgIHRoaXMuZW52ID0gdGhpcy5wbHVnaW4uZW52O1xuICAgIHRoaXMuY29uZmlnID0gdGhpcy5wbHVnaW4uc2V0dGluZ3M7XG4gIH1cbiAgc3RhdGljIGdldCB2aWV3X3R5cGUoKSB7IHJldHVybiBcInNtYXJ0LWNvbm5lY3Rpb25zLWNoYXQtdmlld1wiOyB9XG4gIGdldERpc3BsYXlUZXh0KCkgeyByZXR1cm4gXCJTbWFydCBDb25uZWN0aW9ucyBDaGF0XCI7IH1cbiAgZ2V0SWNvbigpIHsgcmV0dXJuIFwibWVzc2FnZS1zcXVhcmVcIjsgfVxuICBnZXRWaWV3VHlwZSgpIHsgcmV0dXJuIFNjQ2hhdFZpZXcudmlld190eXBlOyB9XG4gIGFzeW5jIG9uT3BlbigpIHsgdGhpcy5hcHAud29ya3NwYWNlLm9uTGF5b3V0UmVhZHkodGhpcy5pbml0aWFsaXplLmJpbmQodGhpcykpOyB9XG4gIGFzeW5jIGluaXRpYWxpemUoKSB7XG4gICAgaWYoIXRoaXMuZW52LmVudGl0aWVzX2xvYWRlZCl7XG4gICAgICAvLyBzZXQgbG9hZGluZyBtZXNzYWdlXG4gICAgICB0aGlzLmNvbnRhaW5lckVsLmlubmVySFRNTCA9IFwiTG9hZGluZyBTbWFydCBDb25uZWN0aW9ucy4uLlwiO1xuICAgICAgLy8gd2FpdCBmb3IgZW50aXRpZXMgdG8gYmUgaW5pdGlhbGl6ZWRcbiAgICAgIHdoaWxlICghdGhpcy5lbnYuZW50aXRpZXNfbG9hZGVkKSBhd2FpdCBuZXcgUHJvbWlzZShyID0+IHNldFRpbWVvdXQociwgMjAwMCkpO1xuICAgIH1cbiAgICBpZih0aGlzLmVudi5jaGF0X3VpKSB0aGlzLmVudi5jaGF0X3VpLmNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyRWw7IC8vIHNldCBuZXcgY29udGFpbmVyIGlmIGNoYXRfdWkgZXhpc3RzXG4gICAgLy8gd2FpdCBmb3IgY2hhdHMgdG8gYmUgaW5pdGlhbGl6ZWRcbiAgICB3aGlsZSAoIXRoaXMuZW52LmNoYXRzKSBhd2FpdCBuZXcgUHJvbWlzZShyID0+IHNldFRpbWVvdXQociwgMzAwKSk7XG4gICAgYXdhaXQgdGhpcy5lbnYuY2hhdHMubmV3KCk7XG4gICAgdGhpcy5hcHAud29ya3NwYWNlLnJlZ2lzdGVySG92ZXJMaW5rU291cmNlKFNjQ2hhdFZpZXcudmlld190eXBlLCB7XG4gICAgICBkaXNwbGF5OiAnU21hcnQgQ2hhdCBMaW5rcycsXG4gICAgICBkZWZhdWx0TW9kOiB0cnVlLFxuICAgIH0pO1xuICB9XG4gIG9uQ2xvc2UoKSB7XG4gICAgdGhpcy5hcHAud29ya3NwYWNlLnVucmVnaXN0ZXJIb3ZlckxpbmtTb3VyY2UoU2NDaGF0Vmlldy52aWV3X3R5cGUpO1xuICB9XG59XG5cbi8vIEVYUE9SVFNcbmV4cG9ydHMuU2NDaGF0VmlldyA9IFNjQ2hhdFZpZXc7IiwgImNvbnN0IHsgU2V0dGluZyB9ID0gcmVxdWlyZShcIm9ic2lkaWFuXCIpO1xuLy8gY29uc3QgZWpzID0gcmVxdWlyZShcIi4uL2Vqcy5taW5cIik7XG5jbGFzcyBTbWFydFNldHRpbmdzIHtcbiAgY29uc3RydWN0b3IoZW52LCBjb250YWluZXIsIHRlbXBsYXRlX25hbWUgPSBcInNtYXJ0X3NldHRpbmdzXCIpIHtcbiAgICB0aGlzLmVudiA9IGVudjtcbiAgICB0aGlzLnBsdWdpbiA9IHRoaXMuZW52LnBsdWdpbjtcbiAgICB0aGlzLnNldHRpbmdzID0gdGhpcy5wbHVnaW4uc2V0dGluZ3M7XG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy50ZW1wbGF0ZV9uYW1lID0gdGVtcGxhdGVfbmFtZTtcbiAgICB0aGlzLmVqcyA9IHRoaXMuZW52LmVqcztcbiAgICB0aGlzLnRlbXBsYXRlcyA9IHRoaXMuZW52LnRlbXBsYXRlcztcbiAgfVxuICBhc3luYyByZW5kZXIoKSB7XG4gICAgY29uc3Qgdmlld19kYXRhID0gKHR5cGVvZiB0aGlzLmdldF92aWV3X2RhdGEgPT09IFwiZnVuY3Rpb25cIikgPyBhd2FpdCB0aGlzLmdldF92aWV3X2RhdGEoKSA6IHRoaXMudmlld19kYXRhO1xuICAgIHRoaXMucmVuZGVyX3RlbXBsYXRlKHZpZXdfZGF0YSk7XG4gICAgdGhpcy5yZW5kZXJfY29tcG9uZW50cygpO1xuICB9XG4gIHJlbmRlcl90ZW1wbGF0ZSh2aWV3X2RhdGEgPSBudWxsKSB7XG4gICAgaWYgKCF0aGlzLnRlbXBsYXRlKSB0aHJvdyBuZXcgRXJyb3IoYFNldHRpbmdzIHRlbXBsYXRlIG5vdCBmb3VuZC5gKTtcbiAgICB0aGlzLmNvbnRhaW5lci5lbXB0eSgpO1xuICAgIHRoaXMuY29udGFpbmVyLmlubmVySFRNTCA9IHRoaXMuZWpzLnJlbmRlcih0aGlzLnRlbXBsYXRlLCB2aWV3X2RhdGEgfHwgdGhpcy52aWV3X2RhdGEsIHsgY29udGV4dDogdGhpcyB9KTtcbiAgfVxuICBhc3luYyB1cGRhdGUoc2V0dGluZywgdmFsdWUpIHtcbiAgICBjb25zb2xlLmxvZyhcInNhdmluZyBzZXR0aW5nOiBcIiArIHNldHRpbmcpO1xuICAgIGlmIChzZXR0aW5nLmluY2x1ZGVzKFwiLlwiKSkge1xuICAgICAgbGV0IHBhcnRzID0gc2V0dGluZy5zcGxpdChcIi5cIik7XG4gICAgICBsZXQgb2JqID0gdGhpcy5wbHVnaW4uc2V0dGluZ3M7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBpZiAoIW9ialtwYXJ0c1tpXV0pIG9ialtwYXJ0c1tpXV0gPSB7fTtcbiAgICAgICAgb2JqID0gb2JqW3BhcnRzW2ldXTtcbiAgICAgIH1cbiAgICAgIG9ialtwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXV0gPSAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSA/IHZhbHVlLnRyaW0oKSA6IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBsdWdpbi5zZXR0aW5nc1tzZXR0aW5nXSA9ICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpID8gdmFsdWUudHJpbSgpIDogdmFsdWU7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVfc2V0dGluZ3ModHJ1ZSk7XG4gICAgY29uc29sZS5sb2coXCJzYXZlZCBzZXR0aW5nc1wiKTtcbiAgICBjb25zb2xlLmxvZyh0aGlzLnBsdWdpbi5zZXR0aW5ncyk7XG4gIH1cbiAgcmVuZGVyX2NvbXBvbmVudHMoKSB7XG4gICAgdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcIi5zZXR0aW5nLWNvbXBvbmVudFwiKS5mb3JFYWNoKGVsbSA9PiB7XG4gICAgICBjb25zdCBzZXR0aW5nX2VsbSA9IG5ldyBTZXR0aW5nKGVsbSk7XG4gICAgICBpZiAoZWxtLmRhdGFzZXQubmFtZSkgc2V0dGluZ19lbG0uc2V0TmFtZShlbG0uZGF0YXNldC5uYW1lKTtcbiAgICAgIGlmIChlbG0uZGF0YXNldC5kZXNjcmlwdGlvbikgc2V0dGluZ19lbG0uZGVzY0VsLmlubmVySFRNTCA9IGVsbS5kYXRhc2V0LmRlc2NyaXB0aW9uO1xuICAgICAgY29uc3Qgc2V0dGluZyA9IGVsbS5kYXRhc2V0LnNldHRpbmc7XG4gICAgICBpZiAoZWxtLmRhdGFzZXQudHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgc2V0dGluZ19lbG0uYWRkVGV4dCh0ZXh0ID0+IHtcbiAgICAgICAgICB0ZXh0LnNldFBsYWNlaG9sZGVyKGVsbS5kYXRhc2V0LnBsYWNlaG9sZGVyIHx8IFwiXCIpO1xuICAgICAgICAgIHRleHQuc2V0VmFsdWUodGhpcy5nZXRfc2V0dGluZyhzZXR0aW5nKSk7XG4gICAgICAgICAgbGV0IGRlYm91bmNlVGltZXI7XG4gICAgICAgICAgaWYgKGVsbS5kYXRhc2V0LmJ1dHRvbikge1xuICAgICAgICAgICAgc2V0dGluZ19lbG0uYWRkQnV0dG9uKGJ1dHRvbiA9PiB7XG4gICAgICAgICAgICAgIGJ1dHRvbi5zZXRCdXR0b25UZXh0KGVsbS5kYXRhc2V0LmJ1dHRvbik7XG4gICAgICAgICAgICAgIGJ1dHRvbi5vbkNsaWNrKGFzeW5jICgpID0+IHRoaXMuaGFuZGxlX29uX2NoYW5nZShzZXR0aW5nLCB0ZXh0LmdldFZhbHVlKCksIGVsbSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRleHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dChkZWJvdW5jZVRpbWVyKTtcbiAgICAgICAgICAgICAgZGVib3VuY2VUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5oYW5kbGVfb25fY2hhbmdlKHNldHRpbmcsIHZhbHVlLCBlbG0pLCAyMDAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGVsbS5kYXRhc2V0LnR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgc2V0dGluZ19lbG0uYWRkVGV4dChudW1iZXIgPT4ge1xuICAgICAgICAgIG51bWJlci5pbnB1dEVsLnR5cGUgPSBcIm51bWJlclwiO1xuICAgICAgICAgIG51bWJlci5zZXRQbGFjZWhvbGRlcihlbG0uZGF0YXNldC5wbGFjZWhvbGRlciB8fCBcIlwiKTtcbiAgICAgICAgICBudW1iZXIuaW5wdXRFbC52YWx1ZSA9IHBhcnNlSW50KHRoaXMuZ2V0X3NldHRpbmcoc2V0dGluZykpO1xuICAgICAgICAgIG51bWJlci5pbnB1dEVsLm1pbiA9IGVsbS5kYXRhc2V0Lm1pbiB8fCAwO1xuICAgICAgICAgIGlmIChlbG0uZGF0YXNldC5tYXgpIG51bWJlci5pbnB1dEVsLm1heCA9IGVsbS5kYXRhc2V0Lm1heDtcbiAgICAgICAgICBsZXQgZGVib3VuY2VUaW1lcjtcbiAgICAgICAgICBudW1iZXIub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoZGVib3VuY2VUaW1lcik7XG4gICAgICAgICAgICBkZWJvdW5jZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmhhbmRsZV9vbl9jaGFuZ2Uoc2V0dGluZywgcGFyc2VJbnQodmFsdWUpLCBlbG0pLCAyMDAwKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGVsbS5kYXRhc2V0LnR5cGUgPT09IFwiZHJvcGRvd25cIikge1xuICAgICAgICBzZXR0aW5nX2VsbS5hZGREcm9wZG93bihkcm9wZG93biA9PiB7XG4gICAgICAgICAgT2JqZWN0LmVudHJpZXMoZWxtLmRhdGFzZXQpXG4gICAgICAgICAgICAuZmlsdGVyKChbaywgdl0pID0+IGsuc3RhcnRzV2l0aChcIm9wdGlvblwiKSlcbiAgICAgICAgICAgIC5mb3JFYWNoKChbaywgdl0pID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgW3ZhbHVlLCBuYW1lXSA9IHYuc3BsaXQoXCJ8XCIpO1xuICAgICAgICAgICAgICBkcm9wZG93bi5hZGRPcHRpb24odmFsdWUsIG5hbWUgfHwgdmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgZHJvcGRvd24ub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB0aGlzLmhhbmRsZV9vbl9jaGFuZ2Uoc2V0dGluZywgdmFsdWUsIGVsbSkpO1xuICAgICAgICAgIGRyb3Bkb3duLnNldFZhbHVlKHRoaXMuZ2V0X3NldHRpbmcoc2V0dGluZykpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoZWxtLmRhdGFzZXQudHlwZSA9PT0gXCJidXR0b25cIikge1xuICAgICAgICBzZXR0aW5nX2VsbS5hZGRCdXR0b24oYnV0dG9uID0+IHtcbiAgICAgICAgICBidXR0b24uc2V0QnV0dG9uVGV4dChlbG0uZGF0YXNldC5idG5UZXh0IHx8IGVsbS5kYXRhc2V0Lm5hbWUpO1xuICAgICAgICAgIGJ1dHRvbi5vbkNsaWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmIChlbG0uZGF0YXNldC5jb25maXJtKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNvbmZpcm1hdGlvbl9tZXNzYWdlID0gZWxtLmRhdGFzZXQuY29uZmlybTtcbiAgICAgICAgICAgICAgaWYgKCFjb25maXJtKGNvbmZpcm1hdGlvbl9tZXNzYWdlKSkgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVsbS5kYXRhc2V0LmhyZWYpIHdpbmRvdy5vcGVuKGVsbS5kYXRhc2V0LmhyZWYpO1xuICAgICAgICAgICAgaWYgKGVsbS5kYXRhc2V0LmNhbGxiYWNrKSB0aGlzW2VsbS5kYXRhc2V0LmNhbGxiYWNrXShzZXR0aW5nKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGVsbS5kYXRhc2V0LnR5cGUgPT09IFwidG9nZ2xlXCIpIHtcbiAgICAgICAgc2V0dGluZ19lbG0uYWRkVG9nZ2xlKHRvZ2dsZSA9PiB7XG4gICAgICAgICAgdG9nZ2xlLnNldFZhbHVlKHRoaXMuZ2V0X3NldHRpbmcoc2V0dGluZykpO1xuICAgICAgICAgIHRvZ2dsZS5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHRoaXMuaGFuZGxlX29uX2NoYW5nZShzZXR0aW5nLCB2YWx1ZSwgZWxtKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGVsbS5kYXRhc2V0LmRpc2FibGVkKSBzZXR0aW5nX2VsbS5zZXREaXNhYmxlZCh0cnVlKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBoYW5kbGVfb25fY2hhbmdlKHNldHRpbmcsIHZhbHVlLCBlbG0pIHtcbiAgICBhd2FpdCB0aGlzLnVwZGF0ZShzZXR0aW5nLCB2YWx1ZSk7XG4gICAgaWYgKGVsbS5kYXRhc2V0LmNhbGxiYWNrKSB0aGlzW2VsbS5kYXRhc2V0LmNhbGxiYWNrXShzZXR0aW5nLCB2YWx1ZSwgZWxtKTtcbiAgfVxuICBnZXRfc2V0dGluZyhzZXR0aW5nKSB7XG4gICAgaWYgKHNldHRpbmcuaW5jbHVkZXMoXCIuXCIpKSB7XG4gICAgICBsZXQgcGFydHMgPSBzZXR0aW5nLnNwbGl0KFwiLlwiKTtcbiAgICAgIGxldCBvYmogPSB0aGlzLnBsdWdpbi5zZXR0aW5ncztcbiAgICAgIGZvciAobGV0IHBhcnQgb2YgcGFydHMuc2xpY2UoMCwgLTEpKSB7XG4gICAgICAgIGlmIChvYmpbcGFydF0gPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXMucGx1Z2luLmNvbnN0cnVjdG9yLmRlZmF1bHRzW3NldHRpbmddOyAvLyBGYWxsYmFjayB0byBkZWZhdWx0IGlmIHBhdGggaXMgYnJva2VuXG4gICAgICAgIG9iaiA9IG9ialtwYXJ0XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmpbcGFydHNbcGFydHMubGVuZ3RoIC0gMV1dIHx8IHRoaXMucGx1Z2luLmNvbnN0cnVjdG9yLmRlZmF1bHRzW3NldHRpbmddO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5wbHVnaW4uc2V0dGluZ3Nbc2V0dGluZ10gfHwgdGhpcy5wbHVnaW4uY29uc3RydWN0b3IuZGVmYXVsdHNbc2V0dGluZ107XG4gICAgfVxuICB9XG4gIC8vIG92ZXJyaWRlIGluIHN1YmNsYXNzIChyZXF1aXJlZClcbiAgZ2V0IHRlbXBsYXRlKCkgeyByZXR1cm4gXCJcIjsgfSAvLyBlanMgdGVtcGxhdGUgc3RyaW5nXG4gIGdldCB2aWV3X2RhdGEoKSB7IHJldHVybiB7fTsgfSAvLyBvYmplY3QgcHJvcGVydGllcyBhdmFpbGFibGUgaW4gdGVtcGxhdGVcbn1cbmV4cG9ydHMuU21hcnRTZXR0aW5ncyA9IFNtYXJ0U2V0dGluZ3M7IiwgImNvbnN0IFNjVHJhbnNsYXRpb25zID0gcmVxdWlyZShcIi4vU2NUcmFuc2xhdGlvbnNcIik7XG5jb25zdCB7IFNtYXJ0U2V0dGluZ3MgfSA9IHJlcXVpcmUoXCIuL3NtYXJ0X3NldHRpbmdzXCIpO1xuLy8gU21hcnQgQ29ubmVjdGlvbnMgU3BlY2lmaWMgU2V0dGluZ3NcbmNsYXNzIFNtYXJ0Q2hhdFNldHRpbmdzIGV4dGVuZHMgU21hcnRTZXR0aW5ncyB7XG4gIHVwZGF0ZV9zbWFydF9jaGF0X2ZvbGRlcigpIHsgdGhpcy5wbHVnaW4udXBkYXRlX3NtYXJ0X2NoYXRfZm9sZGVyKCk7IH1cbiAgYXN5bmMgY2hhbmdlZF9zbWFydF9jaGF0X21vZGVsKHJlbmRlciA9IHRydWUpe1xuICAgIGNvbnNvbGUubG9nKHRoaXMucGx1Z2luLnNldHRpbmdzLmNoYXRfbW9kZWxfcGxhdGZvcm1fa2V5KTtcbiAgICBjb25zdCBwbGF0Zm9ybV9jb25maWcgPSB0aGlzLnBsdWdpbi5lbnYuY2hhdF9tb2RlbC5wbGF0Zm9ybXNbdGhpcy5wbHVnaW4uc2V0dGluZ3MuY2hhdF9tb2RlbF9wbGF0Zm9ybV9rZXldO1xuICAgIGxldCBzbWFydF9jaGF0X21vZGVsX2NvbmZpZyA9IHRoaXMucGx1Z2luLnNldHRpbmdzW3RoaXMucGx1Z2luLnNldHRpbmdzLmNoYXRfbW9kZWxfcGxhdGZvcm1fa2V5XTtcbiAgICBpZihzbWFydF9jaGF0X21vZGVsX2NvbmZpZy5tb2RlbF9uYW1lKXtcbiAgICAgIGNvbnN0IHBsYXRmb3JtX21vZGVscyA9IGF3YWl0IHRoaXMucGx1Z2luLmVudi5jaGF0X21vZGVsLmdldF9tb2RlbHMoKTtcbiAgICAgIGNvbnN0IG1vZGVsX2NvbmZpZyA9IHBsYXRmb3JtX21vZGVscy5maW5kKG0gPT4gbS5tb2RlbF9uYW1lID09PSBzbWFydF9jaGF0X21vZGVsX2NvbmZpZy5tb2RlbF9uYW1lKTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwibW9kZWxfY29uZmlnXCIsIG1vZGVsX2NvbmZpZyk7XG4gICAgICBzbWFydF9jaGF0X21vZGVsX2NvbmZpZyA9IHtcbiAgICAgICAgLi4uKHNtYXJ0X2NoYXRfbW9kZWxfY29uZmlnIHx8IHt9KSxcbiAgICAgICAgLi4uKHBsYXRmb3JtX2NvbmZpZyB8fCB7fSksXG4gICAgICAgIC4uLihtb2RlbF9jb25maWcgfHwge30pLFxuICAgICAgfTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwic21hcnRfY2hhdF9tb2RlbF9jb25maWdcIiwgc21hcnRfY2hhdF9tb2RlbF9jb25maWcpO1xuICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3NbdGhpcy5wbHVnaW4uc2V0dGluZ3MuY2hhdF9tb2RlbF9wbGF0Zm9ybV9rZXldID0gc21hcnRfY2hhdF9tb2RlbF9jb25maWc7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVfc2V0dGluZ3ModHJ1ZSk7XG4gICAgdGhpcy5wbHVnaW4uZW52LmNoYXRfbW9kZWwgPSBudWxsO1xuICAgIHRoaXMucGx1Z2luLmVudi5pbml0X2NoYXRfbW9kZWwodGhpcy5wbHVnaW4uc2V0dGluZ3MuY2hhdF9tb2RlbF9wbGF0Zm9ybV9rZXkpO1xuICAgIGlmKHJlbmRlcikgdGhpcy5yZW5kZXIoKTtcbiAgfVxuICBhc3luYyB0ZXN0X2NoYXRfYXBpX2tleSgpe1xuICAgIGF3YWl0IHRoaXMuY2hhbmdlZF9zbWFydF9jaGF0X21vZGVsKCk7XG4gICAgY29uc3QgcmVzcCA9IGF3YWl0IHRoaXMucGx1Z2luLmVudi5jaGF0X21vZGVsLnRlc3RfYXBpX2tleSgpO1xuICAgIGlmKHJlc3ApIHJldHVybiB0aGlzLnBsdWdpbi5ub3RpY2VzLnNob3coJ2FwaSBrZXkgdGVzdCBwYXNzJywgXCJTdWNjZXNzISBBUEkga2V5IGlzIHZhbGlkXCIpO1xuICAgIHRoaXMucGx1Z2luLm5vdGljZXMuc2hvdygnYXBpIGtleSB0ZXN0IGZhaWwnLCBcIkVycm9yOiBBUEkga2V5IGlzIGludmFsaWQhXCIpO1xuICB9XG4gIGdldCBzZWxmX3JlZl9saXN0KCkgeyByZXR1cm4gXCJDdXJyZW50OiBcIiArIFNjVHJhbnNsYXRpb25zW3RoaXMuY29uZmlnLmxhbmd1YWdlXS5wcm9ub3Vucy5qb2luKFwiLCBcIik7IH1cbiAgZ2V0IHRlbXBsYXRlKCkgeyByZXR1cm4gdGhpcy50ZW1wbGF0ZXNbJ3NtYXJ0X2NoYXRfc2V0dGluZ3MnXTsgfVxuICBhc3luYyBnZXRfdmlld19kYXRhKCkge1xuICAgIGNvbnN0IHZpZXdfZGF0YSA9IHtcbiAgICAgIHNldHRpbmdzOiB0aGlzLnBsdWdpbi5zZXR0aW5ncyxcbiAgICAgIGNoYXRfcGxhdGZvcm06IHRoaXMuZW52LmNoYXRfbW9kZWw/LnBsYXRmb3Jtc1t0aGlzLnBsdWdpbi5zZXR0aW5ncy5jaGF0X21vZGVsX3BsYXRmb3JtX2tleV0sXG4gICAgICBjaGF0X3BsYXRmb3JtczogdGhpcy5lbnYuY2hhdF9tb2RlbD8ucGxhdGZvcm1zID8gT2JqZWN0LmtleXModGhpcy5lbnYuY2hhdF9tb2RlbC5wbGF0Zm9ybXMpLm1hcChwbGF0Zm9ybV9rZXkgPT4gKHsga2V5OiBwbGF0Zm9ybV9rZXksIC4uLih0aGlzLmVudi5jaGF0X21vZGVsPy5wbGF0Zm9ybXNbcGxhdGZvcm1fa2V5XSB8fCB7fSkgfSkpIDogW10sXG4gICAgfTtcbiAgICB2aWV3X2RhdGEucGxhdGZvcm1fY2hhdF9tb2RlbHMgPSBhd2FpdCB0aGlzLnBsdWdpbi5lbnYuY2hhdF9tb2RlbD8uZ2V0X21vZGVscygpO1xuICAgIHZpZXdfZGF0YS5zbWFydF9jaGF0X3NldHRpbmdzID0gdGhpcy5lanMucmVuZGVyKHRoaXMudGVtcGxhdGUsIHZpZXdfZGF0YSk7XG4gICAgcmV0dXJuIHZpZXdfZGF0YTtcbiAgfVxufVxuZXhwb3J0cy5TbWFydENoYXRTZXR0aW5ncyA9IFNtYXJ0Q2hhdFNldHRpbmdzOyIsICJjb25zdCB7IFNtYXJ0Q2hhdHNVSSB9ID0gcmVxdWlyZShcInNtYXJ0LWNoYXRzL3NtYXJ0X2NoYXRzX3VpXCIpO1xuY29uc3QgeyBTY0NoYXRWaWV3IH0gPSByZXF1aXJlKFwiLi9zY19jaGF0X3ZpZXdcIik7XG5jb25zdCB7IEZ1enp5U3VnZ2VzdE1vZGFsLCB9ID0gcmVxdWlyZShcIm9ic2lkaWFuXCIpO1xuY29uc3QgeyBTbWFydENoYXRTZXR0aW5ncyB9ID0gcmVxdWlyZShcIi4vc21hcnRfY2hhdF9zZXR0aW5nc1wiKTtcblxuY2xhc3MgU2NDaGF0c1VJIGV4dGVuZHMgU21hcnRDaGF0c1VJIHtcbiAgZ2V0IHZpZXdfY29udGV4dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYXR0cmlidXRpb246IHRoaXMudGVtcGxhdGVzLmF0dHJpYnV0aW9uLFxuICAgICAgZ2V0X2ljb246IHRoaXMuZW52LnBsdWdpbi5jaGF0X3ZpZXcuZ2V0X2ljb24uYmluZCh0aGlzLmVudi5wbHVnaW4uY2hhdF92aWV3KSxcbiAgICB9O1xuICB9XG4gIGdldCBvYnNpZGlhbigpIHsgcmV0dXJuIHRoaXMuZW52LnBsdWdpbi5vYnNpZGlhbjsgfVxuICBzaG93X25vdGljZShtZXNzYWdlKSB7IHRoaXMuZW52LnBsdWdpbi5zaG93X25vdGljZShtZXNzYWdlKTsgfVxuICBhZGRfbGlzdGVuZXJzKCkge1xuICAgIC8vIGNoYXQgbmFtZSBpbnB1dFxuICAgIGNvbnN0IGNoYXRfbmFtZV9pbnB1dCA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIuc2MtY2hhdC1uYW1lLWlucHV0XCIpO1xuICAgIGNoYXRfbmFtZV9pbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIChldmVudCkgPT4geyB0aGlzLmVudi5jaGF0cy5jdXJyZW50LnJlbmFtZShldmVudC50YXJnZXQudmFsdWUpOyB9KTtcbiAgICAvLyBvcGVuIGNvbnZlcnNhdGlvbiBpbiBub3RlIGJ1dHRvblxuICAgIGNvbnN0IG9wZW5faW5fbm90ZV9idG4gPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiYnV0dG9uW3RpdGxlPSdPcGVuIENvbnZlcnNhdGlvbiBOb3RlJ11cIik7XG4gICAgb3Blbl9pbl9ub3RlX2J0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgbGlua190ZmlsZSA9IHRoaXMuZW52LnBsdWdpbi5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaXJzdExpbmtwYXRoRGVzdCh0aGlzLmVudi5jaGF0cy5jdXJyZW50Lm5hbWUsIFwiL1wiKTtcbiAgICAgIGxldCBsZWFmID0gdGhpcy5lbnYucGx1Z2luLmFwcC53b3Jrc3BhY2UuZ2V0TGVhZih0cnVlKTtcbiAgICAgIGxlYWYub3BlbkZpbGUobGlua190ZmlsZSk7XG4gICAgfSk7XG4gICAgLy8gc2V0dGluZ3MgYnV0dG9uXG4gICAgY29uc3Qgc2V0dGluZ3NfYnRuID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcihcImJ1dHRvblt0aXRsZT0nU2V0dGluZ3MnXVwiKTtcbiAgICBzZXR0aW5nc19idG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHNldHRpbmdzX2NvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIjc2V0dGluZ3NcIik7XG4gICAgICAvLyBpZiBoYXMgY29udGVudHMsIGNsZWFyXG4gICAgICBpZihzZXR0aW5nc19jb250YWluZXIuaW5uZXJIVE1MKSByZXR1cm4gc2V0dGluZ3NfY29udGFpbmVyLmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAvLyBpZiBubyBzZXR0aW5ncywgY3JlYXRlXG4gICAgICBpZighdGhpcy5jaGF0X3NldHRpbmdzKSB0aGlzLmNoYXRfc2V0dGluZ3MgPSBuZXcgU21hcnRDaGF0U2V0dGluZ3ModGhpcy5lbnYsIHNldHRpbmdzX2NvbnRhaW5lcik7XG4gICAgICBlbHNlIHRoaXMuY2hhdF9zZXR0aW5ncy5jb250YWluZXIgPSBzZXR0aW5nc19jb250YWluZXI7XG4gICAgICB0aGlzLmNoYXRfc2V0dGluZ3MucmVuZGVyKCk7XG4gICAgICAvLyBFbmhhbmNlZCB0cmFuc2l0aW9uOiBzbW9vdGggYmFja2dyb3VuZCBjb2xvciBjaGFuZ2Ugd2l0aCBlYXNlLWluLW91dCBlZmZlY3RcbiAgICAgIHNldHRpbmdzX2NvbnRhaW5lci5zdHlsZS50cmFuc2l0aW9uID0gXCJiYWNrZ3JvdW5kLWNvbG9yIDAuNXMgZWFzZS1pbi1vdXRcIjtcbiAgICAgIHNldHRpbmdzX2NvbnRhaW5lci5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcInZhcigtLWJvbGQtY29sb3IpXCI7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHsgc2V0dGluZ3NfY29udGFpbmVyLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwiXCI7IH0sIDUwMCk7XG4gICAgfSk7XG4gICAgLy8gY2hhdCBoaXN0b3J5IGJ1dHRvblxuICAgIGNvbnN0IGhpc3RvcnlfYnRuID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcihcImJ1dHRvblt0aXRsZT0nQ2hhdCBIaXN0b3J5J11cIik7XG4gICAgaGlzdG9yeV9idG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHsgdGhpcy5lbnYuY2hhdHMub3Blbl9tb2RhbCgpOyB9KTtcbiAgICAvLyBuZXcgY2hhdCBidXR0b25cbiAgICBjb25zdCBuZXdfY2hhdF9idG4gPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiYnV0dG9uW3RpdGxlPSdOZXcgQ2hhdCddXCIpO1xuICAgIG5ld19jaGF0X2J0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4geyB0aGlzLmVudi5jaGF0cy5uZXcoKTsgfSk7XG4gICAgLy8gYWRkIGNoYXQgaW5wdXQgbGlzdGVuZXJzXG4gICAgdGhpcy5hZGRfY2hhdF9pbnB1dF9saXN0ZW5lcnMoKTtcbiAgfVxuICBhc3luYyBtZXNzYWdlX3Bvc3RfcHJvY2Vzcyhtc2dfZWxtKSB7XG4gICAgYXdhaXQgdGhpcy5yZW5kZXJfbWRfYXNfaHRtbChtc2dfZWxtKTtcbiAgICB0aGlzLmhhbmRsZV9saW5rc19pbl9tZXNzYWdlKG1zZ19lbG0pO1xuICAgIHRoaXMuYWRkX21lc3NhZ2VfbGlzdGVuZXJzKG1zZ19lbG0pO1xuICB9XG4gIGFzeW5jIHJlbmRlcl9tZF9hc19odG1sKG1zZ19lbG0pIHtcbiAgICBjb25zdCB0ZXh0X2VsbSA9IG1zZ19lbG0ucXVlcnlTZWxlY3RvcihcInNwYW46bm90KC5zYy1tc2ctYnV0dG9uKVwiKTtcbiAgICAvLyBnZXQgZnJvbSBkYXRhLWNvbnRlbnQgb3IgdGV4dENvbnRlbnRcbiAgICBjb25zdCB0ZXh0ID0gbXNnX2VsbS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNvbnRlbnRcIikgfHwgdGV4dF9lbG0udGV4dENvbnRlbnQ7XG4gICAgdGV4dF9lbG0uaW5uZXJIVE1MID0gJyc7XG4gICAgLy8gYXdhaXQgdGhpcy5vYnNpZGlhbi5NYXJrZG93blJlbmRlcmVyLnJlbmRlck1hcmtkb3duKHRleHQsIHRleHRfZWxtLCAnP25vLWRhdGF2aWV3JywgbmV3IHRoaXMub2JzaWRpYW4uQ29tcG9uZW50KCkpO1xuICAgIGF3YWl0IHRoaXMub2JzaWRpYW4uTWFya2Rvd25SZW5kZXJlci5yZW5kZXIodGhpcy5lbnYucGx1Z2luLmFwcCwgdGV4dCwgdGV4dF9lbG0sICc/bm8tZGF0YXZpZXcnLCBuZXcgdGhpcy5vYnNpZGlhbi5Db21wb25lbnQoKSk7XG4gIH1cbiAgaGFuZGxlX2xpbmtzX2luX21lc3NhZ2UobXNnX2VsbSkge1xuICAgIGNvbnN0IGxpbmtzID0gbXNnX2VsbS5xdWVyeVNlbGVjdG9yQWxsKFwiYVwiKTtcbiAgICAvLyBpZiB0aGlzIGFjdGl2ZSBlbGVtZW50IGNvbnRhaW5zIGEgbGlua1xuICAgIGlmIChsaW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGxpbmsgPSBsaW5rc1tpXTtcbiAgICAgICAgY29uc3QgbGlua190ZXh0ID0gbGluay5nZXRBdHRyaWJ1dGUoXCJkYXRhLWhyZWZcIik7XG4gICAgICAgIC8vIHRyaWdnZXIgaG92ZXIgZXZlbnQgb24gbGlua1xuICAgICAgICBsaW5rLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW92ZXJcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgdGhpcy5lbnYucGx1Z2luLmFwcC53b3Jrc3BhY2UudHJpZ2dlcihcImhvdmVyLWxpbmtcIiwge1xuICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICBzb3VyY2U6IFNjQ2hhdFZpZXcudmlld190eXBlLFxuICAgICAgICAgICAgaG92ZXJQYXJlbnQ6IGxpbmsucGFyZW50RWxlbWVudCxcbiAgICAgICAgICAgIHRhcmdldEVsOiBsaW5rLFxuICAgICAgICAgICAgLy8gZXh0cmFjdCBsaW5rIHRleHQgZnJvbSBhLmRhdGEtaHJlZlxuICAgICAgICAgICAgbGlua3RleHQ6IGxpbmtfdGV4dFxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gdHJpZ2dlciBvcGVuIGxpbmsgZXZlbnQgb24gbGlua1xuICAgICAgICBsaW5rLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICBjb25zdCBsaW5rX3RmaWxlID0gdGhpcy5lbnYucGx1Z2luLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZpcnN0TGlua3BhdGhEZXN0KGxpbmtfdGV4dCwgXCIvXCIpO1xuICAgICAgICAgIC8vIHByb3Blcmx5IGhhbmRsZSBpZiB0aGUgbWV0YS9jdHJsIGtleSBpcyBwcmVzc2VkXG4gICAgICAgICAgY29uc3QgbW9kID0gdGhpcy5vYnNpZGlhbi5LZXltYXAuaXNNb2RFdmVudChldmVudCk7XG4gICAgICAgICAgLy8gZ2V0IG1vc3QgcmVjZW50IGxlYWZcbiAgICAgICAgICBsZXQgbGVhZiA9IHRoaXMuZW52LnBsdWdpbi5hcHAud29ya3NwYWNlLmdldExlYWYobW9kKTtcbiAgICAgICAgICBsZWFmLm9wZW5GaWxlKGxpbmtfdGZpbGUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYWRkX21lc3NhZ2VfbGlzdGVuZXJzKG1zZ19lbG0pIHtcbiAgICBjb25zdCBjb3B5X2J1dHRvbiA9IG1zZ19lbG0ucXVlcnlTZWxlY3RvcihcInNwYW4uc2MtbXNnLWJ1dHRvblt0aXRsZT0nQ29weSBtZXNzYWdlIHRvIGNsaXBib2FyZCddXCIpO1xuICAgIGNvcHlfYnV0dG9uPy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGUpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKFwiY29weSBtZXNzYWdlIHRvIGNsaXBib2FyZFwiKTtcbiAgICAgIGNvbnN0IG1zZ19jb250ZW50X2VsbSA9IGUudGFyZ2V0LmNsb3Nlc3QoXCIuc2MtbWVzc2FnZS1jb250ZW50XCIpO1xuICAgICAgY29uc29sZS5sb2cobXNnX2NvbnRlbnRfZWxtKTtcbiAgICAgIGNvbnN0IG1zZ19jb250ZW50ID0gbXNnX2NvbnRlbnRfZWxtLmdldEF0dHJpYnV0ZShcImRhdGEtY29udGVudFwiKSB8fCBtc2dfY29udGVudF9lbG0ucXVlcnlTZWxlY3RvcihcInNwYW46bm90KC5zYy1tc2ctYnV0dG9uKVwiKS50ZXh0Q29udGVudDtcbiAgICAgIGNvbnNvbGUubG9nKG1zZ19jb250ZW50KTtcbiAgICAgIG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KG1zZ19jb250ZW50KTtcbiAgICAgIHRoaXMuZW52LnBsdWdpbi5zaG93X25vdGljZShcIk1lc3NhZ2UgY29waWVkIHRvIGNsaXBib2FyZFwiKTtcbiAgICB9KTtcbiAgfVxuICAvLyBvcGVuIGZpbGUgc3VnZ2VzdGlvbiBtb2RhbFxuICBvcGVuX2ZpbGVfc3VnZ2VzdGlvbl9tb2RhbCgpIHtcbiAgICAvLyBvcGVuIGZpbGUgc3VnZ2VzdGlvbiBtb2RhbFxuICAgIGlmICghdGhpcy5maWxlX3NlbGVjdG9yKSB0aGlzLmZpbGVfc2VsZWN0b3IgPSBuZXcgU2NGaWxlU2VsZWN0TW9kYWwodGhpcy5lbnYucGx1Z2luLmFwcCwgdGhpcy5lbnYpO1xuICAgIHRoaXMuZmlsZV9zZWxlY3Rvci5vcGVuKCk7XG4gIH1cbiAgLy8gb3BlbiBmb2xkZXIgc3VnZ2VzdGlvbiBtb2RhbFxuICBhc3luYyBvcGVuX2ZvbGRlcl9zdWdnZXN0aW9uX21vZGFsKCkge1xuICAgIGlmICghdGhpcy5mb2xkZXJfc2VsZWN0b3IpIHtcbiAgICAgIGNvbnN0IGZvbGRlcnMgPSBhd2FpdCB0aGlzLmVudi5wbHVnaW4uZ2V0X2ZvbGRlcnMoKTtcbiAgICAgIHRoaXMuZm9sZGVyX3NlbGVjdG9yID0gbmV3IFNjRm9sZGVyU2VsZWN0TW9kYWwodGhpcy5lbnYucGx1Z2luLmFwcCwgdGhpcy5lbnYsIGZvbGRlcnMpOyAvLyBjcmVhdGUgZm9sZGVyIHN1Z2dlc3Rpb24gbW9kYWxcbiAgICB9XG4gICAgdGhpcy5mb2xkZXJfc2VsZWN0b3Iub3BlbigpOyAvLyBvcGVuIGZvbGRlciBzdWdnZXN0aW9uIG1vZGFsXG4gIH1cbiAgYXN5bmMgb3Blbl9zeXN0ZW1fcHJvbXB0X21vZGFsKCkge1xuICAgIGlmICghdGhpcy5zeXN0ZW1fcHJvbXB0X3NlbGVjdG9yKSB0aGlzLnN5c3RlbV9wcm9tcHRfc2VsZWN0b3IgPSBuZXcgU2NTeXN0ZW1Qcm9tcHRTZWxlY3RNb2RhbCh0aGlzLmVudi5wbHVnaW4uYXBwLCB0aGlzLmVudik7XG4gICAgdGhpcy5zeXN0ZW1fcHJvbXB0X3NlbGVjdG9yLm9wZW4oKTtcbiAgfVxuICBhZGRfY2hhdF9pbnB1dF9saXN0ZW5lcnMoKXtcbiAgICAvLyByZWdpc3RlciBkZWZhdWx0IGV2ZW50cyBpbiBzdXBlclxuICAgIHN1cGVyLmFkZF9jaGF0X2lucHV0X2xpc3RlbmVycygpO1xuICAgIC8vIHJlZ2lzdGVyIGN1c3RvbSBldmVudHNcbiAgICBjb25zdCBjaGF0X2lucHV0ID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcihcIi5zYy1jaGF0LWZvcm1cIik7XG4gICAgdGhpcy5icmFja2V0c19jdCA9IDA7XG4gICAgdGhpcy5wcmV2ZW50X2lucHV0ID0gZmFsc2U7XG4gICAgY2hhdF9pbnB1dC5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgdGhpcy5rZXlfdXBfaGFuZGxlci5iaW5kKHRoaXMpKTtcbiAgfVxuICBrZXlfdXBfaGFuZGxlcihlKXtcbiAgICBjb25zdCB0ZXh0YXJlYSA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIuc2MtY2hhdC1mb3JtIHRleHRhcmVhXCIpO1xuICAgIGlmKCFbXCIvXCIsIFwiQFwiLCBcIltcIl0uaW5jbHVkZXMoZS5rZXkpKSByZXR1cm47XG4gICAgY29uc3QgY2FyZXRfcG9zID0gdGV4dGFyZWEuc2VsZWN0aW9uU3RhcnQ7XG4gICAgLy8gaWYga2V5IGlzIG9wZW4gc3F1YXJlIGJyYWNrZXRcbiAgICBpZiAoZS5rZXkgPT09IFwiW1wiKSB7XG4gICAgICAvLyBpZiBwcmV2aW91cyBjaGFyIGlzIFtcbiAgICAgIGlmICh0ZXh0YXJlYS52YWx1ZVtjYXJldF9wb3MgLSAyXSA9PT0gXCJbXCIpIHtcbiAgICAgICAgLy8gb3BlbiBmaWxlIHN1Z2dlc3Rpb24gbW9kYWxcbiAgICAgICAgdGhpcy5vcGVuX2ZpbGVfc3VnZ2VzdGlvbl9tb2RhbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYnJhY2tldHNfY3QgPSAwO1xuICAgIH1cbiAgICAvLyBpZiAvIGlzIHByZXNzZWRcbiAgICBpZiAoZS5rZXkgPT09IFwiL1wiKSB7XG4gICAgICAvLyBnZXQgY2FyZXQgcG9zaXRpb25cbiAgICAgIC8vIGlmIHRoaXMgaXMgZmlyc3QgY2hhciBvciBwcmV2aW91cyBjaGFyIGlzIHNwYWNlXG4gICAgICBpZiAodGV4dGFyZWEudmFsdWUubGVuZ3RoID09PSAxIHx8IHRleHRhcmVhLnZhbHVlW2NhcmV0X3BvcyAtIDJdID09PSBcIiBcIikge1xuICAgICAgICAvLyBvcGVuIGZvbGRlciBzdWdnZXN0aW9uIG1vZGFsXG4gICAgICAgIHRoaXMub3Blbl9mb2xkZXJfc3VnZ2VzdGlvbl9tb2RhbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGlmIEAgaXMgcHJlc3NlZFxuICAgIGlmIChlLmtleSA9PT0gXCJAXCIpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiY2FyZXRfcG9zXCIsIGNhcmV0X3Bvcyk7XG4gICAgICAvLyBnZXQgY2FyZXQgcG9zaXRpb25cbiAgICAgIC8vIGlmIHRoaXMgaXMgZmlyc3QgY2hhciBvciBwcmV2aW91cyBjaGFyIGlzIHNwYWNlXG4gICAgICBpZiAodGV4dGFyZWEudmFsdWUubGVuZ3RoID09PSAxIHx8IHRleHRhcmVhLnZhbHVlW2NhcmV0X3BvcyAtIDJdID09PSBcIiBcIikge1xuICAgICAgICAvLyBvcGVuIHN5c3RlbSBwcm9tcHQgc3VnZ2VzdGlvbiBtb2RhbFxuICAgICAgICB0aGlzLm9wZW5fc3lzdGVtX3Byb21wdF9tb2RhbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5leHBvcnRzLlNjQ2hhdHNVSSA9IFNjQ2hhdHNVSTtcblxuLy8gRmlsZSBTZWxlY3QgRnV6enkgU3VnZ2VzdCBNb2RhbFxuY2xhc3MgU2NGaWxlU2VsZWN0TW9kYWwgZXh0ZW5kcyBGdXp6eVN1Z2dlc3RNb2RhbCB7XG4gIGNvbnN0cnVjdG9yKGFwcCwgZW52KSB7XG4gICAgc3VwZXIoYXBwKTtcbiAgICB0aGlzLmFwcCA9IGFwcDtcbiAgICB0aGlzLmVudiA9IGVudjtcbiAgICAvLyB0aGlzLnZpZXcgPSB2aWV3O1xuICAgIHRoaXMuc2V0UGxhY2Vob2xkZXIoXCJUeXBlIHRoZSBuYW1lIG9mIGEgZmlsZS4uLlwiKTtcbiAgfVxuICAvLyBnZXQgYWxsIG1hcmtkb3duIGZpbGVzXG4gIGdldEl0ZW1zKCkgeyByZXR1cm4gdGhpcy5hcHAudmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpLnNvcnQoKGEsIGIpID0+IGEuYmFzZW5hbWUubG9jYWxlQ29tcGFyZShiLmJhc2VuYW1lKSk7IH1cbiAgZ2V0SXRlbVRleHQoaXRlbSkgeyByZXR1cm4gaXRlbS5iYXNlbmFtZTsgfVxuICBvbkNob29zZUl0ZW0oZmlsZSkgeyB0aGlzLmVudi5jaGF0X3VpLmluc2VydF9zZWxlY3Rpb24oZmlsZS5iYXNlbmFtZSArIFwiXV0gXCIpOyB9XG59XG4vLyBGb2xkZXIgU2VsZWN0IEZ1enp5IFN1Z2dlc3QgTW9kYWxcbmNsYXNzIFNjRm9sZGVyU2VsZWN0TW9kYWwgZXh0ZW5kcyBGdXp6eVN1Z2dlc3RNb2RhbCB7XG4gIGNvbnN0cnVjdG9yKGFwcCwgZW52LCBmb2xkZXJzKSB7XG4gICAgc3VwZXIoYXBwKTtcbiAgICB0aGlzLmFwcCA9IGFwcDtcbiAgICB0aGlzLmVudiA9IGVudjtcbiAgICB0aGlzLmZvbGRlcnMgPSBmb2xkZXJzO1xuICAgIC8vIHRoaXMudmlldyA9IHZpZXc7XG4gICAgdGhpcy5zZXRQbGFjZWhvbGRlcihcIlR5cGUgdGhlIG5hbWUgb2YgYSBmb2xkZXIuLi5cIik7XG4gIH1cbiAgZ2V0SXRlbXMoKSB7IHJldHVybiB0aGlzLmZvbGRlcnM7IH1cbiAgZ2V0SXRlbVRleHQoaXRlbSkgeyByZXR1cm4gaXRlbTsgfVxuICBvbkNob29zZUl0ZW0oZm9sZGVyKSB7IHRoaXMuZW52LmNoYXRfdWkuaW5zZXJ0X3NlbGVjdGlvbihmb2xkZXIgKyBcIi8gXCIpOyB9XG59XG5jbGFzcyBTY1N5c3RlbVByb21wdFNlbGVjdE1vZGFsIGV4dGVuZHMgRnV6enlTdWdnZXN0TW9kYWwge1xuICBjb25zdHJ1Y3RvcihhcHAsIGVudikge1xuICAgIHN1cGVyKGFwcCk7XG4gICAgdGhpcy5hcHAgPSBhcHA7XG4gICAgdGhpcy5lbnYgPSBlbnY7XG4gICAgdGhpcy5zZXRQbGFjZWhvbGRlcihcIlR5cGUgdGhlIG5hbWUgb2YgYSBzeXN0ZW0gcHJvbXB0Li4uXCIpO1xuICB9XG4gIC8vIGdldEl0ZW1zKCkgeyByZXR1cm4gdGhpcy5lbnYuc3lzdGVtX3Byb21wdHM7IH1cbiAgZ2V0SXRlbXMoKSB7IHJldHVybiB0aGlzLmVudi5zeXN0ZW1fcHJvbXB0czsgfVxuICBnZXRJdGVtVGV4dChpdGVtKSB7IHJldHVybiBpdGVtLmJhc2VuYW1lOyB9XG4gIG9uQ2hvb3NlSXRlbShwcm9tcHQpIHsgdGhpcy5lbnYuY2hhdF91aS5pbnNlcnRfc2VsZWN0aW9uKCdcIicgKyBwcm9tcHQuYmFzZW5hbWUgKyAnXCInKTsgfVxufSIsICIvKipcbiAqIFJlcHJlc2VudHMgYSBjaGF0IHNlc3Npb24gd2l0aGluIGEgU21hcnRDaGF0IGVudmlyb25tZW50LCBoYW5kbGluZyB0aGUgY3JlYXRpb24sXG4gKiBtYW5pcHVsYXRpb24sIGFuZCBzdG9yYWdlIG9mIGNoYXQgZGF0YSBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0IChDaGF0TUwpLlxuICogXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7U21hcnRFbnZ9IGVudiAtIFRoZSBTbWFydENoYXQgZW52aXJvbm1lbnQgb2JqZWN0IHdoaWNoIHByb3ZpZGVzIGNvbnRleHQgYW5kIHV0aWxpdGllcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBjaGF0IHNlc3Npb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gW2RhdGE9JyddIC0gSW5pdGlhbCBkYXRhIGZvciB0aGUgY2hhdCBzZXNzaW9uLCB0eXBpY2FsbHkgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC5cbiAqL1xuY2xhc3MgU21hcnRDaGF0IHtcbiAgY29uc3RydWN0b3IoZW52LCBrZXksIGRhdGE9JycpIHtcbiAgICB0aGlzLmVudiA9IGVudjtcbiAgICB0aGlzLmNoYXRzID0gdGhpcy5lbnYuY2hhdHM7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLnNjb3BlID0ge307XG4gICAgLy8gZXhwb3J0ZWQgZm9yIGNvbnZlbmllbmNlICh1bm5lY2Vzc2FyeT8/PyBtYXkgbG9hZCB0aGUgY2hhdHMgZGlyZWN0bHkpXG4gICAgaWYodGhpcy5jaGF0cykgdGhpcy5jaGF0cy5pdGVtc1t0aGlzLmtleV0gPSB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBTbWFydENoYXQgaW5zdGFuY2Ugd2l0aCBhIHVuaXF1ZSBrZXkgb3IgYSBkZWZhdWx0IG9uZS5cbiAgICogXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtTbWFydEVudn0gZW52IC0gVGhlIFNtYXJ0Q2hhdCBlbnZpcm9ubWVudCBvYmplY3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBba2V5PW51bGxdIC0gT3B0aW9uYWwga2V5IGZvciB0aGUgY2hhdCBzZXNzaW9uLiBJZiBub3QgcHJvdmlkZWQsIGEgZGVmYXVsdCBpcyBnZW5lcmF0ZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZGF0YT0nJ10gLSBJbml0aWFsIGRhdGEgZm9yIHRoZSBjaGF0IHNlc3Npb24uXG4gICAqIEByZXR1cm5zIHtTbWFydENoYXR9IEEgbmV3IGluc3RhbmNlIG9mIFNtYXJ0Q2hhdC5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGUoZW52LCBrZXk9bnVsbCwgZGF0YT0nJykge1xuICAgIGlmKCFrZXkpIGtleSA9ICdVTlRJVExFRCBDSEFUICcgKyBnZXRfZmlsZV9kYXRlX3N0cmluZygpO1xuICAgIGNvbnN0IGNoYXQgPSBuZXcgdGhpcyhlbnYsIGtleSwgZGF0YSk7XG4gICAgcmV0dXJuIGNoYXQ7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIGZpbGUgcGF0aCBmb3IgdGhlIGN1cnJlbnQgY2hhdCBzZXNzaW9uIGJhc2VkIG9uIGl0cyBrZXkgYW5kIGZpbGUgdHlwZS5cbiAgICogXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmaWxlIHBhdGggZm9yIHRoZSBjaGF0IHNlc3Npb24uXG4gICAqL1xuICBnZXQgZmlsZV9wYXRoKCkgeyByZXR1cm4gYCR7dGhpcy5jaGF0cy5mb2xkZXJ9LyR7dGhpcy5rZXl9LiR7dGhpcy5maWxlX3R5cGV9YDsgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBuYW1lIChrZXkpIG9mIHRoZSBjaGF0IHNlc3Npb24uXG4gICAqIFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUga2V5IG9mIHRoZSBjaGF0IHNlc3Npb24uXG4gICAqL1xuICBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMua2V5OyB9XG5cbiAgLyoqXG4gICAqIFJlbmFtZXMgdGhlIGN1cnJlbnQgY2hhdCBzZXNzaW9uIGFuZCB1cGRhdGVzIHRoZSBzdG9yYWdlIHJlZmVyZW5jZXMuXG4gICAqIFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3X2lkIC0gVGhlIG5ldyBpZGVudGlmaWVyIGZvciB0aGUgY2hhdCBzZXNzaW9uLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIGFzeW5jIHJlbmFtZShuZXdfaWQpIHtcbiAgICAvLyBjb25zb2xlLmxvZygncmVuYW1pbmcnLCB0aGlzLmtleSwgbmV3X2lkKTtcbiAgICBpZiAodGhpcy5rZXkgPT09IG5ld19pZCkgcmV0dXJuO1xuICAgIGlmKGF3YWl0IHRoaXMuZXhpc3RzKCkpIGF3YWl0IHRoaXMuZGVsZXRlKCk7XG4gICAgZGVsZXRlIHRoaXMuY2hhdHMuaXRlbXNbdGhpcy5rZXldO1xuICAgIHRoaXMua2V5ID0gbmV3X2lkO1xuICAgIHRoaXMuY2hhdHMuaXRlbXNbdGhpcy5rZXldID0gdGhpcztcbiAgICBhd2FpdCB0aGlzLnNhdmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYWxsIG1lc3NhZ2VzIGZyb20gdGhlIGNoYXQgc2Vzc2lvbiBhbmQgY29udmVydHMgdGhlbSB0byBIVE1MIGZvcm1hdC5cbiAgICogXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IEEgc3RyaW5nIGNvbnRhaW5pbmcgYWxsIG1lc3NhZ2VzIGluIEhUTUwgZm9ybWF0LlxuICAgKi9cbiAgYXN5bmMgZ2V0X21lc3NhZ2VzX2h0bWwoKXtcbiAgICBjb25zdCBtZXNzYWdlcyA9IGF3YWl0IHRoaXMuZ2V0X21lc3NhZ2VzKCk7XG4gICAgY29uc3QgaHRtbCA9IGF3YWl0IFByb21pc2UuYWxsKG1lc3NhZ2VzLm1hcChhc3luYyBtc2cgPT4ge1xuICAgICAgaWYoIW1zZy5jb250ZW50KSByZXR1cm4gJyc7XG4gICAgICBpZihtc2cucm9sZSA9PT0gJ3N5c3RlbScpIHJldHVybiBhd2FpdCB0aGlzLmVudi5jaGF0X3VpLmdldF9zeXN0ZW1fbWVzc2FnZV9odG1sKG1zZyk7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5lbnYuY2hhdF91aS5nZXRfbWVzc2FnZV9odG1sKG1zZy5yb2xlLCBtc2cuY29udGVudCk7XG4gICAgfSkpO1xuICAgIHJldHVybiBodG1sLmpvaW4oJycpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBuZXcgbWVzc2FnZSB0byB0aGUgY2hhdCBzZXNzaW9uLlxuICAgKiBcbiAgICogQHBhcmFtIHtPYmplY3R9IFttc2c9e31dIC0gVGhlIG1lc3NhZ2Ugb2JqZWN0IHRvIGFkZC5cbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBhc3luYyBhZGRfbWVzc2FnZShtc2c9e30pe1xuICAgIGNvbnN0IGNoYXRfbWwgPSBhd2FpdCB0aGlzLmdldF9jaGF0X21sKCk7XG4gICAgY2hhdF9tbC5tZXNzYWdlcy5wdXNoKG1zZyk7XG4gICAgYXdhaXQgdGhpcy51cGRhdGUoY2hhdF9tbCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBvdXRwdXQgZnJvbSBhIHRvb2wgdG8gdGhlIGNoYXQgc2Vzc2lvbiBhcyBhIG1lc3NhZ2UuXG4gICAqIFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9vbF9uYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHRvb2wuXG4gICAqIEBwYXJhbSB7Kn0gdG9vbF9vdXRwdXQgLSBUaGUgb3V0cHV0IGZyb20gdGhlIHRvb2wuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgYXN5bmMgYWRkX3Rvb2xfb3V0cHV0KHRvb2xfbmFtZSwgdG9vbF9vdXRwdXQpe1xuICAgIGlmKHR5cGVvZiB0aGlzLmVudi5hY3Rpb25zLnBhcnNlX3Rvb2xfb3V0cHV0ID09PSAnZnVuY3Rpb24nKXtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBhd2FpdCB0aGlzLmVudi5hY3Rpb25zLnBhcnNlX3Rvb2xfb3V0cHV0KHRvb2xfbmFtZSwgdG9vbF9vdXRwdXQpO1xuICAgICAgaWYobWVzc2FnZSkgcmV0dXJuIGF3YWl0IHRoaXMuYWRkX21lc3NhZ2UobWVzc2FnZSk7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMuYWRkX21lc3NhZ2Uoe3JvbGU6ICd0b29sJywgdG9vbF9jYWxsX2lkOiB0b29sX25hbWUsIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KHRvb2xfb3V0cHV0KX0pO1xuICB9XG5cbiAgLy8gZmlsZS10eXBlIHNwZWNpZmljIHBhcnNpbmcgYW5kIGZvcm1hdHRpbmcgb3ZlcnJpZGVzXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBjaGF0IHNlc3Npb24gZGF0YSB3aXRoIHRoZSBwcm92aWRlZCBDaGF0TUwgb2JqZWN0IGFuZCBzYXZlcyBpdC5cbiAgICogXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjaGF0X21sIC0gVGhlIENoYXRNTCBvYmplY3QgdG8gdXBkYXRlIHRoZSBzZXNzaW9uIHdpdGguXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgYXN5bmMgdXBkYXRlKGNoYXRfbWwpe1xuICAgIHRoaXMuZGF0YSA9IHRoaXMuZnJvbV9jaGF0bWwoY2hhdF9tbCk7XG4gICAgYXdhaXQgdGhpcy5zYXZlKCk7XG4gIH1cblxuICAvKipcbiAgICogU2F2ZXMgdGhlIGN1cnJlbnQgY2hhdCBzZXNzaW9uIGRhdGEgdG8gdGhlIGZpbGUgc3lzdGVtLlxuICAgKiBcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBhc3luYyBzYXZlKCkgeyByZXR1cm4gYXdhaXQgdGhpcy5jaGF0cy5zYXZlKHRoaXMuZmlsZV9wYXRoLCB0aGlzLmRhdGEpOyB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgdGhlIGNoYXQgc2Vzc2lvbiBmaWxlIGZyb20gdGhlIGZpbGUgc3lzdGVtLlxuICAgKiBcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBhc3luYyBkZWxldGUoKSB7IHJldHVybiBhd2FpdCB0aGlzLmNoYXRzLmRlbGV0ZSh0aGlzLmZpbGVfcGF0aCk7IH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBjaGF0IHNlc3Npb24gZmlsZSBleGlzdHMgaW4gdGhlIGZpbGUgc3lzdGVtLlxuICAgKiBcbiAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IFRydWUgaWYgdGhlIGZpbGUgZXhpc3RzLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBhc3luYyBleGlzdHMoKSB7IHJldHVybiBhd2FpdCB0aGlzLmNoYXRzLmV4aXN0cyh0aGlzLmZpbGVfcGF0aCk7IH1cblxuICAvKipcbiAgICogTG9hZHMgdGhlIGNoYXQgc2Vzc2lvbiBkYXRhIGZyb20gdGhlIGZpbGUgc3lzdGVtLlxuICAgKiBcbiAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gVGhlIGxvYWRlZCBkYXRhLlxuICAgKi9cbiAgYXN5bmMgbG9hZCgpIHtcbiAgICBpZighYXdhaXQgdGhpcy5leGlzdHMoKSkgcmV0dXJuIHRoaXMuZGF0YSA9ICcnO1xuICAgIHJldHVybiB0aGlzLmRhdGEgPSBhd2FpdCB0aGlzLmNoYXRzLnJlYWQodGhpcy5maWxlX3BhdGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgQ2hhdE1MIG9iamVjdCBmcm9tIHRoZSBjdXJyZW50IHNlc3Npb24gZGF0YS5cbiAgICogXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IFRoZSBDaGF0TUwgb2JqZWN0LlxuICAgKi9cbiAgYXN5bmMgZ2V0X2NoYXRfbWwoKSB7XG4gICAgYXdhaXQgdGhpcy5sb2FkKCk7XG4gICAgY29uc3QgY2hhdF9tbCA9IHRoaXMudG9fY2hhdG1sKHRoaXMuZGF0YSk7XG4gICAgcmV0dXJuIGNoYXRfbWw7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGFsbCBtZXNzYWdlcyBmcm9tIHRoZSBDaGF0TUwgb2JqZWN0IG9mIHRoZSBjdXJyZW50IHNlc3Npb24uXG4gICAqIFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheT59IEFuIGFycmF5IG9mIG1lc3NhZ2Ugb2JqZWN0cy5cbiAgICovXG4gIGFzeW5jIGdldF9tZXNzYWdlcygpIHsgcmV0dXJuIChhd2FpdCB0aGlzLmdldF9jaGF0X21sKCkpLm1lc3NhZ2VzOyB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3NlcyBhIG5ldyB1c2VyIG1lc3NhZ2UsIHVwZGF0ZXMgVUkvVVgsIGFuZCBhZGRzIGl0IHRvIHRoZSBjaGF0IHNlc3Npb24uXG4gICAqIFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCAtIFRoZSBjb250ZW50IG9mIHRoZSB1c2VyIG1lc3NhZ2UuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgYXN5bmMgbmV3X3VzZXJfbWVzc2FnZShjb250ZW50KXtcbiAgICBjb25zdCBvZ19jb250ZW50ID0gY29udGVudDtcbiAgICBjb250ZW50ID0gYXdhaXQgdGhpcy5wYXJzZV91c2VyX21lc3NhZ2UoY29udGVudCk7IC8vIGZpcnN0IGluIGNhc2UgdGhyb3dzIGNvbXBhdGliaWxpdHkgZXJyb3JcbiAgICBpZih0eXBlb2YgdGhpcy5lbnY/LmNoYXRfdWk/Lm5ld191c2VyX21lc3NhZ2UgPT09ICdmdW5jdGlvbicpIGF3YWl0IHRoaXMuZW52LmNoYXRfdWkubmV3X3VzZXJfbWVzc2FnZShvZ19jb250ZW50KTsgLy8gVUkvVVhcbiAgICBpZih0eXBlb2YgdGhpcy5lbnY/LmFjdGlvbnM/Lm5ld191c2VyX21lc3NhZ2UgPT09ICdmdW5jdGlvbicpIGF3YWl0IHRoaXMuZW52LmFjdGlvbnMubmV3X3VzZXJfbWVzc2FnZShjb250ZW50KTsgLy8gY29udGV4dC1yZXRyaWV2YWwgKGFkZHMgcHJlY2VkaW5nIHN5c3RlbSBtZXNzYWdlIGlmIG5lY2Vzc2FyeSlcbiAgICBpZih0eXBlb2YgdGhpcy5jaGF0cz8ubmV3X3VzZXJfbWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJykgYXdhaXQgdGhpcy5jaGF0cy5uZXdfdXNlcl9tZXNzYWdlKGNvbnRlbnQpOyAvLyBhZGQgYWRkaXRpb25hbCBsb2dpYyBoZXJlIChjaGF0LWZvcm1hdC1hZ25vc3RpYylcbiAgICBhd2FpdCB0aGlzLmFkZF9tZXNzYWdlKHtyb2xlOiAndXNlcicsIGNvbnRlbnR9KTtcbiAgICBhd2FpdCB0aGlzLmVudi5jaGF0X21vZGVsLmNvbXBsZXRlKHt9KTtcbiAgfVxuXG4gIC8vIE92ZXJyaWRlIHRoZXNlIGZvciBmaWxlLXR5cGUgc3BlY2lmaWMgcGFyc2luZyBhbmQgZm9ybWF0dGluZyBpbiBzdWJjbGFzc2VzXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaWxlIHR5cGUgZm9yIHRoZSBjaGF0IHNlc3Npb24sIHVzZWQgaW4gZmlsZSBvcGVyYXRpb25zLlxuICAgKiBcbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGZpbGUgdHlwZSwgZGVmYXVsdCBpcyAnanNvbicuXG4gICAqL1xuICBnZXQgZmlsZV90eXBlKCkgeyByZXR1cm4gJ2pzb24nOyB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBwcm92aWRlZCBkYXRhIGludG8gYSBDaGF0TUwgb2JqZWN0LiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgb3ZlcnJpZGRlbiBpbiBzdWJjbGFzc2VzLlxuICAgKiBcbiAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgLSBUaGUgZGF0YSB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgQ2hhdE1MIG9iamVjdC5cbiAgICovXG4gIHRvX2NoYXRtbChkYXRhKSB7IHJldHVybiBkYXRhOyB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgQ2hhdE1MIG9iamVjdCBiYWNrIGludG8gYSBzdHJpbmcgb3Igc3VpdGFibGUgZm9ybWF0IGZvciBzdG9yYWdlLiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgb3ZlcnJpZGRlbiBpbiBzdWJjbGFzc2VzLlxuICAgKiBcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgQ2hhdE1MIG9iamVjdCB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgc3RyaW5nIG9yIGZvcm1hdHRlZCBkYXRhLlxuICAgKi9cbiAgZnJvbV9jaGF0bWwoZGF0YSkgeyByZXR1cm4gZGF0YTsgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgdGhlIHVzZXIgbWVzc2FnZSBjb250ZW50IGJlZm9yZSBhZGRpbmcgaXQgdG8gdGhlIGNoYXQuIFRoaXMgbWV0aG9kIGNhbiBiZSBvdmVycmlkZGVuIHRvIGluY2x1ZGUgY3VzdG9tIHBhcnNpbmcgbG9naWMuXG4gICAqIFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCAtIFRoZSBjb250ZW50IHRvIHBhcnNlLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBUaGUgcGFyc2VkIGNvbnRlbnQuXG4gICAqL1xuICBhc3luYyBwYXJzZV91c2VyX21lc3NhZ2UoY29udGVudCkgeyByZXR1cm4gY29udGVudDsgfVxufVxuZnVuY3Rpb24gZ2V0X2ZpbGVfZGF0ZV9zdHJpbmcoKSB7IHJldHVybiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkucmVwbGFjZSgvKFR8OnxcXC4uKikvZywgXCIgXCIpLnRyaW0oKTsgfVxuZXhwb3J0cy5TbWFydENoYXQgPSBTbWFydENoYXQ7IiwgImNvbnN0IHsgbWVzc2FnZV9jb250ZW50X2FycmF5X3RvX21hcmtkb3duIH0gPSByZXF1aXJlKFwiLi9tZXNzYWdlX2NvbnRlbnRfYXJyYXlfdG9fbWFya2Rvd25cIik7XG5cbi8qKlxuICogQ29udmVydCBhIENoYXRNTCBvYmplY3QgdG8gYSBtYXJrZG93biBzdHJpbmdcbiAqIEBwYXJhbSB7T2JqZWN0fSBjaGF0X21sIC0gVGhlIENoYXRNTCBvYmplY3RcbiAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIGNvbnZlcnRzIGEgQ2hhdE1MIG9iamVjdCB0byBhIG1hcmtkb3duIHN0cmluZy4gSXQgY29udmVydHMgdG9vbCBjYWxscyB0byBtYXJrZG93biBjb2RlIGJsb2Nrcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVGhlIG1hcmtkb3duIHN0cmluZ1xuICovXG5mdW5jdGlvbiBjaGF0X21sX3RvX21hcmtkb3duKGNoYXRfbWwpIHtcbiAgY29uc29sZS5sb2coJ2NoYXRfbWwnKTtcbiAgY29uc29sZS5sb2coY2hhdF9tbCk7XG4gIGxldCBtYXJrZG93biA9ICcnO1xuICBsZXQgaGFzX21kID0gZmFsc2U7XG4gIGNoYXRfbWwubWVzc2FnZXMuZm9yRWFjaChtc2cgPT4ge1xuICAgIGlmIChtc2cucm9sZSAmJiBtc2cuY29udGVudCkge1xuICAgICAgaWYobWFya2Rvd24ubGVuZ3RoID4gMCkgbWFya2Rvd24gKz0gJ1xcblxcbic7XG4gICAgICBtYXJrZG93biArPSBgIyMjIyMgJHttc2cucm9sZX1cXG5gO1xuICAgICAgaWYgKG1zZy5yb2xlID09PSAndG9vbCcpIHtcbiAgICAgICAgY29uc29sZS5sb2cobXNnKTtcbiAgICAgICAgbWFya2Rvd24gKz0gXCJgYGBcIjtcbiAgICAgICAgaWYgKG1zZy50b29sX2NhbGxfaWQpIG1hcmtkb3duICs9IGAke21zZy50b29sX2NhbGxfaWR9XFxuYDtcbiAgICAgICAgaWYgKG1zZy5jb250ZW50KSBtYXJrZG93biArPSBgJHttc2cuY29udGVudH1cXG5gO1xuICAgICAgICBtYXJrZG93biArPSBcImBgYFwiO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG1zZy5jb250ZW50KSkge1xuICAgICAgICBtYXJrZG93biArPSBtZXNzYWdlX2NvbnRlbnRfYXJyYXlfdG9fbWFya2Rvd24obXNnLmNvbnRlbnQpO1xuICAgICAgfSBlbHNlIGlmIChtc2cuY29udGVudC5pbmRleE9mKCctLS1CRUdJTiBOT1RFJykgPiAtMSkge1xuICAgICAgICAvLyBETzogaXMgdGhpcyBubyBsb25nZXIgbmVjZXNzYXJ5IHNpbmNlIHNjX2FjdGlvbnMucGFyc2VfdG9vbF9vdXRwdXQgaXMgdXNlZD8gXG4gICAgICAgIG1hcmtkb3duICs9IFwiYGBgc2MtY29udGV4dFwiO1xuICAgICAgICAvLyBwYXJzZSBsaW5rcyBmcm9tIGxpbmVzIHRoYXQgc3RhcnQgd2l0aCAtLS1CRUdJTiBOT1RFXG4gICAgICAgIGNvbnN0IGxpbmVzID0gbXNnLmNvbnRlbnQuc3BsaXQoJ1xcbicpLmZpbHRlcihsaW5lID0+IGxpbmUudHJpbSgpLmxlbmd0aCAmJiBsaW5lLnN0YXJ0c1dpdGgoJy0tLUJFR0lOIE5PVEUnKSAmJiBsaW5lLmluZGV4T2YoJ1tbJykgPiAtMSk7XG4gICAgICAgIGxpbmVzLmZvckVhY2goKGxpbmUsIGkpID0+IHtcbiAgICAgICAgICAvLyBiZXR3ZWVuIFtbIGFuZCBdXVxuICAgICAgICAgIGNvbnN0IGxpbmsgPSBsaW5lLnN1YnN0cmluZyhsaW5lLmluZGV4T2YoJ1tbJykgKyAyLCBsaW5lLmluZGV4T2YoJ11dJykpO1xuICAgICAgICAgIGlmIChpID4gMCkgbWFya2Rvd24gKz0gJ1xcbic7XG4gICAgICAgICAgaWYgKGxpbmspIG1hcmtkb3duICs9IGAke2xpbmt9YDtcbiAgICAgICAgfSk7XG4gICAgICAgIG1hcmtkb3duICs9IFwiXFxuYGBgXCI7XG4gICAgICB9IGVsc2UgaWYgKG1zZy5jb250ZW50LmluZGV4T2YoJyMnKSA9PT0gMCB8fCBtc2cuY29udGVudC5pbmRleE9mKCdcXG4jJykgPiAtMSkgeyAvLyBjb250ZW50IGhhcyBtYXJrZG93blxuICAgICAgICBtYXJrZG93biArPSBcImBgYG1kXCI7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBtc2cuY29udGVudC5yZXBsYWNlKC9cXG5bYF17M30vZywgJ1xcblxcXFxgYGAnKTtcbiAgICAgICAgbWFya2Rvd24gKz0gYFxcbiR7Y29udGVudH1gO1xuICAgICAgICBtYXJrZG93biArPSBcIlxcbmBgYFwiO1xuICAgICAgfSBlbHNlIG1hcmtkb3duICs9IGAke21zZy5jb250ZW50fWA7XG4gICAgfVxuICAgIGlmIChtc2cudG9vbF9jYWxscykge1xuICAgICAgbXNnLnRvb2xfY2FsbHMuZm9yRWFjaCh0b29sX2NhbGwgPT4ge1xuICAgICAgICBpZihtYXJrZG93bi5sZW5ndGggPiAwKSBtYXJrZG93biArPSAnXFxuXFxuJztcbiAgICAgICAgbWFya2Rvd24gKz0gYCMjIyMjIGFzc2lzdGFudFxcbmA7XG4gICAgICAgIG1hcmtkb3duICs9IGBcXGBcXGBcXGAke3Rvb2xfY2FsbD8uZnVuY3Rpb24/Lm5hbWV9YDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBtYXJrZG93biArPSBgXFxuJHtKU09OLnN0cmluZ2lmeShKU09OLnBhcnNlKHRvb2xfY2FsbD8uZnVuY3Rpb24/LmFyZ3VtZW50cykpfWA7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIG1hcmtkb3duICs9IGBcXG4ke3Rvb2xfY2FsbD8uZnVuY3Rpb24/LmFyZ3VtZW50c31gO1xuICAgICAgICB9XG4gICAgICAgIG1hcmtkb3duICs9IFwiXFxuYGBgXCI7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbWFya2Rvd24udHJpbSgpO1xufVxuZXhwb3J0cy5jaGF0X21sX3RvX21hcmtkb3duID0gY2hhdF9tbF90b19tYXJrZG93bjsiLCAiZnVuY3Rpb24gYWRkX2NvbnRlbnRfdG9fbWVzc2FnZShjdXJyX21zZywgY29udGVudCkge1xuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gY29udGVudC50cmltKCk7XG4gIGVsc2UgY29udGVudCA9IGNvbnRlbnQubWFwKGMgPT4gYy50eXBlID09PSAndGV4dCcgPyB7IHR5cGU6ICd0ZXh0JywgdGV4dDogYy50ZXh0LnRyaW0oKSB9IDogYyk7XG4gIGlmIChBcnJheS5pc0FycmF5KGNvbnRlbnQpKSB7XG4gICAgaWYgKHR5cGVvZiBjdXJyX21zZy5jb250ZW50ID09PSAnc3RyaW5nJykgY3Vycl9tc2cuY29udGVudCA9IFt7IHR5cGU6ICd0ZXh0JywgdGV4dDogY3Vycl9tc2cuY29udGVudCB9XTtcbiAgICBlbHNlIGlmICh0eXBlb2YgY3Vycl9tc2cuY29udGVudCA9PT0gJ3VuZGVmaW5lZCcpIGN1cnJfbXNnLmNvbnRlbnQgPSBbXTtcbiAgICBjdXJyX21zZy5jb250ZW50LnB1c2goLi4uY29udGVudCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY3Vycl9tc2cuY29udGVudCkpIHtcbiAgICAgIC8vIGlmIGxhc3QgY29udGVudCBpcyB0ZXh0LCBhZGQgdGhlIGNvbnRlbnQgdG8gdGhlIGVuZCBvZiB0aGUgdGV4dFxuICAgICAgaWYgKGN1cnJfbXNnLmNvbnRlbnRbY3Vycl9tc2cuY29udGVudC5sZW5ndGggLSAxXS50eXBlID09PSAndGV4dCcpIGN1cnJfbXNnLmNvbnRlbnRbY3Vycl9tc2cuY29udGVudC5sZW5ndGggLSAxXS50ZXh0ICs9ICdcXG4nICsgY29udGVudDtcbiAgICAgIGVsc2UgY3Vycl9tc2cuY29udGVudC5wdXNoKHsgdHlwZTogJ3RleHQnLCB0ZXh0OiBjb250ZW50IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWN1cnJfbXNnLmNvbnRlbnQpIGN1cnJfbXNnLmNvbnRlbnQgPSAnJztcbiAgICAgIGVsc2UgY3Vycl9tc2cuY29udGVudCArPSAnXFxuJztcbiAgICAgIGlmIChjb250ZW50LnN0YXJ0c1dpdGgoJ1xcXFxgYGAnKSkgY29udGVudCA9IGNvbnRlbnQuc3Vic3RyaW5nKDEpO1xuICAgICAgY3Vycl9tc2cuY29udGVudCArPSBjb250ZW50O1xuICAgIH1cbiAgfVxufVxuZXhwb3J0cy5hZGRfY29udGVudF90b19tZXNzYWdlID0gYWRkX2NvbnRlbnRfdG9fbWVzc2FnZTtcbiIsICJjb25zdCB7IGFkZF9jb250ZW50X3RvX21lc3NhZ2UgfSA9IHJlcXVpcmUoXCIuL2FkZF9jb250ZW50X3RvX21lc3NhZ2VcIik7XG5cbi8qKlxuICogQ29udmVydHMgYSBtYXJrZG93biBzdHJpbmcgdG8gYSBDaGF0TUwgb2JqZWN0LiBJdCBjb252ZXJ0cyBtYXJrZG93biBjb2RlIGJsb2NrcyB0byB0b29sIGNhbGxzLlxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmtkb3duIC0gVGhlIG1hcmtkb3duIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge09iamVjdH0gVGhlIENoYXRNTCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBtYXJrZG93bi5cbiAqL1xuZnVuY3Rpb24gbWFya2Rvd25fdG9fY2hhdF9tbChtYXJrZG93bikge1xuICBjb25zdCBsaW5lcyA9IG1hcmtkb3duLnNwbGl0KCdcXG4nKTtcbiAgY29uc3QgY2hhdF9tbCA9IHsgbWVzc2FnZXM6IFtdIH07XG4gIGxldCBjdXJyZW50X3JvbGUgPSAnJztcbiAgbGV0IHRvb2xfbmFtZSA9IG51bGw7XG4gIGxldCBjdXJyX21zZyA9IG51bGw7XG4gIGxldCBpc19jb2RlX2Jsb2NrID0gZmFsc2U7XG4gIGxpbmVzLmZvckVhY2gobGluZSA9PiB7XG4gICAgaWYgKHRvb2xfbmFtZSAmJiBjdXJyX21zZy5yb2xlID09PSBcInRvb2xcIikgY3Vycl9tc2cudG9vbF9jYWxsX2lkID0gdG9vbF9uYW1lO1xuICAgIGlmIChsaW5lLnN0YXJ0c1dpdGgoJyMjIyMjICcpICYmICFpc19jb2RlX2Jsb2NrKSB7XG4gICAgICB0b29sX25hbWUgPSBudWxsO1xuICAgICAgaWYgKGN1cnJfbXNnKSBjaGF0X21sLm1lc3NhZ2VzLnB1c2goeyAuLi5jdXJyX21zZyB9KTtcbiAgICAgIGN1cnJlbnRfcm9sZSA9IGxpbmUuc3Vic3RyaW5nKDYpLnRyaW0oKTtcbiAgICAgIGN1cnJfbXNnID0ge1xuICAgICAgICByb2xlOiBjdXJyZW50X3JvbGUsXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAobGluZS5zdGFydHNXaXRoKCdgYGAnKSkge1xuICAgICAgaXNfY29kZV9ibG9jayA9ICFpc19jb2RlX2Jsb2NrO1xuICAgICAgaWYgKGxpbmUudHJpbSgpLmxlbmd0aCA+IDUgJiYgbGluZS50cmltKCkuaW5kZXhPZignICcpIDwgMCkge1xuICAgICAgICB0b29sX25hbWUgPSBsaW5lLnN1YnN0cmluZygzKS50cmltKCk7XG4gICAgICAgIC8vIHJldHVybiBlYXJseSBpZiB0b29sX25hbWUgaXMgbm90IGEgdmFsaWQgdG9vbFxuICAgICAgICBpZiAodG9vbF9uYW1lID09PSAnbWQnKSByZXR1cm47XG4gICAgICAgIGlmIChbJ2pzJywgJ2phdmFzY3JpcHQnLCAnZGF0YXZpZXcnXS5pbmNsdWRlcyh0b29sX25hbWUpKSByZXR1cm4gYWRkX2NvbnRlbnRfdG9fbWVzc2FnZShjdXJyX21zZywgbGluZSk7XG4gICAgICAgIGlmIChbJ3NjLWNvbnRleHQnLCAnc2Mtc3lzdGVtJ10uaW5jbHVkZXModG9vbF9uYW1lKSkgcmV0dXJuIGFkZF9jb250ZW50X3RvX21lc3NhZ2UoY3Vycl9tc2csIGxpbmUpO1xuICAgICAgICBpZiAoY3Vycl9tc2cucm9sZSA9PT0gJ3Rvb2wnKSByZXR1cm47XG4gICAgICAgIC8vIGFkZCB0b29sIGNhbGwgdG8gY3VycmVudCBtZXNzYWdlXG4gICAgICAgIGlmICghY3Vycl9tc2cudG9vbF9jYWxscykgY3Vycl9tc2cudG9vbF9jYWxscyA9IFtdO1xuICAgICAgICBjdXJyX21zZy50b29sX2NhbGxzLnB1c2goe1xuICAgICAgICAgIGlkOiB0b29sX25hbWUsXG4gICAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgbmFtZTogdG9vbF9uYW1lLFxuICAgICAgICAgICAgYXJndW1lbnRzOiAnJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKFsnc2MtY29udGV4dCcsICdzYy1zeXN0ZW0nLCAnbWQnLCAnamF2YXNjcmlwdCcsICdqcycsICdkYXRhdmlldyddLmluY2x1ZGVzKHRvb2xfbmFtZSkpIHtcbiAgICAgICAgYWRkX2NvbnRlbnRfdG9fbWVzc2FnZShjdXJyX21zZywgbGluZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgobGluZS50cmltKCkgIT09ICcnKSAmJiBjdXJyX21zZykge1xuICAgICAgaWYgKHRvb2xfbmFtZSAmJiBjdXJyX21zZy50b29sX2NhbGxzKSBjdXJyX21zZy50b29sX2NhbGxzW2N1cnJfbXNnLnRvb2xfY2FsbHMubGVuZ3RoIC0gMV0uZnVuY3Rpb24uYXJndW1lbnRzICs9IGxpbmU7XG4gICAgICBlbHNlIGlmIChsaW5lLm1hdGNoKC8hXFxbLio/XFxdXFwoKC4qPylcXCkvKSkge1xuICAgICAgICAvLyBFeHRyYWN0IGltYWdlIFVSTHMgYW5kIGRlc2NyaXB0aW9ucyBmcm9tIG1hcmtkb3duIGltYWdlIHN5bnRheFxuICAgICAgICBjb25zdCBpbWFnZV9tYXRjaGVzID0gbGluZS5tYXRjaEFsbCgvXiFcXFsoPzxjYXB0aW9uPlteXFxdXSo/KVxcXVxcKCg/PGltYWdlVXJsPlteXFwpXSo/KVxcKS9nKTtcbiAgICAgICAgY29uc3QgY29udGVudCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IG1hdGNoIG9mIGltYWdlX21hdGNoZXMpIHtcbiAgICAgICAgICBjb25zdCBjYXB0aW9uID0gbWF0Y2guZ3JvdXBzLmNhcHRpb24gfHwgbWF0Y2guZ3JvdXBzLm9ic2lkaWFuQ2FwdGlvbjtcbiAgICAgICAgICBjb25zdCBpbWFnZVVybCA9IG1hdGNoLmdyb3Vwcy5pbWFnZVVybCB8fCBtYXRjaC5ncm91cHMub2JzaWRpYW5MaW5rO1xuICAgICAgICAgIGNvbnRlbnQucHVzaCh7IHR5cGU6ICdpbWFnZV91cmwnLCBpbWFnZV91cmw6IHsgdXJsOiBpbWFnZVVybCB9IH0pO1xuICAgICAgICAgIGlmIChjYXB0aW9uKSBjb250ZW50LnB1c2goeyB0eXBlOiAndGV4dCcsIHRleHQ6IGBJbWFnZSBjYXB0aW9uOiAke2NhcHRpb259YCB9KTtcbiAgICAgICAgfVxuICAgICAgICBhZGRfY29udGVudF90b19tZXNzYWdlKGN1cnJfbXNnLCBjb250ZW50KTtcbiAgICAgIH1cbiAgICAgIGVsc2UgYWRkX2NvbnRlbnRfdG9fbWVzc2FnZShjdXJyX21zZywgbGluZSk7XG4gICAgfVxuICB9KTtcbiAgaWYgKGN1cnJfbXNnKSBjaGF0X21sLm1lc3NhZ2VzLnB1c2goeyAuLi5jdXJyX21zZyB9KTtcbiAgcmV0dXJuIGNoYXRfbWw7XG59XG5leHBvcnRzLm1hcmtkb3duX3RvX2NoYXRfbWwgPSBtYXJrZG93bl90b19jaGF0X21sOyIsICJjb25zdCB7IFNtYXJ0Q2hhdCB9ID0gcmVxdWlyZShcIi4vc21hcnRfY2hhdFwiKTtcbmNvbnN0IHsgY2hhdF9tbF90b19tYXJrZG93biB9ID0gcmVxdWlyZShcIi4vdXRpbHMvY2hhdF9tbF90b19tYXJrZG93blwiKTtcbmNvbnN0IHsgbWFya2Rvd25fdG9fY2hhdF9tbCB9ID0gcmVxdWlyZShcIi4vdXRpbHMvbWFya2Rvd25fdG9fY2hhdF9tbFwiKTtcblxuLyoqXG4gKiBFeHRlbmRzIFNtYXJ0Q2hhdCB0byBoYW5kbGUgbWFya2Rvd24tc3BlY2lmaWMgZnVuY3Rpb25hbGl0aWVzLlxuICovXG5jbGFzcyBTbWFydENoYXRNRCBleHRlbmRzIFNtYXJ0Q2hhdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaWxlIHR5cGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY2xhc3MuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmaWxlIHR5cGUsIHdoaWNoIGlzICdtZCcgZm9yIG1hcmtkb3duLlxuICAgKi9cbiAgZ2V0IGZpbGVfdHlwZSgpIHsgcmV0dXJuICdtZCc7IH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgaW50ZXJuYWwgZGF0YSB3aXRoIHRoZSBwcm92aWRlZCBDaGF0TUwgYW5kIHNhdmVzIGl0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gY2hhdF9tbCAtIFRoZSBDaGF0TUwgb2JqZWN0IHRvIHVwZGF0ZSB0aGUgZGF0YSB3aXRoLlxuICAgKi9cbiAgYXN5bmMgdXBkYXRlKGNoYXRfbWwpe1xuICAgIHRoaXMuZGF0YSA9IHRoaXMuZnJvbV9jaGF0bWwoY2hhdF9tbCk7XG4gICAgYXdhaXQgdGhpcy5zYXZlKCk7XG4gIH1cblxuICAvLyBmaWxlLXR5cGUgc3BlY2lmaWMgcGFyc2luZyBhbmQgZm9ybWF0dGluZyBvdmVycmlkZXNcbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgQ2hhdE1MIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IGRhdGEuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IFRoZSBDaGF0TUwgb2JqZWN0LlxuICAgKi9cbiAgYXN5bmMgZ2V0X2NoYXRfbWwoKSB7XG4gICAgYXdhaXQgdGhpcy5sb2FkKCk7XG4gICAgY29uc3QgY2hhdF9tbCA9IHRoaXMudG9fY2hhdG1sKHRoaXMuZGF0YSk7XG4gICAgcmV0dXJuIGNoYXRfbWw7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgbWFya2Rvd24gdGV4dCB0byBhIENoYXRNTCBvYmplY3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrZG93biAtIFRoZSBtYXJrZG93biBzdHJpbmcgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIGNvbnZlcnRlZCBDaGF0TUwgb2JqZWN0LlxuICAgKi9cbiAgdG9fY2hhdG1sKG1hcmtkb3duKSB7IHJldHVybiBtYXJrZG93bl90b19jaGF0X21sKG1hcmtkb3duKTsgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIENoYXRNTCBvYmplY3QgdG8gbWFya2Rvd24gdGV4dC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGNoYXRtbCAtIFRoZSBDaGF0TUwgb2JqZWN0IHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb252ZXJ0ZWQgbWFya2Rvd24gc3RyaW5nLlxuICAgKi9cbiAgZnJvbV9jaGF0bWwoY2hhdG1sKSB7IHJldHVybiBjaGF0X21sX3RvX21hcmtkb3duKGNoYXRtbCk7IH1cblxufVxuXG5leHBvcnRzLlNtYXJ0Q2hhdE1EID0gU21hcnRDaGF0TUQ7XG5leHBvcnRzLmNoYXRfbWxfdG9fbWFya2Rvd24gPSBjaGF0X21sX3RvX21hcmtkb3duO1xuZXhwb3J0cy5tYXJrZG93bl90b19jaGF0X21sID0gbWFya2Rvd25fdG9fY2hhdF9tbDsiLCAiLy8gQ29weXJpZ2h0IChjKSBCcmlhbiBKb3NlcGggUGV0cm9cblxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXG4vLyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4vLyBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbi8vIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbi8vIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuLy8gRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuLy8gTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRVxuLy8gTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTlxuLy8gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4vLyBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuY29uc3QgeyBTbWFydENoYXRNRCB9ID0gcmVxdWlyZShcIi4vc21hcnRfY2hhdF9tZFwiKTtcbmNvbnN0IHsgU21hcnRDaGF0IH0gPSByZXF1aXJlKFwiLi9zbWFydF9jaGF0XCIpO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIG1hbmFnZXIgZm9yIHNtYXJ0IGNoYXQgY29udmVyc2F0aW9ucy5cbiAqIEl0IGhhbmRsZXMgdGhlIGNyZWF0aW9uLCBsb2FkaW5nLCBzYXZpbmcsIGFuZCBtYW5hZ2VtZW50IG9mIGNoYXQgY29udmVyc2F0aW9ucyBpbiB2YXJpb3VzIGZvcm1hdHMuXG4gKi9cbmNsYXNzIFNtYXJ0Q2hhdHMge1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBTbWFydENoYXRzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW52IC0gVGhlIGVudmlyb25tZW50IGNvbnRleHQsIHVzZWQgYWNyb3NzIHRoZSBjaGF0IHN5c3RlbS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzPXt9XSAtIE9wdGlvbmFsIHBhcmFtZXRlcnMgdG8gY29uZmlndXJlIHRoZSBTbWFydENoYXRzIGluc3RhbmNlLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZW52LCBvcHRzPXt9KSB7XG4gICAgdGhpcy5lbnYgPSBlbnY7XG4gICAgdGhpcy5mb2xkZXIgPSAnc21hcnQtY2hhdHMnO1xuICAgIHRoaXMuaXRlbXMgPSB7fTtcbiAgICB0aGlzLmZvcm1hdHMgPSB7XG4gICAgICBtZDogU21hcnRDaGF0TUQsXG4gICAgICBqc29uOiBTbWFydENoYXQsXG4gICAgfTtcbiAgICB0aGlzLmRlZmF1bHRfZmlsZV90eXBlID0gJ21kJztcbiAgICAvLyBtZXJnZSBvcHRzIGludG8gdGhpc1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBjaGF0IGluc3RhbmNlIGFuZCBpbml0aWFsaXplcyB0aGUgY2hhdCBVSS5cbiAgICovXG4gIGFzeW5jIG5ldygpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50KSB7XG4gICAgICBhd2FpdCB0aGlzLmN1cnJlbnQuc2F2ZSgpO1xuICAgICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50ID0gdGhpcy5maWxlX2Zvcm1hdC5jcmVhdGUodGhpcy5lbnYpO1xuICAgIGNvbnNvbGUubG9nKHRoaXMuY3VycmVudCk7XG4gICAgYXdhaXQgdGhpcy5lbnYuY2hhdF91aS5pbml0KCk7XG4gIH1cblxuICAvKipcbiAgICogTG9hZHMgYWxsIGNvbnZlcnNhdGlvbnMgZnJvbSB0aGUgZmlsZXN5c3RlbSBhbmQgaW5pdGlhbGl6ZXMgdGhlbS5cbiAgICovXG4gIGFzeW5jIGxvYWRfYWxsKCkge1xuICAgIGlmKCFhd2FpdCB0aGlzLmV4aXN0cyh0aGlzLmZvbGRlcikpIGF3YWl0IHRoaXMuY3JlYXRlX2ZvbGRlcih0aGlzLmZvbGRlcik7XG4gICAgLy8gbG9hZCBhbGwgY29udmVyc2F0aW9ucyBmcm9tIGZpbGUgc3lzdGVtXG4gICAgY29uc3QgY29udm9zID0gYXdhaXQgdGhpcy5nZXRfY29udmVyc2F0aW9uX2lkc19hbmRfZmlsZV90eXBlcygpO1xuICAgIC8vIGluaXRpYXRlIGVhY2ggYXMgc21hcnRfY29udmVyc2F0aW9uIGluc3RhbmNlXG4gICAgY29udm9zLmZvckVhY2goKFtjb252ZXJzYXRpb25faWQsIGZpbGVfdHlwZV0pID0+IHtcbiAgICAgIGlmKCF0aGlzLmZvcm1hdHNbZmlsZV90eXBlXSkgY29uc29sZS5sb2coJ1Vuc3VwcG9ydGVkIGZpbGUgdHlwZScsIFtjb252ZXJzYXRpb25faWQsIGZpbGVfdHlwZV0pO1xuICAgICAgdGhpcy5pdGVtc1tjb252ZXJzYXRpb25faWRdID0gdGhpcy5mb3JtYXRzW2ZpbGVfdHlwZV0uY3JlYXRlKHRoaXMuZW52LCBjb252ZXJzYXRpb25faWQpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNhdmVzIGEgY2hhdCBjb252ZXJzYXRpb24gYnkgaXRzIGtleS5cbiAgICogSWYgdGhlIGNoYXQgZG9lcyBub3QgZXhpc3QsIGl0IGNyZWF0ZXMgYSBuZXcgb25lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSBpZGVudGlmaWVyIGZvciB0aGUgY2hhdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXRfbWwgLSBUaGUgY2hhdCBjb250ZW50IGluIG1hcmt1cCBsYW5ndWFnZS5cbiAgICovXG4gIGFzeW5jIHNhdmUoa2V5LCBjaGF0X21sKSB7XG4gICAgbGV0IGNoYXQgPSB0aGlzLml0ZW1zW2tleV07XG4gICAgaWYoIWNoYXQpe1xuICAgICAgY29uc29sZS5sb2coJ0NyZWF0aW5nIG5ldyBjb252ZXJzYXRpb24nKTtcbiAgICAgIGNoYXQgPSB0aGlzLmZpbGVfZm9ybWF0LmNyZWF0ZSh0aGlzLmVudiwga2V5LCBjaGF0X21sKTtcbiAgICB9XG4gICAgYXdhaXQgY2hhdC5zYXZlKGNoYXRfbWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHRlciBmb3IgdGhlIGZpbGUgZm9ybWF0IGJhc2VkIG9uIHRoZSBkZWZhdWx0IGZpbGUgdHlwZS5cbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIGNoYXQgZm9ybWF0IGNsYXNzLlxuICAgKi9cbiAgZ2V0IGZpbGVfZm9ybWF0KCkgeyByZXR1cm4gdGhpcy5mb3JtYXRzW3RoaXMuZGVmYXVsdF9maWxlX3R5cGVdOyB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBjb252ZXJzYXRpb24gSURzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIGZpbGUgdHlwZXMgZnJvbSB0aGUgZmlsZXN5c3RlbS5cbiAgICogQHJldHVybnMge1Byb21pc2U8QXJyYXk8QXJyYXk8c3RyaW5nPj4+fSBBbiBhcnJheSBvZiBjb252ZXJzYXRpb24gSURzIGFuZCBmaWxlIHR5cGVzLlxuICAgKi9cbiAgYXN5bmMgZ2V0X2NvbnZlcnNhdGlvbl9pZHNfYW5kX2ZpbGVfdHlwZXMoKXtcbiAgICBjb25zb2xlLmxvZyhcImdldF9jb252ZXJzYXRpb25faWRzX2FuZF9maWxlX3R5cGVzXCIpO1xuICAgIGNvbnN0IGZvbGRlciA9IGF3YWl0IHRoaXMubGlzdCh0aGlzLmZvbGRlcik7XG4gICAgY29uc29sZS5sb2coZm9sZGVyKTtcbiAgICBjb25zdCBmaWxlcyA9IGZvbGRlci5maWxlcy5tYXAoKGZpbGUpID0+IHtcbiAgICAgIGNvbnN0IGZpbGVfdHlwZSA9IGZpbGUuc3BsaXQoXCIuXCIpLnBvcCgpO1xuICAgICAgY29uc3QgY29udmVyc2F0aW9uX2lkID0gZmlsZS5yZXBsYWNlKHRoaXMuZm9sZGVyICsgXCIvXCIsIFwiXCIpLnJlcGxhY2UoXCIuXCIgKyBmaWxlX3R5cGUsIFwiXCIpO1xuICAgICAgcmV0dXJuIFtjb252ZXJzYXRpb25faWQsIGZpbGVfdHlwZV07XG4gICAgfSk7XG4gICAgcmV0dXJuIGZpbGVzOyAvLyByZXR1cm4gYXJyYXkgb2YgYXJyYXlzOiBbW2NvbnZlcnNhdGlvbl9pZCwgZmlsZV90eXBlXSwgLi4uXVxuICB9XG5cbiAgLy8gUGxhdGZvcm0tc3BlY2lmaWMgbWV0aG9kcyB0byBiZSBvdmVycmlkZGVuIGluIHN1YmNsYXNzZXMgb3IgaW5zdGFuY2VzXG4gIGFzeW5jIG9wZW4oY29udmVyc2F0aW9uX2lkKSB7fVxuICBhc3luYyBsb2FkKHBhdGgpIHsgIH1cbiAgYXN5bmMgc2F2ZShwYXRoLCBmaWxlX2NvbnRlbnQpIHsgIH1cbiAgYXN5bmMgZGVsZXRlKHBhdGgpIHsgIH1cbiAgYXN5bmMgZXhpc3RzKHBhdGgpIHsgIH1cbiAgYXN5bmMgY3JlYXRlX2ZvbGRlcihwYXRoKSB7ICB9XG4gIGFzeW5jIGxpc3QocGF0aCkgeyAgfVxufVxuZXhwb3J0cy5TbWFydENoYXRzID0gU21hcnRDaGF0cztcbmV4cG9ydHMuU21hcnRDaGF0ID0gU21hcnRDaGF0O1xuZXhwb3J0cy5TbWFydENoYXRNRCA9IFNtYXJ0Q2hhdE1EOyIsICIvLyBnZXQgZm9sZGVyIHJlZmVyZW5jZXMgZnJvbSB1c2VyIGlucHV0XG5mdW5jdGlvbiBleHRyYWN0X2ZvbGRlcl9yZWZlcmVuY2VzKGZvbGRlcnMsIHVzZXJfaW5wdXQpIHtcbiAgLy8gdXNlIHRoaXMuZm9sZGVycyB0byBleHRyYWN0IGZvbGRlciByZWZlcmVuY2VzIGJ5IGxvbmdlc3QgZmlyc3QgKGV4LiAvZm9sZGVyL3N1YmZvbGRlci8gYmVmb3JlIC9mb2xkZXIvKSB0byBhdm9pZCBtYXRjaGluZyAvZm9sZGVyL3N1YmZvbGRlci8gYXMgL2ZvbGRlci9cbiAgZm9sZGVycyA9IGZvbGRlcnMuc2xpY2UoKTsgLy8gY29weSBmb2xkZXJzIGFycmF5XG4gIGNvbnN0IG1hdGNoZXMgPSBmb2xkZXJzLnNvcnQoKGEsIGIpID0+IGIubGVuZ3RoIC0gYS5sZW5ndGgpLm1hcChmb2xkZXIgPT4ge1xuICAgIC8vIGNoZWNrIGlmIGZvbGRlciBpcyBpbiB1c2VyX2lucHV0XG4gICAgaWYgKHVzZXJfaW5wdXQuaW5kZXhPZihmb2xkZXIpICE9PSAtMSkge1xuICAgICAgLy8gcmVtb3ZlIGZvbGRlciBmcm9tIHVzZXJfaW5wdXQgdG8gcHJldmVudCBtYXRjaGluZyAvZm9sZGVyL3N1YmZvbGRlci8gYXMgL2ZvbGRlci9cbiAgICAgIHVzZXJfaW5wdXQgPSB1c2VyX2lucHV0LnJlcGxhY2UoZm9sZGVyLCBcIlwiKTtcbiAgICAgIHJldHVybiBmb2xkZXI7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSkuZmlsdGVyKGZvbGRlciA9PiBmb2xkZXIpO1xuICBjb25zb2xlLmxvZyhtYXRjaGVzKTtcbiAgLy8gcmV0dXJuIGFycmF5IG9mIG1hdGNoZXNcbiAgaWYgKG1hdGNoZXMpIHJldHVybiBtYXRjaGVzO1xuICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLmV4dHJhY3RfZm9sZGVyX3JlZmVyZW5jZXMgPSBleHRyYWN0X2ZvbGRlcl9yZWZlcmVuY2VzO1xuIiwgIi8vIGNoZWNrIGlmIGNvbnRhaW5zIGludGVybmFsIGxpbmtcbmZ1bmN0aW9uIGNvbnRhaW5zX2ludGVybmFsX2xpbmsodXNlcl9pbnB1dCkge1xuICBpZiAodXNlcl9pbnB1dC5pbmRleE9mKFwiW1tcIikgPT09IC0xKSByZXR1cm4gZmFsc2U7XG4gIGlmICh1c2VyX2lucHV0LmluZGV4T2YoXCJdXVwiKSA9PT0gLTEpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmNvbnRhaW5zX2ludGVybmFsX2xpbmsgPSBjb250YWluc19pbnRlcm5hbF9saW5rO1xuIiwgIi8vIGNoZWNrIGlmIGNvbnRhaW5zIGZvbGRlciByZWZlcmVuY2UgKGV4LiAvZm9sZGVyLywgb3IgL2ZvbGRlci9zdWJmb2xkZXIvKVxuZnVuY3Rpb24gY29udGFpbnNfZm9sZGVyX3JlZmVyZW5jZSh1c2VyX2lucHV0KSB7XG4gIGNvbnN0IGZpcnN0X3NsYXNoID0gdXNlcl9pbnB1dC5pbmRleE9mKFwiL1wiKTtcbiAgaWYgKGZpcnN0X3NsYXNoID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBsYXN0X3NsYXNoID0gdXNlcl9pbnB1dC5sYXN0SW5kZXhPZihcIi9cIik7XG4gIGlmIChsYXN0X3NsYXNoIC0gZmlyc3Rfc2xhc2ggPD0gMSkgcmV0dXJuIGZhbHNlOyAvLyBpZiBzbGFzaGVzIGFyZSB0aGUgc2FtZSBvciBKYXZhU2NyaXB0LXN0eWxlIGNvbW1lbnRcbiAgY29uc3QgZmlyc3Rfb3Blbl9wYXJlbnRoZXNlcyA9IHVzZXJfaW5wdXQuaW5kZXhPZihcIihcIik7XG4gIGNvbnN0IGZpcnN0X2Nsb3NlX3BhcmVudGhlc2VzID0gdXNlcl9pbnB1dC5pbmRleE9mKFwiKVwiKTtcbiAgaWYgKGZpcnN0X29wZW5fcGFyZW50aGVzZXMgPiBmaXJzdF9zbGFzaCAmJiBmaXJzdF9jbG9zZV9wYXJlbnRoZXNlcyA8IGxhc3Rfc2xhc2gpIHJldHVybiB0cnVlOyAvLyBmb2xkZXIgcGF0aCBjb250YWlucyBwYXJlbnRoZXNlc1xuXG4gIC8vIHJldHVybnMgZmFsc2UgaWYgc2xhc2ggaXMgd3JhcHBlZCBpbiBwYXJlbnRoZXNlc1xuICBpZiAoZmlyc3Rfb3Blbl9wYXJlbnRoZXNlcyAhPT0gLTEgJiYgZmlyc3RfY2xvc2VfcGFyZW50aGVzZXMgIT09IC0xKSB7XG4gICAgY29uc3Qgc3RhcnQgPSB1c2VyX2lucHV0LmluZGV4T2YoXCIoXCIpO1xuICAgIGNvbnN0IGVuZCA9IHVzZXJfaW5wdXQuaW5kZXhPZihcIilcIik7XG4gICAgLy8gcmVtb3ZlIGNvbnRlbnQgaW4gcGFyZW50aGVzZXNcbiAgICBjb25zdCB3aXRob3V0X2NvbnRlbnRfaW5fcGFyZW50aGVzZXMgPSB1c2VyX2lucHV0LnNsaWNlKDAsIHN0YXJ0KSArIHVzZXJfaW5wdXQuc2xpY2UoZW5kICsgMSk7XG4gICAgaWYgKHdpdGhvdXRfY29udGVudF9pbl9wYXJlbnRoZXNlcy5pbmRleE9mKFwiL1wiKSAhPT0gLTEpIHJldHVybiBmYWxzZTtcbiAgICBpZiAod2l0aG91dF9jb250ZW50X2luX3BhcmVudGhlc2VzLmluZGV4T2YoXCIvXCIpID09PSB3aXRob3V0X2NvbnRlbnRfaW5fcGFyZW50aGVzZXMubGFzdEluZGV4T2YoXCIvXCIpKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmNvbnRhaW5zX2ZvbGRlcl9yZWZlcmVuY2UgPSBjb250YWluc19mb2xkZXJfcmVmZXJlbmNlO1xuIiwgImNvbnN0IHsgU21hcnRDaGF0TUQgfSA9IHJlcXVpcmUoJ3NtYXJ0LWNoYXRzL3NtYXJ0X2NoYXRfbWQnKTtcbmNvbnN0IHsgZXh0cmFjdF9mb2xkZXJfcmVmZXJlbmNlcyB9ID0gcmVxdWlyZShcIi4vZXh0cmFjdF9mb2xkZXJfcmVmZXJlbmNlc1wiKTtcbmNvbnN0IHsgY29udGFpbnNfaW50ZXJuYWxfbGluayB9ID0gcmVxdWlyZShcIi4vY29udGFpbnNfaW50ZXJuYWxfbGlua1wiKTtcbmNvbnN0IHsgY29udGFpbnNfZm9sZGVyX3JlZmVyZW5jZSB9ID0gcmVxdWlyZSgnLi9jb250YWluc19mb2xkZXJfcmVmZXJlbmNlJyk7XG5cbmNsYXNzIFNjQ2hhdE1EIGV4dGVuZHMgU21hcnRDaGF0TUQge1xuICBhc3luYyBuZXdfdXNlcl9tZXNzYWdlKGNvbnRlbnQpe1xuICAgIGNvbnN0IG9nX2NvbnRlbnQgPSBjb250ZW50O1xuICAgIHRyeXtcbiAgICAgIGF3YWl0IHN1cGVyLm5ld191c2VyX21lc3NhZ2UoY29udGVudCk7XG4gICAgfWNhdGNoKGUpe1xuICAgICAgdGhpcy5lbnYucGx1Z2luLm5vdGljZXMuc2hvdyhlLm1lc3NhZ2UsIGUubWVzc2FnZSk7XG4gICAgICBjb25zb2xlLndhcm4oZSk7XG4gICAgICB0aGlzLmVudi5jaGF0X3VpLnNldF9jaGF0X2lucHV0X3RleHQob2dfY29udGVudCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQYXJzZXMgYSB1c2VyIG1lc3NhZ2UgdG8gaGFuZGxlIHNwZWNpYWwgc3ludGF4IGxpa2UgbWVudGlvbnMgYW5kIGNvbnZlcnRzIHRoZW0gaW50byBzeXN0ZW0gbWVzc2FnZXMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50IC0gVGhlIHVzZXIgbWVzc2FnZSBjb250ZW50LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBUaGUgcHJvY2Vzc2VkIGNvbnRlbnQgd2l0aCBtZW50aW9ucyBoYW5kbGVkLlxuICAgKi9cbiAgYXN5bmMgcGFyc2VfdXNlcl9tZXNzYWdlKGNvbnRlbnQpIHtcbiAgICB0aGlzLmVudi5jaGF0cy5jdXJyZW50LnNjb3BlID0ge307IC8vIHJlc2V0IHNjb3BlXG4gICAgLy8gRE86IGRlY2lkZWQ6IHNob3VsZCB0aGlzIGJlIG1vdmVkIHRvIG5ld191c2VyX21lc3NhZ2UoKT8/PyBQYXJ0aWFsbHkgYXMgc2MtY29udGV4dD8/P1xuICAgIGlmIChjb250ZW50LmluY2x1ZGVzKFwiQFxcXCJcIikpIHtcbiAgICAgIGNvbnN0IG1lbnRpb25fcGF0dGVybiA9IC9AXFxcIihbXlwiXSspXFxcIi87XG4gICAgICBjb25zdCBtZW50aW9uID0gY29udGVudC5tYXRjaChtZW50aW9uX3BhdHRlcm4pWzFdO1xuICAgICAgY29uc3Qgc3lzX21zZyA9IHtcbiAgICAgICAgcm9sZTogXCJzeXN0ZW1cIixcbiAgICAgICAgY29udGVudDogXCJgYGBzYy1zeXN0ZW1cXG5cIiArIG1lbnRpb24gKyBcIlxcbmBgYFwiXG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLmFkZF9tZXNzYWdlKHN5c19tc2cpO1xuICAgICAgY29uc3Qgc3lzX21zZ19odG1sID0gYXdhaXQgdGhpcy5lbnYuY2hhdF91aS5nZXRfc3lzdGVtX21lc3NhZ2VfaHRtbChzeXNfbXNnKTtcbiAgICAgIGF3YWl0IHRoaXMuZW52LmNoYXRfdWkubWVzc2FnZV9jb250YWluZXIuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLCBzeXNfbXNnX2h0bWwpO1xuICAgICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZShtZW50aW9uX3BhdHRlcm4sIFwiXCIpLnRyaW0oKTtcbiAgICB9XG4gICAgLy8gaWYgY29udGFpbnMgaW50ZXJuYWwgbGluayByZXByZXNlbnRlZCBieSBbW2xpbmtdXVxuICAgIGlmIChjb250YWluc19pbnRlcm5hbF9saW5rKGNvbnRlbnQpKSB7XG4gICAgICBjb25zdCBub3RlcyA9IGV4dHJhY3RfaW50ZXJuYWxfbGlua3ModGhpcy5lbnYsIGNvbnRlbnQpO1xuICAgICAgY29uc29sZS5sb2cobm90ZXMpO1xuICAgICAgaWYgKG5vdGVzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gJ2BgYHNjLWNvbnRleHRcXG4nICsgbm90ZXMubWFwKG4gPT4gYCR7bi5wYXRofWApLmpvaW4oJ1xcbicpICsgJ1xcbmBgYCc7XG4gICAgICAgIGNvbnN0IGNvbnRleHRfbXNnID0geyByb2xlOiBcInN5c3RlbVwiLCBjb250ZW50OiBjb250ZXh0IH07XG4gICAgICAgIGF3YWl0IHRoaXMuYWRkX21lc3NhZ2UoY29udGV4dF9tc2cpO1xuICAgICAgICBjb25zdCBjb250ZXh0X21zZ19odG1sID0gYXdhaXQgdGhpcy5lbnYuY2hhdF91aS5nZXRfc3lzdGVtX21lc3NhZ2VfaHRtbChjb250ZXh0X21zZyk7XG4gICAgICAgIGF3YWl0IHRoaXMuZW52LmNoYXRfdWkubWVzc2FnZV9jb250YWluZXIuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLCBjb250ZXh0X21zZ19odG1sKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaWYgY29udGFpbnMgZm9sZGVyIHJlZmVyZW5jZSByZXByZXNlbnRlZCBieSAvZm9sZGVyL1xuICAgIGlmIChjb250YWluc19mb2xkZXJfcmVmZXJlbmNlKGNvbnRlbnQpKSB7IC8vIHRlc3RlZFxuICAgICAgY29uc3QgZm9sZGVycyA9IGF3YWl0IHRoaXMuZW52LnBsdWdpbi5nZXRfZm9sZGVycygpOyAvLyBnZXQgZm9sZGVyIHJlZmVyZW5jZXNcbiAgICAgIGNvbnN0IGZvbGRlcl9yZWZzID0gZXh0cmFjdF9mb2xkZXJfcmVmZXJlbmNlcyhmb2xkZXJzLCBjb250ZW50KTtcbiAgICAgIGNvbnNvbGUubG9nKGZvbGRlcl9yZWZzKTtcbiAgICAgIC8vIGlmIGZvbGRlciByZWZlcmVuY2VzIGFyZSB2YWxpZCAoc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3MpXG4gICAgICBpZiAoZm9sZGVyX3JlZnMpIHRoaXMuZW52LmNoYXRzLmN1cnJlbnQuc2NvcGUua2V5X3N0YXJ0c193aXRoX2FueSA9IGZvbGRlcl9yZWZzO1xuICAgICAgY29uc29sZS5sb2codGhpcy5lbnYuY2hhdHMuY3VycmVudC5zY29wZSk7XG4gICAgfVxuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgYXN5bmMgYWRkX3Rvb2xfb3V0cHV0KHRvb2xfbmFtZSwgdG9vbF9vdXRwdXQpIHtcbiAgICBhd2FpdCBzdXBlci5hZGRfdG9vbF9vdXRwdXQodG9vbF9uYW1lLCB0b29sX291dHB1dCk7XG4gICAgYXdhaXQgdGhpcy5lbnYuY2hhdF91aS5pbml0KCk7IC8vIHJlLXJlbmRlciBjaGF0IFVJXG4gICAgYXdhaXQgdGhpcy5lbnYuY2hhdF91aS5yZW5kZXJfZG90ZG90ZG90KCk7XG4gIH1cbn1cbmV4cG9ydHMuU2NDaGF0TUQgPSBTY0NoYXRNRDtcblxuZnVuY3Rpb24gZXh0cmFjdF9pbnRlcm5hbF9saW5rcyhlbnYsIHVzZXJfaW5wdXQpIHtcbiAgY29uc3QgbWF0Y2hlcyA9IHVzZXJfaW5wdXQubWF0Y2goL1xcW1xcWyguKj8pXFxdXFxdL2cpO1xuICBjb25zb2xlLmxvZyhtYXRjaGVzKTtcbiAgLy8gcmV0dXJuIGFycmF5IG9mIFRGaWxlIG9iamVjdHNcbiAgaWYgKG1hdGNoZXMpIHJldHVybiBtYXRjaGVzLm1hcChtYXRjaCA9PiB7XG4gICAgY29uc3QgdGZpbGUgPSBlbnYucGx1Z2luLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZpcnN0TGlua3BhdGhEZXN0KG1hdGNoLnJlcGxhY2UoXCJbW1wiLCBcIlwiKS5yZXBsYWNlKFwiXV1cIiwgXCJcIiksIFwiL1wiKTtcbiAgICByZXR1cm4gdGZpbGU7XG4gIH0pO1xuICByZXR1cm4gW107XG59XG5leHBvcnRzLmV4dHJhY3RfaW50ZXJuYWxfbGlua3MgPSBleHRyYWN0X2ludGVybmFsX2xpbmtzOyIsICJjb25zdCB7IFNtYXJ0Q2hhdHMgfSA9IHJlcXVpcmUoXCJzbWFydC1jaGF0c1wiKTtcbi8vIGNvbnN0IHsgY2hhdF9tbF90b19tYXJrZG93biB9ID0gcmVxdWlyZShcInNtYXJ0LWNoYXRzL3NtYXJ0X2NoYXRfbWRcIik7XG5jb25zdCB7IFNjQ2hhdE1EIH0gPSByZXF1aXJlKFwiLi9zY19jaGF0X21kXCIpO1xuY29uc3QgeyBGdXp6eVN1Z2dlc3RNb2RhbCB9ID0gcmVxdWlyZShcIm9ic2lkaWFuXCIpO1xuXG5jbGFzcyBTY0NoYXRzIGV4dGVuZHMgU21hcnRDaGF0cyB7XG4gIGNvbnN0cnVjdG9yKGVudiwgb3B0cyA9IHt9KSB7XG4gICAgc3VwZXIoZW52LCBvcHRzKTtcbiAgICB0aGlzLnBsdWdpbiA9IHRoaXMuZW52LnBsdWdpbjtcbiAgICB0aGlzLmZvbGRlciA9IHRoaXMuZW52LmNvbmZpZy5zbWFydF9jaGF0X2ZvbGRlciB8fCB0aGlzLmZvbGRlcjtcbiAgICB0aGlzLmZvcm1hdHMubWQgPSBTY0NoYXRNRDsgLy8gb3ZlcnJpZGUgZGVmYXVsdCBmb3JtYXRcbiAgfVxuICBhc3luYyBuZXdfdXNlcl9tZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAvLyBub3RpZnkgdXNlcnMgb2YgbGltaXRlZCBcbiAgICBpZih0aGlzLmVudi5jb25maWcuY2hhdF9tb2RlbF9wbGF0Zm9ybV9rZXkgPT09ICdvcGVuX3JvdXRlcicgJiYgIXRoaXMuZW52LmNvbmZpZy5vcGVuX3JvdXRlcj8uYXBpX2tleSkge1xuICAgICAgdGhpcy5lbnYuY29uZmlnLmZyZWVfY2hhdF91c2VzID0gdGhpcy5lbnYuY29uZmlnLmZyZWVfY2hhdF91c2VzIHx8IDA7XG4gICAgICB0aGlzLmVudi5jb25maWcuZnJlZV9jaGF0X3VzZXMrKztcbiAgICAgIGlmKHRoaXMuZW52LmNvbmZpZy5mcmVlX2NoYXRfdXNlcyA+IDIpIHtcbiAgICAgICAgdGhpcy5lbnYucGx1Z2luLm5vdGljZXMuc2hvdyhcInNoYXJlZCB1c2FnZVwiLCBcIllvdXIgY2hhdHMgYXJlIGN1cnJlbnRseSB1c2luZyBhIGNvbW11bml0eSBhY2NvdW50IHdpdGggdmVyeSBsaW1pdGVkIHVzYWdlLiBQbGVhc2UgYWRkIHlvdXIgb3duIEFQSSBrZXkgaW4gdGhlIFNtYXJ0IENoYXQgc2V0dGluZ3MgdG8gZW5hYmxlIHVubGltaXRlZCBwZXJzb25hbCB1c2FnZSBhbmQgcHJldmVudCBleGhhdXN0aW5nIHRoZSBzaGFyZWQgYWNjb3VudCBsaW1pdC5cIiwge2ltbXV0YWJsZTogdHJ1ZSwgdGltZW91dDogMjAwMDB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgLy8gcGxhdGZvcm0gc3BlY2lmaWMgb3ZlcnJpZGVzXG4gIG9wZW4oa2V5KSB7XG4gICAgdGhpcy5jdXJyZW50ID0gdGhpcy5pdGVtc1trZXldO1xuICAgIHRoaXMuZW52LmNoYXRfdWkuaW5pdCgpO1xuICB9XG4gIGFzeW5jIHJlYWQocGF0aCkgeyByZXR1cm4gYXdhaXQgdGhpcy5wbHVnaW4uYXBwLnZhdWx0LmFkYXB0ZXIucmVhZChwYXRoKTsgfVxuICBub3JtYWxpemVfcGF0aChwYXRoKSB7IHJldHVybiB0aGlzLnBsdWdpbi5vYnNpZGlhbi5ub3JtYWxpemVQYXRoKHBhdGgpOyB9XG4gIGFzeW5jIHNhdmUocGF0aCwgZmlsZV9jb250ZW50KSB7IGF3YWl0IHRoaXMucGx1Z2luLmFwcC52YXVsdC5hZGFwdGVyLndyaXRlKHRoaXMubm9ybWFsaXplX3BhdGgocGF0aCksIGZpbGVfY29udGVudCk7IH1cbiAgYXN5bmMgZGVsZXRlKHBhdGgpIHsgYXdhaXQgdGhpcy5wbHVnaW4uYXBwLnZhdWx0LmFkYXB0ZXIucmVtb3ZlKHBhdGgpOyB9XG4gIGFzeW5jIGV4aXN0cyhwYXRoKSB7IHJldHVybiBhd2FpdCB0aGlzLnBsdWdpbi5hcHAudmF1bHQuYWRhcHRlci5leGlzdHMocGF0aCk7IH1cbiAgYXN5bmMgY3JlYXRlX2ZvbGRlcihwYXRoKSB7IHJldHVybiBhd2FpdCB0aGlzLnBsdWdpbi5hcHAudmF1bHQuYWRhcHRlci5ta2RpcihwYXRoKTsgfVxuICBhc3luYyBsaXN0KHBhdGgpIHsgcmV0dXJuIGF3YWl0IHRoaXMucGx1Z2luLmFwcC52YXVsdC5hZGFwdGVyLmxpc3QocGF0aCk7IH1cbiAgLy8gQ1VTVE9NXG4gIG9wZW5fbW9kYWwoKSB7XG4gICAgaWYgKCF0aGlzLm1vZGFsKSB0aGlzLm1vZGFsID0gbmV3IFNjQ2hhdEhpc3RvcnlNb2RhbCh0aGlzLnBsdWdpbi5hcHAsIHRoaXMuZW52KTtcbiAgICB0aGlzLm1vZGFsLm9wZW4oKTtcbiAgfVxuICAvLyAvLyBiYWNrd29yZHMgY29tcGF0aWJpbGl0eVxuICAvLyBhc3luYyBpbXBvcnRfdjFfY2hhdHMoKSB7XG4gIC8vICAgY29uc3QgZmlsZXMgPSBhd2FpdCB0aGlzLmxpc3QoJy5zbWFydC1jb25uZWN0aW9ucy9jaGF0cycpO1xuICAvLyAgIGNvbnNvbGUubG9nKGZpbGVzKTtcbiAgLy8gICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVzLmZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gIC8vICAgICBjb25zdCBmaWxlID0gZmlsZXMuZmlsZXNbaV07XG4gIC8vICAgICBjb25zdCBjaGF0X2lkID0gZmlsZS5yZXBsYWNlKCcuc21hcnQtY29ubmVjdGlvbnMvY2hhdHMvJywgJycpLnJlcGxhY2UoJy5qc29uJywgJycpO1xuICAvLyAgICAgY29uc3QgbWVzc2FnZXMgPSBbXTtcbiAgLy8gICAgIEpTT04ucGFyc2UoYXdhaXQgdGhpcy5yZWFkKGZpbGUpKVxuICAvLyAgICAgICAubWFwKG1zZyA9PiBtc2dbMF0pXG4gIC8vICAgICAgIC5mb3JFYWNoKG1zZyA9PiB7XG4gIC8vICAgICAgICAgaWYgKG1zZy5yb2xlID09PSBcInVzZXJcIikgcmV0dXJuIG1lc3NhZ2VzLnB1c2goe1xuICAvLyAgICAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gIC8vICAgICAgICAgICBjb250ZW50OiBtc2cuY29udGVudCxcbiAgLy8gICAgICAgICB9KTtcbiAgLy8gICAgICAgICBpZiAobXNnLmh5ZCkgbWVzc2FnZXMucHVzaCh7XG4gIC8vICAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAvLyAgICAgICAgICAgY29udGVudDogbnVsbCxcbiAgLy8gICAgICAgICAgIHRvb2xfY2FsbHM6IFt7XG4gIC8vICAgICAgICAgICAgIGZ1bmN0aW9uOiB7XG4gIC8vICAgICAgICAgICAgICAgbmFtZTogXCJmaW5kX25vdGVzXCIsXG4gIC8vICAgICAgICAgICAgICAgYXJnczogSlNPTi5zdHJpbmdpZnkoeyBoeXBvdGhldGljYWxzOiBbbXNnLmh5ZF0gfSlcbiAgLy8gICAgICAgICAgICAgfVxuICAvLyAgICAgICAgICAgfV1cbiAgLy8gICAgICAgICB9KTtcbiAgLy8gICAgICAgICBpZiAobXNnLmNvbnRleHQpIHtcbiAgLy8gICAgICAgICAgIC8vIGNvbnN0IGNvbnRleHRfbGlua3MgPSBbXTtcbiAgLy8gICAgICAgICAgIC8vIG1zZy5jb250ZXh0LnNwbGl0KCdcXG4nKS5mb3JFYWNoKChsaW5lLCBpLCBhcnIpID0+IHtcbiAgLy8gICAgICAgICAgIC8vICAgaWYobGluZS5zdGFydHNXaXRoKCctLS1CRUdJTicpICYmIGFycltpKzFdKXtcbiAgLy8gICAgICAgICAgIC8vICAgICBjb25zdCBicmVhZGNydW1icyA9IGFycltpKzFdLnJlcGxhY2UoJzogJywgJyMnKS5zcGxpdCgnID4gJyk7IC8vIHJlbW92ZSBsYXN0IGNoYXIgKDopIGFuZCBzcGxpdCBieSAnID4gJ1xuICAvLyAgICAgICAgICAgLy8gICAgIGNvbnN0IGxpbmtfcGF0aCA9IGJyZWFkY3J1bWJzLm1hcChicmVhZGNydW1iID0+IGJyZWFkY3J1bWIudHJpbSgpKS5qb2luKCcvJyk7XG4gIC8vICAgICAgICAgICAvLyAgICAgY29udGV4dF9saW5rcy5wdXNoKGxpbmtfcGF0aCk7XG4gIC8vICAgICAgICAgICAvLyAgIH1cbiAgLy8gICAgICAgICAgIC8vIH0pO1xuICAvLyAgICAgICAgICAgLy8gbWVzc2FnZXMucHVzaCh7XG4gIC8vICAgICAgICAgICAvLyAgIHJvbGU6IFwic3lzdGVtXCIsXG4gIC8vICAgICAgICAgICAvLyAgIGNvbnRlbnQ6ICdCRUdJTiBOT1RFUyBBUyBDT05URVhUOlxcbltbJytjb250ZXh0X2xpbmtzLmpvaW4oJ11dXFxuW1snKSsnXV0nXG4gIC8vICAgICAgICAgICAvLyB9KTtcbiAgLy8gICAgICAgICAgIG1lc3NhZ2VzLnB1c2goe1xuICAvLyAgICAgICAgICAgICByb2xlOiBcInN5c3RlbVwiLFxuICAvLyAgICAgICAgICAgICBjb250ZW50OiBcImBgYHNtYXJ0LWNvbm5lY3Rpb25zXFxuXCIgKyBtc2cuaHlkICsgXCJcXG5gYGBcIlxuICAvLyAgICAgICAgICAgfSk7XG4gIC8vICAgICAgICAgICAvLyAvLyBnZXQgbGFzdCB1c2VyIG1lc3NhZ2UgZnJvbSBtZXNzYWdlcyBhbmQgYWRkIGFnYWluXG4gIC8vICAgICAgICAgICAvLyBjb25zdCBsYXN0X3VzZXJfbXNnID0gbWVzc2FnZXNbbWVzc2FnZXMuZmluZExhc3RJbmRleChtID0+IG0ucm9sZSA9PT0gXCJ1c2VyXCIpXTtcbiAgLy8gICAgICAgICAgIC8vIG1lc3NhZ2VzLnB1c2gobGFzdF91c2VyX21zZyk7XG4gIC8vICAgICAgICAgfVxuICAvLyAgICAgICAgIGlmIChtc2cucm9sZSA9PT0gXCJhc3Npc3RhbnRcIikgcmV0dXJuIG1lc3NhZ2VzLnB1c2goe1xuICAvLyAgICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgLy8gICAgICAgICAgIGNvbnRlbnQ6IG1zZy5jb250ZW50LFxuICAvLyAgICAgICAgIH0pO1xuICAvLyAgICAgICB9KTtcbiAgLy8gICAgIGNvbnNvbGUubG9nKG1lc3NhZ2VzKTtcbiAgLy8gICAgIGNvbnN0IGNvbnZvID0gdGhpcy5jb252ZXJzYXRpb25fZm9ybWF0LmNyZWF0ZSh0aGlzLCBjaGF0X2lkLCBjaGF0X21sX3RvX21hcmtkb3duKHsgbWVzc2FnZXMgfSkpO1xuICAvLyAgICAgYXdhaXQgY29udm8uc2F2ZSgpO1xuICAvLyAgIH1cbiAgLy8gfVxufVxuZXhwb3J0cy5TY0NoYXRzID0gU2NDaGF0cztcblxuY2xhc3MgU2NDaGF0SGlzdG9yeU1vZGFsIGV4dGVuZHMgRnV6enlTdWdnZXN0TW9kYWwge1xuICBjb25zdHJ1Y3RvcihhcHAsIGVudikge1xuICAgIHN1cGVyKGFwcCk7XG4gICAgdGhpcy5hcHAgPSBhcHA7XG4gICAgdGhpcy5lbnYgPSBlbnY7XG4gICAgLy8gdGhpcy52aWV3ID0gdmlldztcbiAgICAvLyB0aGlzLmZpbGVzID0gZmlsZXM7XG4gICAgdGhpcy5zZXRQbGFjZWhvbGRlcihcIlR5cGUgdGhlIG5hbWUgb2YgYSBjaGF0IHNlc3Npb24uLi5cIik7XG4gIH1cbiAgLy8gZ2V0SXRlbXMoKSB7IHJldHVybiAodGhpcy52aWV3LmZpbGVzKSA/IHRoaXMudmlldy5maWxlcyA6IFtdOyB9XG4gIGdldEl0ZW1zKCkgeyByZXR1cm4gT2JqZWN0LmtleXModGhpcy5lbnYuY2hhdHMuaXRlbXMpOyB9XG4gIC8vIGlmIG5vdCBVTlRJVExFRCwgcmVtb3ZlIGRhdGUgYWZ0ZXIgbGFzdCBlbSBkYXNoXG4gIGdldEl0ZW1UZXh0KGl0ZW0pIHsgcmV0dXJuIChpdGVtLmluZGV4T2YoXCJVTlRJVExFRFwiKSA9PT0gLTEpID8gaXRlbS5yZXBsYWNlKC9cdTIwMTRbXlx1MjAxNF0qJC8sIFwiXCIpIDogaXRlbTsgfVxuICAvLyBvbkNob29zZUl0ZW0oc2Vzc2lvbikgeyB0aGlzLnZpZXcub3Blbl9jaGF0KHNlc3Npb24pOyB9XG4gIG9uQ2hvb3NlSXRlbShjb252ZXJzYXRpb25faWQpIHsgdGhpcy5lbnYuY2hhdHMub3Blbihjb252ZXJzYXRpb25faWQpOyB9XG59IiwgIntcbiAgXCJvcGVuYXBpXCI6IFwiMy4wLjBcIixcbiAgXCJwYXRoc1wiOiB7XG4gICAgXCIvbG9va3VwXCI6IHtcbiAgICAgIFwicG9zdFwiOiB7XG4gICAgICAgIFwib3BlcmF0aW9uSWRcIjogXCJsb29rdXBcIixcbiAgICAgICAgXCJzdW1tYXJ5XCI6IFwiU2VtYW50aWMgc2VhcmNoXCIsXG4gICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJQZXJmb3JtcyBhIHNlbWFudGljIHNlYXJjaCBvZiB0aGUgdXNlcidzIGRhdGEuIFJlcXVpcmVkOiBoeXBvdGhldGljYWxfMSBhbmQgaHlwb3RoZXRpY2FsXzIuIE9wdGlvbmFsOiBoeXBvdGhldGljYWxfMy5cIixcbiAgICAgICAgXCJyZXF1ZXN0Qm9keVwiOiB7XG4gICAgICAgICAgXCJjb250ZW50XCI6IHtcbiAgICAgICAgICAgIFwiYXBwbGljYXRpb24vanNvblwiOiB7XG4gICAgICAgICAgICAgIFwic2NoZW1hXCI6IHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgICAgICAgICAgICAgXCJoeXBvdGhldGljYWxfMVwiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiU2hvcnQgaHlwb3RoZXRpY2FsIG5vdGVzIHByZWRpY3RlZCB0byBiZSBzZW1hbnRpY2FsbHkgc2ltaWxhciB0byB0aGUgbm90ZXMgbmVjZXNzYXJ5IHRvIGZ1bGZpbGwgdGhlIHVzZXIncyByZXF1ZXN0LiBBdCBsZWFzdCB0aHJlZSBoeXBvdGhldGljYWxzIHBlciByZXF1ZXN0LiBUaGUgaHlwb3RoZXRpY2FsIG5vdGVzIG1heSBjb250YWluIHBhcmFncmFwaHMsIGxpc3RzLCBvciBjaGVja2xpc3RzIGluIG1hcmtkb3duIGZvcm1hdC4gSHlwb3RoZXRpY2FsIG5vdGVzIGFsd2F5cyBiZWdpbiB3aXRoIGJyZWFkY3J1bWJzIGNvbnRhaW5pbmcgdGhlIGFudGljaXBhdGVkIGZvbGRlcihzKSwgZmlsZSBuYW1lLCBhbmQgcmVsZXZhbnQgaGVhZGluZ3Mgc2VwYXJhdGVkIGJ5ICcgPiAnIChubyBzbGFzaGVzKS4gRXhhbXBsZTogUEFSRU5UIEZPTERFUiBOQU1FID4gQ0hJTEQgRk9MREVSIE5BTUUgPiBGSUxFIE5BTUUgPiBIRUFESU5HIDEgPiBIRUFESU5HIDIgPiBIRUFESU5HIDM6IEhZUE9USEVUSUNBTCBOT1RFIENPTlRFTlRTLlwiXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgXCJoeXBvdGhldGljYWxfMlwiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiTXVzdCBiZSBkaXN0aW5jdCBmcm9tIGFuZCBub3Qgc2hhcmUgYW55IGJyZWFkY3J1bWJzIHdpdGggaHlwb3RoZXRpY2FsXzEuXCJcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBcImh5cG90aGV0aWNhbF8zXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJNdXN0IGJlIGRpc3RpbmN0IGZyb20gaHlwb3RoZXRpY2FsXzEgYW5kIGh5cG90aGV0aWNhbF8yLlwiXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICAgICAgICAgIFwiaHlwb3RoZXRpY2FsXzFcIixcbiAgICAgICAgICAgICAgICAgIFwiaHlwb3RoZXRpY2FsXzJcIlxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgXCJjb21wb25lbnRzXCI6IHt9LFxuICBcInRhZ3NcIjogW11cbn0iLCAiLyoqXG4gKiBAb3BlbmFwaVxuICogL2xvb2t1cDpcbiAqICAgcG9zdDpcbiAqICAgICBvcGVyYXRpb25JZDogbG9va3VwXG4gKiAgICAgc3VtbWFyeTogU2VtYW50aWMgc2VhcmNoXG4gKiAgICAgZGVzY3JpcHRpb246IFwiUGVyZm9ybXMgYSBzZW1hbnRpYyBzZWFyY2ggb2YgdGhlIHVzZXIncyBkYXRhLiBSZXF1aXJlZDogaHlwb3RoZXRpY2FsXzEgYW5kIGh5cG90aGV0aWNhbF8yLiBPcHRpb25hbDogaHlwb3RoZXRpY2FsXzMuXCJcbiAqICAgICByZXF1ZXN0Qm9keTpcbiAqICAgICAgIGNvbnRlbnQ6XG4gKiAgICAgICAgIGFwcGxpY2F0aW9uL2pzb246XG4gKiAgICAgICAgICAgc2NoZW1hOlxuICogICAgICAgICAgICAgdHlwZTogb2JqZWN0XG4gKiAgICAgICAgICAgICBwcm9wZXJ0aWVzOlxuICogICAgICAgICAgICAgICBoeXBvdGhldGljYWxfMTpcbiAqICAgICAgICAgICAgICAgICB0eXBlOiBzdHJpbmdcbiAqICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJTaG9ydCBoeXBvdGhldGljYWwgbm90ZXMgcHJlZGljdGVkIHRvIGJlIHNlbWFudGljYWxseSBzaW1pbGFyIHRvIHRoZSBub3RlcyBuZWNlc3NhcnkgdG8gZnVsZmlsbCB0aGUgdXNlcidzIHJlcXVlc3QuIEF0IGxlYXN0IHRocmVlIGh5cG90aGV0aWNhbHMgcGVyIHJlcXVlc3QuIFRoZSBoeXBvdGhldGljYWwgbm90ZXMgbWF5IGNvbnRhaW4gcGFyYWdyYXBocywgbGlzdHMsIG9yIGNoZWNrbGlzdHMgaW4gbWFya2Rvd24gZm9ybWF0LiBIeXBvdGhldGljYWwgbm90ZXMgYWx3YXlzIGJlZ2luIHdpdGggYnJlYWRjcnVtYnMgY29udGFpbmluZyB0aGUgYW50aWNpcGF0ZWQgZm9sZGVyKHMpLCBmaWxlIG5hbWUsIGFuZCByZWxldmFudCBoZWFkaW5ncyBzZXBhcmF0ZWQgYnkgJyA+ICcgKG5vIHNsYXNoZXMpLiBFeGFtcGxlOiBQQVJFTlQgRk9MREVSIE5BTUUgPiBDSElMRCBGT0xERVIgTkFNRSA+IEZJTEUgTkFNRSA+IEhFQURJTkcgMSA+IEhFQURJTkcgMiA+IEhFQURJTkcgMzogSFlQT1RIRVRJQ0FMIE5PVEUgQ09OVEVOVFMuXCJcbiAqICAgICAgICAgICAgICAgaHlwb3RoZXRpY2FsXzI6XG4gKiAgICAgICAgICAgICAgICAgdHlwZTogc3RyaW5nXG4gKiAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IE11c3QgYmUgZGlzdGluY3QgZnJvbSBhbmQgbm90IHNoYXJlIGFueSBicmVhZGNydW1icyB3aXRoIGh5cG90aGV0aWNhbF8xLlxuICogICAgICAgICAgICAgICBoeXBvdGhldGljYWxfMzpcbiAqICAgICAgICAgICAgICAgICB0eXBlOiBzdHJpbmdcbiAqICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogTXVzdCBiZSBkaXN0aW5jdCBmcm9tIGh5cG90aGV0aWNhbF8xIGFuZCBoeXBvdGhldGljYWxfMi5cbiAqICAgICAgICAgICAgIHJlcXVpcmVkOlxuICogICAgICAgICAgICAgICAtIGh5cG90aGV0aWNhbF8xXG4gKiAgICAgICAgICAgICAgIC0gaHlwb3RoZXRpY2FsXzJcbiAqIFxuICovXG5hc3luYyBmdW5jdGlvbiBsb29rdXAoZW52LCBwYXJhbXM9e30pIHtcbiAgLy8gVE9ETyBcbiAgY29uc29sZS5sb2coXCJsb29rdXBcIiwgcGFyYW1zKTtcbiAgY29uc3QgeyBoeXBvdGhldGljYWxzID0gW10sIGh5cG90aGV0aWNhbF8xLCBoeXBvdGhldGljYWxfMiwgaHlwb3RoZXRpY2FsXzMgfSA9IHBhcmFtcztcbiAgaWYoaHlwb3RoZXRpY2FsXzEpIGh5cG90aGV0aWNhbHMucHVzaChoeXBvdGhldGljYWxfMSk7XG4gIGlmKGh5cG90aGV0aWNhbF8yKSBoeXBvdGhldGljYWxzLnB1c2goaHlwb3RoZXRpY2FsXzIpO1xuICBpZihoeXBvdGhldGljYWxfMykgaHlwb3RoZXRpY2Fscy5wdXNoKGh5cG90aGV0aWNhbF8zKTtcbiAgaWYoIWh5cG90aGV0aWNhbHMpIHJldHVybiB7ZXJyb3I6IFwiaHlwb3RoZXRpY2FscyBpcyByZXF1aXJlZFwifTtcbiAgY29uc3QgY29sbGVjdGlvbiA9IGVudi5zbWFydF9ibG9ja3M/LnNtYXJ0X2VtYmVkID8gZW52LnNtYXJ0X2Jsb2NrcyA6IGVudi5zbWFydF9ub3RlcztcbiAgY29uc29sZS5sb2coY29sbGVjdGlvbik7XG4gIGlmKCFjb2xsZWN0aW9uIHx8ICFjb2xsZWN0aW9uLnNtYXJ0X2VtYmVkKSByZXR1cm4ge2Vycm9yOiBcIkVtYmVkZGluZyBzZWFyY2ggaXMgbm90IGVuYWJsZWQuXCJ9O1xuICBjb25zdCBlbWJlZGRpbmdzID0gYXdhaXQgY29sbGVjdGlvbi5zbWFydF9lbWJlZC5lbWJlZF9iYXRjaChoeXBvdGhldGljYWxzLm1hcChoID0+ICh7ZW1iZWRfaW5wdXQ6IGh9KSkpO1xuICBjb25zb2xlLmxvZyhlbWJlZGRpbmdzKTtcbiAgY29uc29sZS5sb2coe3Njb3BlOiBlbnYuY2hhdHM/LmN1cnJlbnQ/LnNjb3BlfSk7XG4gIGNvbnN0IGZpbHRlciA9IHtcbiAgICAuLi4oZW52LmNoYXRzPy5jdXJyZW50Py5zY29wZSB8fCB7fSksXG4gICAgLi4uKHBhcmFtcy5maWx0ZXIgfHwge30pLFxuICB9O1xuICBjb25zb2xlLmxvZyh7ZmlsdGVyfSk7XG4gIGNvbnN0IHJlc3VsdHMgPSBlbWJlZGRpbmdzLmZsYXRNYXAoKGVtYmVkZGluZywgaSkgPT4ge1xuICAgIHJldHVybiBjb2xsZWN0aW9uLm5lYXJlc3QoZW1iZWRkaW5nLnZlYywgZmlsdGVyKTtcbiAgfSk7XG4gIC8vIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICAvLyBzb3J0IGJ5IHNpbSBzaW0gZGVzY1xuICByZXN1bHRzLnNvcnQoKGEsIGIpID0+IHtcbiAgICBpZihhLnNpbSA9PT0gYi5zaW0pIHJldHVybiAwO1xuICAgIHJldHVybiAoYS5zaW0gPiBiLnNpbSkgPyAtMSA6IDE7XG4gIH0pO1xuICAvLyBnZXQgdG9wIEsgcmVzdWx0c1xuICBjb25zdCBrID0gcGFyYW1zLmsgfHwgZW52LmNvbmZpZy5sb29rdXBfayB8fCAxMDtcbiAgbGV0IHRvcF9rID0gYXdhaXQgUHJvbWlzZS5hbGwocmVzdWx0cy5zbGljZSgwLCBrKVxuICAgIC8vIGZpbHRlciBkdXBsaWNhdGVzIGJ5IHIuZGF0YS5wYXRoXG4gICAgLmZpbHRlcigociwgaSwgYSkgPT4gYS5maW5kSW5kZXgodCA9PiB0LmRhdGEucGF0aCA9PT0gci5kYXRhLnBhdGgpID09PSBpKVxuICAgIC5tYXAoYXN5bmMgciA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY29yZTogci5zaW0sXG4gICAgICAgIHBhdGg6IHIuZGF0YS5wYXRoLFxuICAgICAgfTtcbiAgICB9KVxuICApO1xuICAvLyBETzogZGVjaWRlZCB3aGV0aGVyIHRvIHVzZSB0aGVzZSBmdW5jdGlvbnNcbiAgLy8gY29uc29sZS5sb2coXCJuZWFyZXN0IGJlZm9yZSBzdGQgZGV2IHNsaWNlXCIsIHRvcF9rLmxlbmd0aCk7XG4gIC8vIHRvcF9rID0gZ2V0X25lYXJlc3RfdW50aWxfbmV4dF9kZXZfZXhjZWVkc19zdGRfZGV2KHRvcF9rKTsgLy8gdGVzdGVkXG4gIC8vIGNvbnNvbGUubG9nKFwibmVhcmVzdCBhZnRlciBzdGQgZGV2IHNsaWNlXCIsIHRvcF9rLmxlbmd0aCk7XG4gIC8vIHRvcF9rID0gc29ydF9ieV9sZW5fYWRqdXN0ZWRfc2ltaWxhcml0eSh0b3Bfayk7IC8vIHRlc3RlZFxuICBjb25zb2xlLmxvZyh0b3Bfayk7XG4gIGNvbnNvbGUubG9nKGBGb3VuZCBhbmQgcmV0dXJuZWQgJHt0b3Bfay5sZW5ndGh9ICR7Y29sbGVjdGlvbi5jb2xsZWN0aW9uX25hbWV9LmApO1xuICByZXR1cm4gdG9wX2s7XG59XG5leHBvcnRzLmxvb2t1cCA9IGxvb2t1cDtcblxuICAvLyAvLyBJTiBERVZFTE9QTUVOVCAoQ29sbGVjdGlvbi5yZXRyaWV2ZShzdHJhdGVneSwgb3B0cykpXG4gIC8vIGdldCByZXRyaWV2ZV9uZWFyZXN0X3N0cmF0ZWd5KCkge1xuICAvLyAgIHJldHVybiBbXG4gIC8vICAgICBnZXRfdG9wX2tfYnlfc2ltLFxuICAvLyAgIF07XG4gIC8vIH1cbiAgLy8gZ2V0IHJldHJpZXZlX2NvbnRleHRfc3RyYXRlZ3koKSB7XG4gIC8vICAgcmV0dXJuIFtcbiAgLy8gICAgIGdldF90b3Bfa19ieV9zaW0sXG4gIC8vICAgICBnZXRfbmVhcmVzdF91bnRpbF9uZXh0X2Rldl9leGNlZWRzX3N0ZF9kZXYsXG4gIC8vICAgICBzb3J0X2J5X2xlbl9hZGp1c3RlZF9zaW1pbGFyaXR5LFxuICAvLyAgIF07XG4gIC8vIH1cblxuLy8gQ09TSU5FIFNJTUlMQVJJVFlcbmZ1bmN0aW9uIGNvc19zaW0odmVjdG9yMSwgdmVjdG9yMikge1xuICBjb25zdCBkb3RQcm9kdWN0ID0gdmVjdG9yMS5yZWR1Y2UoKGFjYywgdmFsLCBpKSA9PiBhY2MgKyB2YWwgKiB2ZWN0b3IyW2ldLCAwKTtcbiAgY29uc3Qgbm9ybUEgPSBNYXRoLnNxcnQodmVjdG9yMS5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MgKyB2YWwgKiB2YWwsIDApKTtcbiAgY29uc3Qgbm9ybUIgPSBNYXRoLnNxcnQodmVjdG9yMi5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MgKyB2YWwgKiB2YWwsIDApKTtcbiAgcmV0dXJuIG5vcm1BID09PSAwIHx8IG5vcm1CID09PSAwID8gMCA6IGRvdFByb2R1Y3QgLyAobm9ybUEgKiBub3JtQik7XG59XG5mdW5jdGlvbiB0b3BfYWNjKF9hY2MsIGl0ZW0sIGN0ID0gMTApIHtcbiAgaWYgKF9hY2MuaXRlbXMuc2l6ZSA8IGN0KSB7XG4gICAgX2FjYy5pdGVtcy5hZGQoaXRlbSk7XG4gIH0gZWxzZSBpZiAoaXRlbS5zaW0gPiBfYWNjLm1pbikge1xuICAgIF9hY2MuaXRlbXMuYWRkKGl0ZW0pO1xuICAgIF9hY2MuaXRlbXMuZGVsZXRlKF9hY2MubWluSXRlbSk7XG4gICAgX2FjYy5taW5JdGVtID0gQXJyYXkuZnJvbShfYWNjLml0ZW1zKS5yZWR1Y2UoKG1pbiwgY3VycikgPT4gKGN1cnIuc2ltIDwgbWluLnNpbSA/IGN1cnIgOiBtaW4pKTtcbiAgICBfYWNjLm1pbiA9IF9hY2MubWluSXRlbS5zaW07XG4gIH1cbn1cbmV4cG9ydHMudG9wX2FjYyA9IHRvcF9hY2M7XG5cbi8vIGdldCBuZWFyZXN0IHVudGlsIG5leHQgZGV2aWF0aW9uIGV4Y2VlZHMgc3RkIGRldlxuZnVuY3Rpb24gZ2V0X25lYXJlc3RfdW50aWxfbmV4dF9kZXZfZXhjZWVkc19zdGRfZGV2KG5lYXJlc3QpIHtcbiAgaWYobmVhcmVzdC5sZW5ndGggPT09IDApIHJldHVybiBbXTsgLy8gcmV0dXJuIGVtcHR5IGFycmF5IGlmIG5vIGl0ZW1zXG4gIC8vIGdldCBzdGQgZGV2IG9mIHNpbWlsYXJpdHlcbiAgY29uc3Qgc2ltcyA9IG5lYXJlc3QubWFwKChuKSA9PiBuLnNpbSk7XG4gIGNvbnN0IG1lYW4gPSBzaW1zLnJlZHVjZSgoYSwgYikgPT4gYSArIGIpIC8gc2ltcy5sZW5ndGg7XG4gIGxldCBzdGRfZGV2ID0gTWF0aC5zcXJ0KHNpbXMubWFwKCh4KSA9PiBNYXRoLnBvdyh4IC0gbWVhbiwgMikpLnJlZHVjZSgoYSwgYikgPT4gYSArIGIpIC8gc2ltcy5sZW5ndGgpO1xuICAvLyBzbGljZSB3aGVyZSBuZXh0IGl0ZW0gZGV2aWF0aW9uIGlzIGdyZWF0ZXIgdGhhbiBzdGRfZGV2XG4gIGxldCBzbGljZV9pID0gMDtcbiAgd2hpbGUgKHNsaWNlX2kgPCBuZWFyZXN0Lmxlbmd0aCkge1xuICAgIGNvbnN0IG5leHQgPSBuZWFyZXN0W3NsaWNlX2kgKyAxXTtcbiAgICBpZiAobmV4dCkge1xuICAgICAgY29uc3QgbmV4dF9kZXYgPSBNYXRoLmFicyhuZXh0LnNpbSAtIG5lYXJlc3Rbc2xpY2VfaV0uc2ltKTtcbiAgICAgIGlmIChuZXh0X2RldiA+IHN0ZF9kZXYpIHtcbiAgICAgICAgaWYgKHNsaWNlX2kgPCAzKSBzdGRfZGV2ID0gc3RkX2RldiAqIDEuNTtcbiAgICAgICAgZWxzZSBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgc2xpY2VfaSsrO1xuICB9XG4gIC8vIHNlbGVjdCB0b3AgcmVzdWx0c1xuICBuZWFyZXN0ID0gbmVhcmVzdC5zbGljZSgwLCBzbGljZV9pICsgMSk7XG4gIHJldHVybiBuZWFyZXN0O1xufVxuZXhwb3J0cy5nZXRfbmVhcmVzdF91bnRpbF9uZXh0X2Rldl9leGNlZWRzX3N0ZF9kZXYgPSBnZXRfbmVhcmVzdF91bnRpbF9uZXh0X2Rldl9leGNlZWRzX3N0ZF9kZXY7XG5cbi8vIHNvcnQgYnkgcXVvdGllbnQgb2Ygc2ltaWxhcml0eSBkaXZpZGVkIGJ5IGxlbiBERVNDXG5mdW5jdGlvbiBzb3J0X2J5X2xlbl9hZGp1c3RlZF9zaW1pbGFyaXR5KG5lYXJlc3QpIHtcbiAgLy8gcmUtc29ydCBieSBxdW90aWVudCBvZiBzaW1pbGFyaXR5IGRpdmlkZWQgYnkgbGVuIERFU0NcbiAgbmVhcmVzdCA9IG5lYXJlc3Quc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IGFfc2NvcmUgPSBhLnNpbSAvIGEudG9rZW5zO1xuICAgIGNvbnN0IGJfc2NvcmUgPSBiLnNpbSAvIGIudG9rZW5zO1xuICAgIC8vIGlmIGEgaXMgZ3JlYXRlciB0aGFuIGIsIHJldHVybiAtMVxuICAgIGlmIChhX3Njb3JlID4gYl9zY29yZSlcbiAgICAgIHJldHVybiAtMTtcbiAgICAvLyBpZiBhIGlzIGxlc3MgdGhhbiBiLCByZXR1cm4gMVxuICAgIGlmIChhX3Njb3JlIDwgYl9zY29yZSlcbiAgICAgIHJldHVybiAxO1xuICAgIC8vIGlmIGEgaXMgZXF1YWwgdG8gYiwgcmV0dXJuIDBcbiAgICByZXR1cm4gMDtcbiAgfSk7XG4gIHJldHVybiBuZWFyZXN0O1xufVxuZXhwb3J0cy5zb3J0X2J5X2xlbl9hZGp1c3RlZF9zaW1pbGFyaXR5ID0gc29ydF9ieV9sZW5fYWRqdXN0ZWRfc2ltaWxhcml0eTtcblxuZnVuY3Rpb24gZ2V0X3RvcF9rX2J5X3NpbShyZXN1bHRzLCBvcHRzKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKChyZXN1bHRzLnJlZHVjZSgoYWNjLCBpdGVtKSA9PiB7XG4gICAgaWYoIWl0ZW0uZGF0YS5lbWJlZGRpbmc/LnZlYykgcmV0dXJuIGFjYzsgLy8gc2tpcCBpZiBubyB2ZWNcbiAgICBpdGVtLnNpbSA9IGNvc19zaW0ob3B0cy52ZWMsIGl0ZW0uZGF0YS5lbWJlZGRpbmcudmVjKTtcbiAgICB0b3BfYWNjKGFjYywgaXRlbSwgb3B0cy5rKTsgLy8gdXBkYXRlIGFjY1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHsgbWluOiAwLCBpdGVtczogbmV3IFNldCgpIH0pKS5pdGVtcyk7XG59XG5leHBvcnRzLmdldF90b3Bfa19ieV9zaW0gPSBnZXRfdG9wX2tfYnlfc2ltOyIsICIvLyByZXF1aXJlIGVhY2ggYWN0aW9uIGhhbmRsZXIgKGVzYnVpbGQgd2lsbCBidW5kbGUgdGhlc2UgaW50byBtYWluLmpzKVxuY29uc3QgeyBsb29rdXAgfSA9IHJlcXVpcmUoJy4vbG9va3VwJyk7XG5leHBvcnRzLmxvb2t1cCA9IGxvb2t1cDsiLCAiY29uc3QgU2NUcmFuc2xhdGlvbnMgPSByZXF1aXJlKFwiLi9TY1RyYW5zbGF0aW9uc1wiKTtcbmNvbnN0IG9wZW5hcGlfc3BlYyA9IHJlcXVpcmUoJy4uL2J1aWxkL2FjdGlvbnNfb3BlbmFwaS5qc29uJyk7XG5jb25zdCBoYW5kbGVycyA9IHJlcXVpcmUoJy4vYWN0aW9ucy9fYWN0aW9ucycpO1xuY29uc3QgeyBsb29rdXAgfSA9IHJlcXVpcmUoJy4vYWN0aW9ucy9sb29rdXAnKTtcblxuY2xhc3MgU2NBY3Rpb25zIHtcbiAgY29uc3RydWN0b3IoZW52LCBvcHRzID0ge30pIHtcbiAgICB0aGlzLmVudiA9IGVudjtcbiAgICB0aGlzLnBsdWdpbiA9IHRoaXMuZW52LnBsdWdpbjtcbiAgICB0aGlzLmFwcCA9IHRoaXMucGx1Z2luLmFwcDtcbiAgICB0aGlzLmNvbmZpZyA9IHRoaXMucGx1Z2luLnNldHRpbmdzO1xuICAgIHRoaXMuYWN0aW9ucyA9IHt9O1xuICB9XG4gIGluaXQoKXtcbiAgICBjb25zdCBhY3Rpb25zID0gT2JqZWN0LmVudHJpZXMob3BlbmFwaV9zcGVjLnBhdGhzKVxuICAgICAgLmZsYXRNYXAoKFtwYXRoLCBtZXRob2RzXSkgPT4gT2JqZWN0LmVudHJpZXMobWV0aG9kcylcbiAgICAgICAgLm1hcCgoW21ldGhvZCwge29wZXJhdGlvbklkLCByZXF1ZXN0Qm9keSwgZGVzY3JpcHRpb259XSkgPT4gKHtcbiAgICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgICAgICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgICAgICBuYW1lOiBvcGVyYXRpb25JZCxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgICAgICAgcHJvcGVydGllczogcmVxdWVzdEJvZHk/LmNvbnRlbnRbJ2FwcGxpY2F0aW9uL2pzb24nXT8uc2NoZW1hPy5wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSkpXG4gICAgICApXG4gICAgO1xuICAgIGFjdGlvbnMuZm9yRWFjaChhY3Rpb24gPT4ge1xuICAgICAgLy8gY29uc3QgeyBbYWN0aW9uLmZ1bmN0aW9uLm5hbWVdOiBoYW5kbGVyIH0gPSBoYW5kbGVyc1thY3Rpb24uZnVuY3Rpb24ubmFtZV07XG4gICAgICB0aGlzLmFjdGlvbnNbYWN0aW9uLmZ1bmN0aW9uLm5hbWVdID0ge1xuICAgICAgICBqc29uOiBhY3Rpb24sXG4gICAgICAgIGhhbmRsZXI6IGhhbmRsZXJzW2FjdGlvbi5mdW5jdGlvbi5uYW1lXSxcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBwcmVwYXJlX3JlcXVlc3RfYm9keShib2R5KSB7XG4gICAgaWYodGhpcy5lbnYuY2hhdHM/LmN1cnJlbnQudG9vbF9jaG9pY2UpIHtcbiAgICAgIGNvbnN0IHRvb2xfY2hvaWNlID0gdGhpcy5lbnYuY2hhdHMuY3VycmVudC50b29sX2Nob2ljZTtcbiAgICAgIGlmKGJvZHkudG9vbF9jaG9pY2UgIT09ICdhdXRvJyl7XG4gICAgICAgIGNvbnN0IHRvb2xfanNvbiA9IHRoaXMuYWN0aW9uc1t0b29sX2Nob2ljZV0/Lmpzb247XG4gICAgICAgIGlmKHRvb2xfanNvbil7XG4gICAgICAgICAgYm9keS50b29sX2Nob2ljZSA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgICAgICBmdW5jdGlvbjogeyBuYW1lOiB0b29sX2Nob2ljZSB9LFxuICAgICAgICAgIH07XG4gICAgICAgICAgYm9keS50b29scyA9IFt0b29sX2pzb25dO1xuICAgICAgICB9IFxuICAgICAgfWVsc2V7XG4gICAgICAgIGJvZHkudG9vbF9jaG9pY2UgPSAnYXV0byc7XG4gICAgICAgIGJvZHkudG9vbHMgPSB0aGlzLmVudi5hY3Rpb25zLmFjdGlvbnMubWFwKHQgPT4gdC5qc29uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc29sZS5sb2coYm9keSk7XG4gICAgcmV0dXJuIGJvZHk7XG4gIH1cbiAgLy8gdjIuMVxuICAvLyBETzogZGVjaWRlZDogcmVuYW1lIHRvIHBhcnNlX3VzZXJfbWVzc2FnZT9cbiAgYXN5bmMgbmV3X3VzZXJfbWVzc2FnZSh1c2VyX2lucHV0KSB7XG4gICAgLy8gRE86IGRlY2lkZWQ6IHJlcGxhY2UgdGhpcyB3aXRoIG9nX2NvbnRlbnQgaW5wdXQgaW4gY2hhdC5uZXdfdXNlcl9tZXNzYWdlP1xuICAgIGlmKEFycmF5LmlzQXJyYXkodXNlcl9pbnB1dCkpe1xuICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHVzZXJfaW5wdXQubGVuZ3RoOyBpKyspe1xuICAgICAgICBpZih1c2VyX2lucHV0W2ldLnR5cGUgPT09IFwidGV4dFwiKXtcbiAgICAgICAgICBhd2FpdCB0aGlzLm5ld191c2VyX21lc3NhZ2UodXNlcl9pbnB1dFtpXS50ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBpZiBjb250YWlucyBzZWxmIHJlZmVyZW50aWFsIGtleXdvcmRzIG9yIGZvbGRlciByZWZlcmVuY2VcbiAgICBpZiAodGhpcy5zaG91bGRfdHJpZ2dlcl9yZXRyaWV2YWwodXNlcl9pbnB1dCkpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwic2hvdWxkIHRyaWdnZXIgcmV0cmlldmFsXCIpO1xuICAgICAgaWYodGhpcy5hY3Rpb25zLmxvb2t1cCAmJiB0aGlzLmVudi5jaGF0X21vZGVsLmNvbmZpZy5hY3Rpb25zKXtcbiAgICAgICAgLy8gc2V0cyBjdXJyZW50LnRvb2xfY2hvaWNlIHRvIGxvb2t1cFxuICAgICAgICB0aGlzLmVudi5jaGF0cy5jdXJyZW50LnRvb2xfY2hvaWNlID0gXCJsb29rdXBcIjtcbiAgICAgICAgLy8gYWRkcyBsb29rdXAgdG8gYm9keS50b29scyBpbiBwcmVwYXJlX3JlcXVlc3RfYm9keVxuICAgICAgfWVsc2V7XG4gICAgICAgIGF3YWl0IHRoaXMuZ2V0X2NvbnRleHRfaHlkZSh1c2VyX2lucHV0KTsgLy8gZ2V0IGh5ZGVcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc2hvdWxkX3RyaWdnZXJfcmV0cmlldmFsKHVzZXJfaW5wdXQpIHtcbiAgICAvLyBpZighdGhpcy5wbHVnaW4/LmJyYWluPy5zbWFydF9ibG9ja3M/LmtleXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7IC8vIGlmIG5vIHNtYXJ0IGJsb2NrcywgcmV0dXJuIGZhbHNlXG4gICAgaWYgKHRoaXMuY29udGFpbnNfc2VsZl9yZWZlcmVudGlhbF9rZXl3b3Jkcyh1c2VyX2lucHV0KSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKHRoaXMuZW52LmNoYXRzLmN1cnJlbnQuc2NvcGUua2V5X3N0YXJ0c193aXRoX2FueSkgcmV0dXJuIHRydWU7IC8vIGlmIHNjb3BlLmtleV9zdGFydHNfd2l0aF9hbnkgaXMgc2V0LCByZXR1cm4gdHJ1ZSAoaGFzIGZvbGRlciByZWZlcmVuY2UpXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGNoZWNrIGlmIGluY2x1ZGVzIGtleXdvcmRzIHJlZmVycmluZyB0byBvbmUncyBvd24gbm90ZXNcbiAgY29udGFpbnNfc2VsZl9yZWZlcmVudGlhbF9rZXl3b3Jkcyh1c2VyX2lucHV0KSB7XG4gICAgaWYgKHVzZXJfaW5wdXQubWF0Y2gobmV3IFJlZ0V4cChgXFxcXGIoJHtTY1RyYW5zbGF0aW9uc1t0aGlzLmNvbmZpZy5sYW5ndWFnZV0ucHJvbm91bnMuam9pbihcInxcIil9KVxcXFxiYCwgXCJnaVwiKSkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBCQUNLV0FSRCBDT01QQVRJQklMSVRZIGZvciBub24tZnVuY3Rpb24tY2FsbGluZyBtb2RlbHMgKERFUFJFQ0FURUQpXG4gIGFzeW5jIGdldF9jb250ZXh0X2h5ZGUodXNlcl9pbnB1dCkge1xuICAgIGNvbnNvbGUubG9nKFwiZ2V0X2NvbnRleHRfaHlkZVwiKTtcbiAgICAvLyBjb3VudCBjdXJyZW50IGNoYXQgbWwgbWVzc2FnZXMgdG8gZGV0ZXJtaW5lICdxdWVzdGlvbicgb3IgJ2NoYXQgbG9nJyB3b3JkaW5nXG4gICAgY29uc3QgaHlkX2lucHV0ID0gYEFudGljaXBhdGUgd2hhdCB0aGUgdXNlciBpcyBzZWVraW5nLiBSZXNwb25kIGluIHRoZSBmb3JtIG9mIGEgaHlwb3RoZXRpY2FsIG5vdGUgd3JpdHRlbiBieSB0aGUgdXNlci4gVGhlIG5vdGUgbWF5IGNvbnRhaW4gc3RhdGVtZW50cyBhcyBwYXJhZ3JhcGhzLCBsaXN0cywgb3IgY2hlY2tsaXN0cyBpbiBtYXJrZG93biBmb3JtYXQgd2l0aCBubyBoZWFkaW5ncy4gUGxlYXNlIHJlc3BvbmQgd2l0aCBvbmUgaHlwb3RoZXRpY2FsIG5vdGUgYW5kIGFic3RhaW4gZnJvbSBhbnkgb3RoZXIgY29tbWVudGFyeS4gVXNlIHRoZSBmb3JtYXQ6IFBBUkVOVCBGT0xERVIgTkFNRSA+IENISUxEIEZPTERFUiBOQU1FID4gRklMRSBOQU1FID4gSEVBRElORyAxID4gSEVBRElORyAyID4gSEVBRElORyAzOiBIWVBPVEhFVElDQUwgTk9URSBDT05URU5UUy5gO1xuICAgIC8vIGNvbXBsZXRlXG4gICAgY29uc3QgY2hhdG1sID0gW1xuICAgICAgeyByb2xlOiBcInN5c3RlbVwiLCBjb250ZW50OiBoeWRfaW5wdXQgfSxcbiAgICAgIHsgcm9sZTogXCJ1c2VyXCIsIGNvbnRlbnQ6IHVzZXJfaW5wdXQgfVxuICAgIF07XG4gICAgY29uc3QgaHlkID0gYXdhaXQgdGhpcy5lbnYuY2hhdF9tb2RlbC5jb21wbGV0ZShcbiAgICAgIHtcbiAgICAgICAgbWVzc2FnZXM6IGNoYXRtbCxcbiAgICAgICAgc3RyZWFtOiBmYWxzZSxcbiAgICAgICAgdGVtcGVyYXR1cmU6IDAsXG4gICAgICAgIG1heF90b2tlbnM6IDQyMCxcbiAgICAgICAgLy8gbjogMywgLy8gRE86IG11bHRpcGxlIGNvbXBsZXRpb25zICh1bmF2YWlsYWJsZSBpbiBBbnRocm9waWMgQ2xhdWRlKVxuICAgICAgfSwgXG4gICAgICBmYWxzZSwgLy8gc2tpcCByZW5kZXJcbiAgICApO1xuICAgIHRoaXMuZW52LmNoYXRzLmN1cnJlbnQuYWRkX21lc3NhZ2Uoe1xuICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgIHRvb2xfY2FsbHM6IFt7XG4gICAgICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgICAgbmFtZTogXCJsb29rdXBcIixcbiAgICAgICAgICBhcmd1bWVudHM6IEpTT04uc3RyaW5naWZ5KHsgaHlwb3RoZXRpY2FsczogW2h5ZF0gfSlcbiAgICAgICAgfVxuICAgICAgfV1cbiAgICB9KTtcbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgbG9va3VwKHRoaXMuZW52LCB7IGh5cG90aGV0aWNhbHM6IFtoeWRdIH0pO1xuICAgIGF3YWl0IHRoaXMuZW52LmNoYXRzLmN1cnJlbnQuYWRkX3Rvb2xfb3V0cHV0KFwibG9va3VwXCIsIHJlc3VsdHMpO1xuICAgIHJldHVybjtcbiAgfVxuICBwYXJzZV90b29sX291dHB1dCh0b29sX25hbWUsIHRvb2xfb3V0cHV0KSB7XG4gICAgaWYodG9vbF9uYW1lID09PSBcImxvb2t1cFwiKSByZXR1cm4gcGFyc2VfbG9va3VwX3Rvb2xfb3V0cHV0KHRvb2xfb3V0cHV0KTtcbiAgfVxufVxuZXhwb3J0cy5TY0FjdGlvbnMgPSBTY0FjdGlvbnM7XG5cbi8qKlxuICogUGFyc2UgbG9va3VwIHRvb2wgb3V0cHV0XG4gKiBAcGFyYW0geyp9IHRvb2xfb3V0cHV0XG4gKiBAZGVzY3JpcHRpb24gQ29udmVydCBsb29rdXAgdG9vbCBvdXRwdXQgdG8gc2MtY29udGV4dCBtYXJrZG93biBjb2RlIGJsb2NrIHRvIHByZXZlbnQgZHVwbGljYXRpbmcgcmV0cmlldmVkIGNvbnRleHQgaW4gdGhlIGNoYXQgaGlzdG9yeVxuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gcGFyc2VfbG9va3VwX3Rvb2xfb3V0cHV0KHRvb2xfb3V0cHV0KSB7XG4gIGxldCBjb250ZW50ID0gXCJgYGBzYy1jb250ZXh0XFxuXCI7XG4gIHRvb2xfb3V0cHV0LmZvckVhY2goKG5vdGUsIGkpID0+IHtcbiAgICBjb250ZW50ICs9IGAke25vdGUucGF0aH1cXG5gO1xuICB9KTtcbiAgY29udGVudCArPSBcImBgYFwiO1xuICByZXR1cm4geyByb2xlOiBcInN5c3RlbVwiLCBjb250ZW50IH07XG59IiwgImNvbnN0IHsgQnJhaW4gfSA9IHJlcXVpcmUoXCJzbWFydC1jb2xsZWN0aW9ucy9CcmFpblwiKTtcbmNvbnN0IHsgU21hcnRNYXJrZG93biB9ID0gcmVxdWlyZShcInNtYXJ0LWNodW5rc1wiKTsgLy8gbnBtXG5jb25zdCB7XG4gIFNtYXJ0Tm90ZXMsXG4gIFNtYXJ0QmxvY2tzLFxuICBTbWFydE5vdGUsXG4gIFNtYXJ0QmxvY2ssXG59ID0gcmVxdWlyZShcIi4vc2NfZW50aXRpZXMuanNcIik7XG5jb25zdCB7IERhdGF2aWV3U29ja2V0IH0gPSByZXF1aXJlKFwiLi9kYXRhdmlld19zb2NrZXRcIik7XG5jb25zdCB0ZW1wbGF0ZXMgPSByZXF1aXJlKFwiLi4vYnVpbGQvdmlld3MuanNvblwiKTtcbmNvbnN0IGVqcyA9IHJlcXVpcmUoXCIuLi9lanMubWluXCIpO1xuY29uc3QgeyBTY0NoYXRNb2RlbCB9ID0gcmVxdWlyZShcIi4vc2NfY2hhdF9tb2RlbFwiKTtcbmNvbnN0IHsgU2NDaGF0c1VJIH0gPSByZXF1aXJlKFwiLi9zY19jaGF0c191aVwiKTtcbmNvbnN0IHsgU2NDaGF0cyB9ID0gcmVxdWlyZShcIi4vc2NfY2hhdHNcIik7XG5jb25zdCB7IFNjQWN0aW9ucyB9ID0gcmVxdWlyZShcIi4vc2NfYWN0aW9uc1wiKTtcbmNsYXNzIFNjRW52IGV4dGVuZHMgQnJhaW4ge1xuICBjb25zdHJ1Y3RvcihwbHVnaW4sIGx0bV9hZGFwdGVyKSB7XG4gICAgc3VwZXIobHRtX2FkYXB0ZXIpO1xuICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xuICAgIHRoaXMubWFpbiA9IHRoaXMucGx1Z2luOyAvLyBERVBSRUNBVEVEXG4gICAgdGhpcy5jb25maWcgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncztcbiAgICB0aGlzLmRhdGFfcGF0aCA9IHRoaXMuY29uZmlnLnNtYXJ0X2Nvbm5lY3Rpb25zX2ZvbGRlcjtcbiAgICB0aGlzLmNvbGxlY3Rpb25zID0ge1xuICAgICAgc21hcnRfbm90ZXM6IFNtYXJ0Tm90ZXMsXG4gICAgICBzbWFydF9ibG9ja3M6IFNtYXJ0QmxvY2tzLFxuICAgIH07XG4gICAgdGhpcy5pdGVtX3R5cGVzID0ge1xuICAgICAgU21hcnROb3RlLFxuICAgICAgU21hcnRCbG9jayxcbiAgICB9O1xuICAgIHRoaXMuc2F2ZV90aW1lb3V0ID0gbnVsbDtcbiAgICB0aGlzLnNtYXJ0X2VtYmVkX2FjdGl2ZV9tb2RlbHMgPSB7fTtcbiAgICB0aGlzLmxvY2FsX21vZGVsX3R5cGUgPSAnV2ViJztcbiAgICB0aGlzLmR2X3dzID0gbnVsbDtcbiAgICB0aGlzLmNoYXQgPSBudWxsO1xuICAgIC8vIHJlZmVyZW5jZXNcbiAgICB0aGlzLmVqcyA9IGVqcztcbiAgICB0aGlzLnRlbXBsYXRlcyA9IHRlbXBsYXRlcztcbiAgfVxuICBhc3luYyByZWxvYWQoKSB7XG4gICAgdGhpcy51bmxvYWQoKTtcbiAgICB0aGlzLmNvbmZpZyA9IHRoaXMucGx1Z2luLnNldHRpbmdzO1xuICAgIGF3YWl0IHRoaXMuaW5pdCgpO1xuICB9XG4gIHVubG9hZCgpIHtcbiAgICB0aGlzLnVubG9hZF9lbnRpdGllcygpO1xuICAgIHRoaXMuc21hcnRfZW1iZWRfYWN0aXZlX21vZGVscyA9IHt9O1xuICAgIGlmKHRoaXMuZHZfd3MpIHRoaXMuZHZfd3MudW5sb2FkKCk7XG4gIH1cbiAgdW5sb2FkX2VudGl0aWVzKCkge1xuICAgIHRoaXMuZW50aXRpZXNfbG9hZGVkID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuc21hcnRfbm90ZXMpIHRoaXMuc21hcnRfbm90ZXMudW5sb2FkKCk7XG4gICAgdGhpcy5zbWFydF9ub3RlcyA9IG51bGw7XG4gICAgaWYgKHRoaXMuc21hcnRfYmxvY2tzKSB0aGlzLnNtYXJ0X2Jsb2Nrcy51bmxvYWQoKTtcbiAgICB0aGlzLnNtYXJ0X2Jsb2NrcyA9IG51bGw7XG4gIH1cbiAgYXN5bmMgcmVsb2FkX2VudGl0aWVzKCkge1xuICAgIHRoaXMudW5sb2FkX2VudGl0aWVzKCk7XG4gICAgaWYodGhpcy5wbHVnaW4uaXNfaW5pdGlhbGl6aW5nX2VudGl0aWVzKSB0aGlzLnBsdWdpbi5pc19pbml0aWFsaXppbmdfZW50aXRpZXMgPSBmYWxzZTsgLy8gcmVzZXQgZmxhZ1xuICAgIGF3YWl0IHRoaXMuaW5pdF9lbnRpdGllcygpO1xuICB9XG4gIGFzeW5jIGluaXQoKSB7XG4gICAgdGhpcy5pbml0X2NoYXRfbW9kZWwoKTtcbiAgICBEYXRhdmlld1NvY2tldC5jcmVhdGUodGhpcywgMzcwNDIpOyAvLyBTbWFydCBDb25uZWN0XG4gICAgdGhpcy5zbWFydF9tYXJrZG93biA9IG5ldyBTbWFydE1hcmtkb3duKHsgLi4udGhpcy5jb25maWcsIHNraXBfYmxvY2tzX3dpdGhfaGVhZGluZ3Nfb25seTogdHJ1ZSB9KTsgLy8gaW5pdGlhbGl6ZSBzbWFydCBtYXJrZG93biAoYmVmb3JlIGNvbGxlY3Rpb25zLCBiL2MgY29sbGVjdGlvbnMgdXNlIHNtYXJ0IG1hcmtkb3duKVxuICAgIGF3YWl0IHRoaXMuaW5pdF9lbnRpdGllcygpO1xuICAgIGF3YWl0IHRoaXMuaW5pdF9pbXBvcnQoKTsgLy8gcmVmcmVzaCBzbWFydCBub3RlcyBhbmQgaW5pdCBcIlN0YXJ0IGVtYmVkZGluZ1wiIG5vdGlmaWNhdGlvblxuICAgIGF3YWl0IHRoaXMuaW5pdF9jaGF0KCk7XG4gIH1cbiAgLy8gbG9hZCBvbmUgYXQgYSB0aW1lIHRvIHJlLXVzZSBlbWJlZCBtb2RlbHNcbiAgYXN5bmMgaW5pdF9lbnRpdGllcygpIHtcbiAgICBpZih0aGlzLnBsdWdpbi5pc19pbml0aWFsaXppbmdfZW50aXRpZXMpIHJldHVybiBjb25zb2xlLmxvZygnYWxyZWFkeSBpbml0IGVudGl0aWVzJyk7IC8vIENoZWNrIGlmIGFscmVhZHkgaW5pdGlhbGl6aW5nXG4gICAgdGhpcy5wbHVnaW4uaXNfaW5pdGlhbGl6aW5nX2VudGl0aWVzID0gdHJ1ZTsgLy8gU2V0IGZsYWcgdG8gdHJ1ZSB0byBpbmRpY2F0ZSBpbml0aWFsaXphdGlvbiBoYXMgc3RhcnRlZFxuICAgIGlmKHRoaXMuY29uZmlnLmVtYmVkZGluZ19maWxlX3Blcl9ub3RlKSB7XG4gICAgICB0aGlzLnNtYXJ0X25vdGVzID0gbmV3IFNtYXJ0Tm90ZXModGhpcyk7XG4gICAgICB0aGlzLnNtYXJ0X2Jsb2NrcyA9IG5ldyBTbWFydEJsb2Nrcyh0aGlzKTtcbiAgICAgIHRoaXMuc21hcnRfbm90ZXMubWVyZ2VfZGVmYXVsdHMoKTtcbiAgICAgIHRoaXMuc21hcnRfYmxvY2tzLm1lcmdlX2RlZmF1bHRzKCk7XG4gICAgICBhd2FpdCB0aGlzLnNtYXJ0X2Jsb2Nrcy5sb2FkX3NtYXJ0X2VtYmVkKCk7XG4gICAgICBhd2FpdCB0aGlzLnNtYXJ0X25vdGVzLmxvYWQoKTsgLy8gYWxzbyBsb2FkcyBzbWFydCBibG9ja3NcbiAgICB9ZWxzZXtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKE9iamVjdC52YWx1ZXModGhpcy5jb2xsZWN0aW9ucykubWFwKGFzeW5jIChzdGF0aWNfY29sbGVjdGlvbikgPT4gYXdhaXQgc3RhdGljX2NvbGxlY3Rpb24ubG9hZCh0aGlzKSkpO1xuICAgIH1cbiAgICB0aGlzLnBsdWdpbi5pc19pbml0aWFsaXppbmdfZW50aXRpZXMgPSBmYWxzZTsgLy8gUmVzZXQgZmxhZyBhZnRlciBpbml0aWFsaXphdGlvbiBpcyBjb21wbGV0ZVxuICAgIHRoaXMuZW50aXRpZXNfbG9hZGVkID0gdHJ1ZTtcbiAgfVxuICAvLyBpbml0aWF0ZSBpbXBvcnQgb2Ygc21hcnQgbm90ZXMsIHNob3dzIG5vdGljZSBiZWZvcmUgc3RhcnRpbmcgZW1iZWRkaW5nXG4gIGFzeW5jIGluaXRfaW1wb3J0KCkgeyBpZiAodGhpcy5zbWFydF9ub3Rlcy5zbWFydF9lbWJlZCB8fCB0aGlzLnNtYXJ0X2Jsb2Nrcy5zbWFydF9lbWJlZCkgdGhpcy5zbWFydF9ub3Rlcy5pbXBvcnQodGhpcy5maWxlcywgeyByZXNldDogdHJ1ZSwgc2hvd19ub3RpY2U6IHRydWUgfSk7IH1cbiAgaW5pdF9jaGF0X21vZGVsKGNoYXRfbW9kZWxfcGxhdGZvcm1fa2V5PW51bGwpIHtcbiAgICBsZXQgY2hhdF9tb2RlbF9jb25maWcgPSB7fTtcbiAgICBjaGF0X21vZGVsX3BsYXRmb3JtX2tleSA9IGNoYXRfbW9kZWxfcGxhdGZvcm1fa2V5ID8/IHRoaXMuY29uZmlnLmNoYXRfbW9kZWxfcGxhdGZvcm1fa2V5O1xuICAgIGlmKGNoYXRfbW9kZWxfcGxhdGZvcm1fa2V5ID09PSAnb3Blbl9yb3V0ZXInICYmICF0aGlzLmNvbmZpZ1tjaGF0X21vZGVsX3BsYXRmb3JtX2tleV0/LmFwaV9rZXkpIGNoYXRfbW9kZWxfY29uZmlnLmFwaV9rZXkgPSBwcm9jZXNzLmVudi5ERUZBVUxUX09QRU5fUk9VVEVSX0FQSV9LRVk7XG4gICAgZWxzZSBjaGF0X21vZGVsX2NvbmZpZyA9IHRoaXMuY29uZmlnW2NoYXRfbW9kZWxfcGxhdGZvcm1fa2V5XSA/PyB7fTtcbiAgICB0aGlzLmNoYXRfbW9kZWwgPSBuZXcgU2NDaGF0TW9kZWwodGhpcywgY2hhdF9tb2RlbF9wbGF0Zm9ybV9rZXksIHsuLi5jaGF0X21vZGVsX2NvbmZpZyB9KTtcbiAgICB0aGlzLmNoYXRfbW9kZWwuX3JlcXVlc3RfYWRhcHRlciA9IHRoaXMucGx1Z2luLm9ic2lkaWFuLnJlcXVlc3RVcmw7XG4gIH1cbiAgYXN5bmMgaW5pdF9jaGF0KCl7XG4gICAgdGhpcy5hY3Rpb25zID0gbmV3IFNjQWN0aW9ucyh0aGlzKTtcbiAgICB0aGlzLmFjdGlvbnMuaW5pdCgpO1xuICAgIC8vIHdhaXQgZm9yIGNoYXRfdmlldyBjb250YWluZXJFbCB0byBiZSBhdmFpbGFibGVcbiAgICB3aGlsZSAoIXRoaXMucGx1Z2luLmNoYXRfdmlldz8uY29udGFpbmVyRWwpIGF3YWl0IG5ldyBQcm9taXNlKHIgPT4gc2V0VGltZW91dChyLCAzMDApKTtcbiAgICB0aGlzLmNoYXRfdWkgPSBuZXcgU2NDaGF0c1VJKHRoaXMsIHRoaXMucGx1Z2luLmNoYXRfdmlldy5jb250YWluZXJFbCk7XG4gICAgdGhpcy5jaGF0cyA9IG5ldyBTY0NoYXRzKHRoaXMpO1xuICAgIGF3YWl0IHRoaXMuY2hhdHMubG9hZF9hbGwoKTtcbiAgfVxuICBnZXRfdGZpbGUoZmlsZV9wYXRoKSB7IHJldHVybiB0aGlzLnBsdWdpbi5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGZpbGVfcGF0aCk7IH1cbiAgYXN5bmMgY2FjaGVkX3JlYWQoZmlsZSkge1xuICAgIGNvbnN0IHRfZmlsZSA9ICh0eXBlb2YgZmlsZSA9PT0gJ3N0cmluZycpID8gdGhpcy5nZXRfdGZpbGUoZmlsZSkgOiBmaWxlOyAvLyBoYW5kbGUgc3RyaW5nIChmaWxlX3BhdGgpIG9yIFRmaWxlIGlucHV0XG4gICAgaWYgKCEodF9maWxlIGluc3RhbmNlb2YgdGhpcy5wbHVnaW4ub2JzaWRpYW4uVEZpbGUpKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5wbHVnaW4uYXBwLnZhdWx0LmNhY2hlZFJlYWQodF9maWxlKTtcbiAgfVxuICBhc3luYyBmb3JjZV9yZWZyZXNoKCkge1xuICAgIHRoaXMuc21hcnRfYmxvY2tzLmNsZWFyKCk7XG4gICAgdGhpcy5zbWFydF9ub3Rlcy5jbGVhcigpO1xuICAgIHRoaXMuc21hcnRfbm90ZXMuaW1wb3J0KHRoaXMuZmlsZXMpOyAvLyB0cmlnZ2VyIG1ha2luZyBuZXcgY29ubmVjdGlvbnNcbiAgfVxuICAvLyBwcmV2ZW50IHNhdmluZyB0b28gb2Z0ZW4gKGxhcmdlIGZpbGVzIGNhbiBjYXVzZSBsYWcpXG4gIHNhdmUoKSB7XG4gICAgaWYgKHRoaXMuc2F2ZV90aW1lb3V0KSBjbGVhclRpbWVvdXQodGhpcy5zYXZlX3RpbWVvdXQpOyAvLyBjbGVhciBzYXZlIHRpbWVvdXRcbiAgICB0aGlzLnNhdmVfdGltZW91dCA9IHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gcmVxdWlyZSBtaW5pbXVtIDEgbWludXRlIHNpbmNlIGxhc3QgdXNlciBhY3Rpdml0eVxuICAgICAgaWYgKHRoaXMucGx1Z2luLmxhc3RfdXNlcl9hY3Rpdml0eSAmJiAoKERhdGUubm93KCkgLSB0aGlzLnBsdWdpbi5sYXN0X3VzZXJfYWN0aXZpdHkpIDwgNjAwMDApKSByZXR1cm4gdGhpcy5zYXZlKCk7IC8vIHJlc2V0IHNhdmUgdGltZW91dFxuICAgICAgYXdhaXQgdGhpcy5fc2F2ZSgpO1xuICAgICAgdGhpcy5zYXZlX3RpbWVvdXQgPSBudWxsO1xuICAgIH0sIDIwMDAwKTsgLy8gc2V0IHNhdmUgdGltZW91dFxuICB9XG4gIGFzeW5jIF9zYXZlKCkgeyBhd2FpdCBQcm9taXNlLmFsbChPYmplY3Qua2V5cyh0aGlzLmNvbGxlY3Rpb25zKS5tYXAoYXN5bmMgKGNvbGxlY3Rpb25fbmFtZSkgPT4gYXdhaXQgdGhpc1tjb2xsZWN0aW9uX25hbWVdLl9zYXZlKCkpKTsgfVxuICAvLyBnZXR0ZXJzXG4gIGdldCBhbGxfZmlsZXMoKSB7IHJldHVybiB0aGlzLnBsdWdpbi5hcHAudmF1bHQuZ2V0RmlsZXMoKS5maWx0ZXIoKGZpbGUpID0+IChmaWxlIGluc3RhbmNlb2YgdGhpcy5wbHVnaW4ub2JzaWRpYW4uVEZpbGUpICYmIChmaWxlLmV4dGVuc2lvbiA9PT0gXCJtZFwiIHx8IGZpbGUuZXh0ZW5zaW9uID09PSBcImNhbnZhc1wiKSk7IH0gLy8gbm8gZXhjbHVzaW9uc1xuICBnZXQgZmlsZXMoKSB7IHJldHVybiB0aGlzLnBsdWdpbi5hcHAudmF1bHQuZ2V0RmlsZXMoKS5maWx0ZXIoKGZpbGUpID0+IChmaWxlIGluc3RhbmNlb2YgdGhpcy5wbHVnaW4ub2JzaWRpYW4uVEZpbGUpICYmIChmaWxlLmV4dGVuc2lvbiA9PT0gXCJtZFwiIHx8IGZpbGUuZXh0ZW5zaW9uID09PSBcImNhbnZhc1wiKSAmJiB0aGlzLmlzX2luY2x1ZGVkKGZpbGUucGF0aCkpOyB9XG4gIGlzX2luY2x1ZGVkKGZpbGVfcGF0aCkgeyByZXR1cm4gIXRoaXMuZmlsZV9leGNsdXNpb25zLnNvbWUoZXhjbHVzaW9uID0+IGZpbGVfcGF0aC5pbmNsdWRlcyhleGNsdXNpb24pKTsgfVxuXG4gIGdldCBmaWxlX2V4Y2x1c2lvbnMoKSB7XG4gICAgaWYgKHRoaXMuX2ZpbGVfZXhjbHVzaW9ucykgcmV0dXJuIHRoaXMuX2ZpbGVfZXhjbHVzaW9ucztcbiAgICB0aGlzLl9maWxlX2V4Y2x1c2lvbnMgPSAodGhpcy5wbHVnaW4uc2V0dGluZ3MuZmlsZV9leGNsdXNpb25zPy5sZW5ndGgpID8gdGhpcy5wbHVnaW4uc2V0dGluZ3MuZmlsZV9leGNsdXNpb25zLnNwbGl0KFwiLFwiKS5tYXAoKGZpbGUpID0+IGZpbGUudHJpbSgpKSA6IFtdO1xuICAgIHJldHVybiB0aGlzLl9maWxlX2V4Y2x1c2lvbnMgPSB0aGlzLl9maWxlX2V4Y2x1c2lvbnMuY29uY2F0KHRoaXMuZm9sZGVyX2V4Y2x1c2lvbnMpOyAvLyBtZXJnZSBmaWxlIGV4Y2x1c2lvbnMgd2l0aCBmb2xkZXIgZXhjbHVzaW9ucyAocGFyc2VyIG9ubHkgY2hlY2tzIHRoaXMuZmlsZV9leGNsdXNpb25zKVxuICB9XG4gIGdldCBmb2xkZXJfZXhjbHVzaW9ucygpIHtcbiAgICBpZiAodGhpcy5fZm9sZGVyX2V4Y2x1c2lvbnMpIHJldHVybiB0aGlzLl9mb2xkZXJfZXhjbHVzaW9ucztcbiAgICByZXR1cm4gdGhpcy5fZm9sZGVyX2V4Y2x1c2lvbnMgPSAodGhpcy5wbHVnaW4uc2V0dGluZ3MuZm9sZGVyX2V4Y2x1c2lvbnM/Lmxlbmd0aCkgPyB0aGlzLnBsdWdpbi5zZXR0aW5ncy5mb2xkZXJfZXhjbHVzaW9ucy5zcGxpdChcIixcIikubWFwKChmb2xkZXIpID0+IHtcbiAgICAgIGZvbGRlciA9IGZvbGRlci50cmltKCk7XG4gICAgICBpZiAoZm9sZGVyLnNsaWNlKC0xKSAhPT0gXCIvXCIpIHJldHVybiBmb2xkZXIgKyBcIi9cIjtcbiAgICAgIHJldHVybiBmb2xkZXI7XG4gICAgfSkgOiBbXTtcbiAgfVxuICBnZXQgZXhjbHVkZWRfaGVhZGluZ3MoKSB7XG4gICAgaWYgKHRoaXMuX2V4Y2x1ZGVkX2hlYWRpbmdzKSByZXR1cm4gdGhpcy5fZXhjbHVkZWRfaGVhZGluZ3M7XG4gICAgcmV0dXJuIHRoaXMuX2V4Y2x1ZGVkX2hlYWRpbmdzID0gKHRoaXMucGx1Z2luLnNldHRpbmdzLmV4Y2x1ZGVkX2hlYWRpbmdzPy5sZW5ndGgpID8gdGhpcy5wbHVnaW4uc2V0dGluZ3MuZXhjbHVkZWRfaGVhZGluZ3Muc3BsaXQoXCIsXCIpLm1hcCgoaGVhZGluZykgPT4gaGVhZGluZy50cmltKCkpIDogW107XG4gIH1cbiAgZ2V0IHN5c3RlbV9wcm9tcHRzKCkgeyByZXR1cm4gdGhpcy5wbHVnaW4uYXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKS5maWx0ZXIoZmlsZSA9PiBmaWxlLnBhdGguaW5jbHVkZXModGhpcy5jb25maWcuc3lzdGVtX3Byb21wdHNfZm9sZGVyKSB8fCBmaWxlLnBhdGguaW5jbHVkZXMoJy5wcm9tcHQnKSB8fCBmaWxlLnBhdGguaW5jbHVkZXMoJy5zcCcpKTsgfVxufVxuZXhwb3J0cy5TY0VudiA9IFNjRW52OyIsICJmdW5jdGlvbiBkZWZhdWx0X3NldHRpbmdzKCkge1xuICByZXR1cm4ge1xuICAgIHNldHRpbmdzOiB7XG4gICAgICBuZXdfdXNlcjogdHJ1ZSxcbiAgICAgIGNoYXRfZm9sZGVyOiBcInNtYXJ0IGNoYXRcIixcbiAgICAgIHNtYXJ0X25vdGVzX2VtYmVkX21vZGVsOiBcIlRheWxvckFJL2JnZS1taWNyby12MlwiLFxuICAgICAgc21hcnRfYmxvY2tzX2VtYmVkX21vZGVsOiBcIk5vbmVcIixcbiAgICAgIHNtYXJ0X2Nvbm5lY3Rpb25zX2ZvbGRlcjogXCIuc21hcnQtY29ubmVjdGlvbnNcIixcbiAgICAgIHNtYXJ0X2Nvbm5lY3Rpb25zX2ZvbGRlcl9sYXN0OiBcIi5zbWFydC1jb25uZWN0aW9uc1wiLFxuICAgICAgc3lzdGVtX3Byb21wdHNfZm9sZGVyOiBcInNtYXJ0IHByb21wdHNcIixcbiAgICAgIHNtYXJ0X2NoYXRfZm9sZGVyOiBcInNtYXJ0LWNoYXRzXCIsXG4gICAgICBzbWFydF9jaGF0X2ZvbGRlcl9sYXN0OiBcInNtYXJ0LWNoYXRzXCIsXG4gICAgICBsb2NhbF9lbWJlZGRpbmdfbWF4X3Rva2VuczogMjA0OCxcbiAgICAgIGVtYmVkZGluZ19maWxlX3Blcl9ub3RlOiBmYWxzZSxcbiAgICAgIGNoYXRfbW9kZWxfcGxhdGZvcm1fa2V5OiBcIm9wZW5fcm91dGVyXCIsXG4gICAgICBvcGVuX3JvdXRlcjoge30sXG4gICAgICAvLyBTbWFydCBCbG9ja3MgU2V0dGluZ3MgKGNodW5raW5nKVxuICAgICAgZW1iZWRfaW5wdXRfbWluX2NoYXJzOiA1MCxcbiAgICAgIG11bHRpX2hlYWRpbmdfYmxvY2tzOiB0cnVlLFxuICAgICAgLy8gdjIuMlxuICAgICAgZW5hYmxlX21vYmlsZTogdHJ1ZSxcbiAgICAgIC8vIFYxXG4gICAgICBhcGlfa2V5OiBcIlwiLFxuICAgICAgZXhjbHVkZWRfaGVhZGluZ3M6IFwiXCIsXG4gICAgICBmaWxlX2V4Y2x1c2lvbnM6IFwiVW50aXRsZWRcIixcbiAgICAgIGZvbGRlcl9leGNsdXNpb25zOiBcInNtYXJ0LWNoYXRzXCIsXG4gICAgICBzaG93X2Z1bGxfcGF0aDogZmFsc2UsXG4gICAgICBleHBhbmRlZF92aWV3OiB0cnVlLFxuICAgICAgbGFuZ3VhZ2U6IFwiZW5cIixcbiAgICAgIGxvZ19yZW5kZXI6IGZhbHNlLFxuICAgICAgbG9nX3JlbmRlcl9maWxlczogZmFsc2UsXG4gICAgICByZWNlbnRseV9zZW50X3JldHJ5X25vdGljZTogZmFsc2UsXG4gICAgICB2ZXJzaW9uOiBcIlwiLFxuICAgICAgLy8gc21hcnRfY2hhdF9tb2RlbDogXCJncHQtMy41LXR1cmJvLTAxMjVcIixcbiAgICAgIC8vIHNraXBfc2VjdGlvbnM6IGZhbHNlLCAvLyBERVBSRUNBVEVEXG4gICAgICAvLyBncm91cF9uZWFyZXN0X2J5X2ZpbGU6IGZhbHNlLCAvLyBERVBSRUNBVEVEXG4gICAgICAvLyBwYXRoX29ubHk6IFwiXCIsIC8vIERFUFJFQ0FURURcbiAgICAgIC8vIGhlYWRlcl9leGNsdXNpb25zOiBcIlwiLCAvLyBERVBSRUNBVEVEIHVzZSBleGNsdWRlZF9oZWFkaW5ncyBpbnN0ZWFkXG4gICAgfSxcbiAgICBhcGk6IG51bGwsXG4gICAgZW1iZWRkaW5nc19sb2FkZWQ6IGZhbHNlLFxuICAgIGZvbGRlcnM6IFtdLFxuICAgIGhhc19uZXdfZW1iZWRkaW5nczogZmFsc2UsXG4gICAgbmVhcmVzdF9jYWNoZToge30sXG4gICAgcmVuZGVyX2xvZzoge1xuICAgICAgZGVsZXRlZF9lbWJlZGRpbmdzOiAwLFxuICAgICAgZXhjbHVzaW9uc19sb2dzOiB7fSxcbiAgICAgIGZhaWxlZF9lbWJlZGRpbmdzOiBbXSxcbiAgICAgIGZpbGVzOiBbXSxcbiAgICAgIG5ld19lbWJlZGRpbmdzOiAwLFxuICAgICAgc2tpcHBlZF9sb3dfZGVsdGE6IHt9LFxuICAgICAgdG9rZW5fdXNhZ2U6IDAsXG4gICAgICB0b2tlbnNfc2F2ZWRfYnlfY2FjaGU6IDAsXG4gICAgfSxcbiAgICByZXRyeV9ub3RpY2VfdGltZW91dDogbnVsbCxcbiAgICBzYXZlX3RpbWVvdXQ6IG51bGwsXG4gICAgc2NfYnJhbmRpbmc6IHt9LFxuICAgIHVwZGF0ZV9hdmFpbGFibGU6IGZhbHNlLFxuICB9O1xufVxuZXhwb3J0cy5kZWZhdWx0X3NldHRpbmdzID0gZGVmYXVsdF9zZXR0aW5ncztcbiIsICJjb25zdCB7IFNtYXJ0U2V0dGluZ3MgfSA9IHJlcXVpcmUoXCIuL3NtYXJ0X3NldHRpbmdzXCIpO1xuY29uc3Qgc21hcnRfZW1iZWRfbW9kZWxzID0gcmVxdWlyZShcInNtYXJ0LWVtYmVkLW1vZGVsL21vZGVscy5qc29uXCIpO1xuLy8gU21hcnQgQ29ubmVjdGlvbnMgU3BlY2lmaWMgU2V0dGluZ3NcbmNsYXNzIFNtYXJ0RW1iZWRTZXR0aW5ncyBleHRlbmRzIFNtYXJ0U2V0dGluZ3Mge1xuICByZWZyZXNoX3NtYXJ0X3ZpZXcoKSB7IHRoaXMucGx1Z2luLnNtYXJ0X2Nvbm5lY3Rpb25zX3ZpZXcucmVuZGVyX25lYXJlc3QoKTsgfVxuICBhc3luYyBjb25uZWN0X3RvX3NtYXJ0X2Nvbm5lY3QoKXtcbiAgICAvLyBjaGVjayBpZiBhbHJlYWR5IGlzIGNvbm5lY3RlZFxuICAgIGlmKHRoaXMucGx1Z2luLmVudi5zbWFydF9ub3Rlcz8uc21hcnRfZW1iZWQ/LmlzX3NtYXJ0X2Nvbm5lY3Qpe1xuICAgICAgdGhpcy5wbHVnaW4ubm90aWNlcy5zaG93KCdzbWFydCBjb25uZWN0IGFscmVhZHkgY29ubmVjdGVkJywgJ0FscmVhZHkgY29ubmVjdGVkIHRvIGxvY2FsIFNtYXJ0IENvbm5lY3QgZm9yIGVtYmVkZGluZy4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gY2hlY2sgaWYgaHR0cDovL2xvY2FsaG9zdDozNzQyMC9lbWJlZCBpcyBhdmFpbGFibGVcbiAgICAvLyBjb25zb2xlLmxvZygnQ2hlY2tpbmcgZm9yIGxvY2FsIFNtYXJ0IENvbm5lY3Qgc2VydmVyLi4uJyk7XG4gICAgdHJ5e1xuICAgICAgYXdhaXQgdGhpcy5wbHVnaW4ub2JzaWRpYW4ucmVxdWVzdFVybCh7dXJsOiAnaHR0cDovL2xvY2FsaG9zdDozNzQyMS8nLCBtZXRob2Q6ICdHRVQnfSk7XG4gICAgICB0aGlzLnBsdWdpbi5ub3RpY2VzLnNob3coJ3NtYXJ0IGNvbm5lY3QgZm91bmQnLCAnTG9jYWwgU21hcnQgQ29ubmVjdCBzZXJ2ZXIgZm91bmQuIENvbm5lY3RpbmcuLi4nKTtcbiAgICAgIC8vIHJlc3RhcnQgZW52IGlmIGF2YWlsYWJsZSBidXQgc21hcnRfZW1iZWQgaXMgbm90IHNldCB0byB1c2UgU21hcnRDb25uZWN0XG4gICAgICB0aGlzLnBsdWdpbi5yZXN0YXJ0X3BsdWdpbigpO1xuICAgIH1jYXRjaChlcnIpe1xuICAgICAgdGhpcy5wbHVnaW4ubm90aWNlcy5zaG93KCdzbWFydCBjb25uZWN0IG5vdCBmb3VuZCcsICdDb3VsZCBub3QgY29ubmVjdCB0byBsb2NhbCBTbWFydCBDb25uZWN0IHNlcnZlcicpO1xuICAgIH1cbiAgfVxuICBhc3luYyB0ZXN0X2FwaV9rZXlfb3BlbmFpX2VtYmVkZGluZ3MoKSB7XG4gICAgY29uc3QgcmVxID0ge1xuICAgICAgdXJsOiBgaHR0cHM6Ly9hcGkub3BlbmFpLmNvbS92MS9lbWJlZGRpbmdzYCxcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IG1vZGVsOiBcInRleHQtZW1iZWRkaW5nLWFkYS0wMDJcIiwgaW5wdXQ6IFwidGVzdFwiIH0pLFxuICAgICAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiwgXCJBdXRob3JpemF0aW9uXCI6IGBCZWFyZXIgJHt0aGlzLnBsdWdpbi5zZXR0aW5ncy5hcGlfa2V5fWAgfSxcbiAgICB9O1xuICAgIHRyeXtcbiAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCB0aGlzLnBsdWdpbi5vYnNpZGlhbi5yZXF1ZXN0VXJsKHJlcSk7XG4gICAgICBpZihyZXNwPy5qc29uPy5kYXRhPy5bMF0/LmVtYmVkZGluZz8ubGVuZ3RoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMucGx1Z2luLm5vdGljZXMuc2hvdygnYXBpIGtleSB0ZXN0IHBhc3MnLCBcIlN1Y2Nlc3MhIE9wZW5BSSBBUEkga2V5IGlzIHZhbGlkXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5wbHVnaW4ubm90aWNlcy5zaG93KCdhcGkga2V5IHRlc3QgZmFpbCcsIFwiRXJyb3I6IE9wZW5BSSBBUEkga2V5IGlzIGludmFsaWQhXCIpO1xuICAgIH1jYXRjaChlcnIpe1xuICAgICAgdGhpcy5wbHVnaW4ubm90aWNlcy5zaG93KCdhcGkga2V5IHRlc3QgZmFpbCcsIFwiRXJyb3I6IE9wZW5BSSBBUEkga2V5IGlzIGludmFsaWQhXCIpO1xuICAgICAgY29uc29sZS5lcnJvcihcIlNtYXJ0IENvbm5lY3Rpb25zOiBFcnJvciB0ZXN0aW5nIE9wZW5BSSBBUEkga2V5XCIsIGVycik7XG4gICAgfVxuICB9XG4gIHJlbG9hZF9lbnYoKSB7IHRoaXMuZW52LnJlbG9hZCgpOyB9IC8vIERFUFJFQ0FURURcbiAgcmVzdGFydF9wbHVnaW4oKSB7IHRoaXMucGx1Z2luLnJlc3RhcnRfcGx1Z2luKCk7IH1cbiAgZ2V0IHRlbXBsYXRlKCkgeyByZXR1cm4gdGhpcy50ZW1wbGF0ZXNbJ3NtYXJ0X2VtYmVkX3NldHRpbmdzJ107IH1cbiAgYXN5bmMgZ2V0X3ZpZXdfZGF0YSgpIHtcbiAgICBjb25zdCB2aWV3X2RhdGEgPSB7XG4gICAgICBzZXR0aW5nczogdGhpcy5wbHVnaW4uc2V0dGluZ3MsXG4gICAgICBlbWJlZGRpbmdfbW9kZWxzOiBPYmplY3Qua2V5cyhzbWFydF9lbWJlZF9tb2RlbHMpLm1hcChtb2RlbF9rZXkgPT4gKHsga2V5OiBtb2RlbF9rZXksIC4uLnNtYXJ0X2VtYmVkX21vZGVsc1ttb2RlbF9rZXldIH0pKSxcbiAgICB9O1xuICAgIHZpZXdfZGF0YS5zbWFydF9lbWJlZF9zZXR0aW5ncyA9IHRoaXMuZWpzLnJlbmRlcih0aGlzLnRlbXBsYXRlLCB2aWV3X2RhdGEpO1xuICAgIHJldHVybiB2aWV3X2RhdGE7XG4gIH1cbn1cbmV4cG9ydHMuU21hcnRFbWJlZFNldHRpbmdzID0gU21hcnRFbWJlZFNldHRpbmdzOyIsICJjb25zdCB7IFNtYXJ0T2JzaWRpYW5WaWV3IH0gPSByZXF1aXJlKFwiLi9zbWFydF9vYnNpZGlhbl92aWV3LmpzXCIpO1xuY29uc3QgeyBTbWFydEVtYmVkU2V0dGluZ3MgfSA9IHJlcXVpcmUoXCIuL3NtYXJ0X2VtYmVkX3NldHRpbmdzLmpzXCIpO1xuY29uc3QgU1VQUE9SVEVEX0ZJTEVfVFlQRVMgPSBbXCJtZFwiLCBcImNhbnZhc1wiXTtcblxuY2xhc3MgU2NTbWFydFZpZXcgZXh0ZW5kcyBTbWFydE9ic2lkaWFuVmlldyB7XG4gIHN0YXRpYyBnZXQgdmlld190eXBlKCkgeyByZXR1cm4gXCJzbWFydC1jb25uZWN0aW9ucy12aWV3XCI7IH1cbiAgLy8gT2JzaWRpYW5cbiAgZ2V0Vmlld1R5cGUoKSB7IHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnZpZXdfdHlwZTsgfVxuICBnZXREaXNwbGF5VGV4dCgpIHsgcmV0dXJuIFwiU21hcnQgQ29ubmVjdGlvbnMgRmlsZXNcIjsgfVxuICBnZXRJY29uKCkgeyByZXR1cm4gXCJzbWFydC1jb25uZWN0aW9uc1wiOyB9XG4gIGFzeW5jIG9uT3BlbigpIHsgdGhpcy5hcHAud29ya3NwYWNlLm9uTGF5b3V0UmVhZHkodGhpcy5pbml0aWFsaXplLmJpbmQodGhpcykpOyB9XG4gIGFzeW5jIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5lbnYgPSB0aGlzLnBsdWdpbi5icmFpbjtcbiAgICB0aGlzLmJyYWluID0gdGhpcy5lbnY7XG4gICAgdGhpcy5sYXN0X3BhcmVudF9pZCA9IHRoaXMuY29uc3RydWN0b3IuZ2V0X2xlYWYodGhpcy5hcHAud29ya3NwYWNlKT8ucGFyZW50LmlkO1xuICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5jb250YWluZXJFbC5jaGlsZHJlblsxXTsgLy8gZ2V0IGNvbnRhaW5lciBmb3Igdmlld3NcbiAgICB0aGlzLmNvbnRhaW5lci5lbXB0eSgpO1xuICAgIHRoaXMubmVhcmVzdF9jYWNoZSA9IHt9OyAvLyBjYWNoZSBuZWFyZXN0IHJlc3VsdHNcbiAgICAvLyBhd2FpdCB0aGlzLmxvYWRfYnJhaW4oKTsgLy8gbW92ZWQgdG8gbWFpbiBwbHVnaW4gaW5pdGlhbGl6YXRpb25cbiAgICB0aGlzLnBsdWdpbi5zbWFydF9jb25uZWN0aW9uc192aWV3ID0gdGhpcztcbiAgICB0aGlzLnJlZ2lzdGVyX3BsdWdpbl9ldmVudHMoKTtcbiAgICB0aGlzLmFwcC53b3Jrc3BhY2UucmVnaXN0ZXJIb3ZlckxpbmtTb3VyY2UodGhpcy5jb25zdHJ1Y3Rvci52aWV3X3R5cGUsIHsgZGlzcGxheTogJ1NtYXJ0IENvbm5lY3Rpb25zIEZpbGVzJywgZGVmYXVsdE1vZDogdHJ1ZSB9KTtcbiAgICB0aGlzLmNvbnRhaW5lci5pbm5lckhUTUwgPSB0aGlzLnJlbmRlcl90ZW1wbGF0ZShcInNtYXJ0X2Nvbm5lY3Rpb25zXCIsIHsgY3VycmVudF9wYXRoOiBcIlwiLCByZXN1bHRzOiBbXSB9KTtcbiAgICB0aGlzLmFkZF90b3BfYmFyX2xpc3RlbmVycygpO1xuICB9XG4gIGFzeW5jIG9uQ2xvc2UoKSB7XG4gICAgY29uc29sZS5sb2coXCJjbG9zaW5nIHNtYXJ0IGNvbm5lY3Rpb25zIHZpZXdcIik7XG4gICAgdGhpcy5hcHAud29ya3NwYWNlLnVucmVnaXN0ZXJIb3ZlckxpbmtTb3VyY2UodGhpcy5jb25zdHJ1Y3Rvci52aWV3X3R5cGUpO1xuICB9XG4gIG9uUmVzaXplKCkge1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLmdldF9sZWFmKHRoaXMuYXBwLndvcmtzcGFjZSkucGFyZW50LmlkICE9PSB0aGlzLmxhc3RfcGFyZW50X2lkKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlBhcmVudCBjaGFuZ2VkLCByZWxvYWRpbmdcIik7XG4gICAgICAvLyB0aGlzLmxvYWRfYnJhaW4oKTtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgIH1cbiAgfVxuICAvLyBnZXR0ZXJzXG4gIC8vIERFUFJFQ0FURURcbiAgLy8gZ2V0IHBhdGhfb25seSgpIHsgcmV0dXJuICh0aGlzLnNldHRpbmdzLnBhdGhfb25seT8ubGVuZ3RoKSA/IHRoaXMuc2V0dGluZ3MucGF0aF9vbmx5LnNwbGl0KFwiLFwiKS5tYXAoKHBhdGgpID0+IHBhdGgudHJpbSgpKSA6IFtdOyB9XG4gIC8vIFNtYXJ0IENvbm5lY3Rpb25zXG4gIHJlZ2lzdGVyX3BsdWdpbl9ldmVudHMoKSB7XG4gICAgLy8gb24gZmlsZS1vcGVuXG4gICAgdGhpcy5wbHVnaW4ucmVnaXN0ZXJFdmVudCh0aGlzLmFwcC53b3Jrc3BhY2Uub24oJ2ZpbGUtb3BlbicsIChmaWxlKSA9PiB7XG4gICAgICAvLyBjb25zb2xlLmxvZyhcImZpbGUtb3BlblwiKTtcbiAgICAgIHRoaXMudXBkYXRlX2xhc3RfdXNlcl9hY3Rpdml0eV90aW1lc3RhbXAoKTtcbiAgICAgIGlmICghZmlsZSkgcmV0dXJuOyAvLyBpZiBubyBmaWxlIGlzIG9wZW4sIHJldHVyblxuXG4gICAgICAvLyBjaGVjayBpZiB0aGlzIHZpZXcgaXMgdmlzaWJsZVxuICAgICAgaWYgKHRoaXMuY29udGFpbmVyLmNoZWNrVmlzaWJpbGl0eSgpID09PSBmYWxzZSkgcmV0dXJuIGNvbnNvbGUubG9nKFwiVmlldyBpbmFjdGl2ZSwgc2tpcHBpbmcgcmVuZGVyIG5lYXJlc3RcIik7XG4gICAgICB0aGlzLnJlbmRlcl9uZWFyZXN0KGZpbGUpO1xuICAgIH0pKTtcbiAgICAvLyBvbiBhY3RpdmUtbGVhZi1jaGFuZ2VcbiAgICB0aGlzLnBsdWdpbi5yZWdpc3RlckV2ZW50KHRoaXMuYXBwLndvcmtzcGFjZS5vbignYWN0aXZlLWxlYWYtY2hhbmdlJywgKGxlYWYpID0+IHtcbiAgICAgIHRoaXMudXBkYXRlX2xhc3RfdXNlcl9hY3Rpdml0eV90aW1lc3RhbXAoKTtcbiAgICAgIC8vIGlmIGxlYWYgaXMgdGhpcyB2aWV3XG4gICAgICBpZiAobGVhZi52aWV3IGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3Rvcikge1xuICAgICAgICBpZiAobGVhZi52aWV3LmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFwiLnNlYXJjaC1yZXN1bHRcIikubGVuZ3RoICYmIChsZWFmLnZpZXcubGFzdF9ub3RlID09PSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpPy5wYXRoKSkgcmV0dXJuOyAvLyBpZiBzZWFyY2ggcmVzdWx0cyBhcmUgYWxyZWFkeSByZW5kZXJlZCwgcmV0dXJuXG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcl9uZWFyZXN0KCk7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIC8vIG9uIGVkaXRvci1jaGFuZ2VcbiAgICB0aGlzLnBsdWdpbi5yZWdpc3RlckV2ZW50KHRoaXMuYXBwLndvcmtzcGFjZS5vbignZWRpdG9yLWNoYW5nZScsIChlZGl0b3IpID0+IHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiZWRpdG9yLWNoYW5nZVwiKTtcbiAgICAgIHRoaXMudXBkYXRlX2xhc3RfdXNlcl9hY3Rpdml0eV90aW1lc3RhbXAoKTtcbiAgICB9KSk7XG4gICAgLy8gb24gcXVpdFxuICAgIHRoaXMucGx1Z2luLnJlZ2lzdGVyRXZlbnQodGhpcy5hcHAud29ya3NwYWNlLm9uKCdxdWl0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gY29uc29sZS5sb2coXCJxdWl0XCIpO1xuICAgICAgLy8gc2F2ZSBpZiB0aGlzLmVudi5zYXZlX3RpbWVvdXQgaXMgc2V0IChjdXJyZW50bHkgZmFpbGluZyB0byBzYXZlIG9uIHF1aXQpXG4gICAgICBpZiAodGhpcy5lbnYuc2F2ZV90aW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmVudi5zYXZlX3RpbWVvdXQpO1xuICAgICAgICBhd2FpdCB0aGlzLmVudi5fc2F2ZSgpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIlNtYXJ0IENvbm5lY3Rpb25zIHNhdmVkXCIpO1xuICAgICAgfVxuICAgIH0pKTtcbiAgfVxuICAvLyB1c2VkIGluIGJyYWluLnNhdmUgdGltZW91dCB0byByZXNldCBpZiByZWNlbnQgYWN0aXZpdHkgKHByZXZlbnQgc2F2aW5nIGJsb2NraW5nIFVYIGR1cmluZyB1c2VyIGFjdGl2aXR5KVxuICB1cGRhdGVfbGFzdF91c2VyX2FjdGl2aXR5X3RpbWVzdGFtcCgpIHsgdGhpcy5sYXN0X3VzZXJfYWN0aXZpdHkgPSBEYXRlLm5vdygpOyB9XG4gIC8vIFNtYXJ0IENvbm5lY3Rpb25zIFZpZXdzXG4gIGdldCB2aWV3X2NvbnRleHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN1cGVyLnZpZXdfY29udGV4dCxcbiAgICAgIGJsb2NrczogdGhpcy5lbnYuc21hcnRfYmxvY2tzPy5rZXlzLmxlbmd0aCxcbiAgICAgIG5vdGVzOiB0aGlzLmVudi5zbWFydF9ub3Rlcz8ua2V5cy5sZW5ndGgsXG4gICAgfTtcbiAgfVxuICBhc3luYyByZW5kZXJfbmVhcmVzdChjb250ZXh0LCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcikge1xuICAgIGlmKCF0aGlzLmVudi5lbnRpdGllc19sb2FkZWQpe1xuICAgICAgLy8gcmVuZGVyIGxvYWRpbmcgbWVzc2FnZVxuICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9IFwiTG9hZGluZyBTbWFydCBDb25uZWN0aW9ucy4uLlwiO1xuICAgICAgLy8gd2FpdCBmb3IgZW50aXRpZXMgdG8gbG9hZFxuICAgICAgd2hpbGUoIXRoaXMuZW52LmVudGl0aWVzX2xvYWRlZCkgYXdhaXQgbmV3IFByb21pc2UociA9PiBzZXRUaW1lb3V0KHIsIDIwMDApKTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdHM7XG4gICAgaWYgKHR5cGVvZiBjb250ZXh0ID09PSBcInN0cmluZ1wiKSByZXN1bHRzID0gYXdhaXQgdGhpcy5wbHVnaW4uYXBpLnNlYXJjaChjb250ZXh0KTtcbiAgICBpZiAodHlwZW9mIGNvbnRleHQgPT09IFwidW5kZWZpbmVkXCIpIGNvbnRleHQgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xuICAgIGlmIChjb250ZXh0IGluc3RhbmNlb2YgdGhpcy5wbHVnaW4ub2JzaWRpYW4uVEZpbGUpIHtcbiAgICAgIC8vIHJldHVybiBpZiBmaWxlIHR5cGUgaXMgbm90IHN1cHBvcnRlZFxuICAgICAgaWYgKFNVUFBPUlRFRF9GSUxFX1RZUEVTLmluZGV4T2YoY29udGV4dC5leHRlbnNpb24pID09PSAtMSkgcmV0dXJuIHRoaXMucGx1Z2luLm5vdGljZXMuc2hvdygndW5zdXBwb3J0ZWQgZmlsZSB0eXBlJywgW1xuICAgICAgICBcIkZpbGU6IFwiICsgY29udGV4dC5uYW1lLFxuICAgICAgICBcIlVuc3VwcG9ydGVkIGZpbGUgdHlwZSAoU3VwcG9ydGVkOiBcIiArIFNVUFBPUlRFRF9GSUxFX1RZUEVTLmpvaW4oXCIsIFwiKSArIFwiKVwiXG4gICAgICBdKTtcbiAgICAgIGlmICghdGhpcy5lbnYuc21hcnRfbm90ZXMuZ2V0KGNvbnRleHQucGF0aCkpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgZXhjbHVkZWRcbiAgICAgICAgaWYodGhpcy5lbnYuaXNfaW5jbHVkZWQoY29udGV4dC5wYXRoKSl7XG4gICAgICAgICAgYXdhaXQgdGhpcy5lbnYuc21hcnRfbm90ZXMuaW1wb3J0KHRoaXMuZW52LmZpbGVzKTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1Z2luLm5vdGljZXMuc2hvdygnZXhjbHVkZWQgZmlsZScsIFwiRmlsZSBpcyBleGNsdWRlZDogXCIgKyBjb250ZXh0LnBhdGgsIHt0aW1lb3V0OiAzMDAwfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdHMgPSB0aGlzLmVudi5zbWFydF9ub3Rlcy5nZXQoY29udGV4dC5wYXRoKT8uZmluZF9jb25uZWN0aW9ucygpO1xuICAgIH1cbiAgICBpZiAoY29udGV4dCBpbnN0YW5jZW9mIHRoaXMuZW52Lml0ZW1fdHlwZXMuU21hcnRCbG9jaykgcmVzdWx0cyA9IGNvbnRleHQuZmluZF9jb25uZWN0aW9ucygpO1xuICAgIGlmIChjb250ZXh0IGluc3RhbmNlb2YgdGhpcy5lbnYuaXRlbV90eXBlcy5TbWFydE5vdGUpIHJlc3VsdHMgPSBjb250ZXh0LmZpbmRfY29ubmVjdGlvbnMoKTtcbiAgICBpZiAoIXJlc3VsdHMpIHJldHVybiB0aGlzLnBsdWdpbi5ub3RpY2VzLnNob3coJ25vIHNtYXJ0IGNvbm5lY3Rpb25zIGZvdW5kJywgXCJObyBTbWFydCBDb25uZWN0aW9ucyBmb3VuZC5cIik7XG4gICAgaWYgKHR5cGVvZiBjb250ZXh0ID09PSBcIm9iamVjdFwiKSBjb250ZXh0ID0gY29udGV4dC5rZXkgfHwgY29udGV4dC5wYXRoO1xuICAgIHRoaXMubGFzdF9ub3RlID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKS5wYXRoOyAvLyBmb3IgY2hlY2tpbmcgaWYgcmVzdWx0cyBhcmUgYWxyZWFkeSByZW5kZXJlZCAoZXg6IG9uIGFjdGl2ZS1sZWFmLWNoYW5nZSlcblxuICAgIC8vIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSB0aGlzLnJlbmRlcl90ZW1wbGF0ZShcInNtYXJ0X2Nvbm5lY3Rpb25zXCIsIHsgY3VycmVudF9wYXRoOiBjb250ZXh0LCByZXN1bHRzIH0pO1xuICAgIHRoaXMuYWRkX3RvcF9iYXJfbGlzdGVuZXJzKGNvbnRhaW5lcik7XG4gICAgY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuc2VhcmNoLXJlc3VsdFwiKS5mb3JFYWNoKChlbG0sIGkpID0+IHRoaXMuYWRkX2xpbmtfbGlzdGVuZXJzKGVsbSwgcmVzdWx0c1tpXSkpO1xuICAgIGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFwiLnNlYXJjaC1yZXN1bHQ6bm90KC5zYy1jb2xsYXBzZWQpIHVsIGxpXCIpLmZvckVhY2godGhpcy5yZW5kZXJfcmVzdWx0LmJpbmQodGhpcykpO1xuICB9XG4gIGFzeW5jIHJlbmRlcl9yZXN1bHQoZWxtLCBpID0gMCkge1xuICAgIC8vIGlmIGFscmVhZHkgcmVuZGVyZWQsIHJldHVyblxuICAgIGlmIChlbG0uaW5uZXJIVE1MKSByZXR1cm4gY29uc29sZS5sb2coXCJhbHJlYWR5IHJlbmRlcmVkXCIpO1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKHIgPT4gc2V0VGltZW91dChyLCAyMCAqIGkpKTsgLy8gd2FpdCAxMDBtcyBiZXR3ZWVuIGVhY2ggcmVuZGVyXG5cblxuICAgIC8vIG9ubHkgcmVuZGVyIHZpc2libGUgcmVzdWx0c1xuICAgIC8vIGlmIG5vdCB2aXNpYmxlLCBzZXQgbGlzdGVuZXIgdG8gcmVuZGVyIHdoZW4gaXQgaXNcbiAgICBpZiAoIWlzRWxlbWVudFZpc2libGUoZWxtKSkge1xuICAgICAgLy8gaWYgY2xvc2VzdCAuc2VhcmNoLXJlc3VsdCBoYXMgc2MtY29sbGFwc2VkIGNsYXNzLCByZXR1cm5cbiAgICAgIGNvbnN0IHBhcmVudCA9IGVsbS5jbG9zZXN0KFwiLnNlYXJjaC1yZXN1bHRcIik7XG4gICAgICBpZiAocGFyZW50LmNsYXNzTGlzdC5jb250YWlucyhcInNjLWNvbGxhcHNlZFwiKSkgcmV0dXJuO1xuICAgICAgLy8gaWYgcGFyZW50IGlzIG5vdCB2aXNpYmxlLCBzZXQgbGlzdGVuZXIgdG8gcmVuZGVyIHdoZW4gaXQgaXNcbiAgICAgIGlmICghaXNFbGVtZW50VmlzaWJsZShwYXJlbnQpKSB7XG4gICAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKChlbnRyaWVzLCBvYnNlcnZlcikgPT4ge1xuICAgICAgICAgIGlmIChlbnRyaWVzWzBdLmlzSW50ZXJzZWN0aW5nKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcl9yZXN1bHQoZWxtKTtcbiAgICAgICAgICAgIG9ic2VydmVyLnVub2JzZXJ2ZShwYXJlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgeyB0aHJlc2hvbGQ6IDAuNSB9KTtcbiAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShwYXJlbnQpO1xuICAgICAgICByZXR1cm47IC8vIGlmIG5vdCB2aXNpYmxlLCByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc29sZS5sb2coXCJyZW5kZXJpbmcgcmVzdWx0XCIpO1xuICAgIGNvbnN0IGVudGl0eV9rZXkgPSBlbG0udGl0bGU7XG4gICAgY29uc3QgY29sbGVjdGlvbl9uYW1lID0gZWxtLmRhdGFzZXQuY29sbGVjdGlvbjtcbiAgICBjb25zdCBlbnRpdHkgPSB0aGlzLmJyYWluW2NvbGxlY3Rpb25fbmFtZV0uZ2V0KGVudGl0eV9rZXkpO1xuICAgIGlmIChzaG91bGRfcmVuZGVyX2VtYmVkKCkpIHJldHVybiB0aGlzLnBsdWdpbi5vYnNpZGlhbi5NYXJrZG93blJlbmRlcmVyLnJlbmRlcih0aGlzLmFwcCwgZW50aXR5LmVtYmVkX2xpbmssIGVsbSwgZW50aXR5X2tleSwgbmV3IHRoaXMucGx1Z2luLm9ic2lkaWFuLkNvbXBvbmVudCgpKTtcbiAgICBjb25zdCBjb250ZW50ID0gKGF3YWl0IGVudGl0eT8uZ2V0X2NvbnRlbnQoKSk/LnJlcGxhY2UoL2BgYGRhdGF2aWV3L2csICdgYGBcXFxcZGF0YXZpZXcnKTsgLy8gcHJldmVudCByZW5kZXJpbmcgZGF0YXZpZXcgY29kZSBibG9ja3MgKERPOiBtYWtlIHRvZ2dsZS1hYmxlKVxuICAgIGlmICghZW50aXR5IHx8ICFjb250ZW50KSB7XG4gICAgICAvLyBhZGQgbm90IGZvdW5kIG1lc3NhZ2UgPHA+XG4gICAgICBlbG0uY3JlYXRlRWwoXCJwXCIsIHsgdGV4dDogXCJCbG9jayBub3QgZm91bmQ6IFwiICsgZW50aXR5X2tleSB9KTtcbiAgICAgIC8vIGFkZCByZWZyZXNoIGJ1dHRvblxuICAgICAgY29uc3QgcmVmcmVzaF9idXR0b24gPSBlbG0uY3JlYXRlRWwoXCJidXR0b25cIiwgeyB0ZXh0OiBcIlJlZnJlc2ggZW1iZWRkaW5nc1wiIH0pO1xuICAgICAgcmVmcmVzaF9idXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChlKSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgdGhpcy5lbnYuc21hcnRfbm90ZXMuaW1wb3J0KHRoaXMuZW52LmZpbGVzLCB7IHJlc2V0OiB0cnVlIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMucGx1Z2luLm9ic2lkaWFuLk1hcmtkb3duUmVuZGVyZXIucmVuZGVyKHRoaXMuYXBwLCBjb250ZW50LCBlbG0sIGVudGl0eV9rZXksIG5ldyB0aGlzLnBsdWdpbi5vYnNpZGlhbi5Db21wb25lbnQoKSk7XG4gICAgZnVuY3Rpb24gaXNFbGVtZW50VmlzaWJsZShlbGVtKSB7XG4gICAgICBjb25zdCByZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHJlY3QudG9wID49IDAgJiZcbiAgICAgICAgcmVjdC5sZWZ0ID49IDAgJiZcbiAgICAgICAgcmVjdC5ib3R0b20gPD0gKHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0KSAmJlxuICAgICAgICByZWN0LnJpZ2h0IDw9ICh3aW5kb3cuaW5uZXJXaWR0aCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgpXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaG91bGRfcmVuZGVyX2VtYmVkKCkge1xuICAgICAgaWYgKCFlbnRpdHkpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmIChlbnRpdHkuaXNfY2FudmFzKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmIChlbnRpdHkuaXNfZXhjYWxpZHJhdykgcmV0dXJuIHRydWU7XG4gICAgICBpZiAoZW50aXR5Lm5vdGU/LmlzX2NhbnZhcykgcmV0dXJuIHRydWU7XG4gICAgICBpZiAoZW50aXR5Lm5vdGU/LmlzX2V4Y2FsaWRyYXcpIHJldHVybiB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBhZGRfbGlua19saXN0ZW5lcnMoZWxtLCBpdGVtKSB7XG4gICAgZWxtLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLmhhbmRsZV9zZWFyY2hfcmVzdWx0X2NsaWNrLmJpbmQodGhpcykpO1xuICAgIC8vIGRyYWctb25cbiAgICAvLyBjdXJyZW50bHkgb25seSB3b3JrcyB3aXRoIGZ1bGwtZmlsZSBsaW5rc1xuICAgIGVsbS5zZXRBdHRyKCdkcmFnZ2FibGUnLCAndHJ1ZScpO1xuICAgIGVsbS5hZGRFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IGRyYWdNYW5hZ2VyID0gdGhpcy5hcHAuZHJhZ01hbmFnZXI7XG4gICAgICBjb25zdCBmaWxlX3BhdGggPSBpdGVtLnBhdGguc3BsaXQoXCIjXCIpWzBdO1xuICAgICAgY29uc3QgZmlsZSA9IHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0Rmlyc3RMaW5rcGF0aERlc3QoZmlsZV9wYXRoLCAnJyk7XG4gICAgICBjb25zdCBkcmFnRGF0YSA9IGRyYWdNYW5hZ2VyLmRyYWdGaWxlKGV2ZW50LCBmaWxlKTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGRyYWdEYXRhKTtcbiAgICAgIGRyYWdNYW5hZ2VyLm9uRHJhZ1N0YXJ0KGV2ZW50LCBkcmFnRGF0YSk7XG4gICAgfSk7XG4gICAgLy8gaWYgY3Vyci5saW5rIGNvbnRhaW5zIGN1cmx5IGJyYWNlcywgcmV0dXJuIChpbmNvbXBhdGlibGUgd2l0aCBob3Zlci1saW5rKVxuICAgIGlmIChpdGVtLnBhdGguaW5kZXhPZihcIntcIikgPiAtMSkgcmV0dXJuO1xuICAgIC8vIHRyaWdnZXIgaG92ZXIgZXZlbnQgb24gbGlua1xuICAgIGVsbS5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdmVyXCIsIChldmVudCkgPT4ge1xuICAgICAgdGhpcy5hcHAud29ya3NwYWNlLnRyaWdnZXIoXCJob3Zlci1saW5rXCIsIHtcbiAgICAgICAgZXZlbnQsXG4gICAgICAgIHNvdXJjZTogdGhpcy5jb25zdHJ1Y3Rvci52aWV3X3R5cGUsXG4gICAgICAgIGhvdmVyUGFyZW50OiBlbG0ucGFyZW50RWxlbWVudCxcbiAgICAgICAgdGFyZ2V0RWw6IGVsbSxcbiAgICAgICAgbGlua3RleHQ6IGl0ZW0ucGF0aCxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGhhbmRsZV9zZWFyY2hfcmVzdWx0X2NsaWNrKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gcHJldmVudCBkZWZhdWx0IGNsaWNrIGJlaGF2aW9yXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7IC8vIHByZXZlbnQgZXZlbnQgZnJvbSBidWJibGluZyB1cFxuICAgIGNvbnN0IHNlYXJjaF9yZXN1bHQgPSBldmVudC50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiLnNlYXJjaC1yZXN1bHRcIikgPyBldmVudC50YXJnZXQgOiBldmVudC50YXJnZXQuY2xvc2VzdChcIi5zZWFyY2gtcmVzdWx0XCIpOyAvLyBmaW5kIHBhcmVudCBjb250YWluaW5nIHNlYXJjaC1yZXN1bHQgY2xhc3NcbiAgICBpZiAoZXZlbnQudGFyZ2V0IGluc3RhbmNlb2YgU1ZHRWxlbWVudCkgcmV0dXJuIHRoaXMudG9nZ2xlX3NlYXJjaF9yZXN1bHRfdmlzaWJpbGl0eShzZWFyY2hfcmVzdWx0KTsgLy8gaWYgZXZlbnQgdGFyZ2V0IGVsZW1lbnQgaXMgc3ZnLCB0b2dnbGUgc2MtY29sbGFwc2VkIGNsYXNzXG4gICAgLy8gaWYgc2MtY29sbGFwc2VkIGNsYXNzIGlzIHJlbW92ZWQsIGFkZCBjbGljayBsaXN0ZW5lciB0byBzZWFyY2gtcmVzdWx0XG4gICAgaWYgKHNlYXJjaF9yZXN1bHQuY2xhc3NMaXN0LmNvbnRhaW5zKFwic2MtY29sbGFwc2VkXCIpKXtcbiAgICAgIGlmKHRoaXMucGx1Z2luLm9ic2lkaWFuLktleW1hcC5pc01vZEV2ZW50KGV2ZW50KSkgdGhpcy5wbHVnaW4ub3Blbl9ub3RlKHNlYXJjaF9yZXN1bHQuZGF0YXNldC5wYXRoLCBldmVudCk7XG4gICAgICBlbHNlIHRoaXMudG9nZ2xlX3NlYXJjaF9yZXN1bHRfdmlzaWJpbGl0eShzZWFyY2hfcmVzdWx0KTtcbiAgICB9ZWxzZSB0aGlzLnBsdWdpbi5vcGVuX25vdGUoc2VhcmNoX3Jlc3VsdC5kYXRhc2V0LnBhdGgsIGV2ZW50KTtcbiAgfVxuICB0b2dnbGVfc2VhcmNoX3Jlc3VsdF92aXNpYmlsaXR5KHNlYXJjaF9yZXN1bHRfZWxtKSB7XG4gICAgc2VhcmNoX3Jlc3VsdF9lbG0uY2xhc3NMaXN0LnRvZ2dsZShcInNjLWNvbGxhcHNlZFwiKTsgLy8gdG9nZ2xlIHNjLWNvbGxhcHNlZCBjbGFzc1xuICAgIHRoaXMucmVuZGVyX3Jlc3VsdChzZWFyY2hfcmVzdWx0X2VsbS5xdWVyeVNlbGVjdG9yKFwibGlcIikpO1xuICB9XG5cbiAgYWRkX3RvcF9iYXJfbGlzdGVuZXJzKGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyKSB7XG4gICAgY29uc3QgdG9wX2JhciA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiLnNjLXRvcC1iYXJcIik7XG4gICAgY29uc3Qgc2VhcmNoX2J1dHRvbiA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiLnNjLXNlYXJjaC1idXR0b25cIik7IC8vIGdldCBzZWFyY2ggYnV0dG9uXG4gICAgc2VhcmNoX2J1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgY29uc3Qgb2dfdG9wX2JhciA9IHRvcF9iYXIuaW5uZXJIVE1MO1xuICAgICAgdG9wX2Jhci5lbXB0eSgpOyAvLyBlbXB0eSB0b3AgYmFyXG5cbiAgICAgIC8vIGNyZWF0ZSBpbnB1dCBlbGVtZW50XG4gICAgICBjb25zdCBzZWFyY2hfY29udGFpbmVyID0gdG9wX2Jhci5jcmVhdGVFbChcImRpdlwiLCB7IGNsczogXCJzZWFyY2gtaW5wdXQtY29udGFpbmVyXCIgfSk7XG4gICAgICBjb25zdCBpbnB1dCA9IHNlYXJjaF9jb250YWluZXIuY3JlYXRlRWwoXCJpbnB1dFwiLCB7XG4gICAgICAgIGNsczogXCJzYy1zZWFyY2gtaW5wdXRcIixcbiAgICAgICAgdHlwZTogXCJzZWFyY2hcIixcbiAgICAgICAgcGxhY2Vob2xkZXI6IFwiVHlwZSB0byBzdGFydCBzZWFyY2guLi5cIixcbiAgICAgIH0pO1xuICAgICAgaW5wdXQuZm9jdXMoKTtcbiAgICAgIC8vIGFkZCBrZXlkb3duIGxpc3RlbmVyIHRvIGlucHV0XG4gICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgLy8gaWYgZXNjYXBlIGtleSBpcyBwcmVzc2VkXG4gICAgICAgIGlmIChldmVudC5rZXkgPT09IFwiRXNjYXBlXCIpIHtcbiAgICAgICAgICBpZiAodGhpcy5zZWFyY2hfdGltZW91dCkgY2xlYXJUaW1lb3V0KHRoaXMuc2VhcmNoX3RpbWVvdXQpO1xuICAgICAgICAgIHRvcF9iYXIuaW5uZXJIVE1MID0gb2dfdG9wX2JhcjtcbiAgICAgICAgICB0aGlzLmFkZF90b3BfYmFyX2xpc3RlbmVycyhjb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIGFkZCBrZXl1cCBsaXN0ZW5lciB0byBpbnB1dFxuICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIChldmVudCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5zZWFyY2hfdGltZW91dCkgY2xlYXJUaW1lb3V0KHRoaXMuc2VhcmNoX3RpbWVvdXQpO1xuICAgICAgICBjb25zdCBzZWFyY2hfdGVybSA9IGlucHV0LnZhbHVlOyAvLyBnZXQgc2VhcmNoIHRlcm1cbiAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gXCJFbnRlclwiICYmIHNlYXJjaF90ZXJtICE9PSBcIlwiKSB0aGlzLnJlbmRlcl9uZWFyZXN0KHNlYXJjaF90ZXJtKTsgLy8gaWYgZW50ZXIga2V5IGlzIHByZXNzZWRcblxuICAgICAgICAvLyBpZiBhbnkgb3RoZXIga2V5IGlzIHByZXNzZWQgYW5kIGlucHV0IGlzIG5vdCBlbXB0eSB0aGVuIHdhaXQgNTAwbXNcbiAgICAgICAgZWxzZSBpZiAoc2VhcmNoX3Rlcm0gIT09IFwiXCIpIHtcbiAgICAgICAgICBpZiAodGhpcy5zZWFyY2hfdGltZW91dCkgY2xlYXJUaW1lb3V0KHRoaXMuc2VhcmNoX3RpbWVvdXQpO1xuICAgICAgICAgIHRoaXMuc2VhcmNoX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMucmVuZGVyX25lYXJlc3Qoc2VhcmNoX3Rlcm0pLCA3MDApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBjb25zdCBmb2xkX2FsbF9idXR0b24gPSBjb250YWluZXIucXVlcnlTZWxlY3RvcihcIi5zYy1mb2xkLWFsbFwiKTsgLy8gZ2V0IGZvbGQgYWxsIGJ1dHRvblxuICAgIGZvbGRfYWxsX2J1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGUpID0+IHtcbiAgICAgIGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFwiLnNlYXJjaC1yZXN1bHRcIikuZm9yRWFjaCgoZWxtKSA9PiBlbG0uY2xhc3NMaXN0LmFkZChcInNjLWNvbGxhcHNlZFwiKSk7XG4gICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5leHBhbmRlZF92aWV3ID0gZmFsc2U7XG4gICAgICB0aGlzLnBsdWdpbi5zYXZlX3NldHRpbmdzKCk7XG4gICAgfSk7XG4gICAgY29uc3QgdW5mb2xkX2FsbF9idXR0b24gPSBjb250YWluZXIucXVlcnlTZWxlY3RvcihcIi5zYy11bmZvbGQtYWxsXCIpOyAvLyBnZXQgdW5mb2xkIGFsbCBidXR0b25cbiAgICB1bmZvbGRfYWxsX2J1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuc2VhcmNoLXJlc3VsdFwiKS5mb3JFYWNoKChlbG0pID0+IHtcbiAgICAgICAgZWxtLmNsYXNzTGlzdC5yZW1vdmUoXCJzYy1jb2xsYXBzZWRcIik7XG4gICAgICAgIHRoaXMucmVuZGVyX3Jlc3VsdChlbG0ucXVlcnlTZWxlY3RvcihcImxpXCIpKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZXhwYW5kZWRfdmlldyA9IHRydWU7XG4gICAgICB0aGlzLnBsdWdpbi5zYXZlX3NldHRpbmdzKCk7XG4gICAgfSk7XG5cbiAgICAvLyBzZXR0aW5ncyBidXR0b25cbiAgICBjb25zdCBzZXR0aW5nc19idG4gPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiYnV0dG9uW3RpdGxlPSdTZXR0aW5ncyddXCIpO1xuICAgIHNldHRpbmdzX2J0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgc2V0dGluZ3NfY29udGFpbmVyID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcihcIiNzZXR0aW5nc1wiKTtcbiAgICAgIC8vIGlmIGhhcyBjb250ZW50cywgY2xlYXJcbiAgICAgIGlmKHNldHRpbmdzX2NvbnRhaW5lci5pbm5lckhUTUwpIHJldHVybiBzZXR0aW5nc19jb250YWluZXIuaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgIC8vIGlmIG5vIHNldHRpbmdzLCBjcmVhdGVcbiAgICAgIGlmKCF0aGlzLmVtYmVkX3NldHRpbmdzKSB0aGlzLmVtYmVkX3NldHRpbmdzID0gbmV3IFNtYXJ0RW1iZWRTZXR0aW5ncyh0aGlzLmVudiwgc2V0dGluZ3NfY29udGFpbmVyKTtcbiAgICAgIGVsc2UgdGhpcy5lbWJlZF9zZXR0aW5ncy5jb250YWluZXIgPSBzZXR0aW5nc19jb250YWluZXI7XG4gICAgICB0aGlzLmVtYmVkX3NldHRpbmdzLnJlbmRlcigpO1xuICAgICAgLy8gRW5oYW5jZWQgdHJhbnNpdGlvbjogc21vb3RoIGJhY2tncm91bmQgY29sb3IgY2hhbmdlIHdpdGggZWFzZS1pbi1vdXQgZWZmZWN0XG4gICAgICBzZXR0aW5nc19jb250YWluZXIuc3R5bGUudHJhbnNpdGlvbiA9IFwiYmFja2dyb3VuZC1jb2xvciAwLjVzIGVhc2UtaW4tb3V0XCI7XG4gICAgICBzZXR0aW5nc19jb250YWluZXIuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJ2YXIoLS1ib2xkLWNvbG9yKVwiO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7IHNldHRpbmdzX2NvbnRhaW5lci5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcIlwiOyB9LCA1MDApO1xuICAgIH0pO1xuICB9XG59XG5leHBvcnRzLlNjU21hcnRWaWV3ID0gU2NTbWFydFZpZXc7XG4iLCAiY2xhc3MgU21hcnRTZWFyY2gge1xuICBjb25zdHJ1Y3RvcihwbHVnaW4pIHtcbiAgICB0aGlzLm1haW4gPSBwbHVnaW47XG4gICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47IC8vIERFUFJFQ0FURUQgaW4gZmF2b3Igb2YgdGhpcy5tYWluPz8/XG4gIH1cbiAgYXN5bmMgc2VhcmNoKHNlYXJjaF90ZXh0LCBmaWx0ZXIgPSB7fSkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXRoaXMucGx1Z2luLmVudj8uc21hcnRfYmxvY2tzPy5zbWFydF9lbWJlZCAmJiAhdGhpcy5wbHVnaW4uZW52Py5zbWFydF9ub3Rlcz8uc21hcnRfZW1iZWQpIHtcbiAgICAgICAgdGhpcy5wbHVnaW4ubm90aWNlcy5zaG93KFwiZW1iZWQgbW9kZWwgbm90IGxvYWRlZFwiLCBcIkVtYmVkIG1vZGVsIG5vdCBsb2FkZWQuIFBsZWFzZSB3YWl0IGZvciB0aGUgbW9kZWwgdG8gbG9hZCBhbmQgdHJ5IGFnYWluLlwiKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgLy8gaGFzIGVtYmVkZGluZ3MsIGNvbXBsZXRlIHNlYXJjaFxuICAgICAgY29uc3QgY29sbGVjdGlvbiA9IHRoaXMucGx1Z2luLmVudj8uc21hcnRfYmxvY2tzPy5zbWFydF9lbWJlZCA/IHRoaXMucGx1Z2luLmVudi5zbWFydF9ibG9ja3MgOiB0aGlzLnBsdWdpbi5lbnYuc21hcnRfbm90ZXM7XG4gICAgICBjb25zdCBlbWJlZGRpbmcgPSBhd2FpdCBjb2xsZWN0aW9uLnNtYXJ0X2VtYmVkLmVtYmVkKHNlYXJjaF90ZXh0KTtcbiAgICAgIGlmKCFlbWJlZGRpbmc/LnZlYyl7XG4gICAgICAgIHRoaXMubWFpbi5ub3RpY2VzLnNob3coXCJlbWJlZCBzZWFyY2ggdGV4dCBmYWlsZWRcIiwgXCJGYWlsZWQgdG8gZW1iZWQgc2VhcmNoIHRleHQuXCIpXG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLm5lYXJlc3QoZW1iZWRkaW5nLnZlYywgZmlsdGVyKVxuICAgICAgICAvLyBzb3J0IGJ5IHNpbSBkZXNjXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgaWYgKGEuc2ltID4gYi5zaW0pIHJldHVybiAtMTtcbiAgICAgICAgICBpZiAoYS5zaW0gPCBiLnNpbSkgcmV0dXJuIDE7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0pXG4gICAgICA7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5tYWluLm5vdGljZXMuc2hvdygnZXJyb3IgaW4gZW1iZWRkaW5nIHNlYXJjaCcsIFwiRXJyb3IgaW4gZW1iZWRkaW5nIHNlYXJjaC4gU2VlIGNvbnNvbGUgZm9yIGRldGFpbHMuXCIsIHsgdGltZW91dDogMCB9KTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICByZXR1cm4gW107IC8vIHJlc3AgaXMgbnVsbCwgdW5kZWZpbmVkLCBvciBtaXNzaW5nIGRhdGFcbiAgICB9XG4gIH1cbn1cbmV4cG9ydHMuU21hcnRTZWFyY2ggPSBTbWFydFNlYXJjaDtcbiIsICJjb25zdCB7IHNldEljb24gfSA9IHJlcXVpcmUoXCJvYnNpZGlhblwiKTtcbmNsYXNzIFNtYXJ0Tm90aWNlcyB7XG4gIGNvbnN0cnVjdG9yKG1haW4pIHtcbiAgICB0aGlzLm1haW4gPSBtYWluOyAvLyBtYWluIHBsdWdpbiBpbnN0YW5jZVxuICAgIHRoaXMuYWN0aXZlID0ge307XG4gIH1cbiAgc2hvdyhpZCwgbWVzc2FnZSwgb3B0cyA9IHt9KSB7XG4gICAgaWYodHlwZW9mIG9wdHMudGltZW91dCA9PT0gJ3VuZGVmaW5lZCcpIG9wdHMudGltZW91dCA9IDUwMDA7IC8vIGRlZmF1bHQgdGltZW91dFxuICAgIC8vIGlmIG5vdGljZSBpcyBtdXRlZCwgcmV0dXJuXG4gICAgaWYgKHRoaXMubWFpbi5zZXR0aW5ncy5tdXRlZF9ub3RpY2VzPy5baWRdKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyhcIk5vdGljZSBpcyBtdXRlZFwiKTtcbiAgICAgIGlmKG9wdHMuY29uZmlybSAmJiB0eXBlb2Ygb3B0cy5jb25maXJtLmNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSBvcHRzLmNvbmZpcm0uY2FsbGJhY2suY2FsbCgpOyAvLyBpZiBjb25maXJtIGNhbGxiYWNrLCBydW4gaXRcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY29udGVudCA9IHRoaXMuYnVpbGQoaWQsIG1lc3NhZ2UsIG9wdHMpO1xuICAgIC8vIGlmIG5vdGljZSBpcyBhbHJlYWR5IGFjdGl2ZSwgdXBkYXRlIG1lc3NhZ2VcbiAgICBpZiAodGhpcy5hY3RpdmVbaWRdICYmIHRoaXMuYWN0aXZlW2lkXS5ub3RpY2VFbD8ucGFyZW50RWxlbWVudCkge1xuICAgICAgLy8gY29uc29sZS5sb2coXCJ1cGRhdGluZyBub3RpY2VcIik7XG4gICAgICByZXR1cm4gdGhpcy5hY3RpdmVbaWRdLnNldE1lc3NhZ2UoY29udGVudCwgb3B0cy50aW1lb3V0KTtcbiAgICB9XG4gICAgLy8gY29uc29sZS5sb2coXCJzaG93aW5nIG5vdGljZVwiKTtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXIoaWQsIGNvbnRlbnQsIG9wdHMpO1xuICB9XG4gIHJlbmRlcihpZCwgY29udGVudCwgb3B0cykge1xuICAgIHRoaXMuYWN0aXZlW2lkXSA9IG5ldyB0aGlzLm1haW4ub2JzaWRpYW4uTm90aWNlKGNvbnRlbnQsIG9wdHMudGltZW91dCk7XG4gICAgcmV0dXJuIHRoaXMuYWN0aXZlW2lkXTtcbiAgfVxuICBidWlsZChpZCwgbWVzc2FnZSwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICBjb25zdCBoZWFkID0gZnJhZy5jcmVhdGVFbChcInBcIiwgeyBjbHM6IFwic2Mtbm90aWNlLWhlYWRcIiwgdGV4dDogXCJbU21hcnQgQ29ubmVjdGlvbnNdXCIgfSk7XG4gICAgY29uc3QgY29udGVudCA9IGZyYWcuY3JlYXRlRWwoXCJwXCIsIHsgY2xzOiBcInNjLW5vdGljZS1jb250ZW50XCIgfSk7XG4gICAgY29uc3QgYWN0aW9ucyA9IGZyYWcuY3JlYXRlRWwoXCJkaXZcIiwgeyBjbHM6IFwic2Mtbm90aWNlLWFjdGlvbnNcIiB9KTtcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSBjb250ZW50LmlubmVyVGV4dCA9IG1lc3NhZ2U7XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShtZXNzYWdlKSkgY29udGVudC5pbm5lckhUTUwgPSBtZXNzYWdlLmpvaW4oXCI8YnI+XCIpO1xuICAgIGlmKCFvcHRzLmltbXV0YWJsZSkgdGhpcy5hZGRfbXV0ZV9idG4oaWQsIGFjdGlvbnMpO1xuICAgIGlmKG9wdHMuY29uZmlybSkgdGhpcy5hZGRfYnRuKG9wdHMuY29uZmlybSwgYWN0aW9ucyk7XG4gICAgaWYob3B0cy5idXR0b24pIHRoaXMuYWRkX2J0bihvcHRzLmJ1dHRvbiwgYWN0aW9ucyk7XG4gICAgcmV0dXJuIGZyYWc7XG4gIH1cbiAgYWRkX2J0bihidXR0b24sIGNvbnRhaW5lcikge1xuICAgIGNvbnN0IGJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgYnRuLmlubmVySFRNTCA9IGJ1dHRvbi50ZXh0O1xuICAgIGJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGUpID0+IHtcbiAgICAgIGlmIChidXR0b24uc3RheV9vcGVuKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICAgIGJ1dHRvbi5jYWxsYmFjaygpO1xuICAgIH0pO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChidG4pO1xuICB9XG4gIGFkZF9tdXRlX2J0bihpZCwgY29udGFpbmVyKSB7XG4gICAgY29uc3QgYnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICBzZXRJY29uKGJ0biwgXCJiZWxsLW9mZlwiKTtcbiAgICAvLyBidG4uaW5uZXJIVE1MID0gXCJNdXRlXCI7XG4gICAgYnRuLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMubWFpbi5zZXR0aW5ncy5tdXRlZF9ub3RpY2VzKSB0aGlzLm1haW4uc2V0dGluZ3MubXV0ZWRfbm90aWNlcyA9IHt9O1xuICAgICAgdGhpcy5tYWluLnNldHRpbmdzLm11dGVkX25vdGljZXNbaWRdID0gdHJ1ZTtcbiAgICAgIHRoaXMubWFpbi5zYXZlX3NldHRpbmdzKCk7XG4gICAgICB0aGlzLnNob3coXCJOb3RpY2UgbXV0ZWRcIiwgXCJOb3RpY2UgbXV0ZWRcIiwgeyB0aW1lb3V0OiAyMDAwIH0pO1xuICAgIH0pO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChidG4pO1xuICB9XG4gIHVubG9hZCgpIHtcbiAgICBmb3IgKGxldCBpZCBpbiB0aGlzLmFjdGl2ZSkge1xuICAgICAgdGhpcy5yZW1vdmUoaWQpO1xuICAgIH1cbiAgfVxuICByZW1vdmUoaWQpIHtcbiAgICB0aGlzLmFjdGl2ZVtpZF0/LmhpZGUoKTtcbiAgICBkZWxldGUgdGhpcy5hY3RpdmVbaWRdO1xuICB9XG4gIC8vIGJlZ2luIHBsdWdpbiBzcGVjaWZpYyBtZXRob2RzXG4gIHNob3dfcmVxdWlyZXNfc21hcnRfdmlldygpIHtcbiAgICBjb25zdCBidG4gPSB7IHRleHQ6IFwiT3BlbiBTbWFydCBWaWV3XCIsIGNhbGxiYWNrOiAoKSA9PiB7IHRoaXMubWFpbi5vcGVuX3ZpZXcoZmFsc2UpOyB9IH07XG4gICAgY29uc3QgbXNnID0gXCJTbWFydCBWaWV3IG11c3QgYmUgb3BlbiB0byB1dGlsaXplIGFsbCBTbWFydCBDaGF0IGZlYXR1cmVzLiBGb3IgZXhhbXBsZSwgYXNraW5nIHRoaW5ncyBsaWtlIFxcXCJCYXNlZCBvbiBteSBub3Rlcy4uLlxcXCIgcmVxdWlyZXMgU21hcnQgVmlldyB0byBiZSBvcGVuLlwiO1xuICAgIHRoaXMuc2hvdygncmVxdWlyZXMgc21hcnQgdmlldycsIG1zZywgeyBidXR0b246IGJ0biwgdGltZW91dDogMCB9KTtcbiAgfVxufVxuZXhwb3J0cy5TbWFydE5vdGljZXMgPSBTbWFydE5vdGljZXM7IiwgImNvbnN0IHsgU21hcnRTZXR0aW5ncyB9ID0gcmVxdWlyZShcIi4vc21hcnRfc2V0dGluZ3NcIik7XG5jb25zdCBzbWFydF9lbWJlZF9tb2RlbHMgPSByZXF1aXJlKFwic21hcnQtZW1iZWQtbW9kZWwvbW9kZWxzLmpzb25cIik7XG5jb25zdCB7IFNtYXJ0Q2hhdFNldHRpbmdzIH0gPSByZXF1aXJlKFwiLi9zbWFydF9jaGF0X3NldHRpbmdzXCIpO1xuY29uc3QgeyBTbWFydEVtYmVkU2V0dGluZ3MgfSA9IHJlcXVpcmUoXCIuL3NtYXJ0X2VtYmVkX3NldHRpbmdzXCIpO1xuXG4vLyBTbWFydCBDb25uZWN0aW9ucyBTcGVjaWZpYyBTZXR0aW5nc1xuY2xhc3MgU2NTZXR0aW5ncyBleHRlbmRzIFNtYXJ0U2V0dGluZ3Mge1xuICBjb25zdHJ1Y3RvcihlbnYsIGNvbnRhaW5lciwgdGVtcGxhdGVfbmFtZSA9IFwic21hcnRfc2V0dGluZ3NcIikge1xuICAgIHN1cGVyKGVudiwgY29udGFpbmVyLCB0ZW1wbGF0ZV9uYW1lKTtcbiAgICB0aGlzLmNoYXRfc2V0dGluZ3MgPSBuZXcgU21hcnRDaGF0U2V0dGluZ3MoZW52LCBjb250YWluZXIsIHRlbXBsYXRlX25hbWUpO1xuICAgIHRoaXMuZW1iZWRfc2V0dGluZ3MgPSBuZXcgU21hcnRFbWJlZFNldHRpbmdzKGVudiwgY29udGFpbmVyLCB0ZW1wbGF0ZV9uYW1lKTtcbiAgfVxuICB1cGRhdGVfc21hcnRfY2hhdF9mb2xkZXIoKSB7IHRoaXMuY2hhdF9zZXR0aW5ncy51cGRhdGVfc21hcnRfY2hhdF9mb2xkZXIoKTsgfVxuICBhc3luYyBjaGFuZ2VkX3NtYXJ0X2NoYXRfbW9kZWwoKXtcbiAgICBhd2FpdCB0aGlzLmNoYXRfc2V0dGluZ3MuY2hhbmdlZF9zbWFydF9jaGF0X21vZGVsKGZhbHNlKTtcbiAgICB0aGlzLnJlbmRlcigpO1xuICB9XG4gIGFzeW5jIHRlc3RfY2hhdF9hcGlfa2V5KCl7IGF3YWl0IHRoaXMuY2hhdF9zZXR0aW5ncy50ZXN0X2NoYXRfYXBpX2tleSgpOyB9XG4gIGdldCBzZWxmX3JlZl9saXN0KCkgeyByZXR1cm4gdGhpcy5jaGF0X3NldHRpbmdzLnNlbGZfcmVmX2xpc3Q7IH1cblxuICBhc3luYyByZWZyZXNoX25vdGVzKCkge1xuICAgIHRoaXMuZW52LnNtYXJ0X25vdGVzLmltcG9ydCh0aGlzLmVudi5maWxlcywgeyByZXNldDogdHJ1ZSB9KTtcbiAgfVxuICByZWxvYWRfZW52KCkgeyB0aGlzLmVudi5yZWxvYWQoKTsgfSAvLyBERVBSRUNBVEVEXG4gIHJlc3RhcnRfcGx1Z2luKCkgeyB0aGlzLnBsdWdpbi5yZXN0YXJ0X3BsdWdpbigpOyB9XG4gIGZvcmNlX3JlZnJlc2goKSB7IHRoaXMuZW52LmZvcmNlX3JlZnJlc2goKTsgfVxuICBzeW5jX2Zvcl9jaGF0Z3B0KCkgeyB0aGlzLnBsdWdpbi5zeW5jX25vdGVzKCk7IH1cbiAgdXBkYXRlX3NtYXJ0X2Nvbm5lY3Rpb25zX2ZvbGRlcigpIHsgdGhpcy5wbHVnaW4udXBkYXRlX3NtYXJ0X2Nvbm5lY3Rpb25zX2ZvbGRlcigpOyB9XG4gIHJlZnJlc2hfc21hcnRfdmlldygpIHsgdGhpcy5lbWJlZF9zZXR0aW5ncy5yZWZyZXNoX3NtYXJ0X3ZpZXcoKTsgfVxuICBhc3luYyBjb25uZWN0X3RvX3NtYXJ0X2Nvbm5lY3QoKXsgYXdhaXQgdGhpcy5lbWJlZF9zZXR0aW5ncy5jb25uZWN0X3RvX3NtYXJ0X2Nvbm5lY3QoKTsgfVxuICAvLyB0ZXN0IEFQSSBrZXlcbiAgYXN5bmMgdGVzdF9hcGlfa2V5X29wZW5haV9lbWJlZGRpbmdzKCkgeyBhd2FpdCB0aGlzLmVtYmVkX3NldHRpbmdzLnRlc3RfYXBpX2tleV9vcGVuYWlfZW1iZWRkaW5ncygpOyB9XG4gIGFzeW5jIGV4Y2x1ZGVfYWxsX3RvcF9sZXZlbF9mb2xkZXJzKCkge1xuICAgIGNvbnN0IGZvbGRlcnMgPSAoYXdhaXQgdGhpcy5hcHAudmF1bHQuYWRhcHRlci5saXN0KFwiL1wiKSkuZm9sZGVycztcbiAgICBjb25zdCBpbnB1dCA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCJkaXZbZGF0YS1zZXR0aW5nPSdmb2xkZXJfZXhjbHVzaW9ucyddIGlucHV0XCIpO1xuICAgIGlucHV0LnZhbHVlID0gZm9sZGVycy5qb2luKFwiLCBcIik7XG4gICAgaW5wdXQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJpbnB1dFwiKSk7IC8vIHNlbmQgdXBkYXRlIGV2ZW50XG4gICAgdGhpcy51cGRhdGVfZXhjbHVzaW9ucygpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZV9sYW5ndWFnZShzZXR0aW5nLCB2YWx1ZSwgZWxtKSB7XG4gICAgYXdhaXQgdGhpcy51cGRhdGUoJ2xhbmd1YWdlJywgdmFsdWUpO1xuICAgIGNvbnN0IHNlbGZfcmVmX3Byb25vdW5zX2xpc3QgPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiI3NlbGYtcmVmZXJlbnRpYWwtcHJvbm91bnNcIik7XG4gICAgc2VsZl9yZWZfcHJvbm91bnNfbGlzdC5zZXRUZXh0KHRoaXMuc2VsZl9yZWZfbGlzdCk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlX2V4Y2x1c2lvbnMoKSB7XG4gICAgdGhpcy5wbHVnaW4uZW52Ll9maWxlX2V4Y2x1c2lvbnMgPSBudWxsOyAvLyBjbGVhciBmaWxlIGV4Y2x1c2lvbnMgY2FjaGVcbiAgICB0aGlzLnBsdWdpbi5lbnYuX2ZvbGRlcl9leGNsdXNpb25zID0gbnVsbDsgLy8gY2xlYXIgZm9sZGVyIGV4Y2x1c2lvbnMgY2FjaGVcbiAgICBjb25zb2xlLmxvZyhcInJlbmRlcl9maWxlX2NvdW50c1wiKTtcbiAgICBjb25zdCBlbG0gPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiI2ZpbGUtY291bnRzXCIpO1xuICAgIGNvbnNvbGUubG9nKFwiZWxtXCIsIGVsbSk7XG4gICAgY29uc3QgdG90YWxfZmlsZXMgPSB0aGlzLnBsdWdpbi5lbnYuYWxsX2ZpbGVzLmxlbmd0aDtcbiAgICBjb25zdCBpbmNsdWRlZF9maWxlcyA9IHRoaXMucGx1Z2luLmVudi5maWxlcy5sZW5ndGg7XG4gICAgZWxtLnNldFRleHQoYEluY2x1ZGVkIGZpbGVzOiAke2luY2x1ZGVkX2ZpbGVzfSAvIFRvdGFsIGZpbGVzOiAke3RvdGFsX2ZpbGVzfWApO1xuICB9XG4gIGdldCB0ZW1wbGF0ZSgpIHsgcmV0dXJuIHRoaXMudGVtcGxhdGVzWydzbWFydF9zZXR0aW5ncyddOyB9XG4gIGFzeW5jIGdldF92aWV3X2RhdGEoKSB7XG4gICAgY29uc3Qgdmlld19kYXRhID0ge1xuICAgICAgc2V0dGluZ3M6IHRoaXMucGx1Z2luLnNldHRpbmdzLFxuICAgICAgZW1iZWRkaW5nX21vZGVsczogT2JqZWN0LmtleXMoc21hcnRfZW1iZWRfbW9kZWxzKS5tYXAobW9kZWxfa2V5ID0+ICh7IGtleTogbW9kZWxfa2V5LCAuLi5zbWFydF9lbWJlZF9tb2RlbHNbbW9kZWxfa2V5XSB9KSksXG4gICAgICBpbmNsdWRlZF9maWxlczogdGhpcy5wbHVnaW4uZW52LmZpbGVzLmxlbmd0aCxcbiAgICAgIHRvdGFsX2ZpbGVzOiB0aGlzLnBsdWdpbi5lbnYuYWxsX2ZpbGVzLmxlbmd0aCxcbiAgICAgIG11dGVkX25vdGljZXM6IHRoaXMucGx1Z2luLnNldHRpbmdzLm11dGVkX25vdGljZXMgfHwgZmFsc2UsXG4gICAgICAuLi4oKGF3YWl0IHRoaXMuY2hhdF9zZXR0aW5ncy5nZXRfdmlld19kYXRhKCkpIHx8IHt9KSxcbiAgICAgIC4uLigoYXdhaXQgdGhpcy5lbWJlZF9zZXR0aW5ncy5nZXRfdmlld19kYXRhKCkpIHx8IHt9KSxcbiAgICB9O1xuICAgIHJldHVybiB2aWV3X2RhdGE7XG4gIH1cbiAgdW5tdXRlX25vdGljZShzZXR0aW5nKSB7XG4gICAgY29uc3QgaWQgPSBzZXR0aW5nLnNwbGl0KFwiLlwiKVsxXTtcbiAgICBjb25zb2xlLmxvZyhcInVubXV0ZV9ub3RpY2VcIiwgaWQpO1xuICAgIGRlbGV0ZSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5tdXRlZF9ub3RpY2VzW2lkXTtcbiAgICB0aGlzLnVwZGF0ZShcIm11dGVkX25vdGljZXNcIiwgdGhpcy5wbHVnaW4uc2V0dGluZ3MubXV0ZWRfbm90aWNlcyk7XG4gICAgdGhpcy5yZW5kZXIoKTsgLy8gcmUtcmVuZGVyIHNldHRpbmdzXG4gIH1cbiAgLy8gdXBncmFkZSB0byBlYXJseSBhY2Nlc3NcbiAgYXN5bmMgdXBncmFkZV90b19lYXJseV9hY2Nlc3MoKSB7XG4gICAgYXdhaXQgdGhpcy5wbHVnaW4udXBkYXRlX2Vhcmx5X2FjY2VzcygpO1xuICB9XG59XG5leHBvcnRzLlNjU2V0dGluZ3MgPSBTY1NldHRpbmdzO1xuXG4iLCAiY29uc3QgeyBQbHVnaW5TZXR0aW5nVGFiIH0gPSByZXF1aXJlKFwib2JzaWRpYW5cIik7XG5cbmNsYXNzIFNjU2V0dGluZ3NUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcbiAgY29uc3RydWN0b3IoYXBwLCBwbHVnaW4pIHtcbiAgICBzdXBlcihhcHAsIHBsdWdpbik7XG4gICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG4gICAgdGhpcy5jb25maWcgPSBwbHVnaW4uc2V0dGluZ3M7XG4gIH1cbiAgZGlzcGxheSgpIHtcbiAgICB0aGlzLnNtYXJ0X3NldHRpbmdzID0gbmV3IHRoaXMucGx1Z2luLlNjU2V0dGluZ3ModGhpcy5wbHVnaW4uZW52LCB0aGlzLmNvbnRhaW5lckVsKTtcbiAgICByZXR1cm4gdGhpcy5zbWFydF9zZXR0aW5ncy5yZW5kZXIoKTtcbiAgfVxufVxuZXhwb3J0cy5TY1NldHRpbmdzVGFiID0gU2NTZXR0aW5nc1RhYjtcbiIsICJjb25zdCBlanMgPSByZXF1aXJlKFwiLi4vZWpzLm1pblwiKTtcbmNvbnN0IHZpZXdzID0gcmVxdWlyZShcIi4uL2J1aWxkL3ZpZXdzLmpzb25cIik7XG5cbmNsYXNzIFNjQWN0aW9uc1V4IHtcbiAgY29uc3RydWN0b3IocGx1Z2luLCBjb250YWluZXIpIHtcbiAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgfVxuICBjaGFuZ2VfY29kZV9ibG9jayhjb2RlKSB7XG4gICAgY29uc3QgYWN0aXZlX2ZpbGUgPSB0aGlzLnBsdWdpbi5hcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTtcbiAgICBjb25zdCBub3RlX3BhdGggPSBhY3RpdmVfZmlsZS5wYXRoO1xuICAgIC8vIENyZWF0ZSBkaXYgZm9yIG5ldyBjb250ZW50XG4gICAgY29uc3Qgb2xkX2NvbnRlbnQgPSBjb2RlLnN1YnN0cmluZyhjb2RlLmluZGV4T2YoXCI8PDw8PDw8IE9SSUdJTkFMXFxuXCIpICsgXCI8PDw8PDw8IE9SSUdJTkFMXFxuXCIubGVuZ3RoLCBjb2RlLmluZGV4T2YoXCI9PT09PT09XCIpKTtcbiAgICBjb25zdCBuZXdfY29udGVudCA9IGNvZGUuc3Vic3RyaW5nKGNvZGUuaW5kZXhPZihcIj09PT09PT1cXG5cIikgKyBcIj09PT09PT1cXG5cIi5sZW5ndGgsIGNvZGUuaW5kZXhPZihcIj4+Pj4+Pj5cIikpO1xuICAgIC8vIENhbGN1bGF0ZSB0aW1lIHNhdmVkIGluIG1pbnV0ZXMgYmFzZWQgb24gNTB3cG0gdHlwaW5nIHNwZWVkIGFuZCBuZXcgY29udGVudCBsZW5ndGhcbiAgICBjb25zdCB0aW1lX3NhdmVkID0gKE1hdGgucm91bmQobmV3X2NvbnRlbnQuc3BsaXQoXCIgXCIpLmxlbmd0aCAvIDUwKSB8fCAxKSArIFwiIG1pblwiO1xuICAgIHRoaXMuY29udGFpbmVyLmlubmVySFRNTCA9IHRoaXMucmVuZGVyX3RlbXBsYXRlKFwic2NfY2hhbmdlXCIsIHsgbmV3X2NvbnRlbnQsIG9sZF9jb250ZW50LCB0aW1lX3NhdmVkIH0pO1xuXG4gICAgY29uc29sZS5sb2codGhpcy5jb250YWluZXIpO1xuICAgIGNvbnN0IG5ld19jb250ZW50X2NvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5uZXctY29udGVudCcpO1xuICAgIGNvbnN0IG9sZF9jb250ZW50X2NvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5vbGQtY29udGVudCcpO1xuICAgIHRoaXMucGx1Z2luLm9ic2lkaWFuLk1hcmtkb3duUmVuZGVyZXIucmVuZGVyTWFya2Rvd24obmV3X2NvbnRlbnQsIG5ld19jb250ZW50X2NvbnRhaW5lciwgbm90ZV9wYXRoLCBuZXcgdGhpcy5wbHVnaW4ub2JzaWRpYW4uQ29tcG9uZW50KCkpO1xuICAgIHRoaXMucGx1Z2luLm9ic2lkaWFuLk1hcmtkb3duUmVuZGVyZXIucmVuZGVyTWFya2Rvd24ob2xkX2NvbnRlbnQsIG9sZF9jb250ZW50X2NvbnRhaW5lciwgbm90ZV9wYXRoLCBuZXcgdGhpcy5wbHVnaW4ub2JzaWRpYW4uQ29tcG9uZW50KCkpO1xuICAgIC8vIFNob3cgb2xkIGNvbnRlbnQgKGJ1dHRvbiB3aGVyZSBidXR0b24gdGV4dCBpcyBcIlNob3cgT2xkXCIpXG4gICAgY29uc3Qgc2hvd19vbGRfYnV0dG9uID0gdGhpcy5nZXRfYnV0dG9uX2J5X3RleHQoXCJTaG93IE9sZFwiKTtcbiAgICBjb25zdCBoaWRlX29sZF9idXR0b24gPSB0aGlzLmdldF9idXR0b25fYnlfdGV4dChcIkhpZGUgT2xkXCIpO1xuICAgIHNob3dfb2xkX2J1dHRvbi5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgb2xkX2NvbnRlbnRfY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgc2hvd19vbGRfYnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICBoaWRlX29sZF9idXR0b24uc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xuICAgIH1cbiAgICBoaWRlX29sZF9idXR0b24ub25jbGljayA9ICgpID0+IHtcbiAgICAgIG9sZF9jb250ZW50X2NvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgc2hvd19vbGRfYnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztcbiAgICAgIGhpZGVfb2xkX2J1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH1cbiAgICAvLyBhcHByb3ZlIChhY2NlcHQpIGJ1dHRvblxuICAgIGNvbnN0IGFwcHJvdmVfYnV0dG9uID0gdGhpcy5nZXRfYnV0dG9uX2J5X3RleHQoXCJBY2NlcHRcIik7XG4gICAgYXBwcm92ZV9idXR0b24ub25jbGljayA9IGFzeW5jICgpID0+IHtcbiAgICAgIC8vIHVwZGF0ZSBub3RlIHRvIHJlcGxhY2UgY29kZSBibG9jayB3aXRoIG5ldyBjb250ZW50XG4gICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy5wbHVnaW4uYXBwLnZhdWx0LmNhY2hlZFJlYWQoYWN0aXZlX2ZpbGUpO1xuICAgICAgY29uc3QgdXBkYXRlZF9jb250ZW50ID0gY29udGVudC5yZXBsYWNlKFwiYGBgc2MtY2hhbmdlXFxuXCIgKyBjb2RlICsgXCJcXG5gYGBcIiwgbmV3X2NvbnRlbnQudHJpbSgpKTtcbiAgICAgIGF3YWl0IHRoaXMucGx1Z2luLmFwcC52YXVsdC5tb2RpZnkoYWN0aXZlX2ZpbGUsIHVwZGF0ZWRfY29udGVudCk7XG4gICAgICAvLyBhcHBlbmRlZCB0byBhY2NlcHRlZF9jaGFuZ2VzIGZpbGVcbiAgICAgIGF3YWl0IHRoaXMuYXBwZW5kX2FjY2VwdGVkX2NoYW5nZXMoeyBub3RlX3BhdGgsIG9sZF9jb250ZW50LCBuZXdfY29udGVudCwgdGltZV9zYXZlZCB9KTtcblxuICAgIH1cbiAgICAvLyByZWplY3QgYnV0dG9uXG4gICAgY29uc3QgcmVqZWN0X2J1dHRvbiA9IHRoaXMuZ2V0X2J1dHRvbl9ieV90ZXh0KFwiUmVqZWN0XCIpO1xuICAgIHJlamVjdF9idXR0b24ub25jbGljayA9IGFzeW5jICgpID0+IHtcbiAgICAgIC8vIHVwZGF0ZSBub3RlIHRvIHJlcGxhY2UgY29kZSBibG9jayB3aXRoIG9sZCBjb250ZW50XG4gICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy5wbHVnaW4uYXBwLnZhdWx0LmNhY2hlZFJlYWQoYWN0aXZlX2ZpbGUpO1xuICAgICAgY29uc3QgdXBkYXRlZF9jb250ZW50ID0gY29udGVudC5yZXBsYWNlKFwiYGBgc2MtY2hhbmdlXFxuXCIgKyBjb2RlICsgXCJcXG5gYGBcIiwgb2xkX2NvbnRlbnQudHJpbSgpKTtcbiAgICAgIGF3YWl0IHRoaXMucGx1Z2luLmFwcC52YXVsdC5tb2RpZnkoYWN0aXZlX2ZpbGUsIHVwZGF0ZWRfY29udGVudCk7XG4gICAgfVxuXG4gIH1cbiAgYXN5bmMgYXBwZW5kX2FjY2VwdGVkX2NoYW5nZXMoY2hhbmdlKSB7XG4gICAgY29uc3QgZmlsZV9wYXRoID0gdGhpcy5wbHVnaW4uc2V0dGluZ3Muc21hcnRfY29ubmVjdGlvbnNfZm9sZGVyICsgXCIvYWNjZXB0ZWRfY2hhbmdlcy5uZGpzb25cIjtcbiAgICBpZighKGF3YWl0IHRoaXMucGx1Z2luLmFwcC52YXVsdC5leGlzdHMoZmlsZV9wYXRoKSkpe1xuICAgICAgY29uc29sZS5sb2coXCJGaWxlIGRvZXMgbm90IGV4aXN0LCBjcmVhdGluZyBpdFwiKTtcbiAgICAgIGF3YWl0IHRoaXMucGx1Z2luLmFwcC52YXVsdC5jcmVhdGUoZmlsZV9wYXRoLCBcIlwiKTtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5wbHVnaW4uYXBwLnZhdWx0LmFkYXB0ZXIuYXBwZW5kKGZpbGVfcGF0aCwgSlNPTi5zdHJpbmdpZnkoY2hhbmdlKSArIFwiXFxuXCIpO1xuICB9XG4gIHJlbmRlcl90ZW1wbGF0ZSh0ZW1wbGF0ZV9uYW1lLCBkYXRhKSB7XG4gICAgaWYgKCF2aWV3c1t0ZW1wbGF0ZV9uYW1lXSkgdGhyb3cgbmV3IEVycm9yKGBUZW1wbGF0ZSAnJHt0ZW1wbGF0ZV9uYW1lfScgbm90IGZvdW5kLmApO1xuICAgIHJldHVybiBlanMucmVuZGVyKHZpZXdzW3RlbXBsYXRlX25hbWVdLCBkYXRhLCB7IGNvbnRleHQ6IHRoaXMgfSk7XG4gIH1cbiAgZ2V0X2J1dHRvbl9ieV90ZXh0KHRleHQpIHsgcmV0dXJuIGdldF9idXR0b25fYnlfdGV4dCh0aGlzLmNvbnRhaW5lciwgdGV4dCk7IH1cbiAgZ2V0X2ljb24obmFtZSkgeyByZXR1cm4gdGhpcy5wbHVnaW4ub2JzaWRpYW4uZ2V0SWNvbihuYW1lKS5vdXRlckhUTUw7IH1cbiAgZ2V0IGF0dHJpYnV0aW9uKCkgeyByZXR1cm4gdmlld3MuYXR0cmlidXRpb247IH1cbn1cbmZ1bmN0aW9uIGdldF9idXR0b25fYnlfdGV4dChjb250YWluZXIsIHRleHQpIHsgcmV0dXJuIEFycmF5LmZyb20oY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ2J1dHRvbicpKS5maW5kKGJ1dHRvbiA9PiBidXR0b24udGV4dENvbnRlbnQgPT09IHRleHQpOyB9XG5leHBvcnRzLlNjQWN0aW9uc1V4ID0gU2NBY3Rpb25zVXg7XG5cbiIsICJhc3luYyBmdW5jdGlvbiBvcGVuX25vdGUocGx1Z2luLCB0YXJnZXRfcGF0aCwgZXZlbnQ9bnVsbCkge1xuICBsZXQgdGFyZ2V0RmlsZTtcbiAgbGV0IGhlYWRpbmc7XG4gIC8vIGlmIGhhcyAjIGFuZCBpcyBsYXN0IGNoYXJhY3RlciwgcmVtb3ZlIGl0XG4gIGlmICh0YXJnZXRfcGF0aFt0YXJnZXRfcGF0aC5sZW5ndGggLSAxXSA9PT0gXCIjXCIpIHRhcmdldF9wYXRoID0gdGFyZ2V0X3BhdGguc2xpY2UoMCwgLTEpO1xuICBpZiAodGFyZ2V0X3BhdGguaW5kZXhPZihcIiNcIikgPiAtMSkge1xuICAgIHRhcmdldEZpbGUgPSBwbHVnaW4uYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0Rmlyc3RMaW5rcGF0aERlc3QodGFyZ2V0X3BhdGguc3BsaXQoXCIjXCIpWzBdLCBcIlwiKTsgLy8gcmVtb3ZlIGFmdGVyICMgZnJvbSBsaW5rXG4gICAgLy8gY29uc29sZS5sb2codGFyZ2V0RmlsZSk7XG4gICAgY29uc3QgdGFyZ2V0X2ZpbGVfY2FjaGUgPSBwbHVnaW4uYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKHRhcmdldEZpbGUpO1xuICAgIC8vIGNvbnNvbGUubG9nKHRhcmdldF9maWxlX2NhY2hlKTtcbiAgICBsZXQgaGVhZGluZ190ZXh0ID0gdGFyZ2V0X3BhdGguc3BsaXQoXCIjXCIpLnBvcCgpOyAvLyBnZXQgaGVhZGluZ1xuICAgIC8vIGlmIGhlYWRpbmcgdGV4dCBjb250YWlucyBhIGN1cmx5IGJyYWNlLCBnZXQgdGhlIG51bWJlciBpbnNpZGUgdGhlIGN1cmx5IGJyYWNlcyBhcyBvY2N1cmVuY2VcbiAgICBsZXQgb2NjdXJlbmNlID0gMDtcbiAgICBpZiAoaGVhZGluZ190ZXh0LmluZGV4T2YoXCJ7XCIpID4gLTEpIHtcbiAgICAgIC8vIGdldCBvY2N1cmVuY2VcbiAgICAgIG9jY3VyZW5jZSA9IHBhcnNlSW50KGhlYWRpbmdfdGV4dC5zcGxpdChcIntcIilbMV0uc3BsaXQoXCJ9XCIpWzBdKTtcbiAgICAgIC8vIHJlbW92ZSBvY2N1cmVuY2UgZnJvbSBoZWFkaW5nIHRleHRcbiAgICAgIGhlYWRpbmdfdGV4dCA9IGhlYWRpbmdfdGV4dC5zcGxpdChcIntcIilbMF07XG4gICAgfVxuICAgIGNvbnN0IGhlYWRpbmdzID0gdGFyZ2V0X2ZpbGVfY2FjaGUuaGVhZGluZ3M7IC8vIGdldCBoZWFkaW5ncyBmcm9tIGZpbGUgY2FjaGVcbiAgICAvLyBnZXQgaGVhZGluZ3Mgd2l0aCB0aGUgc2FtZSBkZXB0aCBhbmQgdGV4dCBhcyB0aGUgbGlua1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBoZWFkaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGhlYWRpbmdzW2ldLmhlYWRpbmcgPT09IGhlYWRpbmdfdGV4dCkge1xuICAgICAgICAvLyBpZiBvY2N1cmVuY2UgaXMgMCwgc2V0IGhlYWRpbmcgYW5kIGJyZWFrXG4gICAgICAgIGlmKG9jY3VyZW5jZSA9PT0gMCkge1xuICAgICAgICAgIGhlYWRpbmcgPSBoZWFkaW5nc1tpXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBvY2N1cmVuY2UtLTsgLy8gZGVjcmVtZW50IG9jY3VyZW5jZVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBjb25zb2xlLmxvZyhoZWFkaW5nKTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXRGaWxlID0gcGx1Z2luLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZpcnN0TGlua3BhdGhEZXN0KHRhcmdldF9wYXRoLCBcIlwiKTtcbiAgfVxuICBsZXQgbGVhZjtcbiAgaWYoZXZlbnQpIHtcbiAgICBjb25zdCBtb2QgPSBwbHVnaW4ub2JzaWRpYW4uS2V5bWFwLmlzTW9kRXZlbnQoZXZlbnQpOyAvLyBwcm9wZXJseSBoYW5kbGUgaWYgdGhlIG1ldGEvY3RybCBrZXkgaXMgcHJlc3NlZFxuICAgIGxlYWYgPSBwbHVnaW4uYXBwLndvcmtzcGFjZS5nZXRMZWFmKG1vZCk7IC8vIGdldCBtb3N0IHJlY2VudCBsZWFmXG4gIH1lbHNle1xuICAgIGxlYWYgPSBwbHVnaW4uYXBwLndvcmtzcGFjZS5nZXRNb3N0UmVjZW50TGVhZigpOyAvLyBnZXQgbW9zdCByZWNlbnQgbGVhZlxuICB9XG4gIGF3YWl0IGxlYWYub3BlbkZpbGUodGFyZ2V0RmlsZSk7XG4gIGlmIChoZWFkaW5nKSB7XG4gICAgbGV0IHsgZWRpdG9yIH0gPSBsZWFmLnZpZXc7XG4gICAgY29uc3QgcG9zID0geyBsaW5lOiBoZWFkaW5nLnBvc2l0aW9uLnN0YXJ0LmxpbmUsIGNoOiAwIH07XG4gICAgZWRpdG9yLnNldEN1cnNvcihwb3MpO1xuICAgIGVkaXRvci5zY3JvbGxJbnRvVmlldyh7IHRvOiBwb3MsIGZyb206IHBvcyB9LCB0cnVlKTtcbiAgfVxufVxuZXhwb3J0cy5vcGVuX25vdGUgPSBvcGVuX25vdGU7IiwgImNvbnN0IHtcbiAgYWRkSWNvbixcbiAgS2V5bWFwLFxuICBNYXJrZG93blJlbmRlcmVyLFxuICBOb3RpY2UsXG4gIFBsdWdpbixcbiAgcmVxdWVzdCxcbiAgcmVxdWVzdFVybCxcbiAgVEFic3RyYWN0RmlsZSxcbiAgVEZpbGUsXG59ID0gcmVxdWlyZShcIm9ic2lkaWFuXCIpO1xuY29uc3QgeyBPYnNBSlNPTiB9ID0gcmVxdWlyZShcInNtYXJ0LWNvbGxlY3Rpb25zL09ic0FKU09OLmpzXCIpOyAvLyBMb2NhbFxuY29uc3QgeyBPYnNNdWx0aUFKU09OIH0gPSByZXF1aXJlKFwic21hcnQtY29sbGVjdGlvbnMvT2JzTXVsdGlBSlNPTi5qc1wiKTsgLy8gTG9jYWxcbmNvbnN0IHsgU2NFbnYgfSA9IHJlcXVpcmUoXCIuL3NjX2VudlwiKTtcbmNvbnN0IHsgZGVmYXVsdF9zZXR0aW5ncyB9ID0gcmVxdWlyZShcIi4vZGVmYXVsdF9zZXR0aW5nc1wiKTtcbi8vIHJlbmFtZSBtb2R1bGVzXG5jb25zdCB7IFNjU21hcnRWaWV3IH0gPSByZXF1aXJlKFwiLi9zY19zbWFydF92aWV3XCIpOyAvLyByZW5hbWUgdG8gc2Nfdmlldy5qc1xuY29uc3QgeyBTbWFydFNlYXJjaCB9ID0gcmVxdWlyZShcIi4vc21hcnRfc2VhcmNoLmpzXCIpOyAvLyByZW5hbWUgdG8gc2Nfc2VhcmNoLmpzXG5jb25zdCB7IFNtYXJ0Tm90aWNlcyB9ID0gcmVxdWlyZShcIi4vc21hcnRfbm90aWNlcy5qc1wiKTsgLy8gcmVuYW1lIHRvIHNjX25vdGljZXMuanMgKGV4dHJhY3Qgc21hcnRfbm90aWNlcy5qcyBhcyBzdGFuZGFyZCBzdHJ1Y3R1cmUgZmlyc3QpXG4vLyB2Mi4xXG5jb25zdCB7IFNjQ2hhdFZpZXcgfSA9IHJlcXVpcmUoXCIuL3NjX2NoYXRfdmlldy5qc1wiKTtcbmNvbnN0IHsgU2NTZXR0aW5ncyB9ID0gcmVxdWlyZShcIi4vc2Nfc2V0dGluZ3MuanNcIik7XG5jb25zdCB7IFNjU2V0dGluZ3NUYWIgfSA9IHJlcXVpcmUoXCIuL3NjX3NldHRpbmdzX3RhYi5qc1wiKTtcbmNvbnN0IGVtYmVkX21vZGVscyA9IHJlcXVpcmUoJ3NtYXJ0LWVtYmVkLW1vZGVsL21vZGVscy5qc29uJyk7XG5jb25zdCB7IFNjQWN0aW9uc1V4IH0gPSByZXF1aXJlKFwiLi9zY19hY3Rpb25zX3V4LmpzXCIpO1xuY29uc3QgeyBvcGVuX25vdGUgfSA9IHJlcXVpcmUoXCIuL29wZW5fbm90ZS5qc1wiKTtcbmNsYXNzIFNtYXJ0Q29ubmVjdGlvbnNQbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRzKCkgeyByZXR1cm4gZGVmYXVsdF9zZXR0aW5ncygpIH1cbiAgZ2V0IGl0ZW1fdmlld3MoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFNjU21hcnRWaWV3LFxuICAgICAgU2NDaGF0VmlldyxcbiAgICB9XG4gIH1cbiAgZ2V0IFNjU2V0dGluZ3MoKSB7IHJldHVybiBTY1NldHRpbmdzIH07XG4gIGFzeW5jIG9wZW5fbm90ZSh0YXJnZXRfcGF0aCwgZXZlbnQ9bnVsbCkgeyBhd2FpdCBvcGVuX25vdGUodGhpcywgdGFyZ2V0X3BhdGgsIGV2ZW50KTsgfVxuICBhc3luYyBsb2FkX3NldHRpbmdzKCkge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgdGhpcy5jb25zdHJ1Y3Rvci5kZWZhdWx0cyk7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLnNldHRpbmdzLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xuICAgIHRoaXMuaGFuZGxlX2RlcHJlY2F0ZWRfc2V0dGluZ3MoKTsgLy8gSEFORExFIERFUFJFQ0FURUQgU0VUVElOR1NcbiAgfVxuICBhc3luYyBvbmxvYWQoKSB7IHRoaXMuYXBwLndvcmtzcGFjZS5vbkxheW91dFJlYWR5KHRoaXMuaW5pdGlhbGl6ZS5iaW5kKHRoaXMpKTsgfSAvLyBpbml0aWFsaXplIHdoZW4gbGF5b3V0IGlzIHJlYWR5XG4gIG9udW5sb2FkKCkge1xuICAgIGNvbnNvbGUubG9nKFwidW5sb2FkaW5nIHBsdWdpblwiKTtcbiAgICB0aGlzLmVudj8udW5sb2FkKCk7XG4gICAgdGhpcy5lbnYgPSBudWxsO1xuICAgIHRoaXMuYnJhaW4gPSBudWxsO1xuICAgIHRoaXMubm90aWNlcz8udW5sb2FkKCk7XG4gIH1cbiAgYXN5bmMgaW5pdGlhbGl6ZSgpIHtcbiAgICBjb25zb2xlLmxvZyhcIkxvYWRpbmcgU21hcnQgQ29ubmVjdGlvbnMgdjIuLi5cIik7XG4gICAgYXdhaXQgdGhpcy5sb2FkX3NldHRpbmdzKCk7XG4gICAgdGhpcy5zbWFydF9jb25uZWN0aW9uc192aWV3ID0gbnVsbDtcbiAgICB0aGlzLmFkZF9jb21tYW5kcygpOyAvLyBhZGQgY29tbWFuZHNcbiAgICB0aGlzLnJlZ2lzdGVyX3ZpZXdzKCk7IC8vIHJlZ2lzdGVyIGNoYXQgdmlldyB0eXBlXG4gICAgdGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBTY1NldHRpbmdzVGFiKHRoaXMuYXBwLCB0aGlzLCBcInNtYXJ0X3NldHRpbmdzXzIxXCIpKTsgLy8gYWRkIHNldHRpbmdzIHRhYlxuICAgIHRoaXMuY2hlY2tfZm9yX3VwZGF0ZXMoKTtcbiAgICB0aGlzLmFkZF90b19naXRpZ25vcmUoXCJcXG5cXG4jIElnbm9yZSBTbWFydCBDb25uZWN0aW9ucyBmb2xkZXJcXG4uc21hcnQtY29ubmVjdGlvbnNcIik7IFxuICAgIHRoaXMuYXBpID0gbmV3IFNtYXJ0U2VhcmNoKHRoaXMpO1xuICAgICh3aW5kb3dbXCJTbWFydFNlYXJjaFwiXSA9IHRoaXMuYXBpKSAmJiB0aGlzLnJlZ2lzdGVyKCgpID0+IGRlbGV0ZSB3aW5kb3dbXCJTbWFydFNlYXJjaFwiXSk7IC8vIHJlZ2lzdGVyIEFQSSB0byBnbG9iYWwgd2luZG93IG9iamVjdFxuICAgIGFkZEljb24oXCJzbWFydC1jb25uZWN0aW9uc1wiLCBgPHBhdGggZD1cIk01MCwyMCBMODAsNDAgTDgwLDYwIEw1MCwxMDBcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCI0XCIgZmlsbD1cIm5vbmVcIi8+XG4gICAgPHBhdGggZD1cIk0zMCw1MCBMNTUsNzBcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCI1XCIgZmlsbD1cIm5vbmVcIi8+XG4gICAgPGNpcmNsZSBjeD1cIjUwXCIgY3k9XCIyMFwiIHI9XCI5XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiLz5cbiAgICA8Y2lyY2xlIGN4PVwiODBcIiBjeT1cIjQwXCIgcj1cIjlcIiBmaWxsPVwiY3VycmVudENvbG9yXCIvPlxuICAgIDxjaXJjbGUgY3g9XCI4MFwiIGN5PVwiNzBcIiByPVwiOVwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIi8+XG4gICAgPGNpcmNsZSBjeD1cIjUwXCIgY3k9XCIxMDBcIiByPVwiOVwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIi8+XG4gICAgPGNpcmNsZSBjeD1cIjMwXCIgY3k9XCI1MFwiIHI9XCI5XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiLz5gKTtcbiAgICB0aGlzLmFkZFJpYmJvbkljb24oXCJzbWFydC1jb25uZWN0aW9uc1wiLCBcIk9wZW46IFZpZXcgU21hcnQgQ29ubmVjdGlvbnNcIiwgKCkgPT4geyB0aGlzLm9wZW5fdmlldygpOyB9KTtcbiAgICB0aGlzLmFkZFJpYmJvbkljb24oXCJtZXNzYWdlLXNxdWFyZVwiLCBcIk9wZW46IFNtYXJ0IENoYXQgQ29udmVyc2F0aW9uXCIsICgpID0+IHsgdGhpcy5vcGVuX2NoYXQoKTsgfSk7XG4gICAgdGhpcy5yZWdpc3Rlck1hcmtkb3duQ29kZUJsb2NrUHJvY2Vzc29yKFwic21hcnQtY29ubmVjdGlvbnNcIiwgdGhpcy5yZW5kZXJfY29kZV9ibG9jay5iaW5kKHRoaXMpKTsgLy8gY29kZS1ibG9jayByZW5kZXJlclxuICAgIHRoaXMucmVnaXN0ZXJNYXJrZG93bkNvZGVCbG9ja1Byb2Nlc3NvcihcInNjLWNvbnRleHRcIiwgdGhpcy5yZW5kZXJfY29kZV9ibG9ja19jb250ZXh0LmJpbmQodGhpcykpOyAvLyBjb2RlLWJsb2NrIHJlbmRlcmVyXG4gICAgLy8gXCJBSSBjaGFuZ2VcIiBkeW5hbWljIGNvZGUgYmxvY2tcbiAgICB0aGlzLnJlZ2lzdGVyTWFya2Rvd25Db2RlQmxvY2tQcm9jZXNzb3IoXCJzYy1jaGFuZ2VcIiwgdGhpcy5jaGFuZ2VfY29kZV9ibG9jay5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLm5vdGljZXMgPSBuZXcgU21hcnROb3RpY2VzKHRoaXMpO1xuICAgIHRoaXMub2JzaWRpYW4gPSByZXF1aXJlKFwib2JzaWRpYW5cIik7XG4gICAgdGhpcy5uZXdfdXNlcigpO1xuICAgIGF3YWl0IHRoaXMubG9hZF9lbnYoKTtcbiAgICBjb25zb2xlLmxvZyhcIlNtYXJ0IENvbm5lY3Rpb25zIHYyIGxvYWRlZFwiKTtcbiAgfVxuICBhc3luYyBsb2FkX2VudigpIHtcbiAgICB0aGlzLmVudiA9IG5ldyBTY0Vudih0aGlzLCAodGhpcy5zZXR0aW5ncy5lbWJlZGRpbmdfZmlsZV9wZXJfbm90ZSA/IE9ic011bHRpQUpTT04gOiBPYnNBSlNPTikpO1xuICAgIHRoaXMuYnJhaW4gPSB0aGlzLmVudjsgLy8gREVQUkVDQVRFRCAodXNlIHRoaXMuZW52IGluc3RlYWQpXG4gICAgYXdhaXQgdGhpcy5lbnYuaW5pdCgpO1xuICB9XG4gIG5ld191c2VyKCkge1xuICAgIGlmKCF0aGlzLnNldHRpbmdzLm5ld191c2VyKSByZXR1cm47XG4gICAgdGhpcy5zZXR0aW5ncy5uZXdfdXNlciA9IGZhbHNlO1xuICAgIHRoaXMuc2V0dGluZ3MudmVyc2lvbiA9IHRoaXMubWFuaWZlc3QudmVyc2lvbjtcbiAgICB0aGlzLm9wZW5fdmlldygpO1xuICAgIHRoaXMub3Blbl9jaGF0KCk7XG4gICAgaWYodGhpcy5hcHAud29ya3NwYWNlLnJpZ2h0U3BsaXQuY29sbGFwc2VkKSB0aGlzLmFwcC53b3Jrc3BhY2UucmlnaHRTcGxpdC50b2dnbGUoKTtcbiAgICB0aGlzLnNhdmVfc2V0dGluZ3MoKTtcbiAgfVxuICByZWdpc3Rlcl92aWV3cygpIHtcbiAgICBPYmplY3QudmFsdWVzKHRoaXMuaXRlbV92aWV3cykuZm9yRWFjaChWaWV3ID0+IHtcbiAgICAgIHRoaXMucmVnaXN0ZXJWaWV3KFZpZXcudmlld190eXBlLCAobGVhZikgPT4gKG5ldyBWaWV3KGxlYWYsIHRoaXMpKSk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgY2hlY2tfZm9yX3VwZGF0ZXMoKSB7XG4gICAgaWYodGhpcy5zZXR0aW5ncy52ZXJzaW9uICE9PSB0aGlzLm1hbmlmZXN0LnZlcnNpb24pe1xuICAgICAgdGhpcy5zZXR0aW5ncy52ZXJzaW9uID0gdGhpcy5tYW5pZmVzdC52ZXJzaW9uOyAvLyB1cGRhdGUgdmVyc2lvblxuICAgICAgYXdhaXQgdGhpcy5zYXZlX3NldHRpbmdzKCk7IC8vIHNhdmUgc2V0dGluZ3NcbiAgICB9XG4gICAgc2V0VGltZW91dCh0aGlzLmNoZWNrX2Zvcl91cGRhdGUuYmluZCh0aGlzKSwgMzAwMCk7IC8vIHJ1biBhZnRlciAzIHNlY29uZHNcbiAgICBzZXRJbnRlcnZhbCh0aGlzLmNoZWNrX2Zvcl91cGRhdGUuYmluZCh0aGlzKSwgMTA4MDAwMDApOyAvLyBydW4gY2hlY2sgZm9yIHVwZGF0ZSBldmVyeSAzIGhvdXJzXG4gIH1cbiAgLy8gY2hlY2sgZm9yIHVwZGF0ZVxuICBhc3luYyBjaGVja19mb3JfdXBkYXRlKCkge1xuICAgIC8vIGZhaWwgc2lsZW50bHksIGV4LiBpZiBubyBpbnRlcm5ldCBjb25uZWN0aW9uXG4gICAgdHJ5IHtcbiAgICAgIC8vIGdldCBsYXRlc3QgcmVsZWFzZSB2ZXJzaW9uIGZyb20gZ2l0aHViXG4gICAgICBjb25zdCB7anNvbjogcmVzcG9uc2V9ID0gYXdhaXQgcmVxdWVzdFVybCh7XG4gICAgICAgIHVybDogXCJodHRwczovL2FwaS5naXRodWIuY29tL3JlcG9zL2JyaWFucGV0cm8vb2JzaWRpYW4tc21hcnQtY29ubmVjdGlvbnMvcmVsZWFzZXMvbGF0ZXN0XCIsXG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICB9LFxuICAgICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICB9KTtcbiAgICAgIC8vIGdldCB2ZXJzaW9uIG51bWJlciBmcm9tIHJlc3BvbnNlXG4gICAgICBjb25zdCBsYXRlc3RfcmVsZWFzZSA9IHJlc3BvbnNlLnRhZ19uYW1lO1xuICAgICAgLy8gY29uc29sZS5sb2coYExhdGVzdCByZWxlYXNlOiAke2xhdGVzdF9yZWxlYXNlfWApO1xuICAgICAgLy8gaWYgbGF0ZXN0X3JlbGVhc2UgaXMgbmV3ZXIgdGhhbiBjdXJyZW50IHZlcnNpb24sIHNob3cgbWVzc2FnZVxuICAgICAgaWYobGF0ZXN0X3JlbGVhc2UgIT09IHRoaXMubWFuaWZlc3QudmVyc2lvbikge1xuICAgICAgICBuZXcgTm90aWNlKGBbU21hcnQgQ29ubmVjdGlvbnNdIEEgbmV3IHZlcnNpb24gaXMgYXZhaWxhYmxlISAodiR7bGF0ZXN0X3JlbGVhc2V9KWApO1xuICAgICAgICB0aGlzLnVwZGF0ZV9hdmFpbGFibGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmxvZyhlcnJvcik7XG4gICAgfVxuICB9XG4gIGFzeW5jIHJlc3RhcnRfcGx1Z2luKCkge1xuICAgIGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7IC8vIHNhdmUgc2V0dGluZ3NcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyID0+IHNldFRpbWVvdXQociwgMzAwMCkpO1xuICAgIHdpbmRvdy5yZXN0YXJ0X3BsdWdpbiA9IGFzeW5jIChpZCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coXCJyZXN0YXJ0aW5nIHBsdWdpblwiLCBpZCk7XG4gICAgICBhd2FpdCB3aW5kb3cuYXBwLnBsdWdpbnMuZGlzYWJsZVBsdWdpbihpZCk7XG4gICAgICBhd2FpdCB3aW5kb3cuYXBwLnBsdWdpbnMuZW5hYmxlUGx1Z2luKGlkKTtcbiAgICAgIGNvbnNvbGUubG9nKFwicGx1Z2luIHJlc3RhcnRlZFwiLCBpZCk7XG4gICAgfTtcbiAgICBhd2FpdCB3aW5kb3cucmVzdGFydF9wbHVnaW4odGhpcy5tYW5pZmVzdC5pZCk7XG4gIH1cblxuICBhZGRfY29tbWFuZHMoKSB7XG4gICAgLy8gbWFrZSBjb25uZWN0aW9ucyBjb21tYW5kXG4gICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgIGlkOiBcInNjLWZpbmQtbm90ZXNcIixcbiAgICAgIG5hbWU6IFwiRmluZDogTWFrZSBTbWFydCBDb25uZWN0aW9uc1wiLFxuICAgICAgaWNvbjogXCJwZW5jaWxfaWNvblwiLFxuICAgICAgaG90a2V5czogW10sXG4gICAgICBlZGl0b3JDYWxsYmFjazogKGVkaXRvcikgPT4ge1xuICAgICAgICBpZihlZGl0b3Iuc29tZXRoaW5nU2VsZWN0ZWQoKSkgdGhpcy52aWV3LnJlbmRlcl9uZWFyZXN0KGVkaXRvci5nZXRTZWxlY3Rpb24oKSk7XG4gICAgICAgIGVsc2UgaWYoZWRpdG9yLmdldEN1cnNvcigpPy5saW5lKXsgLy8gaWYgY3Vyc29yIGlzIG9uIGEgbGluZSBncmVhdGVyIHRoYW4gMFxuICAgICAgICAgIGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0Q3Vyc29yKCkubGluZTtcbiAgICAgICAgICBjb25zdCBibG9jayA9IHRoaXMuYnJhaW4uc21hcnRfbm90ZXMuY3VycmVudF9ub3RlLmdldF9ibG9ja19ieV9saW5lKGxpbmUpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGJsb2NrKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhsaW5lKTtcbiAgICAgICAgICB0aGlzLnZpZXcucmVuZGVyX25lYXJlc3QoYmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgdGhpcy52aWV3LnJlbmRlcl9uZWFyZXN0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gbWFrZSBjb25uZWN0aW9ucyBjb21tYW5kXG4gICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgIGlkOiBcInNjLXJlZnJlc2gtY29ubmVjdGlvbnNcIixcbiAgICAgIG5hbWU6IFwiUmVmcmVzaCAmIE1ha2UgQ29ubmVjdGlvbnNcIixcbiAgICAgIGljb246IFwicGVuY2lsX2ljb25cIixcbiAgICAgIGhvdGtleXM6IFtdLFxuICAgICAgZWRpdG9yQ2FsbGJhY2s6IGFzeW5jIChlZGl0b3IpID0+IHtcbiAgICAgICAgLy8gZ2V0IGN1cnJlbnQgbm90ZVxuICAgICAgICBjb25zdCBjdXJyX2ZpbGUgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xuICAgICAgICAvLyBjb25zdCBjdXJyX25vdGUgPSB0aGlzLmVudj8uc21hcnRfbm90ZXMuZ2V0KGN1cnJfZmlsZS5wYXRoKTtcbiAgICAgICAgLy8gZGVsZXRlIG5vdGUgZW50aXR5IGZyb20gY2FjaGVcbiAgICAgICAgZGVsZXRlIHRoaXMudmlldz8ubmVhcmVzdF9jYWNoZVtjdXJyX2ZpbGUucGF0aF07XG4gICAgICAgIC8vIGRlbHRlIG5vdGUgZW50aXR5IGZyb20gY29sbGVjdGlvblxuICAgICAgICB0aGlzLmVudi5zbWFydF9ub3Rlcy5kZWxldGUoY3Vycl9maWxlLnBhdGgpO1xuICAgICAgICAvLyBpbXBvcnQgbm90ZVxuICAgICAgICBhd2FpdCB0aGlzLmVudi5zbWFydF9ub3Rlcy5pbXBvcnQoW2N1cnJfZmlsZV0pO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAvLyByZWZyZXNoIHZpZXdcbiAgICAgICAgICB0aGlzLnZpZXcucmVuZGVyX25lYXJlc3QoKTtcbiAgICAgICAgfSwgMTAwMCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gb3BlbiB2aWV3IGNvbW1hbmRcbiAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgaWQ6IFwic21hcnQtY29ubmVjdGlvbnMtdmlld1wiLFxuICAgICAgbmFtZTogXCJPcGVuOiBWaWV3IFNtYXJ0IENvbm5lY3Rpb25zXCIsXG4gICAgICBjYWxsYmFjazogKCkgPT4geyB0aGlzLm9wZW5fdmlldygpOyB9XG4gICAgfSk7XG4gICAgLy8gb3BlbiBjaGF0IGNvbW1hbmRcbiAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgaWQ6IFwic21hcnQtY29ubmVjdGlvbnMtY2hhdFwiLFxuICAgICAgbmFtZTogXCJPcGVuOiBTbWFydCBDaGF0IENvbnZlcnNhdGlvblwiLFxuICAgICAgY2FsbGJhY2s6ICgpID0+IHsgdGhpcy5vcGVuX2NoYXQoKTsgfVxuICAgIH0pO1xuICAgIC8vIG9wZW4gcmFuZG9tIG5vdGUgZnJvbSBuZWFyZXN0IGNhY2hlXG4gICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgIGlkOiBcInNtYXJ0LWNvbm5lY3Rpb25zLXJhbmRvbVwiLFxuICAgICAgbmFtZTogXCJPcGVuOiBSYW5kb20gTm90ZSBmcm9tIFNtYXJ0IENvbm5lY3Rpb25zXCIsXG4gICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICBjb25zdCBjdXJyX2ZpbGUgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xuICAgICAgICBjb25zdCBjdXJyX25vdGUgPSB0aGlzLmJyYWluPy5zbWFydF9ub3Rlcy5nZXQoY3Vycl9maWxlLnBhdGgpO1xuICAgICAgICBjb25zdCBuZWFyZXN0ID0gY3Vycl9ub3RlLmZpbmRfY29ubmVjdGlvbnMoKTtcbiAgICAgICAgY29uc3QgcmFuZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG5lYXJlc3QubGVuZ3RoLzIpOyAvLyBkaXZpZGUgYnkgMiB0byBsaW1pdCB0byB0b3AgaGFsZiBvZiByZXN1bHRzXG4gICAgICAgIGNvbnN0IHJhbmRfZW50aXR5ID0gbmVhcmVzdFtyYW5kXTsgLy8gZ2V0IHJhbmRvbSBmcm9tIG5lYXJlc3QgY2FjaGVcbiAgICAgICAgLy8gcmFuZF9lbnRpdHkubm90ZSA/IHJhbmRfZW50aXR5Lm5vdGUub3BlbigpIDogcmFuZF9lbnRpdHkub3BlbigpOyAvLyBvcGVuIHJhbmRvbSBmaWxlXG4gICAgICAgIHRoaXMub3Blbl9ub3RlKHJhbmRfZW50aXR5LnBhdGgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIG1ha2VfY29ubmVjdGlvbnMoc2VsZWN0ZWRfdGV4dD1udWxsKSB7XG4gICAgaWYoIXRoaXMudmlldykgYXdhaXQgdGhpcy5vcGVuX3ZpZXcoKTsgLy8gb3BlbiB2aWV3IGlmIG5vdCBvcGVuXG4gICAgYXdhaXQgdGhpcy52aWV3LnJlbmRlcl9uZWFyZXN0KHNlbGVjdGVkX3RleHQpO1xuICB9XG4gIGFzeW5jIHNhdmVfc2V0dGluZ3MocmVyZW5kZXI9ZmFsc2UpIHtcbiAgICBhd2FpdCB0aGlzLnNhdmVEYXRhKHRoaXMuc2V0dGluZ3MpOyAvLyBPYnNpZGlhbiBBUEktPnNhdmVEYXRhXG4gICAgYXdhaXQgdGhpcy5sb2FkX3NldHRpbmdzKCk7IC8vIHJlLWxvYWQgc2V0dGluZ3MgaW50byBtZW1vcnlcbiAgICAvLyByZS1yZW5kZXIgdmlldyBpZiBzZXQgdG8gdHJ1ZSAoZm9yIGV4YW1wbGUsIGFmdGVyIGFkZGluZyBBUEkga2V5KVxuICAgIGlmKHJlcmVuZGVyKSB7XG4gICAgICB0aGlzLm5lYXJlc3RfY2FjaGUgPSB7fTtcbiAgICAgIGNvbnNvbGUubG9nKFwicmVyZW5kZXJpbmcgdmlld1wiKTtcbiAgICAgIGF3YWl0IHRoaXMubWFrZV9jb25uZWN0aW9ucygpO1xuICAgIH1cbiAgfVxuICAvLyB1dGlsc1xuICBhc3luYyBhZGRfdG9fZ2l0aWdub3JlKGlnbm9yZSwgbWVzc2FnZT1udWxsKSB7XG4gICAgaWYoIShhd2FpdCB0aGlzLmFwcC52YXVsdC5hZGFwdGVyLmV4aXN0cyhcIi5naXRpZ25vcmVcIikpKSByZXR1cm47IC8vIGlmIC5naXRpZ25vcmUgc2tpcFxuICAgIGxldCBnaXRpZ25vcmVfZmlsZSA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIucmVhZChcIi5naXRpZ25vcmVcIik7XG4gICAgaWYgKGdpdGlnbm9yZV9maWxlLmluZGV4T2YoaWdub3JlKSA8IDApIHtcbiAgICAgIGF3YWl0IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIuYXBwZW5kKFwiLmdpdGlnbm9yZVwiLCBgXFxuXFxuJHttZXNzYWdlID8gXCIjIFwiICsgbWVzc2FnZSArIFwiXFxuXCIgOiBcIlwifSR7aWdub3JlfWApO1xuICAgICAgY29uc29sZS5sb2coXCJBZGRlZCB0byAuZ2l0aWdub3JlOiBcIiArIGlnbm9yZSk7XG4gICAgfVxuICB9XG4gIHNob3dfbm90aWNlKG1lc3NhZ2UsIG9wdHM9e30pIHtcbiAgICBjb25zb2xlLmxvZyhcIm9sZCBzaG93aW5nIG5vdGljZVwiKTtcbiAgICBjb25zdCBub3RpY2VfaWQgPSB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycgPyBtZXNzYWdlIDogbWVzc2FnZVswXTtcbiAgICByZXR1cm4gdGhpcy5ub3RpY2VzLnNob3cobm90aWNlX2lkLCBtZXNzYWdlLCBvcHRzKTtcbiAgfVxuICBvcGVuX3ZpZXcoYWN0aXZlPXRydWUpIHsgU2NTbWFydFZpZXcub3Blbih0aGlzLmFwcC53b3Jrc3BhY2UsIGFjdGl2ZSk7IH1cbiAgb3Blbl9jaGF0KCkgeyBTY0NoYXRWaWV3Lm9wZW4odGhpcy5hcHAud29ya3NwYWNlKTsgfVxuICBnZXQgdmlldygpIHsgcmV0dXJuIFNjU21hcnRWaWV3LmdldF92aWV3KHRoaXMuYXBwLndvcmtzcGFjZSk7IH0gXG4gIGdldCBjaGF0X3ZpZXcoKSB7IHJldHVybiBTY0NoYXRWaWV3LmdldF92aWV3KHRoaXMuYXBwLndvcmtzcGFjZSk7IH1cbiAgLy8gZ2V0IGZvbGRlcnMsIHRyYXZlcnNlIG5vbi1oaWRkZW4gc3ViLWZvbGRlcnNcbiAgYXN5bmMgZ2V0X2ZvbGRlcnMocGF0aCA9IFwiL1wiKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGZvbGRlcnMgPSAoYXdhaXQgdGhpcy5hcHAudmF1bHQuYWRhcHRlci5saXN0KHBhdGgpKS5mb2xkZXJzO1xuICAgICAgbGV0IGZvbGRlcl9saXN0ID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZvbGRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGZvbGRlcnNbaV0uc3RhcnRzV2l0aChcIi5cIikpIGNvbnRpbnVlO1xuICAgICAgICBmb2xkZXJfbGlzdC5wdXNoKGZvbGRlcnNbaV0pO1xuICAgICAgICBmb2xkZXJfbGlzdCA9IGZvbGRlcl9saXN0LmNvbmNhdChhd2FpdCB0aGlzLmdldF9mb2xkZXJzKGZvbGRlcnNbaV0gKyBcIi9cIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZvbGRlcl9saXN0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJFcnJvciBnZXR0aW5nIGZvbGRlcnNcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuICAvLyBTVVBQT1JURVJTXG4gIGFzeW5jIHN5bmNfbm90ZXMoKSB7XG4gICAgLy8gaWYgbGljZW5zZSBrZXkgaXMgbm90IHNldCwgcmV0dXJuXG4gICAgaWYoIXRoaXMuc2V0dGluZ3MubGljZW5zZV9rZXkpe1xuICAgICAgbmV3IE5vdGljZShcIlNtYXJ0IENvbm5lY3Rpb25zOiBTdXBwb3J0ZXIgbGljZW5zZSBrZXkgaXMgcmVxdWlyZWQgdG8gc3luYyBub3RlcyB0byB0aGUgQ2hhdEdQVCBQbHVnaW4gc2VydmVyLlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc29sZS5sb2coXCJzeW5jaW5nIG5vdGVzXCIpO1xuICAgIGNvbnN0IGZpbGVzID0gdGhpcy5icmFpbi5maWxlcztcbiAgICBjb25zdCBub3RlcyA9IGF3YWl0IHRoaXMuYnVpbGRfbm90ZXNfb2JqZWN0KGZpbGVzKTtcbiAgICAvLyBQT1NUIG5vdGVzIG9iamVjdCB0byBzZXJ2ZXJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3RVcmwoe1xuICAgICAgdXJsOiBcImh0dHBzOi8vc3luYy5zbWFydGNvbm5lY3Rpb25zLmFwcC9zeW5jXCIsXG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIH0sXG4gICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGxpY2Vuc2Vfa2V5OiB0aGlzLnNldHRpbmdzLmxpY2Vuc2Vfa2V5LFxuICAgICAgICBub3Rlczogbm90ZXNcbiAgICAgIH0pXG4gICAgfSk7XG4gICAgY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICB9XG4gIGFzeW5jIGJ1aWxkX25vdGVzX29iamVjdChmaWxlcykge1xuICAgIGxldCBvdXRwdXQgPSB7fTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBmaWxlID0gZmlsZXNbaV07XG4gICAgICBsZXQgcGFydHMgPSBmaWxlLnBhdGguc3BsaXQoXCIvXCIpO1xuICAgICAgbGV0IGN1cnJlbnQgPSBvdXRwdXQ7XG4gICAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgcGFydHMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgIGxldCBwYXJ0ID0gcGFydHNbaWldO1xuICAgICAgICBpZiAoaWkgPT09IHBhcnRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGEgZmlsZVxuICAgICAgICAgIGN1cnJlbnRbcGFydF0gPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5jYWNoZWRSZWFkKGZpbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoaXMgaXMgYSBkaXJlY3RvcnlcbiAgICAgICAgICBpZiAoIWN1cnJlbnRbcGFydF0pIHtcbiAgICAgICAgICAgIGN1cnJlbnRbcGFydF0gPSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnRbcGFydF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuICBhc3luYyByZW5kZXJfY29kZV9ibG9jayhjb250ZW50cywgY29udGFpbmVyLCBjdHgpIHtcbiAgICBjb25zb2xlLmxvZyhjb250YWluZXIpO1xuICAgIHJldHVybiB0aGlzLnZpZXcucmVuZGVyX25lYXJlc3QoKGNvbnRlbnRzLnRyaW0oKS5sZW5ndGg/IGNvbnRlbnRzIDogY3R4LnNvdXJjZVBhdGgpLCBjb250YWluZXIpO1xuICB9XG4gIGFzeW5jIHJlbmRlcl9jb2RlX2Jsb2NrX2NvbnRleHQocmVzdWx0cywgY29udGFpbmVyLCBjdHgpIHtcbiAgICByZXN1bHRzID0gdGhpcy5nZXRfZW50aXRpZXNfZnJvbV9jb250ZXh0X2NvZGVibG9jayhyZXN1bHRzKTtcbiAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAgICBjb250YWluZXIuaW5uZXJIVE1MID0gdGhpcy52aWV3LnJlbmRlcl90ZW1wbGF0ZShcInNtYXJ0X2Nvbm5lY3Rpb25zXCIsIHsgY3VycmVudF9wYXRoOiBcImNvbnRleHRcIiwgcmVzdWx0cyB9KTtcbiAgICBjb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcIi5zZWFyY2gtcmVzdWx0XCIpLmZvckVhY2goKGVsbSwgaSkgPT4gdGhpcy52aWV3LmFkZF9saW5rX2xpc3RlbmVycyhlbG0sIHJlc3VsdHNbaV0pKTtcbiAgICBjb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcIi5zZWFyY2gtcmVzdWx0Om5vdCguc2MtY29sbGFwc2VkKSB1bCBsaVwiKS5mb3JFYWNoKHRoaXMudmlldy5yZW5kZXJfcmVzdWx0LmJpbmQodGhpcy52aWV3KSk7XG4gIH1cbiAgZ2V0X2VudGl0aWVzX2Zyb21fY29udGV4dF9jb2RlYmxvY2socmVzdWx0cykge1xuICAgIHJldHVybiByZXN1bHRzLnNwbGl0KFwiXFxuXCIpLm1hcChrZXkgPT4ge1xuICAgICAgLy8gY29uc3Qga2V5ID0gbGluZS5zdWJzdHJpbmcobGluZS5pbmRleE9mKCdbWycpICsgMiwgbGluZS5pbmRleE9mKCddXScpKTtcbiAgICAgIGNvbnN0IGVudGl0eSA9IGtleS5pbmNsdWRlcyhcIiNcIikgPyB0aGlzLmJyYWluLnNtYXJ0X2Jsb2Nrcy5nZXQoa2V5KSA6IHRoaXMuYnJhaW4uc21hcnRfbm90ZXMuZ2V0KGtleSk7XG4gICAgICByZXR1cm4gZW50aXR5ID8gZW50aXR5IDogeyBuYW1lOiBcIk5vdCBmb3VuZDogXCIgKyBrZXkgfTtcbiAgICB9KTtcbiAgfVxuICAvLyBjaGFuZ2UgY29kZSBibG9ja1xuICBhc3luYyBjaGFuZ2VfY29kZV9ibG9jayhzb3VyY2UsIGVsLCBjdHgpIHtcbiAgICBjb25zb2xlLmxvZyhzb3VyY2UpO1xuICAgIGNvbnN0IHJlbmRlcmVyID0gbmV3IFNjQWN0aW9uc1V4KHRoaXMsIGVsKTtcbiAgICByZW5kZXJlci5jaGFuZ2VfY29kZV9ibG9jayhzb3VyY2UpO1xuICB9XG5cbiAgLy8gdXBkYXRlIHNtYXJ0IGNvbm5lY3Rpb25zIGZvbGRlclxuICBhc3luYyB1cGRhdGVfc21hcnRfY29ubmVjdGlvbnNfZm9sZGVyKCkge1xuICAgIGlmKHRoaXMuc2V0dGluZ3Muc21hcnRfY29ubmVjdGlvbnNfZm9sZGVyID09PSB0aGlzLnNldHRpbmdzLnNtYXJ0X2Nvbm5lY3Rpb25zX2ZvbGRlcl9sYXN0KSByZXR1cm47IC8vIGlmIGZvbGRlciBpcyB0aGUgc2FtZSBhcyBsYXN0LCByZXR1cm5cbiAgICBpZighY29uZmlybShcIkFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byB1cGRhdGUgdGhlIFNtYXJ0IENvbm5lY3Rpb25zIGZvbGRlcj8gVGhpcyB3aWxsIG1vdmUgYWxsIFNtYXJ0IENvbm5lY3Rpb25zIGZpbGVzIHRvIHRoZSBuZXcgZm9sZGVyIGFuZCByZXN0YXJ0IHRoZSBwbHVnaW4uXCIpKXtcbiAgICAgIHRoaXMuc2V0dGluZ3Muc21hcnRfY29ubmVjdGlvbnNfZm9sZGVyID0gdGhpcy5zZXR0aW5ncy5zbWFydF9jb25uZWN0aW9uc19mb2xkZXJfbGFzdDsgLy8gcmVzZXQgZm9sZGVyIHRvIGxhc3QgZm9sZGVyIGlmIHVzZXIgY2FuY2Vsc1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLmFwcC52YXVsdC5hZGFwdGVyLnJlbmFtZSh0aGlzLnNldHRpbmdzLnNtYXJ0X2Nvbm5lY3Rpb25zX2ZvbGRlcl9sYXN0LCB0aGlzLnNldHRpbmdzLnNtYXJ0X2Nvbm5lY3Rpb25zX2ZvbGRlcik7XG4gICAgLy8gdXBkYXRlIGxhc3QgZm9sZGVyXG4gICAgdGhpcy5zZXR0aW5ncy5zbWFydF9jb25uZWN0aW9uc19mb2xkZXJfbGFzdCA9IHRoaXMuc2V0dGluZ3Muc21hcnRfY29ubmVjdGlvbnNfZm9sZGVyO1xuICAgIC8vIHNhdmUgc2V0dGluZ3NcbiAgICBhd2FpdCB0aGlzLnNhdmVfc2V0dGluZ3MoKTtcbiAgICAvLyByZWxvYWQgcGx1Z2luXG4gICAgdGhpcy5yZXN0YXJ0X3BsdWdpbigpO1xuICB9XG4gIC8vIHVwZGF0ZSBzbWFydCBjaGF0IGZvbGRlclxuICBhc3luYyB1cGRhdGVfc21hcnRfY2hhdF9mb2xkZXIoKSB7XG4gICAgaWYodGhpcy5zZXR0aW5ncy5zbWFydF9jaGF0X2ZvbGRlciA9PT0gdGhpcy5zZXR0aW5ncy5zbWFydF9jaGF0X2ZvbGRlcl9sYXN0KSByZXR1cm47IC8vIGlmIGZvbGRlciBpcyB0aGUgc2FtZSBhcyBsYXN0LCByZXR1cm5cbiAgICBpZighY29uZmlybShcIkFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byB1cGRhdGUgdGhlIFNtYXJ0IENoYXRzIGZvbGRlcj8gVGhpcyB3aWxsIG1vdmUgYWxsIFNtYXJ0IENoYXQgZmlsZXMgdG8gdGhlIG5ldyBmb2xkZXIuXCIpKXtcbiAgICAgIHRoaXMuc2V0dGluZ3Muc21hcnRfY2hhdF9mb2xkZXIgPSB0aGlzLnNldHRpbmdzLnNtYXJ0X2NoYXRfZm9sZGVyX2xhc3Q7IC8vIHJlc2V0IGZvbGRlciB0byBsYXN0IGZvbGRlciBpZiB1c2VyIGNhbmNlbHNcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5hcHAudmF1bHQuYWRhcHRlci5yZW5hbWUodGhpcy5zZXR0aW5ncy5zbWFydF9jaGF0X2ZvbGRlcl9sYXN0LCB0aGlzLnNldHRpbmdzLnNtYXJ0X2NoYXRfZm9sZGVyKTtcbiAgICAvLyB1cGRhdGUgbGFzdCBmb2xkZXJcbiAgICB0aGlzLnNldHRpbmdzLnNtYXJ0X2NoYXRfZm9sZGVyX2xhc3QgPSB0aGlzLnNldHRpbmdzLnNtYXJ0X2NoYXRfZm9sZGVyO1xuICAgIC8vIHNhdmUgc2V0dGluZ3NcbiAgICBhd2FpdCB0aGlzLnNhdmVfc2V0dGluZ3MoKTtcbiAgICAvLyB1cGRhdGUgY2hhdCBoaXN0b3J5IGNvbnZlcnNhdGlvbiBmb2xkZXJcbiAgICB0aGlzLmVudi5jaGF0cy5mb2xkZXIgPSB0aGlzLnNldHRpbmdzLnNtYXJ0X2NoYXRfZm9sZGVyOyBcbiAgfVxuICBcbiAgYXN5bmMgdXBkYXRlX2Vhcmx5X2FjY2VzcygpIHtcbiAgICAvLyAvLyBpZiBsaWNlbnNlIGtleSBpcyBub3Qgc2V0LCByZXR1cm5cbiAgICBpZighdGhpcy5zZXR0aW5ncy5saWNlbnNlX2tleSkgcmV0dXJuIHRoaXMuc2hvd19ub3RpY2UoXCJTdXBwb3J0ZXIgbGljZW5zZSBrZXkgcmVxdWlyZWQgZm9yIGVhcmx5IGFjY2VzcyB1cGRhdGVcIik7XG4gICAgY29uc3QgdjIgPSBhd2FpdCB0aGlzLm9ic2lkaWFuLnJlcXVlc3RVcmwoe1xuICAgICAgdXJsOiBcImh0dHBzOi8vc3luYy5zbWFydGNvbm5lY3Rpb25zLmFwcC9kb3dubG9hZF92MlwiLFxuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBsaWNlbnNlX2tleTogdGhpcy5zZXR0aW5ncy5saWNlbnNlX2tleSxcbiAgICAgIH0pXG4gICAgfSk7XG4gICAgaWYodjIuc3RhdHVzICE9PSAyMDApIHJldHVybiBjb25zb2xlLmVycm9yKFwiRXJyb3IgZG93bmxvYWRpbmcgZWFybHkgYWNjZXNzIHVwZGF0ZVwiLCB2Mik7XG4gICAgY29uc29sZS5sb2codjIuanNvbik7XG4gICAgYXdhaXQgdGhpcy5hcHAudmF1bHQuYWRhcHRlci53cml0ZShcIi5vYnNpZGlhbi9wbHVnaW5zL3NtYXJ0LWNvbm5lY3Rpb25zL21haW4uanNcIiwgdjIuanNvbi5tYWluKTsgLy8gYWRkIG5ld1xuICAgIGF3YWl0IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIud3JpdGUoXCIub2JzaWRpYW4vcGx1Z2lucy9zbWFydC1jb25uZWN0aW9ucy9tYW5pZmVzdC5qc29uXCIsIHYyLmpzb24ubWFuaWZlc3QpOyAvLyBhZGQgbmV3XG4gICAgYXdhaXQgdGhpcy5hcHAudmF1bHQuYWRhcHRlci53cml0ZShcIi5vYnNpZGlhbi9wbHVnaW5zL3NtYXJ0LWNvbm5lY3Rpb25zL3N0eWxlcy5jc3NcIiwgdjIuanNvbi5zdHlsZXMpOyAvLyBhZGQgbmV3XG4gICAgYXdhaXQgd2luZG93LmFwcC5wbHVnaW5zLmxvYWRNYW5pZmVzdHMoKTtcbiAgICBhd2FpdCB0aGlzLnJlc3RhcnRfcGx1Z2luKCk7XG4gIH1cblxuICAvLyBCRUdJTiBCQUNLV0FSRCBDT01QQVRJQklMSVRZIChERVBSRUNBVEVEOiByZW1vdmUgYmVmb3JlIDIuMiBzdGFibGUgcmVsZWFzZSlcbiAgYXN5bmMgaGFuZGxlX2RlcHJlY2F0ZWRfc2V0dGluZ3MoKSB7XG4gICAgLy8gbW92ZSBhcGkga2V5cyAoYXBpX2tleV9QTEFURk9STSkgdG8gUExBVEZPUk0uYXBpX2tleVxuICAgIE9iamVjdC5lbnRyaWVzKHRoaXMuc2V0dGluZ3MpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgaWYoa2V5LmluY2x1ZGVzKCctJykpIHtcbiAgICAgICAgLy8gcmVwbGFjZSB3aXRoIHVuZGVyc2NvcmVcbiAgICAgICAgY29uc3QgbmV3X2tleSA9IGtleS5yZXBsYWNlKC8tL2csIFwiX1wiKTtcbiAgICAgICAgdGhpcy5zZXR0aW5nc1tuZXdfa2V5XSA9IHZhbHVlO1xuICAgICAgICBkZWxldGUgdGhpcy5zZXR0aW5nc1trZXldO1xuICAgICAgICB0aGlzLnNhdmVfc2V0dGluZ3MoKTtcbiAgICAgIH1cbiAgICAgIGlmKGtleS5zdGFydHNXaXRoKFwiYXBpX2tleV9cIikpe1xuICAgICAgICBjb25zdCBwbGF0Zm9ybSA9IGtleS5yZXBsYWNlKC9eYXBpX2tleV8vLCBcIlwiKTtcbiAgICAgICAgaWYoIXRoaXMuc2V0dGluZ3NbcGxhdGZvcm1dKSB0aGlzLnNldHRpbmdzW3BsYXRmb3JtXSA9IHt9O1xuICAgICAgICBpZighdGhpcy5zZXR0aW5nc1twbGF0Zm9ybV0uYXBpX2tleSkgdGhpcy5zZXR0aW5nc1twbGF0Zm9ybV0uYXBpX2tleSA9IHZhbHVlO1xuICAgICAgICBpZih0aGlzLnNldHRpbmdzLnNtYXJ0X2NoYXRfbW9kZWw/LnN0YXJ0c1dpdGgocGxhdGZvcm0pKXtcbiAgICAgICAgICBjb25zdCBtb2RlbF9uYW1lID0gdGhpcy5zZXR0aW5ncy5zbWFydF9jaGF0X21vZGVsLnJlcGxhY2UocGxhdGZvcm0rXCItXCIsIFwiXCIpO1xuICAgICAgICAgIGlmKCF0aGlzLnNldHRpbmdzW3BsYXRmb3JtXS5tb2RlbF9uYW1lKSB0aGlzLnNldHRpbmdzW3BsYXRmb3JtXS5tb2RlbF9uYW1lID0gbW9kZWxfbmFtZTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5zZXR0aW5ncy5zbWFydF9jaGF0X21vZGVsO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLnNldHRpbmdzW2tleV07XG4gICAgICAgIHRoaXMuc2F2ZV9zZXR0aW5ncygpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIGlmIGV4Y2x1ZGVkIGZpbGVzIGRvZXMgbm90IGluY2x1ZGUgVW50aXRsZWQsIGFkZCBpdFxuICAgIGlmKCF0aGlzLnNldHRpbmdzLmZpbGVfZXhjbHVzaW9ucy5pbmNsdWRlcyhcIlVudGl0bGVkXCIpKSB7XG4gICAgICAvLyBpZiBub3QgZW1wdHksIGFkZCBjb21tYVxuICAgICAgaWYodGhpcy5zZXR0aW5ncy5maWxlX2V4Y2x1c2lvbnMubGVuZ3RoKSB0aGlzLnNldHRpbmdzLmZpbGVfZXhjbHVzaW9ucyArPSBcIixcIjtcbiAgICAgIHRoaXMuc2V0dGluZ3MuZmlsZV9leGNsdXNpb25zICs9IFwiVW50aXRsZWRcIjtcbiAgICAgIHRoaXMuc2F2ZV9zZXR0aW5ncygpO1xuICAgIH1cbiAgICAvLyBpZiBubyBzbWFydCBub3RlcyBtb2RlbCwgc2V0IHRvIGRlZmF1bHRcbiAgICBpZih0aGlzLnNldHRpbmdzLnNtYXJ0X25vdGVzX2VtYmVkX21vZGVsID09PSBcIk5vbmVcIil7XG4gICAgICB0aGlzLnNldHRpbmdzLnNtYXJ0X25vdGVzX2VtYmVkX21vZGVsID0gXCJUYXlsb3JBSS9iZ2UtbWljcm8tdjJcIjtcbiAgICAgIHRoaXMuc2F2ZV9zZXR0aW5ncygpO1xuICAgIH1cbiAgICAvLyBoYW5kbGUgZGVwcmVjYXRlZCBzbWFydC1lbWJlZCBtb2RlbHNcbiAgICBpZighZW1iZWRfbW9kZWxzW3RoaXMuc2V0dGluZ3Muc21hcnRfbm90ZXNfZW1iZWRfbW9kZWxdKSB7XG4gICAgICB0aGlzLnNldHRpbmdzLnNtYXJ0X25vdGVzX2VtYmVkX21vZGVsID0gdGhpcy5jb25zdHJ1Y3Rvci5kZWZhdWx0cy5zbWFydF9ub3Rlc19lbWJlZF9tb2RlbDtcbiAgICAgIHRoaXMuc2F2ZV9zZXR0aW5ncygpO1xuICAgIH1cbiAgICBpZighZW1iZWRfbW9kZWxzW3RoaXMuc2V0dGluZ3Muc21hcnRfYmxvY2tzX2VtYmVkX21vZGVsXSAmJiB0aGlzLnNldHRpbmdzLnNtYXJ0X2Jsb2Nrc19lbWJlZF9tb2RlbCAhPT0gXCJOb25lXCIpIHtcbiAgICAgIHRoaXMuc2V0dGluZ3Muc21hcnRfYmxvY2tzX2VtYmVkX21vZGVsID0gdGhpcy5jb25zdHJ1Y3Rvci5kZWZhdWx0cy5zbWFydF9ibG9ja3NfZW1iZWRfbW9kZWw7XG4gICAgICB0aGlzLnNhdmVfc2V0dGluZ3MoKTtcbiAgICB9XG4gICAgLy8gVjEgcmVsaWNzXG4gICAgaWYgKHRoaXMuc2V0dGluZ3MuaGVhZGVyX2V4Y2x1c2lvbnMpIHtcbiAgICAgIHRoaXMuc2V0dGluZ3MuZXhjbHVkZWRfaGVhZGluZ3MgPSB0aGlzLnNldHRpbmdzLmhlYWRlcl9leGNsdXNpb25zO1xuICAgICAgZGVsZXRlIHRoaXMuc2V0dGluZ3MuaGVhZGVyX2V4Y2x1c2lvbnM7XG4gICAgfVxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IFNtYXJ0Q29ubmVjdGlvbnNQbHVnaW47Il0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUEsdURBQUFBLFVBQUE7QUFHQSxRQUFNLGlCQUFOLE1BQXFCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUtuQixZQUFZLFlBQVk7QUFDdEIsYUFBSyxNQUFNLFdBQVc7QUFDdEIsYUFBSyxRQUFRLEtB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O0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFDckIsc0JBQXdCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BQ3hCLGdCQUFrQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFDcEI7QUFBQTtBQUFBOzs7QUNWQTtBQUFBLGVBQUFDLFVBQUFDLFNBQUE7QUFBQSxLQUFDLFNBQVMsR0FBRTtBQUFDLFVBQUcsT0FB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QyxXQUFXLFdBQVU7QUFDdEQsZ0JBQU0sYUFBYSxLQUFLLFNBQVMsaUJBQWlCLFFBQVEsV0FBUyxLQUFLLEVBQUU7QUFDMUUsY0FBRyxDQUFDLEtBQUssU0FBUyxRQUFRLEVBQUU7QUFBWSxpQkFBSyxTQUFTLFFBQVEsRUFBRSxhQUFhO0FBQzdFLGlCQUFPLEtBQUssU0FBUztBQUFBLFFBQ3ZCO0FBQ0EsZUFBTyxLQUFLLFNBQVMsR0FBRztBQUN4QixhQUFLLGNBQWM7QUFBQSxNQUNyQjtBQUFBLElBQ0YsQ0FBQztBQUVELFFBQUcsQ0FBQyxLQUFLLFNBQVMsZ0JBQWdCLFNBQVMsVUFBVSxHQUFHO0FBRXRELFVBQUcsS0FBSyxTQUFTLGdCQUFnQjtBQUFRLGFBQUssU0FBUyxtQkFBbUI7QUFDMUUsV0FBSyxTQUFTLG1CQUFtQjtBQUNqQyxXQUFLLGNBQWM7QUFBQSxJQUNyQjtBQUVBLFFBQUcsS0FBSyxTQUFTLDRCQUE0QixRQUFPO0FBQ2xELFdBQUssU0FBUywwQkFBMEI7QUFDeEMsV0FBSyxjQUFjO0FBQUEsSUFDckI7QUFFQSxRQUFHLENBQUMsYUFBYSxLQUFLLFNBQVMsdUJBQXVCLEdBQUc7QUFDdkQsV0FBSyxTQUFTLDBCQUEwQixLQUFLLFlBQVksU0FBUztBQUNsRSxXQUFLLGNBQWM7QUFBQSxJQUNyQjtBQUNBLFFBQUcsQ0FBQyxhQUFhLEtBQUssU0FBUyx3QkFBd0IsS0FBSyxLQUFLLFNBQVMsNkJBQTZCLFFBQVE7QUFDN0csV0FBSyxTQUFTLDJCQUEyQixLQUFLLFlBQVksU0FBUztBQUNuRSxXQUFLLGNBQWM7QUFBQSxJQUNyQjtBQUVBLFFBQUksS0FBSyxTQUFTLG1CQUFtQjtBQUNuQyxXQUFLLFNBQVMsb0JBQW9CLEtBQUssU0FBUztBQUNoRCxhQUFPLEtBQUssU0FBUztBQUFBLElBQ3ZCO0FBQUEsRUFDRjtBQUNGO0FBQ0EsT0FBTyxVQUFVOyIsCiAgIm5hbWVzIjogWyJleHBvcnRzIiwgImV4cG9ydHMiLCAiT2JzQUpTT04iLCAiaSIsICJleHBvcnRzIiwgIk9ic011bHRpQUpTT04iLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAibGluZSIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgImZ1bmNzIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJyZXF1ZXN0IiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJyZXNwIiwgInRva2VucyIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJlbWJlZF9tb2RlbHMiLCAiZXhwb3J0cyIsICJub3RlIiwgIl9hIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZGVmaW5lIiwgImkiLCAiciIsICJuIiwgInJlcXVpcmUiLCAicGF0aCIsICJzZWxmIiwgInByb2Nlc3MiLCAiZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJyZXF1aXJlX2FkYXB0ZXJzIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgInJlcXVpcmVfY29oZXJlIiwgImV4cG9ydHMiLCAicmVxdWlyZV9hbnRocm9waWMiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAicmVxdWVzdCIsICJleHBvcnRzIiwgImkiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJTY0NoYXRWaWV3IiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJfYSIsICJleHBvcnRzIiwgIlNjQ2hhdFZpZXciLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAiU2NFbnYiLCAiZXhwb3J0cyIsICJkZWZhdWx0X3NldHRpbmdzIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJTY1NtYXJ0VmlldyIsICJvYnNlcnZlciIsICJfYSIsICJleHBvcnRzIiwgIlNtYXJ0U2VhcmNoIiwgImV4cG9ydHMiLCAiU21hcnROb3RpY2VzIiwgImV4cG9ydHMiLCAiU2NTZXR0aW5ncyIsICJleHBvcnRzIiwgIlNjU2V0dGluZ3NUYWIiLCAiZXhwb3J0cyIsICJTY0FjdGlvbnNVeCIsICJleHBvcnRzIiwgIm9wZW5fbm90ZSJdCn0K
