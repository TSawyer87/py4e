var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// node_modules/smart-collections/long_term_memory.js
var require_long_term_memory = __commonJS({
  "node_modules/smart-collections/long_term_memory.js"(exports2) {
    var LongTermMemory = class {
      /**
       * Creates an instance of LongTermMemory.
       * @param {Object} collection - The collection object containing the environment and items.
       */
      constructor(collection) {
        this.env = collection.env;
        this.brain = this.env;
        this.collection = collection;
        this.save_timeout = null;
      }
      /**
       * Static method to initialize a LongTermMemory instance using a specific adapter.
       * @param {Object} collection - The collection object to be used.
       * @param {Function} adapter - The adapter class to be instantiated.
       * @returns {LongTermMemory} An instance of the adapter class.
       */
      static wake_up(collection, adapter) {
        const ltm = new adapter(collection);
        return ltm;
      }
      /**
       * Gets the name of the collection.
       * @returns {string} The name of the collection.
       */
      get collection_name() {
        return this.collection.collection_name;
      }
      /**
       * Gets the name of the item in the collection.
       * @returns {string} The name of the item.
       */
      get item_name() {
        return this.collection.item_name;
      }
      /**
       * Gets the data path from the environment.
       * @returns {string} The data path.
       */
      get data_path() {
        return this.env.data_path;
      }
      /**
       * Gets the file name, defaulting to the collection name if not explicitly set.
       * @returns {string} The file name.
       */
      get file_name() {
        return this.collection.file_name || this.collection.collection_name;
      }
      /**
       * Constructs the full file path for the collection's data.
       * @returns {string} The full file path.
       */
      get file_path() {
        return this.data_path + "/" + this.file_name;
      }
      /**
       * Gets the items of the collection.
       * @returns {Array} The items of the collection.
       */
      get items() {
        return this.collection.items;
      }
      /**
       * Sets the items of the collection.
       * @param {Array} items - The new items of the collection.
       */
      set items(items) {
        this.collection.items = items;
      }
      /**
       * Gets the keys of the collection.
       * @returns {Array} The keys of the collection.
       */
      get keys() {
        return this.collection.keys;
      }
      /**
       * Placeholder for loading data, to be implemented by subclasses.
       */
      async load() {
      }
      /**
       * Default save method, logs a message if not overridden.
       */
      save() {
        if (this.constructor.name !== "LongTermMemory")
          console.log("called default, override me");
      }
      /**
       * Default asynchronous save method, logs a message if not overridden.
       */
      async _save() {
        if (this.constructor.name !== "LongTermMemory")
          console.log("called default, override me");
      }
      /**
       * Revives a value from a key-value pair.
       * @param {string} key - The key in the key-value pair.
       * @param {*} value - The value in the key-value pair.
       * @returns {*} The possibly transformed value.
       */
      reviver(key, value) {
        return this.collection.reviver(key, value);
      }
      /**
       * Replaces a value before it is serialized.
       * @param {string} key - The key in the key-value pair.
       * @param {*} value - The value in the key-value pair.
       * @returns {*} The possibly transformed value.
       */
      replacer(key, value) {
        return this.collection.replacer(key, value);
      }
    };
    exports2.LongTermMemory = LongTermMemory;
  }
});

// node_modules/smart-collections/ObsAJSON.js
var require_ObsAJSON = __commonJS({
  "node_modules/smart-collections/ObsAJSON.js"(exports2) {
    var { LongTermMemory } = require_long_term_memory();
    var ObsAJSON2 = class extends LongTermMemory {
      /**
       * Constructs an instance of ObsAJSON.
       * @param {Object} collection - The collection to be managed.
       */
      constructor(collection) {
        super(collection);
        this.adapter = this.env.main.app.vault.adapter;
      }
      /**
       * Asynchronously loads the collection from a JSON file.
       * Parses the file content and initializes collection items based on the stored data.
       * Handles file not found errors by creating necessary directories and files.
       */
      async load() {
        console.log("Loading: " + this.file_path);
        try {
          (await this.adapter.read(this.file_path)).split(",\n").filter((batch) => batch).forEach((batch, i) => {
            const items = JSON.parse(`{${batch}}`);
            Object.entries(items).forEach(([key, value]) => {
              this.collection.items[key] = new this.env.item_types[value.class_name](this.env, value);
            });
          });
          console.log("Loaded: " + this.file_name);
        } catch (err) {
          console.log("Error loading: " + this.file_path);
          console.log(err.stack);
          if (err.code === "ENOENT") {
            this.items = {};
            try {
              await this.adapter.mkdir(this.data_path);
              await this.adapter.write(this.file_path, "");
            } catch (creationErr) {
              console.log("Failed to create folder or file: ", creationErr);
            }
          }
        }
      }
      // wraps _save in timeout to prevent multiple saves at once
      save() {
        if (this.save_timeout)
          clearTimeout(this.save_timeout);
        this.save_timeout = setTimeout(() => {
          this._save();
        }, 1e4);
      }
      /**
       * Saves the collection to a JSON file. This method is throttled to prevent multiple saves at once.
       * @param {boolean} [force=false] - Forces the save operation even if currently saving.
       */
      async _save(force = false) {
        if (this.save_timeout)
          clearTimeout(this.save_timeout);
        this.save_timeout = null;
        if (this._saving)
          return console.log("Already saving: " + this.file_name);
        this._saving = true;
        setTimeout(() => {
          this._saving = false;
        }, 1e4);
        const start = Date.now();
        console.log("Saving: " + this.file_name);
        const temp_file_path = this.file_path.replace(".ajson", ".temp.ajson");
        if (await this.adapter.exists(temp_file_path))
          await this.adapter.remove(temp_file_path);
        try {
          await this.adapter.write(temp_file_path, "");
          let file_content = [];
          const items = Object.values(this.items).filter((i) => i.vec);
          const batches = Math.ceil(items.length / 1e3);
          for (let i = 0; i < batches; i++) {
            file_content = items.slice(i * 1e3, (i + 1) * 1e3).map((i2) => i2.ajson);
            const batch_content = file_content.join(",");
            await this.adapter.append(temp_file_path, batch_content + ",\n");
          }
          if (items.length > batches * 1e3) {
            await this.adapter.append(temp_file_path, items.slice(batches * 1e3).map((i) => i.ajson).join(",") + ",\n");
          }
          const end = Date.now();
          const time = end - start;
          if (force || await this.validate_save(temp_file_path, this.file_path)) {
            if (await this.adapter.exists(this.file_path))
              await this.adapter.remove(this.file_path);
            await this.adapter.rename(temp_file_path, this.file_path);
            console.log("Saved " + this.file_name + " in " + time + "ms");
          } else {
            console.log("Not saving " + this.file_name + " because new file is less than 50% of old file");
          }
        } catch (err) {
          console.error("Error saving: " + this.file_name);
          console.error(err.stack);
          const failed_file_path = temp_file_path.replace(".temp.", ".failed-" + Date.now() + ".");
          await this.adapter.rename(temp_file_path, failed_file_path);
        }
        this._saving = false;
        if (await this.adapter.exists(temp_file_path) && await this.adapter.exists(this.file_path))
          await this.adapter.remove(temp_file_path);
      }
      /**
       * Validates the new file size against the old file size to ensure data integrity.
       * @param {string} new_file_path - Path to the new file.
       * @param {string} old_file_path - Path to the old file.
       * @returns {Promise<boolean>} True if the new file size is more than 50% of the old file size, otherwise false.
       */
      async validate_save(new_file_path, old_file_path) {
        var _a, _b;
        const new_file_size = (_a = await this.adapter.stat(new_file_path)) == null ? void 0 : _a.size;
        const old_file_size = (_b = await this.adapter.stat(old_file_path)) == null ? void 0 : _b.size;
        if (!old_file_size)
          return true;
        console.log("New file size: " + new_file_size + " bytes");
        console.log("Old file size: " + old_file_size + " bytes");
        return new_file_size > old_file_size * 0.5;
      }
      get file_name() {
        return super.file_name + ".ajson";
      }
    };
    exports2.ObsAJSON = ObsAJSON2;
  }
});

// node_modules/smart-collections/ObsMultiAJSON.js
var require_ObsMultiAJSON = __commonJS({
  "node_modules/smart-collections/ObsMultiAJSON.js"(exports2) {
    var { LongTermMemory } = require_long_term_memory();
    var ObsMultiAJSON2 = class extends LongTermMemory {
      /**
       * Creates an instance of ObsMultiAJSON.
       * @param {Object} collection - The collection of items to be managed.
       */
      constructor(collection) {
        super(collection);
        this.adapter = this.env.main.app.vault.adapter;
      }
      /**
       * Asynchronously loads collection items from .ajson files within the specified data path.
       * It ensures that only .ajson files are processed and handles JSON parsing and item instantiation.
       */
      async load() {
        console.log("Loading collection items");
        if (!await this.adapter.exists(this.data_path))
          await this.adapter.mkdir(this.data_path);
        const files = (await this.adapter.list(this.data_path)).files;
        for (const file_path of files) {
          try {
            if (file_path.endsWith(".ajson")) {
              const content = await this.adapter.read(file_path);
              const data = JSON.parse(`{${content.endsWith(",") ? content.slice(0, -1) : content}}`);
              let pruned = "";
              Object.entries(data).forEach(([key, value]) => {
                const entity = new this.env.item_types[value.class_name](this.env, value);
                this.env[entity.collection_name].items[key] = entity;
                pruned += entity.ajson + ",\n";
              });
              await this.adapter.write(file_path, pruned.trim());
            }
          } catch (err) {
            console.log("Error loading file: " + file_path);
            console.log(err.stack);
          }
        }
        console.log("Loaded collection items");
      }
      /**
       * Schedules a save operation to prevent multiple saves happening at the same time.
       */
      save() {
        if (this.save_timeout)
          clearTimeout(this.save_timeout);
        this.save_timeout = setTimeout(() => {
          this._save();
        }, 1e4);
      }
      /**
       * Asynchronously saves modified collection items to their respective .ajson files.
       * @param {boolean} [force=false] - Forces the save operation even if it's currently flagged as saving.
       */
      async _save(force = false) {
        let saved_ct = 0;
        if (this._saving)
          return console.log("Already saving");
        this._saving = true;
        setTimeout(() => {
          this._saving = false;
        }, 1e4);
        const start = Date.now();
        console.log("Saving collection items");
        if (!await this.adapter.exists(this.data_path))
          await this.adapter.mkdir(this.data_path);
        const items = Object.values(this.items).filter((i) => i.vec && i.changed);
        if (items.length === 0) {
          this._saving = false;
          console.log("Nothing to save");
          return;
        }
        try {
          for (const item of items) {
            const item_file_path = `${this.data_path}/${item.multi_ajson_file_name}.ajson`;
            await this.adapter.append(item_file_path, "\n" + item.ajson + ",");
            saved_ct++;
          }
          const end = Date.now();
          const time = end - start;
          console.log(`Saved ${saved_ct} collection items in ${time}ms`);
        } catch (err) {
          console.error("Error saving collection items");
          console.error(err.stack);
        }
        this._saving = false;
      }
      /**
       * Validates the save operation by comparing the file sizes of the new and old files.
       * @param {string} new_file_path - Path to the new file.
       * @param {string} old_file_path - Path to the old file.
       * @returns {Promise<boolean>} - True if the new file size is at least 50% of the old file size, otherwise false.
       */
      async validate_save(new_file_path, old_file_path) {
        var _a, _b;
        const new_file_size = (_a = await this.adapter.stat(new_file_path)) == null ? void 0 : _a.size;
        const old_file_size = (_b = await this.adapter.stat(old_file_path)) == null ? void 0 : _b.size;
        if (!old_file_size)
          return true;
        console.log("New file size: " + new_file_size + " bytes");
        console.log("Old file size: " + old_file_size + " bytes");
        return new_file_size > old_file_size * 0.5;
      }
      /**
       * Gets the data path for storing .ajson files, appending '/multi' to the base path.
       * @returns {string} The data path for .ajson files.
       */
      get data_path() {
        return super.data_path + "/multi";
      }
    };
    exports2.ObsMultiAJSON = ObsMultiAJSON2;
  }
});

// node_modules/smart-collections/env.js
var require_env = __commonJS({
  "node_modules/smart-collections/env.js"(exports2) {
    var { LongTermMemory: LTM } = require_long_term_memory();
    var SmartEnv = class {
      constructor(ltm_adapter = LTM) {
        this.config = {};
        this.item_types = {};
        this.collections = {};
        this.ltm_adapter = ltm_adapter;
        this.data_path = "./test/data";
      }
      init() {
        this.load_collections();
      }
      load_collections() {
        Object.entries(this.collections).map(([collection_name, collection]) => this[collection_name] = collection.load(this));
      }
      get_ref(ref) {
        return this[ref.collection_name].get(ref.key);
      }
    };
    exports2.SmartEnv = SmartEnv;
  }
});

// node_modules/smart-collections/Brain.js
var require_Brain = __commonJS({
  "node_modules/smart-collections/Brain.js"(exports2) {
    var { SmartEnv } = require_env();
    exports2.Brain = SmartEnv;
  }
});

// node_modules/smart-chunks/SmartMarkdown.js
var require_SmartMarkdown = __commonJS({
  "node_modules/smart-chunks/SmartMarkdown.js"(exports2) {
    var SmartMarkdown = class {
      /**
       * Returns the default configuration for the SmartMarkdown parser.
       * @returns {Object} Default configuration settings.
       */
      static get defaults() {
        return {
          excluded_headings: null,
          // comma separated list of headings to exclude
          embed_input_max_chars: 1e3,
          // max length of block
          embed_input_min_chars: 50,
          // min length of block
          skip_blocks_with_headings_only: false
          // skip blocks that only contain headings
        };
      }
      /**
       * Creates an instance of SmartMarkdown with the given configuration.
       * @param {Object} config - User-defined configuration settings.
       */
      constructor(config) {
        this.config = { ...SmartMarkdown.defaults, ...config };
      }
      /**
       * Retrieves the list of headings to be excluded from parsing, if any.
       * @returns {Array|null} An array of headings to exclude, or null if none.
       */
      get excluded_headings() {
        var _a;
        ((_a = this.config.excluded_headings) == null ? void 0 : _a.length) ? this.config.excluded_headings.split(",").map((header) => header.trim()) : null;
      }
      /**
       * Analyzes the markdown content to extract metadata about each heading.
       * @param {string} content - The markdown content to analyze.
       * @returns {Array} An array of objects containing metadata about each heading.
       */
      // WIP
      get_headings_meta(content) {
        return content.split("\n").reduce((acc, line, line_i, lines) => {
          if (!this.is_heading(line))
            return acc;
          const chars_until_next_heading = lines.slice(line_i + 1).findIndex((line2) => this.is_heading(line2));
          const heading_level = line.split("#").length - 1;
          const heading_text = line.replace(/#/g, "").trim();
          acc.push = { line_i, heading_level, heading_text, chars_until_next_heading };
          return acc;
        }, []);
      }
      // v1
      // get block from path
      /**
       * Extracts a specific block of markdown based on a heading path.
       * @param {string} block_path - The path to the block, specified as a series of headings.
       * @param {string} markdown - The markdown content to parse.
       * @param {Object} opts - Options for block extraction, such as character limits per line.
       * @returns {string} The extracted block of markdown text.
       */
      get_block_from_path(block_path, markdown, opts = {}) {
        if (block_path.endsWith("#") && block_path.split("#").length === 2)
          return markdown.split("#")[0];
        if (!this.validate_block_path(block_path))
          return markdown;
        const {
          chars_per_line = null,
          max_chars = this.config.embed_input_max_chars,
          min_chars = this.config.embed_input_min_chars
        } = opts;
        const block = [];
        const block_headings = block_path.split("#").slice(1);
        let currentHeaders = [];
        let begin_line = 0;
        let is_code = false;
        let char_count = 0;
        let heading_occurrence = 0;
        let occurrence_count = 0;
        if (block_headings[block_headings.length - 1].indexOf("{") > -1) {
          heading_occurrence = parseInt(block_headings[block_headings.length - 1].split("{")[1].replace("}", ""));
          block_headings[block_headings.length - 1] = block_headings[block_headings.length - 1].split("{")[0];
        }
        const lines = markdown.split("\n");
        let block_heading_level = 0;
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];
          if (line.indexOf("```") === 0)
            is_code = !is_code;
          if (is_code)
            continue;
          if (["- ", "- [ ] "].indexOf(line) > -1)
            continue;
          if (!this.is_heading(line))
            continue;
          block_heading_level = this.heading_level(line);
          const heading_text = line.replace(/#/g, "").trim();
          const heading_index = block_headings.indexOf(heading_text);
          if (heading_index < 0)
            continue;
          if (currentHeaders.length !== heading_index)
            continue;
          currentHeaders.push(heading_text);
          if (currentHeaders.length === block_headings.length) {
            if (heading_occurrence === 0) {
              begin_line = i + 1;
              break;
            }
            if (occurrence_count === heading_occurrence) {
              begin_line = i + 1;
              break;
            }
            occurrence_count++;
            currentHeaders.pop();
            continue;
          }
        }
        if (begin_line === 0)
          return "";
        is_code = false;
        for (let i = begin_line; i < lines.length; i++) {
          let line = lines[i];
          if (this.is_heading(line) && this.heading_level(line) <= block_heading_level)
            break;
          if (chars_per_line && line.length > chars_per_line)
            line = line.slice(0, chars_per_line) + "...";
          if (line.startsWith("```"))
            is_code = !is_code;
          block.push(line);
          char_count += line.length;
          if (max_chars && char_count > max_chars) {
            const diff = char_count - max_chars;
            block[block.length - 1] = block[block.length - 1].slice(0, block[block.length - 1].length - diff) + "...";
            break;
          }
          if (max_chars && max_chars - char_count < 10)
            break;
        }
        if (is_code)
          block.push("```");
        return block.join("\n").trim();
      }
      /**
       * Parses the markdown content and organizes it into structured blocks based on headings.
       * @param {Object} params - Parameters containing content and optional file path.
       * @returns {Object} An object containing parsed blocks and other metadata.
       */
      parse({ content, file_path = "" }) {
        const file_breadcrumbs = this.file_path_to_breadcrumbs(file_path) + ": ";
        if (file_path.endsWith(".excalidraw.md")) {
          const excalidraw_block = this.get_block_from_path(file_path + "#Text Elements", content).replace("\n%%", "");
          return {
            blocks: [
              {
                text: excalidraw_block,
                path: file_path + "#Text Elements",
                length: excalidraw_block.length,
                heading: "Text Elements"
              }
            ],
            log: []
          };
        }
        const output = content.split("\n").reduce((acc, line, i, arr) => {
          if (this.is_heading(line) && (!acc.curr_level || !this.config.multi_heading_blocks || this.heading_level(line) <= acc.curr_level || acc.curr.length > this.config.embed_input_max_chars)) {
            this.output_block(acc);
            acc.curr_level = this.heading_level(line);
            acc.current_headers = acc.current_headers.filter((header) => header.level < acc.curr_level);
            acc.current_headers.push({ header: line.replace(/#/g, "").trim(), level: acc.curr_level });
            acc.start_line = i;
            acc.curr = file_breadcrumbs;
            acc.curr += acc.current_headers.map((header) => header.header).join(" > ");
            acc.block_headings = "#" + acc.current_headers.map((header) => header.header).join("#");
            this.handle_duplicate_headings(acc);
            acc.block_headings_list.push(acc.block_headings);
            acc.block_path = file_path + acc.block_headings;
            acc.curr_heading = line.replace(/#/g, "").trim();
            return acc;
          }
          if (this.is_content_line(line)) {
            if (acc.curr.indexOf("\n") === -1)
              acc.curr += ":";
            acc.curr += "\n" + line;
            acc.curr_line = i;
          }
          if (i === arr.length - 1)
            this.output_block(acc);
          return acc;
        }, { block_headings: "", block_headings_list: [], block_path: file_path + "#", curr: file_breadcrumbs, current_headers: [], blocks: [], log: [], start_line: 0, curr_line: 0, curr_heading: null });
        return {
          ...output,
          file_path,
          // remove properties that are exclusive to the reduce function
          block_headings: void 0,
          block_headings_list: void 0,
          block_path: void 0,
          curr: void 0,
          current_headers: void 0
        };
      }
      /**
       * Handles duplicate headings by appending a unique identifier to the heading path.
       * @param {Object} acc - The accumulator object used in reduce function.
       */
      // if block_headings is already in block_headings_list then add a number to the end
      handle_duplicate_headings(acc) {
        if (!acc.block_headings_list.includes(acc.block_headings))
          return;
        let count = 1;
        const uniqueHeadings = new Set(acc.block_headings_list);
        while (uniqueHeadings.has(`${acc.block_headings}{${count}}`)) {
          count++;
        }
        acc.block_headings = `${acc.block_headings}{${count}}`;
      }
      /**
       * Outputs the current block into the structured blocks array after validation.
       * @param {Object} acc - The accumulator object used in reduce function.
       */
      // push the current block to the blocks array
      output_block(acc) {
        const { embed_input_max_chars, embed_input_min_chars } = this.config;
        if (acc.curr.indexOf("\n") === -1)
          return acc.log.push(`Skipping empty block: ${acc.curr}`);
        if (!this.validate_heading(acc.block_headings))
          return acc.log.push(`Skipping excluded heading: ${acc.block_headings}`);
        if (acc.curr.length > embed_input_max_chars)
          acc.curr = acc.curr.substring(0, embed_input_max_chars);
        const breadcrumbs_length = acc.curr.indexOf("\n") + 1;
        const block_length = acc.curr.length - breadcrumbs_length;
        if (block_length < embed_input_min_chars)
          return acc.log.push(`Skipping block shorter than min length: ${acc.curr}`);
        if (this.config.skip_blocks_with_headings_only) {
          const block_lines = acc.curr.split("\n");
          const block_headings = block_lines.slice(1).filter((line) => this.is_heading(line));
          if (block_headings.length === block_lines.length - 1)
            return acc.log.push(`Skipping block with only headings: ${acc.curr}`);
        }
        acc.blocks.push({
          text: acc.curr.trim(),
          path: acc.block_path,
          length: block_length,
          heading: acc.curr_heading,
          lines: [acc.start_line, acc.curr_line]
        });
      }
      /**
       * Determines if a line of text should be considered as content.
       * @param {string} line - The line of text to evaluate.
       * @returns {boolean} True if the line is content, false otherwise.
       */
      is_content_line(line) {
        if (["- ", "- [ ] "].indexOf(line) > -1)
          return false;
        return true;
      }
      /**
       * Converts a file path to a breadcrumb string format.
       * @param {string} file_path - The file path to convert.
       * @returns {string} The breadcrumb string.
       */
      file_path_to_breadcrumbs(file_path) {
        return file_path.replace(".md", "").split("/").map((crumb) => crumb.trim()).filter((crumb) => crumb !== "").join(" > ");
      }
      // remove .md file extension and convert file_path to breadcrumb formatting
      /**
       * Determines the level of a heading based on the number of '#' characters.
       * @param {string} line - The heading line to evaluate.
       * @returns {number} The level of the heading.
       */
      heading_level(line) {
        return line.split("#").length - 1;
      }
      /**
       * Checks if a line is a heading.
       * @param {string} line - The line to check.
       * @returns {boolean} True if the line is a heading, false otherwise.
       * @param {string} line - The line to check.
       * @returns {boolean} True if the line is a heading, false otherwise.
      */
      is_heading(line) {
        return line.startsWith("#") && ["#", " "].indexOf(line[1]) > -1;
      }
      // check if line is a heading (starts with # and second character is space or # indicating not a tag)
      /**
       * Validates if the block path is correctly formatted to include at least one heading.
       * @param {string} block_path - The block path to validate.
       * @returns {boolean} True if the block path is valid, false otherwise.
       */
      validate_block_path(block_path) {
        return block_path.indexOf("#") > -1;
      }
      // validate block_path contains at least one "#"
      /**
       * Validates a heading against the list of excluded headings.
       * @param {string} headings - The heading to validate.
       * @returns {boolean} True if the heading is not excluded, false if it is.
       */
      validate_heading(headings) {
        var _a;
        return !!!((_a = this.excluded_headings) == null ? void 0 : _a.some((exclusion) => headings.indexOf(exclusion) > -1));
      }
      // validate heading against excluded headings
    };
    exports2.SmartMarkdown = SmartMarkdown;
  }
});

// node_modules/smart-chunks/smart-chunks.js
var require_smart_chunks = __commonJS({
  "node_modules/smart-chunks/smart-chunks.js"(exports2) {
    var { SmartMarkdown } = require_SmartMarkdown();
    exports2.SmartMarkdown = SmartMarkdown;
  }
});

// node_modules/smart-collections/helpers.js
var require_helpers = __commonJS({
  "node_modules/smart-collections/helpers.js"(exports2) {
    function create_uid(data) {
      const str = JSON.stringify(data);
      let hash = 0;
      if (str.length === 0)
        return hash;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = (hash << 5) - hash + char;
        hash = hash & hash;
        if (hash < 0)
          hash = hash * -1;
      }
      return hash.toString() + str.length;
    }
    exports2.create_uid = create_uid;
    function deep_merge(target, source) {
      for (const key in source) {
        if (source.hasOwnProperty(key)) {
          if (is_obj(source[key]) && is_obj(target[key]))
            deep_merge(target[key], source[key]);
          else
            target[key] = source[key];
        }
      }
      return target;
      function is_obj(item) {
        return item && typeof item === "object" && !Array.isArray(item);
      }
    }
    exports2.deep_merge = deep_merge;
    function collection_instance_name_from(class_name) {
      return class_name.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase().replace(/y$/, "ie") + "s";
    }
    exports2.collection_instance_name_from = collection_instance_name_from;
    function cos_sim(vector1, vector2) {
      const dotProduct = vector1.reduce((acc, val, i) => acc + val * vector2[i], 0);
      const normA = Math.sqrt(vector1.reduce((acc, val) => acc + val * val, 0));
      const normB = Math.sqrt(vector2.reduce((acc, val) => acc + val * val, 0));
      return normA === 0 || normB === 0 ? 0 : dotProduct / (normA * normB);
    }
    exports2.cos_sim = cos_sim;
    function top_acc(_acc, item, ct = 10) {
      if (_acc.items.size < ct) {
        _acc.items.add(item);
      } else if (item.sim > _acc.min) {
        _acc.items.add(item);
        _acc.items.delete(_acc.minItem);
        _acc.minItem = Array.from(_acc.items).reduce((min, curr) => curr.sim < min.sim ? curr : min);
        _acc.min = _acc.minItem.sim;
      }
    }
    exports2.top_acc = top_acc;
    function sleep(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }
    exports2.sleep = sleep;
  }
});

// node_modules/smart-collections/CollectionItem.js
var require_CollectionItem = __commonJS({
  "node_modules/smart-collections/CollectionItem.js"(exports2) {
    var helpers = require_helpers();
    var {
      create_uid,
      deep_merge,
      collection_instance_name_from
    } = helpers;
    var CollectionItem = class {
      /**
       * Default properties for an instance of CollectionItem.
       * @returns {Object} Default data configuration.
       */
      static get defaults() {
        return {
          data: {
            key: null
          }
        };
      }
      /**
       * Creates an instance of CollectionItem.
       * @param {Object} brain - The central storage or context.
       * @param {Object|null} data - Initial data for the item.
       */
      constructor(env, data = null) {
        var _a;
        this.env = env;
        this.brain = this.env;
        this.config = (_a = this.env) == null ? void 0 : _a.config;
        this.merge_defaults();
        if (data)
          this.data = data;
        if (!this.data.class_name)
          this.data.class_name = this.constructor.name;
      }
      /**
       * Merges default properties from all classes in the inheritance chain.
       */
      merge_defaults() {
        let current_class = this.constructor;
        while (current_class) {
          for (let key in current_class.defaults) {
            if (typeof current_class.defaults[key] === "object")
              this[key] = { ...current_class.defaults[key], ...this[key] };
            else
              this[key] = current_class.defaults[key];
          }
          current_class = Object.getPrototypeOf(current_class);
        }
      }
      /**
       * Generates or retrieves a unique key for the item. Can be overridden in child classes.
       * @returns {string} The unique key.
       */
      get_key() {
        console.log("called default get_key");
        return create_uid(this.data);
      }
      // update_data - for data in this.data
      /**
       * Updates the data of this item with new data.
       * @param {Object} data - The new data for the item.
       * @returns {boolean} True if data was successfully updated.
       */
      update_data(data) {
        data = JSON.parse(JSON.stringify(data, this.update_data_replacer));
        deep_merge(this.data, data);
        return true;
      }
      /**
       * Custom replacer function for JSON.stringify used in update_data to handle special object types.
       * @param {string} key - The key of the property being stringified.
       * @param {any} value - The value of the property being stringified.
       * @returns {any} The value to be used in the JSON string.
       */
      update_data_replacer(key, value) {
        if (value instanceof CollectionItem)
          return value.ref;
        if (Array.isArray(value))
          return value.map((val) => val instanceof CollectionItem ? val.ref : val);
        return value;
      }
      // init - for data not in this.data
      /**
       * Initializes the item with input_data, potentially asynchronously.
       * Handles interactions with other collection items.
       */
      init() {
        this.save();
      }
      // should always call this.save() in child class init() overrides
      /**
       * Saves the current state of the item to its collection.
       */
      save() {
        if (!this.validate_save()) {
          if (this.key)
            this.collection.delete(this.key);
          return console.error("Invalid save: ", { data: this.data, stack: new Error().stack });
        }
        this.collection.set(this);
        this.collection.save();
      }
      /**
       * Validates the item's data before saving.
       * @returns {boolean} True if the data is valid for saving.
       */
      validate_save() {
        if (!this.key)
          return false;
        if (this.key === "")
          return false;
        if (this.key === "undefined")
          return false;
        return true;
      }
      /**
       * Deletes the item from its collection.
       */
      delete() {
        this.collection.delete(this.key);
      }
      // functional filter (returns true or false) for filtering items in collection; called by collection class
      /**
       * Filters items in the collection based on provided options.
       * @param {Object} opts - Filtering options.
       * @returns {boolean} True if the item passes the filter.
       */
      filter(opts = {}) {
        const {
          exclude_key,
          exclude_keys = exclude_key ? [exclude_key] : [],
          exclude_key_starts_with,
          key_ends_with,
          key_starts_with,
          key_starts_with_any
        } = opts;
        if (exclude_keys == null ? void 0 : exclude_keys.includes(this.key))
          return false;
        if (exclude_key_starts_with && this.key.startsWith(exclude_key_starts_with))
          return false;
        if (key_ends_with && !this.key.endsWith(key_ends_with))
          return false;
        if (key_starts_with && !this.key.startsWith(key_starts_with))
          return false;
        if (key_starts_with_any && !key_starts_with_any.some((prefix) => this.key.startsWith(prefix)))
          return false;
        return true;
      }
      /**
       * Parses the item's data for any necessary processing or transformation. Placeholder for override in child classes.
       */
      parse() {
      }
      /**
       * Retrieves the collection name derived from the class name.
       * @returns {string} The collection name.
       */
      static get collection_name() {
        return collection_instance_name_from(this.name);
      }
      /**
       * Retrieves the collection name for the instance, either from data or the class method.
       * @returns {string} The collection name.
       */
      get collection_name() {
        return this.data.collection_name ? this.data.collection_name : collection_instance_name_from(this.data.class_name || this.constructor.name);
      }
      /**
       * Retrieves the collection this item belongs to.
       * @returns {Object} The collection object.
       */
      get collection() {
        return this.env[this.collection_name];
      }
      /**
       * Retrieves or generates the key for this item.
       * @returns {string} The item's key.
       */
      get key() {
        return this.data.key = this.data.key || this.get_key();
      }
      /**
       * Provides a reference object for this item, containing the collection name and key.
       * @returns {Object} The reference object.
       */
      get ref() {
        return { collection_name: this.collection_name, key: this.key };
      }
      /**
       * Retrieves the sequence key for this item, used for building sequence keys.
       * @returns {string} The sequence key.
       */
      get seq_key() {
        return this.key;
      }
      // used for building sequence keys
    };
    exports2.CollectionItem = CollectionItem;
  }
});

// node_modules/smart-collections/Collection.js
var require_Collection = __commonJS({
  "node_modules/smart-collections/Collection.js"(exports2) {
    var { CollectionItem } = require_CollectionItem();
    var AsyncFunction = Object.getPrototypeOf(async function() {
    }).constructor;
    var helpers = require_helpers();
    var { deep_merge } = helpers;
    var Collection = class {
      /**
       * Constructs a new Collection instance.
       * @param {Object} env - The environment context containing configurations and adapters.
       */
      constructor(env) {
        this.env = env;
        this.brain = this.env;
        this.config = this.env.config;
        this.items = {};
        this.LTM = this.env.ltm_adapter.wake_up(this, this.env.ltm_adapter);
      }
      /**
       * Loads a collection based on the environment and optional configuration.
       * @param {Object} env - The environment context.
       * @param {Object} [config={}] - Optional configuration for the collection.
       * @returns {Promise<Collection>|Collection} The loaded collection instance.
       */
      static load(env, config = {}) {
        const { custom_collection_name } = config;
        env[this.collection_name] = new this(env);
        if (custom_collection_name) {
          env[this.collection_name].collection_name = custom_collection_name;
          env.collections[custom_collection_name] = this.constructor;
        }
        env[this.collection_name].merge_defaults();
        if (env[this.collection_name].load instanceof AsyncFunction)
          return env[this.collection_name].load().then(() => env[this.collection_name]);
        else
          env[this.collection_name].load();
        return env[this.collection_name];
      }
      /**
       * Merges default configurations from all classes in the inheritance chain.
       */
      merge_defaults() {
        var _a, _b;
        let current_class = this.constructor;
        while (current_class) {
          const col_conf = (_b = (_a = this.config) == null ? void 0 : _a.collections) == null ? void 0 : _b[current_class.collection_name];
          Object.entries(typeof col_conf === "object" ? col_conf : {}).forEach(([key, value]) => this[key] = value);
          current_class = Object.getPrototypeOf(current_class);
        }
      }
      /**
       * Saves the current state of the collection.
       */
      save() {
        this.LTM.save();
      }
      /**
       * Loads the collection state.
       */
      load() {
        this.LTM.load();
      }
      /**
       * Revives items from a serialized state.
       * @param {string} key - The key of the item.
       * @param {*} value - The serialized item value.
       * @returns {CollectionItem|*} The revived item or the original value if not an object.
       */
      reviver(key, value) {
        if (typeof value !== "object" || value === null)
          return value;
        if (value.class_name)
          return new this.env.item_types[value.class_name](this.env, value);
        return value;
      }
      replacer(key, value) {
        if (value instanceof this.item_type)
          return value.data;
        if (value instanceof CollectionItem)
          return value.ref;
        return value;
      }
      /**
       * Creates or updates an item in the collection based on the provided data.
       * @param {Object} data - The data to create or update an item.
       * @returns {Promise<CollectionItem>|CollectionItem} The newly created or updated item.
       */
      create_or_update(data = {}) {
        const existing = this.find_by(data);
        const item = existing ? existing : new this.item_type(this.env);
        item.is_new = !!!existing;
        const changed = item.update_data(data);
        if (existing && !changed)
          return existing;
        if (item.validate_save())
          this.set(item);
        if (item.init instanceof AsyncFunction)
          return new Promise((resolve, reject) => {
            item.init(data).then(() => resolve(item));
          });
        item.init(data);
        return item;
      }
      /**
       * Finds an item in the collection that matches the given data.
       * @param {Object} data - The criteria used to find the item.
       * @returns {CollectionItem|null} The found item or null if not found.
       */
      find_by(data) {
        if (data.key)
          return this.get(data.key);
        const temp = new this.item_type(this.env);
        const temp_data = JSON.parse(JSON.stringify(data, temp.update_data_replacer));
        deep_merge(temp.data, temp_data);
        return temp.key ? this.get(temp.key) : null;
      }
      // READ
      /**
       * Filters the items in the collection based on the provided options.
       * @param {Object} opts - The options used to filter the items.
       * @return {CollectionItem[]} The filtered items.
       */
      filter(opts) {
        return Object.entries(this.items).filter(([key, item]) => item.filter(opts)).map(([key, item]) => item);
      }
      /**
       * Retrieves items from the collection based on the provided strategy and options.
       * @param {Function[]} strategy - The strategy used to retrieve the items.
       * @param {Object} opts - The options used to retrieve the items.
       * @return {CollectionItem[]} The retrieved items.
       * @throws {Error} Throws an error if any function in the strategy array is not actually a function or if an async function throws an error.
       */
      async retrieve(strategy = [], opts = {}) {
        return await sequential_async_processor(funcs, this.filter(opts), opts);
      }
      /**
       * Retrieves a single item from the collection based on the provided strategy and options.
       * @param {String} key - The key of the item to retrieve.
       * @return {CollectionItem} The retrieved item.
       */
      get(key) {
        return this.items[key];
      }
      /**
       * Retrieves multiple items from the collection based on the provided keys.
       * @param {String[]} keys - The keys of the items to retrieve.
       * @return {CollectionItem[]} The retrieved items.
       */
      get_many(keys = []) {
        if (Array.isArray(keys))
          return keys.map((key) => this.get(key));
        console.error("get_many called with non-array keys: ", keys);
      }
      /**
       * Retrieves a random item from the collection based on the provided options.
       * @param {Object} opts - The options used to retrieve the item.
       * @return {CollectionItem} The retrieved item.
       */
      get_rand(opts = null) {
        if (opts) {
          const filtered = this.filter(opts);
          return filtered[Math.floor(Math.random() * filtered.length)];
        }
        return this.items[this.keys[Math.floor(Math.random() * this.keys.length)]];
      }
      // UPDATE
      /**
       * Adds or updates an item in the collection.
       * @param {CollectionItem} item - The item to add or update.
       */
      set(item) {
        if (!item.key)
          throw new Error("Item must have key property");
        this.items[item.key] = item;
      }
      /**
       * Updates multiple items in the collection based on the provided keys and data.
       * @param {String[]} keys - The keys of the items to update.
       * @param {Object} data - The data to update the items with.
       */
      update_many(keys = [], data = {}) {
        this.get_many(keys).forEach((item) => item.update_data(data));
      }
      // DESTROY
      /**
       * Clears all items from the collection.
       */
      clear() {
        this.items = {};
      }
      /**
       * Deletes an item from the collection based on its key.
       * @param {String} key - The key of the item to delete.
       */
      delete(key) {
        delete this.items[key];
      }
      /**
       * Deletes multiple items from the collection based on their keys.
       * @param {String[]} keys - The keys of the items to delete.
       */
      delete_many(keys = []) {
        keys.forEach((key) => delete this.items[key]);
      }
      // CONVENIENCE METHODS (namespace getters)
      /**
       * Gets the collection name derived from the class name.
       * @return {String} The collection name.
       */
      static get collection_name() {
        return this.name.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
      }
      /**
       * Gets or sets the collection name. If a name is set, it overrides the default name.
       * @param {String} name - The new collection name.
       */
      get collection_name() {
        return this._collection_name ? this._collection_name : this.constructor.collection_name;
      }
      set collection_name(name) {
        this._collection_name = name;
      }
      /**
       * Gets the keys of the items in the collection.
       * @return {String[]} The keys of the items.
       */
      get keys() {
        return Object.keys(this.items);
      }
      /**
       * Gets the class name of the item type the collection manages.
       * @return {String} The item class name.
       */
      get item_class_name() {
        return this.constructor.name.slice(0, -1).replace(/(ie)$/g, "y");
      }
      // remove 's' from end of name & if name ends in 'ie', replace with 'y'
      /**
       * Gets the name of the item type the collection manages, derived from the class name.
       * @return {String} The item name.
       */
      get item_name() {
        return this.item_class_name.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
      }
      /**
       * Gets the constructor of the item type the collection manages.
       * @return {Function} The item type constructor.
       */
      get item_type() {
        return this.env.item_types[this.item_class_name];
      }
    };
    exports2.Collection = Collection;
    async function sequential_async_processor(funcs2, initial_value, opts = {}) {
      let value = initial_value;
      for (const func of funcs2) {
        if (typeof func !== "function") {
          throw new TypeError("All elements in async_functions array must be functions");
        }
        try {
          value = await func(value, opts);
        } catch (error) {
          throw error;
        }
      }
      return value;
    }
    exports2.sequential_async_processor = sequential_async_processor;
  }
});

// node_modules/smart-embed-model/adapters/adapter.js
var require_adapter = __commonJS({
  "node_modules/smart-embed-model/adapters/adapter.js"(exports2) {
    var Adapter = class {
      /**
       * Constructs an instance of Adapter.
       * @param {object} main - The main context object which should contain a configuration object.
       */
      constructor(main) {
        this.main = main;
        Object.assign(this, main.config);
      }
    };
    exports2.Adapter = Adapter;
  }
});

// node_modules/smart-embed-model/adapters/api.js
var require_api = __commonJS({
  "node_modules/smart-embed-model/adapters/api.js"(exports2) {
    var { Adapter } = require_adapter();
    var ApiAdapter = class extends Adapter {
      /**
       * Counts the number of tokens in the input.
       * Override in child classes to implement third-party token counters.
       * @param {string} input - The input to count tokens for.
       * @returns {Promise<number>} The number of tokens in the input.
       */
      async count_tokens(input) {
        return this.estimate_tokens(input);
      }
      /**
       * Estimates the number of tokens in the input.
       * @param {string|object} input - The input to estimate tokens for.
       * @returns {number} The estimated number of tokens.
       */
      estimate_tokens(input) {
        var _a;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.estimate_tokens) === "function")
          return this.adapter.estimate_tokens(input);
        if (typeof input === "object")
          input = JSON.stringify(input);
        return input.length / 3.7;
      }
      /**
       * Gets the maximum number of characters allowed in the input based on max_tokens.
       * @returns {number} The maximum number of characters.
       */
      get max_chars() {
        return this.max_tokens * 4 - 100;
      }
      /**
       * Embeds the input and returns the first embedding.
       * @param {string} input - The input to embed.
       * @returns {Promise<object>} The first embedding object.
       */
      async embed(input) {
        if (!(input == null ? void 0 : input.length))
          return console.log("input is empty");
        input = this.prepare_embed_input(input);
        const embeddings = await this.request_embedding(input);
        return embeddings[0];
      }
      /**
       * Embeds a batch of items and returns their embeddings.
       * @param {Array} items - The items to embed.
       * @returns {Promise<Array>} The embeddings of the items.
       */
      async embed_batch(items) {
        items = items.filter((item) => {
          var _a;
          return ((_a = item.embed_input) == null ? void 0 : _a.length) > 0;
        });
        if (items.length === 0)
          return console.log("empty batch (or all items have empty embed_input)");
        const embed_inputs = this.prepare_batch_input(items);
        let embeddings = await this.request_embedding(embed_inputs);
        if (!embeddings)
          return console.error(items);
        embeddings = embeddings.map((embedding, i) => this.parse_embedding_output(embed_inputs, embedding, i));
        return items.map((item, i) => {
          item.vec = embeddings[i].vec;
          item.tokens = embeddings[i].tokens;
          return item;
        });
      }
      /**
       * Parses the embedding output for each input.
       * @param {Array} embed_inputs - The inputs used for embedding.
       * @param {object} embedding - The embedding result.
       * @param {number} i - The index of the current embedding.
       * @returns {object} The parsed embedding output.
       */
      parse_embedding_output(embed_inputs, embedding, i) {
        const total_chars = this.count_embed_input_chars(embed_inputs);
        return {
          vec: embedding.vec,
          tokens: Math.round(embed_inputs[i].length / total_chars * embedding.tokens)
        };
      }
      /**
       * Counts the total number of characters in all embed inputs.
       * @param {Array} embed_inputs - The inputs used for embedding.
       * @returns {number} The total number of characters.
       */
      count_embed_input_chars(embed_inputs) {
        return embed_inputs.reduce((acc, curr) => acc + curr.length, 0);
      }
      /**
       * Prepares the batch input by processing each item's embed input.
       * @param {Array} items - The items to prepare.
       * @returns {Array} The prepared batch input.
       */
      prepare_batch_input(items) {
        return items.map((item) => this.prepare_embed_input(item.embed_input));
      }
      /**
       * Prepares the embed input by truncating it if necessary.
       * @param {string} embed_input - The input to prepare.
       * @returns {string} The prepared embed input.
       */
      prepare_embed_input(embed_input) {
        return embed_input.length > this.max_chars ? embed_input.slice(0, this.max_chars) : embed_input;
      }
      /**
       * Prepares the request body for embedding.
       * @param {string[]} embed_input - The input to embed.
       * @returns {object} The prepared request body.
       */
      prepare_request_body(embed_input) {
        const body = {
          model: this.model_name,
          input: embed_input
        };
        if (this.model_name.startsWith("text-embedding-3")) {
          body.dimensions = this.dims;
        }
        return body;
      }
      /**
       * Prepares the request headers for the API call.
       * @returns {object} The prepared request headers.
       */
      prepare_request_headers() {
        let headers = {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.api_key}`
        };
        if (this.headers)
          headers = { ...headers, ...this.headers };
        return headers;
      }
      /**
       * Requests the embedding from the API.
       * @param {string|string[]} embed_input - The input to embed. May be a string or an array of strings.
       * @returns {Promise<object[]>} The embedding objects {vec, tokens}.
       */
      async request_embedding(embed_input) {
        if (embed_input.length === 0) {
          console.log("embed_input is empty");
          return null;
        }
        const request2 = {
          url: this.endpoint,
          method: "POST",
          body: JSON.stringify(this.prepare_request_body(embed_input)),
          headers: this.prepare_request_headers()
        };
        const resp = await this.request(request2);
        return this.parse_response(resp);
      }
      /**
       * Parses the response from the API.
       * @param {object} resp - The response from the API.
       * @returns {Array} The parsed response data.
       */
      parse_response(resp) {
        return resp.data.map((item) => ({
          vec: item.embedding,
          tokens: resp.usage.total_tokens / resp.data.length
        }));
      }
      /**
       * Checks if the response JSON indicates an error.
       * @param {object} resp_json - The response JSON to check.
       * @returns {boolean} True if there is an error, false otherwise.
       */
      is_error(resp_json) {
        return !resp_json.data || !resp_json.usage;
      }
      /**
       * Retrieves the JSON from the response.
       * @param {Response} resp - The response object.
       * @returns {Promise<object>} The response JSON.
       */
      async get_resp_json(resp) {
        return typeof resp.json === "function" ? await resp.json() : await resp.json;
      }
      /**
       * Handles the request, including retries for specific errors.
       * @param {object} req - The request object.
       * @param {number} retries - The current retry count.
       * @returns {Promise<object|null>} The response JSON or null if an error occurs.
       */
      async request(req, retries = 0) {
        try {
          req.throw = false;
          const resp = this.request_adapter ? await this.request_adapter({ url: this.endpoint, ...req }) : await fetch(this.endpoint, req);
          const resp_json = await this.get_resp_json(resp);
          if (this.is_error(resp_json))
            return await this.handle_request_err(resp_json, req, retries);
          return resp_json;
        } catch (error) {
          return await this.handle_request_err(error, req, retries);
        }
      }
      /**
       * Handles errors during the request, including retrying the request.
       * @param {Error} error - The error encountered.
       * @param {object} req - The request object.
       * @param {number} retries - The current retry count.
       * @returns {Promise<object|null>} The response JSON or null if an error persists.
       */
      async handle_request_err(error, req, retries) {
        var _a;
        error = error.error;
        if ((_a = error.message) == null ? void 0 : _a.includes("maximum context length is")) {
          const max_len = parseInt(error.message.split("length is ")[1].split("tokens")[0].trim());
          const requested_len = parseInt(error.message.split("requested")[1].split("tokens")[0].trim());
          console.log(`max context length: ${max_len}, requested: ${requested_len}`);
          const body = JSON.parse(req.body);
          const longest_len = Math.max(...body.input.map((item) => item.length));
          const longest_i = body.input.findIndex((i) => i.length === longest_len);
          const reduce_factor = (requested_len - max_len) / requested_len;
          body.input[longest_i] = body.input[longest_i].slice(0, Math.floor(reduce_factor * longest_len) - 500 * retries);
          console.log(`truncated input: ${body.input[longest_i].length}`);
          req.body = JSON.stringify(body);
          return await this.request(req, retries + 1);
        }
        if (error.status === 429 && retries < 3) {
          const backoff = Math.pow(retries + 1, 2);
          console.log(`Retrying request (429) in ${backoff} seconds...`);
          await new Promise((r) => setTimeout(r, 1e3 * backoff));
          return await this.request(req, retries + 1);
        }
        console.error(error);
        return null;
      }
    };
    exports2.ApiAdapter = ApiAdapter;
  }
});

// node_modules/smart-embed-model/adapters/local_api.js
var require_local_api = __commonJS({
  "node_modules/smart-embed-model/adapters/local_api.js"(exports2) {
    var { ApiAdapter } = require_api();
    var LocalApiAdapter = class extends ApiAdapter {
      async embed(input) {
        const resp = await this.embed_batch([{
          embed_input: input
        }]);
        return resp == null ? void 0 : resp[0];
      }
      async init() {
        this.endpoint = this.local_endpoint;
      }
      prepare_batch_input(items) {
        return items.map((item) => {
          return {
            embed_input: this.prepare_embed_input(item.embed_input)
          };
        });
      }
      parse_embedding_output(embed_inputs, embedding, i) {
        return embedding;
      }
      prepare_request_body(input) {
        return {
          model_config: this.main.config,
          input
        };
      }
      prepare_request_headers() {
        return {
          "Content-Type": "application/json"
        };
      }
      is_error(resp) {
        return resp == null ? void 0 : resp.error;
      }
      parse_response(resp) {
        return resp;
      }
    };
    exports2.LocalApiAdapter = LocalApiAdapter;
  }
});

// node_modules/smart-embed-model/adapters/transformers.js
var require_transformers = __commonJS({
  "node_modules/smart-embed-model/adapters/transformers.js"(exports2) {
    var { Adapter } = require_adapter();
    var TransformersAdapter = class extends Adapter {
      async init() {
        const { env, pipeline, AutoTokenizer } = await import("@xenova/transformers");
        env.allowLocalModels = false;
        this.model = await pipeline("feature-extraction", this.model_name, { quantized: true, max_length: this.max_tokens });
        this.tokenizer = await AutoTokenizer.from_pretrained(this.model_name);
      }
      async embed_batch(items) {
        items = items.filter((item) => {
          var _a;
          return ((_a = item.embed_input) == null ? void 0 : _a.length) > 0;
        });
        if (!(items == null ? void 0 : items.length))
          return [];
        const tokens = await Promise.all(items.map((item) => this.count_tokens(item.embed_input)));
        const embed_input = await Promise.all(items.map(async (item, i) => {
          if (tokens[i] < this.max_tokens)
            return item.embed_input;
          let token_ct = tokens[i];
          let truncated_input = item.embed_input;
          while (token_ct > this.max_tokens) {
            const pct = this.max_tokens / token_ct;
            const max_chars = Math.floor(truncated_input.length * pct * 0.9);
            truncated_input = truncated_input.substring(0, max_chars) + "...";
            token_ct = await this.count_tokens(truncated_input);
          }
          tokens[i] = token_ct;
          return truncated_input;
        }));
        try {
          const resp2 = await this.model(embed_input, { pooling: "mean", normalize: true });
          return items.map((item, i) => {
            item.vec = Array.from(resp2[i].data);
            item.tokens = tokens[i];
            return item;
          });
        } catch (err) {
          console.log(err);
          console.log("Error embedding batch. Trying one at a time...");
        }
        const resp = await Promise.all(items.map(async (item) => {
          const { vec, tokens: tokens2, error } = await this.embed(item.embed_input);
          if (error) {
            console.log("Error embedding item: ", item.key);
            console.log(error);
            item.error = error;
            return item;
          }
          if (!vec) {
            console.log("Error embedding item: ", item.key);
            console.log("Vec: ", vec);
            console.log("Error: ", error);
            console.log("Tokens: ", tokens2);
            console.log("No vec returned");
            item.error = "No vec returned";
            return item;
          }
          item.vec = vec.map((val) => Math.round(val * 1e8) / 1e8);
          item.tokens = tokens2;
          return item;
        }));
        return resp;
      }
      async embed(input) {
        const output = { embed_input: input };
        if (!input)
          return { ...output, error: "No input text." };
        if (!this.model)
          await this.init();
        try {
          output.tokens = await this.count_tokens(input);
          if (output.tokens < 1)
            return { ...output, error: "Input too short." };
          if (output.tokens < this.max_tokens) {
            const embedding = await this.model(input, { pooling: "mean", normalize: true });
            output.vec = Array.from(embedding.data).map((val) => Math.round(val * 1e8) / 1e8);
          } else {
            const pct = this.max_tokens / output.tokens;
            const max_chars = Math.floor(input.length * pct * 0.95);
            input = input.substring(0, max_chars) + "...";
            output.truncated = true;
            console.log("Input too long. Truncating to ", input.length, " characters.");
            const { vec, tokens } = await this.embed(input);
            output.vec = vec;
            output.tokens = tokens;
          }
          return output;
        } catch (err) {
          console.log(err);
          return { ...output, error: err.message };
        }
      }
      async count_tokens(text) {
        if (!this.tokenizer)
          await this.init();
        const { input_ids } = await this.tokenizer(text);
        return input_ids.data.length;
      }
    };
    exports2.TransformersAdapter = TransformersAdapter;
  }
});

// node_modules/smart-embed-model/web_connector.json
var require_web_connector = __commonJS({
  "node_modules/smart-embed-model/web_connector.json"(exports2, module2) {
    module2.exports = {
      script: 'var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === "object" || typeof from === "function") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. "__esModule" has not been set), then set\n  // "default" to the CommonJS "module.exports" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,\n  mod\n));\n\n// adapters/adapter.js\nvar require_adapter = __commonJS({\n  "adapters/adapter.js"(exports) {\n    var Adapter = class {\n      /**\n       * Constructs an instance of Adapter.\n       * @param {object} main - The main context object which should contain a configuration object.\n       */\n      constructor(main) {\n        this.main = main;\n        Object.assign(this, main.config);\n      }\n    };\n    exports.Adapter = Adapter;\n  }\n});\n\n// adapters/transformers.js\nvar require_transformers = __commonJS({\n  "adapters/transformers.js"(exports) {\n    var { Adapter } = require_adapter();\n    var TransformersAdapter = class extends Adapter {\n      async init() {\n        const { env, pipeline, AutoTokenizer } = await import("@xenova/transformers");\n        env.allowLocalModels = false;\n        this.model = await pipeline("feature-extraction", this.model_name, { quantized: true, max_length: this.max_tokens });\n        this.tokenizer = await AutoTokenizer.from_pretrained(this.model_name);\n      }\n      async embed_batch(items) {\n        items = items.filter((item) => {\n          var _a;\n          return ((_a = item.embed_input) == null ? void 0 : _a.length) > 0;\n        });\n        if (!(items == null ? void 0 : items.length))\n          return [];\n        const tokens = await Promise.all(items.map((item) => this.count_tokens(item.embed_input)));\n        const embed_input = await Promise.all(items.map(async (item, i) => {\n          if (tokens[i] < this.max_tokens)\n            return item.embed_input;\n          let token_ct = tokens[i];\n          let truncated_input = item.embed_input;\n          while (token_ct > this.max_tokens) {\n            const pct = this.max_tokens / token_ct;\n            const max_chars = Math.floor(truncated_input.length * pct * 0.9);\n            truncated_input = truncated_input.substring(0, max_chars) + "...";\n            token_ct = await this.count_tokens(truncated_input);\n          }\n          tokens[i] = token_ct;\n          return truncated_input;\n        }));\n        try {\n          const resp2 = await this.model(embed_input, { pooling: "mean", normalize: true });\n          return items.map((item, i) => {\n            item.vec = Array.from(resp2[i].data);\n            item.tokens = tokens[i];\n            return item;\n          });\n        } catch (err) {\n          console.log(err);\n          console.log("Error embedding batch. Trying one at a time...");\n        }\n        const resp = await Promise.all(items.map(async (item) => {\n          const { vec, tokens: tokens2, error } = await this.embed(item.embed_input);\n          if (error) {\n            console.log("Error embedding item: ", item.key);\n            console.log(error);\n            item.error = error;\n            return item;\n          }\n          if (!vec) {\n            console.log("Error embedding item: ", item.key);\n            console.log("Vec: ", vec);\n            console.log("Error: ", error);\n            console.log("Tokens: ", tokens2);\n            console.log("No vec returned");\n            item.error = "No vec returned";\n            return item;\n          }\n          item.vec = vec.map((val) => Math.round(val * 1e8) / 1e8);\n          item.tokens = tokens2;\n          return item;\n        }));\n        return resp;\n      }\n      async embed(input) {\n        const output = { embed_input: input };\n        if (!input)\n          return { ...output, error: "No input text." };\n        if (!this.model)\n          await this.init();\n        try {\n          output.tokens = await this.count_tokens(input);\n          if (output.tokens < 1)\n            return { ...output, error: "Input too short." };\n          if (output.tokens < this.max_tokens) {\n            const embedding = await this.model(input, { pooling: "mean", normalize: true });\n            output.vec = Array.from(embedding.data).map((val) => Math.round(val * 1e8) / 1e8);\n          } else {\n            const pct = this.max_tokens / output.tokens;\n            const max_chars = Math.floor(input.length * pct * 0.95);\n            input = input.substring(0, max_chars) + "...";\n            output.truncated = true;\n            console.log("Input too long. Truncating to ", input.length, " characters.");\n            const { vec, tokens } = await this.embed(input);\n            output.vec = vec;\n            output.tokens = tokens;\n          }\n          return output;\n        } catch (err) {\n          console.log(err);\n          return { ...output, error: err.message };\n        }\n      }\n      async count_tokens(text) {\n        if (!this.tokenizer)\n          await this.init();\n        const { input_ids } = await this.tokenizer(text);\n        return input_ids.data.length;\n      }\n    };\n    exports.TransformersAdapter = TransformersAdapter;\n  }\n});\n\n// transformers_iframe.js\nvar require_transformers_iframe = __commonJS({\n  "transformers_iframe.js"(exports) {\n    var { TransformersAdapter } = require_transformers();\n    var TransformersIframeConnector = class _TransformersIframeConnector extends TransformersAdapter {\n      constructor(model_config, window2) {\n        super({ config: model_config });\n        this.model = null;\n        this.running_init = false;\n        this.window = window2;\n        this.embed_ct = 0;\n        this.timestamp = null;\n        this.tokens = 0;\n      }\n      static async create(model_config, window2) {\n        const connector = new _TransformersIframeConnector(model_config, window2);\n        await connector.init();\n        return connector;\n      }\n      async init() {\n        if (this.model)\n          return console.log("Smart Local Model already loaded");\n        if (this.running_init)\n          await new Promise((resolve) => setTimeout(resolve, 3e3));\n        if (!this.model && !this.running_init)\n          this.running_init = true;\n        console.log("Loading Smart Local Model");\n        const { pipeline, env, AutoTokenizer } = await import("https://cdn.jsdelivr.net/npm/@xenova/transformers@latest");\n        env.allowLocalModels = false;\n        this.model = await pipeline("feature-extraction", this.model_name, { quantized: true });\n        this.tokenizer = await AutoTokenizer.from_pretrained(this.model_name);\n        this.running_init = false;\n        this.window.tokenizer = this.tokenizer;\n        console.log(await this.embed("test"));\n        this.window.parent.postMessage({ type: "model_loaded", data: true }, "*");\n        this.window.addEventListener("message", this.handle_ipc.bind(this), false);\n      }\n      async handle_ipc(event) {\n        if (event.data.type == "smart_embed")\n          this.embed_handler(event.data);\n        if (event.data.type == "smart_embed_token_ct")\n          this.count_tokens_handler(event.data.embed_input);\n      }\n      async embed_handler(event_data) {\n        const { embed_input, handler_id } = event_data;\n        if (!this.timestamp)\n          this.timestamp = Date.now();\n        if (Array.isArray(embed_input)) {\n          const resp = await this.embed_batch(embed_input);\n          const send_data = {\n            type: "smart_embed_resp",\n            handler_id,\n            data: resp\n          };\n          this.window.postMessage(send_data, "*");\n          this.tokens += resp.reduce((acc, item) => acc + item.tokens, 0);\n          this.embed_ct += resp.length;\n        } else {\n          if (!this.timestamp)\n            this.timestamp = Date.now();\n          const send_data = await this.embed(embed_input);\n          send_data.type = "smart_embed_resp";\n          if (handler_id)\n            send_data.handler_id = handler_id;\n          this.window.postMessage(send_data, "*");\n          this.tokens += send_data.tokens;\n          this.embed_ct++;\n        }\n        if (Date.now() - this.timestamp > 1e4) {\n          console.log(`Embedded: ${this.embed_ct} inputs (${this.tokens} tokens, ${(this.tokens / ((Date.now() - this.timestamp) / 1e3)).toFixed(0)} tokens/sec)`);\n          this.timestamp = null;\n          this.tokens = 0;\n          this.embed_ct = 0;\n        }\n      }\n      async count_tokens_handler(input) {\n        const output = await this.count_tokens(input);\n        const send_data = {\n          type: "smart_embed_token_ct",\n          text: "count:" + input,\n          count: output\n        };\n        this.window.postMessage(send_data, "*");\n      }\n    };\n    exports.TransformersIframeConnector = TransformersIframeConnector;\n  }\n});\n\n// smart_embed_web.js\nwindow.addEventListener("message", init);\nasync function init(event) {\n  if (event.data.type === "init") {\n    window.removeEventListener("message", init);\n    const model_config = event.data.model_config;\n    console.log(model_config);\n    const { TransformersIframeConnector } = await Promise.resolve().then(() => __toESM(require_transformers_iframe()));\n    const model = await TransformersIframeConnector.create(model_config, window);\n    window.model = model;\n  }\n}\n//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiYWRhcHRlcnMvYWRhcHRlci5qcyIsICJhZGFwdGVycy90cmFuc2Zvcm1lcnMuanMiLCAidHJhbnNmb3JtZXJzX2lmcmFtZS5qcyIsICJzbWFydF9lbWJlZF93ZWIuanMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8qKlxuICogUmVwcmVzZW50cyBhIGdlbmVyaWMgYWRhcHRlciBjbGFzcyB0aGF0IGluaXRpYWxpemVzIHdpdGggYSBtYWluIGNvbnRleHQgYW5kIGNvcGllcyBpdHMgY29uZmlndXJhdGlvbi5cbiAqL1xuY2xhc3MgQWRhcHRlciB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGFuIGluc3RhbmNlIG9mIEFkYXB0ZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBtYWluIC0gVGhlIG1haW4gY29udGV4dCBvYmplY3Qgd2hpY2ggc2hvdWxkIGNvbnRhaW4gYSBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG1haW4pIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbWFpbiBjb250ZXh0IG9iamVjdCBmcm9tIHdoaWNoIGNvbmZpZ3VyYXRpb24gaXMgZGVyaXZlZC5cbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMubWFpbiA9IG1haW47XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgcHJvcGVydGllcyBmcm9tIHRoZSBtYWluIG9iamVjdCdzIGNvbmZpZyBwcm9wZXJ0eSB0byB0aGlzIGluc3RhbmNlLlxuICAgICAqL1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgbWFpbi5jb25maWcpOyAvLyBDb3B5IGNvbmZpZyB0byB0aGlzXG4gIH1cbn1cblxuLy8gRXhwb3J0IHRoZSBBZGFwdGVyIGNsYXNzIHRvIGJlIGF2YWlsYWJsZSBmb3Igb3RoZXIgbW9kdWxlcy5cbmV4cG9ydHMuQWRhcHRlciA9IEFkYXB0ZXI7XG4iLCAiY29uc3QgeyBBZGFwdGVyIH0gPSByZXF1aXJlKFwiLi9hZGFwdGVyXCIpO1xuXG5jbGFzcyBUcmFuc2Zvcm1lcnNBZGFwdGVyIGV4dGVuZHMgQWRhcHRlciB7XG4gIGFzeW5jIGluaXQoKSB7XG4gICAgY29uc3QgeyBlbnYsIHBpcGVsaW5lLCBBdXRvVG9rZW5pemVyIH0gPSBhd2FpdCBpbXBvcnQoJ0B4ZW5vdmEvdHJhbnNmb3JtZXJzJyk7XG4gICAgZW52LmFsbG93TG9jYWxNb2RlbHMgPSBmYWxzZTtcbiAgICB0aGlzLm1vZGVsID0gYXdhaXQgcGlwZWxpbmUoJ2ZlYXR1cmUtZXh0cmFjdGlvbicsIHRoaXMubW9kZWxfbmFtZSwgeyBxdWFudGl6ZWQ6IHRydWUsIG1heF9sZW5ndGg6IHRoaXMubWF4X3Rva2VucyB9KTtcbiAgICAvLyB0aGlzLm1vZGVsID0gYXdhaXQgcGlwZWxpbmUoJ2ZlYXR1cmUtZXh0cmFjdGlvbicsIHRoaXMubW9kZWxfbmFtZSwgeyBxdWFudGl6ZWQ6IGZhbHNlIH0pO1xuICAgIHRoaXMudG9rZW5pemVyID0gYXdhaXQgQXV0b1Rva2VuaXplci5mcm9tX3ByZXRyYWluZWQodGhpcy5tb2RlbF9uYW1lKTtcbiAgfVxuICBhc3luYyBlbWJlZF9iYXRjaChpdGVtcykge1xuICAgIGl0ZW1zID0gaXRlbXMuZmlsdGVyKGl0ZW0gPT4gaXRlbS5lbWJlZF9pbnB1dD8ubGVuZ3RoID4gMCk7IC8vIHJlbW92ZSBpdGVtcyB3aXRoIGVtcHR5IGVtYmVkX2lucHV0IChjYXVzZXMgLnNwbGl0KCkgZXJyb3IpXG4gICAgaWYoIWl0ZW1zPy5sZW5ndGgpIHJldHVybiBbXTtcbiAgICBjb25zdCB0b2tlbnMgPSBhd2FpdCBQcm9taXNlLmFsbChpdGVtcy5tYXAoaXRlbSA9PiB0aGlzLmNvdW50X3Rva2VucyhpdGVtLmVtYmVkX2lucHV0KSkpO1xuICAgIGNvbnN0IGVtYmVkX2lucHV0ID0gYXdhaXQgUHJvbWlzZS5hbGwoaXRlbXMubWFwKGFzeW5jIChpdGVtLCBpKSA9PiB7XG4gICAgICBpZiAodG9rZW5zW2ldIDwgdGhpcy5tYXhfdG9rZW5zKSByZXR1cm4gaXRlbS5lbWJlZF9pbnB1dDtcbiAgICAgIGxldCB0b2tlbl9jdCA9IHRva2Vuc1tpXTtcbiAgICAgIGxldCB0cnVuY2F0ZWRfaW5wdXQgPSBpdGVtLmVtYmVkX2lucHV0O1xuICAgICAgd2hpbGUgKHRva2VuX2N0ID4gdGhpcy5tYXhfdG9rZW5zKSB7XG4gICAgICAgIGNvbnN0IHBjdCA9IHRoaXMubWF4X3Rva2VucyAvIHRva2VuX2N0OyAvLyBnZXQgcGN0IG9mIGlucHV0IHRvIGtlZXBcbiAgICAgICAgY29uc3QgbWF4X2NoYXJzID0gTWF0aC5mbG9vcih0cnVuY2F0ZWRfaW5wdXQubGVuZ3RoICogcGN0ICogMC45MCk7IC8vIGdldCBudW1iZXIgb2YgY2hhcmFjdGVycyB0byBrZWVwIChtaW51cyAxMCUgZm9yIHNhZmV0eSlcbiAgICAgICAgdHJ1bmNhdGVkX2lucHV0ID0gdHJ1bmNhdGVkX2lucHV0LnN1YnN0cmluZygwLCBtYXhfY2hhcnMpICsgXCIuLi5cIjtcbiAgICAgICAgdG9rZW5fY3QgPSBhd2FpdCB0aGlzLmNvdW50X3Rva2Vucyh0cnVuY2F0ZWRfaW5wdXQpO1xuICAgICAgfVxuICAgICAgLy8gY29uc29sZS5sb2coXCJJbnB1dCB0b28gbG9uZy4gVHJ1bmNhdGluZyB0byBcIiwgdHJ1bmNhdGVkX2lucHV0Lmxlbmd0aCwgXCIgY2hhcmFjdGVycy5cIik7XG4gICAgICAvLyBjb25zb2xlLmxvZyhcIlRva2VuczogXCIsIHRva2Vuc1tpXSwgXCIgLT4gXCIsIHRva2VuX2N0KTtcbiAgICAgIHRva2Vuc1tpXSA9IHRva2VuX2N0O1xuICAgICAgcmV0dXJuIHRydW5jYXRlZF9pbnB1dDtcbiAgICB9KSk7XG5cbiAgICAvLyBjb25zb2xlLmxvZyhlbWJlZF9pbnB1dCk7XG4gICAgdHJ5e1xuICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IHRoaXMubW9kZWwoZW1iZWRfaW5wdXQsIHsgcG9vbGluZzogJ21lYW4nLCBub3JtYWxpemU6IHRydWUgfSk7XG4gICAgICAvLyBjb25zb2xlLmxvZyhyZXNwKTtcbiAgICAgIHJldHVybiBpdGVtcy5tYXAoKGl0ZW0sIGkpID0+IHtcbiAgICAgICAgaXRlbS52ZWMgPSBBcnJheS5mcm9tKHJlc3BbaV0uZGF0YSk7XG4gICAgICAgIGl0ZW0udG9rZW5zID0gdG9rZW5zW2ldO1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH0pO1xuICAgIH1jYXRjaChlcnIpe1xuICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiRXJyb3IgZW1iZWRkaW5nIGJhdGNoLiBUcnlpbmcgb25lIGF0IGEgdGltZS4uLlwiKTtcbiAgICB9XG4gICAgY29uc3QgcmVzcCA9IGF3YWl0IFByb21pc2UuYWxsKGl0ZW1zLm1hcChhc3luYyBpdGVtID0+IHtcbiAgICAgIGNvbnN0IHsgdmVjLCB0b2tlbnMsIGVycm9yIH0gPSBhd2FpdCB0aGlzLmVtYmVkKGl0ZW0uZW1iZWRfaW5wdXQpO1xuICAgICAgaWYoZXJyb3Ipe1xuICAgICAgICBjb25zb2xlLmxvZyhcIkVycm9yIGVtYmVkZGluZyBpdGVtOiBcIiwgaXRlbS5rZXkpO1xuICAgICAgICBjb25zb2xlLmxvZyhlcnJvcik7XG4gICAgICAgIGl0ZW0uZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9XG4gICAgICBpZighdmVjKXtcbiAgICAgICAgY29uc29sZS5sb2coXCJFcnJvciBlbWJlZGRpbmcgaXRlbTogXCIsIGl0ZW0ua2V5KTtcbiAgICAgICAgY29uc29sZS5sb2coXCJWZWM6IFwiLCB2ZWMpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIkVycm9yOiBcIiwgZXJyb3IpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIlRva2VuczogXCIsIHRva2Vucyk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiTm8gdmVjIHJldHVybmVkXCIpO1xuICAgICAgICBpdGVtLmVycm9yID0gXCJObyB2ZWMgcmV0dXJuZWRcIjtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9XG4gICAgICBpdGVtLnZlYyA9IHZlYy5tYXAodmFsID0+IE1hdGgucm91bmQodmFsICogMTAwMDAwMDAwKSAvIDEwMDAwMDAwMCk7IC8vIHJlZHVjZSBwcmVjaXNpb24gdG8gOCBkZWNpbWFsIHBsYWNlcyByZWY6IGh0dHBzOi8vd2ZoYnJpYW4uY29tL3ZlY3Rvci1kaW1lbnNpb24tcHJlY2lzaW9uLWVmZmVjdC1vbi1jb3NpbmUtc2ltaWxhcml0eS9cbiAgICAgIGl0ZW0udG9rZW5zID0gdG9rZW5zO1xuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfSkpO1xuICAgIHJldHVybiByZXNwO1xuICB9XG4gIGFzeW5jIGVtYmVkKGlucHV0KSB7XG4gICAgY29uc3Qgb3V0cHV0ID0geyBlbWJlZF9pbnB1dDogaW5wdXQgfTtcbiAgICBpZiAoIWlucHV0KSByZXR1cm4geyAuLi5vdXRwdXQsIGVycm9yOiBcIk5vIGlucHV0IHRleHQuXCIgfTtcbiAgICBpZiAoIXRoaXMubW9kZWwpIGF3YWl0IHRoaXMuaW5pdCgpO1xuICAgIHRyeSB7XG4gICAgICBvdXRwdXQudG9rZW5zID0gYXdhaXQgdGhpcy5jb3VudF90b2tlbnMoaW5wdXQpO1xuICAgICAgaWYgKG91dHB1dC50b2tlbnMgPCAxKSByZXR1cm4geyAuLi5vdXRwdXQsIGVycm9yOiBcIklucHV0IHRvbyBzaG9ydC5cIiB9O1xuICAgICAgaWYgKG91dHB1dC50b2tlbnMgPCB0aGlzLm1heF90b2tlbnMpIHtcbiAgICAgICAgY29uc3QgZW1iZWRkaW5nID0gYXdhaXQgdGhpcy5tb2RlbChpbnB1dCwgeyBwb29saW5nOiAnbWVhbicsIG5vcm1hbGl6ZTogdHJ1ZSB9KTtcbiAgICAgICAgb3V0cHV0LnZlYyA9IEFycmF5LmZyb20oZW1iZWRkaW5nLmRhdGEpLm1hcCh2YWwgPT4gTWF0aC5yb3VuZCh2YWwgKiAxMDAwMDAwMDApIC8gMTAwMDAwMDAwKTsgLy8gcmVkdWNlIHByZWNpc2lvbiB0byA4IGRlY2ltYWwgcGxhY2VzIHJlZjogaHR0cHM6Ly93Zmhicmlhbi5jb20vdmVjdG9yLWRpbWVuc2lvbi1wcmVjaXNpb24tZWZmZWN0LW9uLWNvc2luZS1zaW1pbGFyaXR5L1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcGN0ID0gdGhpcy5tYXhfdG9rZW5zIC8gb3V0cHV0LnRva2VuczsgLy8gZ2V0IHBjdCBvZiBpbnB1dCB0byBrZWVwXG4gICAgICAgIGNvbnN0IG1heF9jaGFycyA9IE1hdGguZmxvb3IoaW5wdXQubGVuZ3RoICogcGN0ICogMC45NSk7IC8vIGdldCBudW1iZXIgb2YgY2hhcmFjdGVycyB0byBrZWVwIChtaW51cyA1JSBmb3Igc2FmZXR5KVxuICAgICAgICBpbnB1dCA9IGlucHV0LnN1YnN0cmluZygwLCBtYXhfY2hhcnMpICsgXCIuLi5cIjtcbiAgICAgICAgb3V0cHV0LnRydW5jYXRlZCA9IHRydWU7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiSW5wdXQgdG9vIGxvbmcuIFRydW5jYXRpbmcgdG8gXCIsIGlucHV0Lmxlbmd0aCwgXCIgY2hhcmFjdGVycy5cIik7XG4gICAgICAgIGNvbnN0IHsgdmVjLCB0b2tlbnMgfSA9IGF3YWl0IHRoaXMuZW1iZWQoaW5wdXQpO1xuICAgICAgICBvdXRwdXQudmVjID0gdmVjO1xuICAgICAgICBvdXRwdXQudG9rZW5zID0gdG9rZW5zO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICByZXR1cm4geyAuLi5vdXRwdXQsIGVycm9yOiBlcnIubWVzc2FnZSB9O1xuICAgIH1cbiAgfVxuICBhc3luYyBjb3VudF90b2tlbnModGV4dCkge1xuICAgIGlmICghdGhpcy50b2tlbml6ZXIpIGF3YWl0IHRoaXMuaW5pdCgpO1xuICAgIGNvbnN0IHsgaW5wdXRfaWRzIH0gPSBhd2FpdCB0aGlzLnRva2VuaXplcih0ZXh0KTtcbiAgICByZXR1cm4gaW5wdXRfaWRzLmRhdGEubGVuZ3RoOyAvLyBSZXR1cm4gdGhlIG51bWJlciBvZiB0b2tlbnNcbiAgfVxufVxuXG5leHBvcnRzLlRyYW5zZm9ybWVyc0FkYXB0ZXIgPSBUcmFuc2Zvcm1lcnNBZGFwdGVyOyIsICJjb25zdCB7IFRyYW5zZm9ybWVyc0FkYXB0ZXIgfSA9IHJlcXVpcmUoJy4vYWRhcHRlcnMvdHJhbnNmb3JtZXJzJyk7XG5cbi8vIENPTk5FQ1RPUiBGT1IgT0JTSURJQU5cbmNsYXNzIFRyYW5zZm9ybWVyc0lmcmFtZUNvbm5lY3RvciBleHRlbmRzIFRyYW5zZm9ybWVyc0FkYXB0ZXIge1xuICBjb25zdHJ1Y3Rvcihtb2RlbF9jb25maWcsIHdpbmRvdykge1xuICAgIHN1cGVyKHtjb25maWc6IG1vZGVsX2NvbmZpZ30pOyAvLyBhc3NpZ25zIGNvbmZpZyB0byB0aGlzIGluIEFkYXB0ZXJcbiAgICB0aGlzLm1vZGVsID0gbnVsbDtcbiAgICB0aGlzLnJ1bm5pbmdfaW5pdCA9IGZhbHNlO1xuICAgIHRoaXMud2luZG93ID0gd2luZG93O1xuICAgIC8vIHN0YXRzXG4gICAgdGhpcy5lbWJlZF9jdCA9IDA7XG4gICAgdGhpcy50aW1lc3RhbXAgPSBudWxsO1xuICAgIHRoaXMudG9rZW5zID0gMDtcbiAgfVxuICBzdGF0aWMgYXN5bmMgY3JlYXRlKG1vZGVsX2NvbmZpZywgd2luZG93KSB7XG4gICAgY29uc3QgY29ubmVjdG9yID0gbmV3IFRyYW5zZm9ybWVyc0lmcmFtZUNvbm5lY3Rvcihtb2RlbF9jb25maWcsIHdpbmRvdyk7XG4gICAgYXdhaXQgY29ubmVjdG9yLmluaXQoKTtcbiAgICByZXR1cm4gY29ubmVjdG9yO1xuICB9XG4gIGFzeW5jIGluaXQoKSB7XG4gICAgaWYgKHRoaXMubW9kZWwpIHJldHVybiBjb25zb2xlLmxvZyhcIlNtYXJ0IExvY2FsIE1vZGVsIGFscmVhZHkgbG9hZGVkXCIpO1xuICAgIGlmICh0aGlzLnJ1bm5pbmdfaW5pdCkgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDMwMDApKTtcbiAgICBpZiAoIXRoaXMubW9kZWwgJiYgIXRoaXMucnVubmluZ19pbml0KSB0aGlzLnJ1bm5pbmdfaW5pdCA9IHRydWU7XG4gICAgY29uc29sZS5sb2coXCJMb2FkaW5nIFNtYXJ0IExvY2FsIE1vZGVsXCIpO1xuICAgIC8vIGNvbnN0IHsgcGlwZWxpbmUsIGVudiwgQXV0b1Rva2VuaXplciB9ID0gYXdhaXQgaW1wb3J0KCdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B4ZW5vdmEvdHJhbnNmb3JtZXJzQDIuMTMuMCcpO1xuICAgIGNvbnN0IHsgcGlwZWxpbmUsIGVudiwgQXV0b1Rva2VuaXplciB9ID0gYXdhaXQgaW1wb3J0KCdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B4ZW5vdmEvdHJhbnNmb3JtZXJzQGxhdGVzdCcpO1xuICAgIGVudi5hbGxvd0xvY2FsTW9kZWxzID0gZmFsc2U7XG4gICAgdGhpcy5tb2RlbCA9IGF3YWl0IHBpcGVsaW5lKCdmZWF0dXJlLWV4dHJhY3Rpb24nLCB0aGlzLm1vZGVsX25hbWUsIHsgcXVhbnRpemVkOiB0cnVlIH0pO1xuICAgIHRoaXMudG9rZW5pemVyID0gYXdhaXQgQXV0b1Rva2VuaXplci5mcm9tX3ByZXRyYWluZWQodGhpcy5tb2RlbF9uYW1lKTtcbiAgICB0aGlzLnJ1bm5pbmdfaW5pdCA9IGZhbHNlO1xuICAgIHRoaXMud2luZG93LnRva2VuaXplciA9IHRoaXMudG9rZW5pemVyO1xuICAgIGNvbnNvbGUubG9nKGF3YWl0IHRoaXMuZW1iZWQoXCJ0ZXN0XCIpKTtcbiAgICB0aGlzLndpbmRvdy5wYXJlbnQucG9zdE1lc3NhZ2UoeyB0eXBlOiBcIm1vZGVsX2xvYWRlZFwiLCBkYXRhOiB0cnVlIH0sIFwiKlwiKTsgLy8gcG9zdCBtZXNzYWdlIHRvIHBhcmVudCB0aGF0IG1vZGVsIGlzIGxvYWRlZFxuICAgIHRoaXMud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMuaGFuZGxlX2lwYy5iaW5kKHRoaXMpLCBmYWxzZSk7XG4gIH1cbiAgYXN5bmMgaGFuZGxlX2lwYyhldmVudCkge1xuICAgIGlmIChldmVudC5kYXRhLnR5cGUgPT0gXCJzbWFydF9lbWJlZFwiKSB0aGlzLmVtYmVkX2hhbmRsZXIoZXZlbnQuZGF0YSk7XG4gICAgLy8gaWYgKGV2ZW50LmRhdGEudHlwZSA9PSBcInNtYXJ0X2VtYmVkX2JhdGNoXCIpIHRoaXMuZW1iZWRfYmF0Y2hfaGFuZGxlcihldmVudC5kYXRhLmVtYmVkX2lucHV0KTtcbiAgICBpZiAoZXZlbnQuZGF0YS50eXBlID09IFwic21hcnRfZW1iZWRfdG9rZW5fY3RcIikgdGhpcy5jb3VudF90b2tlbnNfaGFuZGxlcihldmVudC5kYXRhLmVtYmVkX2lucHV0KTtcbiAgfVxuICBhc3luYyBlbWJlZF9oYW5kbGVyKGV2ZW50X2RhdGEpIHtcbiAgICBjb25zdCB7IGVtYmVkX2lucHV0LCBoYW5kbGVyX2lkIH0gPSBldmVudF9kYXRhO1xuICAgIC8vIGNvbnNvbGUubG9nKGVtYmVkX2lucHV0KTtcbiAgICBpZighdGhpcy50aW1lc3RhbXApIHRoaXMudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICBpZihBcnJheS5pc0FycmF5KGVtYmVkX2lucHV0KSkge1xuICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IHRoaXMuZW1iZWRfYmF0Y2goZW1iZWRfaW5wdXQpO1xuICAgICAgY29uc3Qgc2VuZF9kYXRhID0ge1xuICAgICAgICB0eXBlOiBcInNtYXJ0X2VtYmVkX3Jlc3BcIixcbiAgICAgICAgaGFuZGxlcl9pZCxcbiAgICAgICAgZGF0YTogcmVzcCxcbiAgICAgIH07XG4gICAgICB0aGlzLndpbmRvdy5wb3N0TWVzc2FnZShzZW5kX2RhdGEsIFwiKlwiKTtcbiAgICAgIHRoaXMudG9rZW5zICs9IHJlc3AucmVkdWNlKChhY2MsIGl0ZW0pID0+IGFjYyArIGl0ZW0udG9rZW5zLCAwKTtcbiAgICAgIHRoaXMuZW1iZWRfY3QgKz0gcmVzcC5sZW5ndGg7XG4gICAgfWVsc2V7XG4gICAgICBpZiAoIXRoaXMudGltZXN0YW1wKSB0aGlzLnRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICBjb25zdCBzZW5kX2RhdGEgPSBhd2FpdCB0aGlzLmVtYmVkKGVtYmVkX2lucHV0KTtcbiAgICAgIHNlbmRfZGF0YS50eXBlID0gXCJzbWFydF9lbWJlZF9yZXNwXCI7XG4gICAgICBpZiAoaGFuZGxlcl9pZCkgc2VuZF9kYXRhLmhhbmRsZXJfaWQgPSBoYW5kbGVyX2lkO1xuICAgICAgdGhpcy53aW5kb3cucG9zdE1lc3NhZ2Uoc2VuZF9kYXRhLCBcIipcIik7XG4gICAgICB0aGlzLnRva2VucyArPSBzZW5kX2RhdGEudG9rZW5zO1xuICAgICAgdGhpcy5lbWJlZF9jdCsrO1xuICAgIH1cbiAgICBpZiAoRGF0ZS5ub3coKSAtIHRoaXMudGltZXN0YW1wID4gMTAwMDApIHtcbiAgICAgIGNvbnNvbGUubG9nKGBFbWJlZGRlZDogJHt0aGlzLmVtYmVkX2N0fSBpbnB1dHMgKCR7dGhpcy50b2tlbnN9IHRva2VucywgJHsodGhpcy50b2tlbnMgLyAoKERhdGUubm93KCkgLSB0aGlzLnRpbWVzdGFtcCkgLyAxMDAwKSkudG9GaXhlZCgwKX0gdG9rZW5zL3NlYylgKTtcbiAgICAgIHRoaXMudGltZXN0YW1wID0gbnVsbDtcbiAgICAgIHRoaXMudG9rZW5zID0gMDtcbiAgICAgIHRoaXMuZW1iZWRfY3QgPSAwO1xuICAgIH1cbiAgfVxuICBhc3luYyBjb3VudF90b2tlbnNfaGFuZGxlcihpbnB1dCkge1xuICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IHRoaXMuY291bnRfdG9rZW5zKGlucHV0KTtcbiAgICBjb25zdCBzZW5kX2RhdGEgPSB7XG4gICAgICB0eXBlOiBcInNtYXJ0X2VtYmVkX3Rva2VuX2N0XCIsXG4gICAgICB0ZXh0OiBcImNvdW50OlwiICsgaW5wdXQsXG4gICAgICBjb3VudDogb3V0cHV0XG4gICAgfTtcbiAgICB0aGlzLndpbmRvdy5wb3N0TWVzc2FnZShzZW5kX2RhdGEsIFwiKlwiKTtcbiAgfVxufVxuZXhwb3J0cy5UcmFuc2Zvcm1lcnNJZnJhbWVDb25uZWN0b3IgPSBUcmFuc2Zvcm1lcnNJZnJhbWVDb25uZWN0b3I7XG5cbiIsICJ3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGluaXQpOyAvLyBsaXN0ZW4gZm9yIGluaXQgbWVzc2FnZVxuYXN5bmMgZnVuY3Rpb24gaW5pdChldmVudCkge1xuICBpZiAoZXZlbnQuZGF0YS50eXBlID09PSAnaW5pdCcpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGluaXQpOyAvLyByZW1vdmUgdGhpcyBldmVudCBsaXN0ZW5lclxuICAgIGNvbnN0IG1vZGVsX2NvbmZpZyA9IGV2ZW50LmRhdGEubW9kZWxfY29uZmlnO1xuICAgIGNvbnNvbGUubG9nKG1vZGVsX2NvbmZpZyk7XG4gICAgY29uc3QgeyBUcmFuc2Zvcm1lcnNJZnJhbWVDb25uZWN0b3IgfSA9IGF3YWl0IGltcG9ydCgnLi90cmFuc2Zvcm1lcnNfaWZyYW1lLmpzJyk7XG4gICAgY29uc3QgbW9kZWwgPSBhd2FpdCBUcmFuc2Zvcm1lcnNJZnJhbWVDb25uZWN0b3IuY3JlYXRlKG1vZGVsX2NvbmZpZywgd2luZG93KTtcbiAgICB3aW5kb3cubW9kZWwgPSBtb2RlbDtcbiAgfVxufSJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFHQSxRQUFNLFVBQU4sTUFBYztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLWixZQUFZLE1BQU07QUFLaEIsYUFBSyxPQUFPO0FBS1osZUFBTyxPQUFPLE1BQU0sS0FBSyxNQUFNO0FBQUEsTUFDakM7QUFBQSxJQUNGO0FBR0EsWUFBUSxVQUFVO0FBQUE7QUFBQTs7O0FDdkJsQjtBQUFBO0FBQUEsUUFBTSxFQUFFLFFBQVEsSUFBSTtBQUVwQixRQUFNLHNCQUFOLGNBQWtDLFFBQVE7QUFBQSxNQUN4QyxNQUFNLE9BQU87QUFDWCxjQUFNLEVBQUUsS0FBSyxV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\n'
    };
  }
});

// node_modules/smart-embed-model/adapters/iframe.js
var require_iframe = __commonJS({
  "node_modules/smart-embed-model/adapters/iframe.js"(exports2) {
    var { Adapter } = require_adapter();
    var web_connector = require_web_connector();
    var IframeAdapter = class extends Adapter {
      constructor(main) {
        super(main);
        this.frame = null;
        this.output = {};
        this.response_handlers = {};
        this.web_script = web_connector.script;
      }
      unload() {
        console.log("SmartEmbedTransformersWebAdapter Unloading");
        this.remove_frame();
        this.frame = null;
        this.output = {};
        this.response_handlers = {};
      }
      async init() {
        if (!this.frame) {
          this.frame = document.createElement("iframe");
          this.frame.style.display = "none";
          this.frame.style.width = "0";
          this.frame.style.height = "0";
          this.frame_loaded = new Promise((resolve) => this.frame.onload = resolve);
          const model_loaded = new Promise((resolve) => {
            window.addEventListener("message", (event) => {
              if (event.data.type === "model_loaded") {
                console.log("Model Loaded: " + this.model_name);
                resolve();
              }
            }, { once: true, capture: false });
          });
          this.frame.srcdoc = this.iframe_script;
          this.container.appendChild(this.frame);
          await this.frame_loaded;
          this.frame.contentWindow.postMessage({ type: "init", model_config: { ...this.main.config, container: null } }, "*");
          await model_loaded;
          this.frame.contentWindow.addEventListener("message", this.handle_iframe_messages.bind(this), false);
        }
        console.log("SmartEmbedTransformersWebAdapter Connected");
      }
      request_embedding(embed_input, retries = 0) {
        if (!(embed_input == null ? void 0 : embed_input.length))
          return console.log("embed_input is empty");
        const handler_id = typeof embed_input === "string" ? embed_input : create_uid(embed_input);
        this.frame.contentWindow.postMessage({ type: "smart_embed", embed_input, handler_id }, "*");
        return new Promise((resolve, reject) => {
          this.response_handlers[handler_id] = ({ error, data }) => {
            if (error) {
              console.log(error);
              reject(error);
            } else {
              resolve(data);
            }
          };
          setTimeout(() => {
            if (this.response_handlers[handler_id]) {
              reject(new Error("Timeout waiting for response"));
              delete this.response_handlers[handler_id];
            }
          }, 6e4);
        });
      }
      async embed_batch(items) {
        items = items.filter((item) => {
          var _a;
          return ((_a = item.embed_input) == null ? void 0 : _a.length) > 0;
        });
        if (!(items == null ? void 0 : items.length))
          return [];
        const resp = await this.request_embedding(items.map((item) => ({ embed_input: item.embed_input })));
        return items.map((item, i) => {
          const resp_item = resp.data[i];
          item.vec = resp_item.vec;
          item.tokens = resp_item.tokens;
          return item;
        });
      }
      embed(input) {
        return this.request_embedding(input);
      }
      count_tokens(input, timeout = 6e4) {
        this.frame.contentWindow.postMessage({ type: "smart_embed_token_ct", embed_input: input }, "*");
        return new Promise((resolve, reject) => {
          this.response_handlers["count:" + input] = ({ error, data }) => {
            if (error) {
              console.log(error);
              reject(error);
            } else {
              resolve(data);
            }
          };
          setTimeout(() => {
            if (this.response_handlers["count:" + input]) {
              reject(new Error("Timeout waiting for response"));
              delete this.response_handlers["count:" + input];
            }
          }, timeout);
        });
      }
      get iframe_script() {
        return `<script type="module">${this.web_script}</script>`;
      }
      get is_embedding() {
        return Object.keys(this.response_handlers).length > 0;
      }
      get queue_length() {
        return Object.keys(this.response_handlers).length;
      }
      get container_id() {
        return this.model_name.replace(/[^a-z0-9]/gi, "_").toLowerCase();
      }
      remove_frame() {
        if (this.frame)
          this.frame.remove();
        const frame_check = this.container.querySelector("#" + this.container_id);
        if (frame_check)
          frame_check.remove();
        console.log("SmartEmbedTransformersWebAdapter Disconnected");
      }
      handle_iframe_messages(event) {
        if (event.data.type === "smart_embed_resp" || event.data.type === "smart_embed_token_ct") {
          const handler = this.response_handlers[event.data.handler_id || event.data.text];
          if (handler) {
            handler({ error: null, data: event.data });
            delete this.response_handlers[event.data.handler_id || event.data.text];
          }
        }
      }
    };
    exports2.IframeAdapter = IframeAdapter;
    function create_uid(data) {
      const str = JSON.stringify(data);
      let hash = 0;
      if (str.length === 0)
        return hash;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = (hash << 5) - hash + char;
        hash = hash & hash;
        if (hash < 0)
          hash = hash * -1;
      }
      return hash.toString() + str.length;
    }
  }
});

// node_modules/smart-embed-model/adapters.js
var require_adapters = __commonJS({
  "node_modules/smart-embed-model/adapters.js"(exports2) {
    var { ApiAdapter } = require_api();
    exports2.api = ApiAdapter;
    var { LocalApiAdapter } = require_local_api();
    exports2.local_api = LocalApiAdapter;
    var { TransformersAdapter } = require_transformers();
    exports2.transformers = TransformersAdapter;
    var { IframeAdapter } = require_iframe();
    exports2.iframe = IframeAdapter;
  }
});

// node_modules/smart-embed-model/models.json
var require_models = __commonJS({
  "node_modules/smart-embed-model/models.json"(exports2, module2) {
    module2.exports = {
      "TaylorAI/bge-micro-v2": {
        model_name: "TaylorAI/bge-micro-v2",
        batch_size: 1,
        dims: 384,
        max_tokens: 512,
        name: "BGE-micro-v2",
        description: "Local, 512 tokens, 384 dim",
        type: "huggingface-transformers"
      },
      "andersonbcdefg/bge-small-4096": {
        model_name: "andersonbcdefg/bge-small-4096",
        batch_size: 1,
        dims: 384,
        max_tokens: 4096,
        name: "BGE-small-4K",
        description: "Local, 4,096 tokens, 384 dim",
        type: "huggingface-transformers"
      },
      "Xenova/jina-embeddings-v2-base-zh-8192": {
        model_name: "Xenova/jina-embeddings-v2-base-zh",
        batch_size: 1,
        dims: 512,
        max_tokens: 8192,
        name: "Jina-v2-base-zh-8K",
        description: "Local, 8,192 tokens, 512 dim, Chinese/English bilingual",
        type: "huggingface-transformers"
      },
      "text-embedding-3-small": {
        model_name: "text-embedding-3-small",
        batch_size: 50,
        dims: 1536,
        max_tokens: 8191,
        name: "OpenAI Text-3 Small",
        description: "API, 8,191 tokens, 1,536 dim",
        endpoint: "https://api.openai.com/v1/embeddings",
        type: "openai"
      },
      "text-embedding-3-large": {
        model_name: "text-embedding-3-large",
        batch_size: 50,
        dims: 3072,
        max_tokens: 8191,
        name: "OpenAI Text-3 Large",
        description: "API, 8,191 tokens, 3,072 dim",
        endpoint: "https://api.openai.com/v1/embeddings",
        type: "openai"
      },
      "text-embedding-3-small-512": {
        model_name: "text-embedding-3-small",
        batch_size: 50,
        dims: 512,
        max_tokens: 8191,
        name: "OpenAI Text-3 Small - 512",
        description: "API, 8,191 tokens, 512 dim",
        endpoint: "https://api.openai.com/v1/embeddings",
        type: "openai"
      },
      "text-embedding-3-large-256": {
        model_name: "text-embedding-3-large",
        batch_size: 50,
        dims: 256,
        max_tokens: 8191,
        name: "OpenAI Text-3 Large - 256",
        description: "API, 8,191 tokens, 256 dim",
        endpoint: "https://api.openai.com/v1/embeddings",
        type: "openai"
      },
      "text-embedding-ada-002": {
        model_name: "text-embedding-ada-002",
        batch_size: 50,
        dims: 1536,
        max_tokens: 8191,
        name: "OpenAI Ada",
        description: "API, 8,191 tokens, 1,536 dim",
        endpoint: "https://api.openai.com/v1/embeddings",
        type: "openai"
      },
      "Xenova/jina-embeddings-v2-small-en": {
        model_name: "Xenova/jina-embeddings-v2-small-en",
        batch_size: 1,
        dims: 512,
        max_tokens: 8192,
        name: "Jina-v2-small-en",
        description: "Local, 8,192 tokens, 512 dim",
        type: "huggingface-transformers"
      },
      "nomic-ai/nomic-embed-text-v1.5-256": {
        model_name: "nomic-ai/nomic-embed-text-v1.5",
        batch_size: 1,
        dims: 256,
        max_tokens: 8192,
        name: "Nomic-embed-text-v1.5",
        description: "Local, 8,192 tokens, 256 dim",
        type: "huggingface-transformers"
      },
      "Xenova/bge-small-en-v1.5": {
        model_name: "Xenova/bge-small-en-v1.5",
        batch_size: 1,
        dims: 384,
        max_tokens: 512,
        name: "BGE-small",
        description: "Local, 512 tokens, 384 dim",
        type: "huggingface-transformers"
      },
      "nomic-ai/nomic-embed-text-v1": {
        model_name: "nomic-ai/nomic-embed-text-v1",
        batch_size: 1,
        dims: 768,
        max_tokens: 2048,
        name: "Nomic-embed-text",
        description: "Local, 2,048 tokens, 768 dim",
        type: "huggingface-transformers"
      }
    };
  }
});

// node_modules/smart-embed-model/smart_embed_model.js
var require_smart_embed_model = __commonJS({
  "node_modules/smart-embed-model/smart_embed_model.js"(exports2) {
    var adapters = require_adapters();
    var embed_models2 = require_models();
    var SmartEmbedModel = class {
      /**
       * Create a SmartEmbed instance.
       * @param {string} env - The environment to use.
       * @param {string|object} config - The model configuration key or the model configuration object.
       * expects model to contain at least a model_key
       */
      constructor(env, config) {
        this.env = env;
        if (config.model_key)
          this.config = { ...embed_models2[config.model_key], ...config };
        else
          this.config = { ...config };
        this.embed_ct = 0;
        this.timestamp = null;
        this.tokens = 0;
        if (this.config.adapter)
          this.adapter = new adapters[this.config.adapter](this);
        else
          this.adapter = new adapters["api"](this);
      }
      /**
       * Factory method to create a new SmartEmbed instance and initialize it.
       * @param {string} env - The environment to use.
       * @param {string} model_config - Full model configuration object or at least a model_key, api_key, and adapter
       * @returns {Promise<SmartEmbed>} A promise that resolves with an initialized SmartEmbed instance.
       */
      static async create(env, model_config) {
        const model = new this(env, model_config);
        if (model.adapter && typeof model.adapter.init === "function")
          await model.adapter.init();
        return model;
      }
      /**
       * Count the number of tokens in the input string.
       * @param {string} input - The input string to process.
       * @returns {Promise<number>} A promise that resolves with the number of tokens.
       */
      async count_tokens(input) {
        if (this.adapter && typeof this.adapter.count_tokens === "function") {
          return await this.adapter.count_tokens(input);
        }
      }
      /**
       * Embed the input string into a numerical array.
       * @param {string} input - The input string to embed.
       * @returns {Promise<number[]>} A promise that resolves with the embedding array.
       */
      async embed(input) {
        if (this.adapter && typeof this.adapter.embed === "function") {
          return await this.adapter.embed(input);
        }
      }
      /**
       * Embed a batch of input strings into arrays of numerical arrays.
       * @param {string[]} input - The array of strings to embed.
       * @returns {Promise<number[][]>} A promise that resolves with the array of embedding arrays.
       */
      async embed_batch(input) {
        if (this.adapter && typeof this.adapter.embed_batch === "function") {
          return await this.adapter.embed_batch(input);
        }
      }
      /**
       * Get the configured batch size for embedding.
       * @returns {number} The batch size.
       */
      get batch_size() {
        return this.config.batch_size;
      }
      /**
       * Get the dimensions of the embedding.
       * @returns {number} The dimensions of the embedding.
       */
      get dims() {
        return this.config.dims;
      }
      /**
       * Get the maximum number of tokens that can be processed.
       * @returns {number} The maximum number of tokens.
       */
      get max_tokens() {
        return this.config.max_tokens;
      }
      /**
       * Get the name of the model used for embedding.
       * @returns {string} The model name.
       */
      get model_name() {
        return this.config.model_name;
      }
    };
    exports2.SmartEmbedModel = SmartEmbedModel;
  }
});

// node_modules/smart-entities/smart_entities.js
var require_smart_entities = __commonJS({
  "node_modules/smart-entities/smart_entities.js"(exports2) {
    var { Collection } = require_Collection();
    var { CollectionItem } = require_CollectionItem();
    var { SmartEmbedModel } = require_smart_embed_model();
    var SmartEntities = class extends Collection {
      constructor(env) {
        super(env);
        this.env = env;
        this._pause_embeddings = false;
      }
      async _save() {
        await this.LTM._save();
      }
      // async b/c Obsidian API is async
      replacer(key, value) {
        if (value instanceof this.item_type) {
          if (!value.validate_save()) {
            console.log("Invalid block, skipping save: ", value.data);
            return void 0;
          }
          if (value.data.embedding.vec && value.data.text)
            value.data.text = void 0;
          return value.data;
        }
        return super.replacer(key, value);
      }
      unload() {
        var _a;
        if (typeof ((_a = this.smart_embed) == null ? void 0 : _a.unload) === "function") {
          this.smart_embed.unload();
          delete this.smart_embed;
        }
        if (this.smart_embed_container) {
          const iframe = this.smart_embed_container.querySelector("iframe");
          if (!iframe)
            return;
          iframe.srcdoc = "";
          iframe.parentNode.removeChild(iframe);
          this.smart_embed_container.remove();
        }
      }
      async load() {
        await this.LTM.load();
        console.log(this);
        console.log(this.env);
        await this.load_smart_embed();
      }
      async load_smart_embed() {
        var _a, _b;
        if (this.smart_embed_model === "None")
          return;
        if (this.env.smart_embed_active_models[this.smart_embed_model] instanceof SmartEmbedModel) {
          this.smart_embed = this.env.smart_embed_active_models[this.smart_embed_model];
          console.log("SmartEmbed already loaded for " + this.collection_name + ": Model: " + this.smart_embed_model);
        } else {
          const model = { model_key: this.smart_embed_model };
          if (this.smart_embed_model.includes("/")) {
            console.log(this.env.local_model_type);
            this.model_key = this.smart_embed_model;
            const local_max = this.env.config.local_embedding_max_tokens;
            if (local_max < model.max_tokens)
              model.max_tokens = local_max;
            console.log("Checking for local Smart Connect server...");
            try {
              const request_adapter = ((_a = this.env.main.obsidian) == null ? void 0 : _a.requestUrl) || null;
              const sc_local = !request_adapter ? await fetch("http://localhost:37421/") : await request_adapter({ url: "http://localhost:37421/", method: "GET" });
              if (sc_local.status === 200) {
                console.log("Local Smart Connect server found");
                this.smart_embed = await SmartEmbedModel.create(this.env, { ...model, request_adapter, adapter: "local_api", local_endpoint: "http://localhost:37421/embed_batch" });
                return;
              }
            } catch (err) {
              console.log("Could not connect to local Smart Connect server");
            }
            if (this.env.local_model_type === "Web") {
              this.model_key += "_web";
              if (this.smart_embed)
                console.log(`Existing WebAdapter for ${this.collection_name} model: ${this.smart_embed_model}`);
              else
                this.smart_embed = await SmartEmbedModel.create(this.env, { ...model, adapter: "iframe", container: this.smart_embed_container });
            } else {
              this.model_key += "_node";
              if (this.smart_embed)
                console.log(`Existing NodeAdapter for ${this.collection_name} model: ${this.smart_embed_model}`);
              else
                this.smart_embed = await SmartEmbedModel.create(this.env, { ...model, adapter: "transformers" });
            }
          } else {
            this.model_key += "_api";
            if (this.smart_embed)
              console.log(`Existing ApiAdapter for ${this.collection_name} model: ${this.smart_embed_model}`);
            else
              this.smart_embed = await SmartEmbedModel.create(this.env, { ...model, request_adapter: (_b = this.env.main.obsidian) == null ? void 0 : _b.requestUrl, api_key: this.config.api_key });
          }
        }
      }
      get smart_embed_container() {
        if (!this.model_key)
          return console.log("model_key not set");
        const id = this.model_key.replace(/[^a-zA-Z0-9]/g, "_");
        if (!window.document)
          return console.log("window.document not available");
        if (window.document.querySelector(`#${id}`))
          return window.document.querySelector(`#${id}`);
        const container = window.document.createElement("div");
        container.id = id;
        window.document.body.appendChild(container);
        return container;
      }
      get smart_embed() {
        var _a;
        return (_a = this.env.active_embed_models) == null ? void 0 : _a[this.model_key];
      }
      set smart_embed(val) {
        if (!this.model_key)
          this.model_key = val.model_name + "_" + val.constructor.name;
        if (!this.env.active_embed_models)
          this.env.active_embed_models = {};
        this.env.active_embed_models[this.model_key] = val;
      }
      pause_embedding() {
        this._pause_embeddings = true;
        this.env.main.notices.remove("embedding progress");
      }
      async ensure_embeddings(show_notice = null) {
        var _a, _b;
        console.log("ensure_embeddings");
        if (!this.smart_embed)
          return console.log("SmartEmbed not loaded for " + this.collection_name);
        const unembedded_items = this.unembedded_items;
        if (unembedded_items.length === 0)
          return true;
        console.log("unembedded_items: ", unembedded_items);
        const performance_notice_msg = "(This is a resource intensive operation)";
        if (show_notice !== false && unembedded_items.length > 30) {
          const start_btn = { text: "Start embedding", callback: () => this.ensure_embeddings(false) };
          this.env.main.notices.show("start embedding", [`Are you ready to begin embedding ${unembedded_items.length} ${this.collection_name}?`, performance_notice_msg], { timeout: 0, confirm: start_btn });
          return false;
        }
        if (this.is_embedding)
          return console.log("already embedding");
        this.is_embedding = true;
        const batch_size = this.smart_embed.batch_size;
        this.env.main.notices.remove("start embedding");
        let total_tokens = 0;
        let time_start = Date.now();
        let time_elapsed = 0;
        let tokens_per_sec = 0;
        for (let i = 0; i < unembedded_items.length; i += batch_size) {
          if (this._pause_embeddings) {
            this._pause_embeddings = false;
            const restart_btn = { text: "Restart", callback: () => this.ensure_embeddings() };
            this.env.main.notices.show("restart embedding", [`Embedding ${this.collection_name}...`, `Paused at ${i} / ${unembedded_items.length} ${this.collection_name}`, performance_notice_msg], { timeout: 0, button: restart_btn });
            this.LTM._save(true);
            this.is_embedding = false;
            return;
          }
          if (i % 10 === 0) {
            const pause_btn = { text: "Pause", callback: () => this.pause_embedding(), stay_open: true };
            this.env.main.notices.show("embedding progress", [`Embedding ${this.collection_name}...`, `Progress: ${i} / ${unembedded_items.length} ${this.collection_name}`, `${tokens_per_sec} tokens/sec`, performance_notice_msg], { timeout: 0, button: pause_btn, immutable: true });
          }
          const items = unembedded_items.slice(i, i + batch_size);
          await Promise.all(items.map(async (item) => await item.get_embed_input()));
          const resp = await this.smart_embed.embed_batch(items);
          items.forEach((item) => {
            item._embed_input = null;
            item.changed = true;
          });
          total_tokens += resp.reduce((acc, item) => acc + item.tokens, 0);
          time_elapsed = Date.now() - time_start;
          tokens_per_sec = Math.round(total_tokens / (time_elapsed / 1e3));
          if (i && i % 500 === 0) {
            await this.LTM._save();
          }
        }
        if ((_b = (_a = this.env.main._notice) == null ? void 0 : _a.noticeEl) == null ? void 0 : _b.parentElement)
          this.env.main._notice.hide();
        const embedded_ct = unembedded_items.filter((i) => i.vec).length;
        this.env.main.notices.remove("embedding progress");
        this.env.main.notices.show("done embedding", [`Embedding ${this.collection_name}...`, `Done creating ${embedded_ct} embeddings.`], { timeout: 1e4 });
        if (unembedded_items.length)
          this.LTM._save();
        this.is_embedding = false;
        return true;
      }
      get embedded_items() {
        return this.smart_embed ? Object.values(this.items).filter((i) => i.vec) : Object.values(this.items);
      }
      get unembedded_items() {
        return this.smart_embed ? Object.values(this.items).filter((item) => !item.vec) : [];
      }
      nearest(vec, filter = {}) {
        if (!vec)
          return console.log("no vec");
        const {
          // results_count = 20,
          results_count = 50
        } = filter;
        const nearest = this.filter(filter).reduce((acc, item) => {
          var _a;
          if (!((_a = item.data.embedding) == null ? void 0 : _a.vec))
            return acc;
          item.sim = cos_sim(vec, item.data.embedding.vec);
          top_acc(acc, item, results_count);
          return acc;
        }, { min: 0, items: /* @__PURE__ */ new Set() });
        return Array.from(nearest.items);
      }
      get file_name() {
        return this.collection_name + "-" + this.smart_embed_model.split("/").pop();
      }
      get smart_embed_model() {
        return this.config[this.collection_name + "_embed_model"];
      }
    };
    var SmartEntity = class extends CollectionItem {
      static get defaults() {
        return {
          data: {
            path: null,
            embedding: {}
          }
        };
      }
      get_key() {
        return this.data.path;
      }
      // DO: clarified/improved logic
      save() {
        this.collection.set(this);
        this.env.save();
      }
      get_nearest(filter = {}) {
      }
      async get_as_context(params = {}) {
        return `---BEGIN NOTE${params.i ? " " + params.i : ""} [[${this.path}]]---
${await this.get_content()}
---END NOTE${params.i ? " " + params.i : ""}---`;
      }
      async get_content() {
      }
      // override in child class
      async get_embed_input() {
      }
      // override in child class
      // getters
      get ajson() {
        return `${JSON.stringify(this.key)}: ${JSON.stringify(this.data)}`;
      }
      get embed_link() {
        return `![[${this.data.path}]]`;
      }
      get multi_ajson_file_name() {
        return this.path.split("#").shift().replace(/[^a-zA-Z0-9]/g, "_").replace(".md", "");
      }
      get name() {
        return (!this.env.main.settings.show_full_path ? this.path.split("/").pop() : this.path.split("/").join(" > ")).split("#").join(" > ").replace(".md", "");
      }
      get path() {
        return this.data.path;
      }
      get tokens() {
        return this.data.embedding.tokens;
      }
      get vec() {
        return this.data.embedding.vec;
      }
      // setters
      set error(error) {
        this.data.embedding.error = error;
      }
      set tokens(tokens) {
        this.data.embedding.tokens = tokens;
      }
      set vec(vec) {
        this.data.embedding.vec = vec;
      }
    };
    function cos_sim(vector1, vector2) {
      const dotProduct = vector1.reduce((acc, val, i) => acc + val * vector2[i], 0);
      const normA = Math.sqrt(vector1.reduce((acc, val) => acc + val * val, 0));
      const normB = Math.sqrt(vector2.reduce((acc, val) => acc + val * val, 0));
      return normA === 0 || normB === 0 ? 0 : dotProduct / (normA * normB);
    }
    function top_acc(_acc, item, ct = 10) {
      if (_acc.items.size < ct) {
        _acc.items.add(item);
      } else if (item.sim > _acc.min) {
        _acc.items.add(item);
        _acc.items.delete(_acc.minItem);
        _acc.minItem = Array.from(_acc.items).reduce((min, curr) => curr.sim < min.sim ? curr : min);
        _acc.min = _acc.minItem.sim;
      }
    }
    exports2.SmartEntity = SmartEntity;
    exports2.SmartEntities = SmartEntities;
    exports2.cos_sim = cos_sim;
    var SmartNotes = class extends SmartEntities {
      async import(files, opts = {}) {
        try {
          let batch = [];
          for (let i = 0; i < files.length; i++) {
            if (batch.length % 10 === 0) {
              this.env.main.notices.show("initial scan progress", [`Making Smart Connections...`, `Progress: ${i} / ${files.length} files`], { timeout: 0 });
              await Promise.all(batch);
              batch = [];
            }
            const note = this.get(files[i].path);
            if (!note)
              batch.push(this.create_or_update({ path: files[i].path }));
            if (note && note.meta_changed) {
              note.data.embedding = {};
              batch.push(this.create_or_update({ path: files[i].path }));
            }
          }
          await Promise.all(batch);
          this.env.main.notices.remove("initial scan progress");
          this.env.main.notices.show("done initial scan", [`Making Smart Connections...`, `Done importing Smart Notes.`], { timeout: 3e3 });
          this.ensure_embeddings();
        } catch (e) {
          console.log("error importing blocks");
          console.log(e);
        }
      }
      async ensure_embeddings(show_notice = false) {
        var _a;
        await super.ensure_embeddings(show_notice);
        await this.prune(true);
        if ((_a = this.env.smart_blocks) == null ? void 0 : _a.smart_embed) {
          await this.env.smart_blocks.ensure_embeddings({ show_notice });
          await this.env.smart_blocks.prune(true);
        }
      }
      async prune(override = false) {
        var _a;
        const remove = [];
        const items_w_vec = Object.entries(this.items).filter(([key, note]) => note.vec);
        const total_items_w_vec = items_w_vec.length;
        const available_notes = this.env.files.reduce((acc, file) => {
          acc[file.path] = true;
          return acc;
        }, {});
        if (!total_items_w_vec) {
          this.clear();
          return;
        }
        for (const [key, note] of items_w_vec) {
          if (!available_notes[note.data.path]) {
            remove.push(key);
            continue;
          }
          if (note.is_gone) {
            remove.push(key);
            continue;
          }
          if (note.meta_changed) {
            const content = await note.get_content();
            const hash = await create_hash(content);
            if (hash !== ((_a = note.last_history) == null ? void 0 : _a.hash)) {
              remove.push(key);
              continue;
            }
          }
        }
        console.log(remove);
        const remove_ratio = remove.length / total_items_w_vec;
        if (override && remove_ratio < 0.5 || confirm(`Are you sure you want to delete ${remove.length} (${Math.floor(remove_ratio * 100)}%) Note-level Embeddings?`)) {
          this.delete_many(remove);
          this.LTM._save(true);
          console.log(`Pruned ${remove.length} Smart Notes`);
        }
      }
      get current_note() {
        return this.get(this.env.main.app.workspace.getActiveFile().path);
      }
      get blocks() {
        this.env.smart_blocks.get_many(this.last_history.blocks);
      }
    };
    var SmartNote = class extends SmartEntity {
      static get defaults() {
        return {
          data: {
            history: []
            // array of { mtime, hash, length, blocks[] }
          },
          _embed_input: null
          // stored temporarily
        };
      }
      async init() {
        var _a;
        const content = await this.get_content();
        const hash = await create_hash(content);
        if (hash !== ((_a = this.last_history) == null ? void 0 : _a.hash)) {
          this.data.history.push({ blocks: {}, mtime: this.t_file.stat.mtime, size: this.t_file.stat.size, hash });
          this.data.embedding = {};
        } else {
          this.last_history.mtime = this.t_file.stat.mtime;
          this.last_history.size = this.t_file.stat.size;
        }
        this.env.smart_blocks.import(this, { show_notice: false });
      }
      async get_embed_input() {
        if (typeof this._embed_input === "string" && this._embed_input.length)
          return this._embed_input;
        const content = await this.get_content();
        const breadcrumbs = this.data.path.split("/").join(" > ").replace(".md", "");
        this._embed_input = `${breadcrumbs}:
${content}`;
        return this._embed_input;
      }
      find_connections() {
        let results = [];
        if (!this.vec && !this.median_block_vec) {
          const start_embedding_btn = {
            text: "Start embedding",
            callback: () => {
              this.collection.import().then(() => this.env.main.view.render_nearest(this));
            }
          };
          this.env.main.notices.show("no embedding found", `No embeddings found for ${this.name}.`, { confirm: start_embedding_btn });
          return results;
        }
        if (this.vec && this.median_block_vec && this.env.smart_blocks.smart_embed && this.collection.smart_embed) {
          const nearest_blocks = this.env.smart_blocks.nearest(this.median_block_vec, { exclude_key_starts_with: this.key });
          const nearest_notes = this.env.smart_notes.nearest(this.vec, { exclude_key_starts_with: this.key });
          results = nearest_blocks.map((block) => {
            const note = nearest_notes.find((note2) => note2.key === block.note_key);
            if (!note)
              block.score = block.sim;
            else
              block.score = (block.sim + note.sim) / 2;
            return block;
          }).sort((a, b) => {
            if (a.score === b.score)
              return 0;
            return a.score > b.score ? -1 : 1;
          });
        } else if (this.median_block_vec && this.env.smart_blocks.smart_embed) {
          const nearest_blocks = this.env.smart_blocks.nearest(this.median_block_vec, { exclude_key_starts_with: this.key });
          results = nearest_blocks.map((block) => {
            var _a;
            if (!((_a = block.note) == null ? void 0 : _a.median_block_vec.length)) {
              block.score = block.sim;
              return block;
            }
            block.score = (block.sim + cos_sim(this.median_block_vec, block.note.median_block_vec)) / 2;
            return block;
          }).sort((a, b) => {
            if (a.score === b.score)
              return 0;
            return a.score > b.score ? -1 : 1;
          });
        } else if (this.vec && this.collection.smart_embed) {
          const nearest_notes = this.env.smart_notes.nearest(this.vec, { exclude_key_starts_with: this.key });
          results = nearest_notes.map((note) => {
            note.score = note.sim;
            return note;
          }).sort((a, b) => {
            if (a.score === b.score)
              return 0;
            return a.score > b.score ? -1 : 1;
          });
        }
        return results;
      }
      open() {
        this.env.main.open_note(this.data.path);
      }
      get_block_by_line(line) {
        return this.blocks.find((block) => block.data.lines[0] <= line && block.data.lines[1] >= line);
      }
      get block_vecs() {
        return this.blocks.map((block) => block.data.embedding.vec).filter((vec) => vec);
      }
      // filter out blocks without vec
      get blocks() {
        return Object.keys(this.last_history.blocks).map((block_key) => this.env.smart_blocks.get(block_key)).filter((block) => block);
      }
      // filter out blocks that don't exist
      get embed_input() {
        return this._embed_input ? this._embed_input : this.get_embed_input();
      }
      get meta_changed() {
        if (!this.last_history)
          return true;
        return this.last_history.mtime !== this.t_file.stat.mtime && this.last_history.size !== this.t_file.stat.size;
      }
      get is_canvas() {
        return this.data.path.endsWith("canvas");
      }
      get is_excalidraw() {
        return this.data.path.endsWith("excalidraw.md");
      }
      get is_gone() {
        return this.t_file === null;
      }
      get last_history() {
        return this.data.history.length ? this.data.history[this.data.history.length - 1] : null;
      }
      get mean_block_vec() {
        return this._mean_block_vec ? this._mean_block_vec : this._mean_block_vec = this.block_vecs.reduce((acc, vec) => acc.map((val, i) => val + vec[i]), Array(384).fill(0)).map((val) => val / this.block_vecs.length);
      }
      get median_block_vec() {
        var _a;
        return this._median_block_vec ? this._median_block_vec : this._median_block_vec = (_a = this.block_vecs[0]) == null ? void 0 : _a.map((val, i) => this.block_vecs.map((vec) => vec[i]).sort()[Math.floor(this.block_vecs.length / 2)]);
      }
      get note_name() {
        return this.path.split("/").pop().replace(".md", "");
      }
      get t_file() {
        return this.env.get_tfile(this.data.path);
      }
    };
    var SmartBlocks = class extends SmartEntities {
      async import(note) {
        try {
          const note_path = note.data.path;
          const note_content = await note.get_content();
          const { blocks } = this.env.smart_markdown.parse({ content: note_content, file_path: note_path });
          blocks.forEach((block) => {
            const item = this.create_or_update(block);
            note.last_history.blocks[item.key] = true;
          });
        } catch (e) {
          console.log("error parsing blocks for note: ", note.key);
          console.log(e);
        }
      }
      async prune(override = false) {
        const remove = [];
        const total_items_w_vec = this.embedded_items.length;
        if (!total_items_w_vec) {
          return;
        }
        for (const [key, block] of Object.entries(this.items)) {
          if (block.is_gone)
            remove.push(key);
        }
        const remove_ratio = remove.length / total_items_w_vec;
        if (override && remove_ratio < 0.5 || confirm(`Are you sure you want to delete ${remove.length} (${Math.floor(remove_ratio * 100)}%) Block-level embeddings?`)) {
          this.delete_many(remove);
          if (!override)
            this.LTM._save(true);
        }
        console.log(`Pruned ${remove.length} SmartBlocks.`);
      }
    };
    var SmartBlock = class extends SmartEntity {
      static get defaults() {
        return {
          data: {
            text: null,
            // hash: null,
            length: 0
          },
          _embed_input: ""
          // stored temporarily
        };
      }
      // SmartChunk: text, length, path
      update_data(data) {
        var _a;
        if (!this.is_new) {
          if (this.data.length !== data.length)
            this.data.embedding = {};
        }
        if (!((_a = this.data.embedding) == null ? void 0 : _a.vec))
          this._embed_input += data.text;
        delete data.text;
        super.update_data(data);
        return true;
      }
      init() {
        if (!this.note)
          return console.log({ "no note for block": this.data });
        if (Array.isArray(this.note.last_history.blocks))
          this.note.last_history.blocks = {};
        this.note.last_history.blocks[this.key] = true;
      }
      async get_content() {
        var _a;
        const note_content = await ((_a = this.note) == null ? void 0 : _a.get_content());
        if (!note_content)
          return null;
        const block_content = this.env.smart_markdown.get_block_from_path(this.data.path, note_content);
        return block_content;
      }
      async get_embed_input() {
        if (typeof this._embed_input === "string" && this._embed_input.length)
          return this._embed_input;
        this._embed_input = this.breadcrumbs + "\n" + await this.get_content();
        return this._embed_input;
      }
      async get_next_k_shot(i) {
        if (!this.next_block)
          return null;
        const current = await this.get_content();
        const next = await this.next_block.get_content();
        return `---BEGIN CURRENT ${i}---
${current}
---END CURRENT ${i}---
---BEGIN NEXT ${i}---
${next}
---END NEXT ${i}---
`;
      }
      find_connections() {
        if (!this.vec)
          return [];
        return this.env.smart_blocks.nearest(this.vec, { exclude_key_starts_with: this.note.key });
      }
      get breadcrumbs() {
        return this.data.path.split("/").join(" > ").split("#").join(" > ").replace(".md", "");
      }
      get embed_input() {
        return this._embed_input ? this._embed_input : this.get_embed_input();
      }
      get lines() {
        return { start: this.data.lines[0], end: this.data.lines[1] };
      }
      get folder() {
        return this.data.path.split("/").slice(0, -1).join("/");
      }
      get is_block() {
        this.data.path.includes("#");
      }
      get is_gone() {
        if (this.env.smart_notes.unembedded_items.length)
          return false;
        if (!this.note)
          return true;
        if (this.note.is_gone)
          return true;
        if (!this.note.last_history.blocks[this.key])
          return true;
        return false;
      }
      // use text length to detect changes
      get name() {
        return (!this.env.main.settings.show_full_path ? this.data.path.split("/").pop() : this.data.path.split("/").join(" > ")).split("#").join(" > ").replace(".md", "");
      }
      // uses data.lines to get next block
      get next_block() {
        var _a;
        if (!this.data.lines)
          return null;
        const next_line = this.data.lines[1] + 1;
        return (_a = this.note.blocks) == null ? void 0 : _a.find((block) => {
          var _a2, _b;
          return next_line === ((_b = (_a2 = block.data) == null ? void 0 : _a2.lines) == null ? void 0 : _b[0]);
        });
      }
      get note() {
        return this.env.smart_notes.get(this.note_key);
      }
      get note_key() {
        return this.data.path.split("#")[0];
      }
      get note_name() {
        return this.note_key.split("/").pop().replace(".md", "");
      }
      // backwards compatibility (DEPRECATED)
      get link() {
        return this.data.path;
      }
    };
    async function create_hash(text) {
      const msgUint8 = new TextEncoder().encode(text.trim());
      const hashBuffer = await crypto.subtle.digest("SHA-256", msgUint8);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      const hashHex = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
      return hashHex;
    }
    exports2.SmartBlock = SmartBlock;
    exports2.SmartBlocks = SmartBlocks;
    exports2.SmartNote = SmartNote;
    exports2.SmartNotes = SmartNotes;
  }
});

// src/render_dataview_codeblocks.js
var require_render_dataview_codeblocks = __commonJS({
  "src/render_dataview_codeblocks.js"(exports2) {
    async function render_dataview_codeblocks(file_content, note_path, opts = {}) {
      opts = {
        char_limit: null,
        ...opts
      };
      const dataview_api = window == null ? void 0 : window["DataviewAPI"];
      if (!dataview_api)
        return file_content;
      const dataview_code_blocks = file_content.match(/```dataview(.*?)```/gs);
      if (!dataview_code_blocks)
        return file_content;
      for (let i = 0; i < dataview_code_blocks.length; i++) {
        if (opts.char_limit && opts.char_limit < file_content.indexOf(dataview_code_blocks[i]))
          break;
        const dataview_code_block = dataview_code_blocks[i];
        const dataview_code_block_content = dataview_code_block.replace("```dataview", "").replace("```", "");
        const dataview_query_result = await dataview_api.queryMarkdown(dataview_code_block_content, note_path, null);
        if (dataview_query_result.successful) {
          file_content = file_content.replace(dataview_code_block, dataview_query_result.value);
        }
      }
      return file_content;
    }
    exports2.render_dataview_codeblocks = render_dataview_codeblocks;
  }
});

// src/sc_entities.js
var require_sc_entities = __commonJS({
  "src/sc_entities.js"(exports2) {
    var {
      SmartBlock: BaseSmartBlock,
      SmartBlocks,
      SmartNote: BaseSmartNote,
      SmartNotes
    } = require_smart_entities();
    var { render_dataview_codeblocks } = require_render_dataview_codeblocks();
    var SmartNote = class extends BaseSmartNote {
      async get_content() {
        return await this.brain.cached_read(this.data.path);
      }
      async get_as_context(params = {}) {
        const content = await render_dataview_codeblocks(await this.get_content(), this.data.path);
        return `---BEGIN NOTE${params.i ? " " + params.i : ""} [[${this.path}]]---
${content}
---END NOTE${params.i ? " " + params.i : ""}---`;
      }
    };
    var SmartBlock = class extends BaseSmartBlock {
      async get_as_context(params = {}) {
        const content = await render_dataview_codeblocks(await this.get_content(), this.data.path);
        return `---BEGIN NOTE${params.i ? " " + params.i : ""} [[${this.path}]]---
${content}
---END NOTE${params.i ? " " + params.i : ""}---`;
      }
    };
    exports2.SmartNotes = SmartNotes;
    exports2.SmartNote = SmartNote;
    exports2.SmartBlocks = SmartBlocks;
    exports2.SmartBlock = SmartBlock;
  }
});

// src/smart_socket.js
var require_smart_socket = __commonJS({
  "src/smart_socket.js"(exports2) {
    var SmartSocket = class {
      /**
       * Creates an instance of SmartSocket.
       * @param {number} port The port number to connect to.
       */
      constructor(port) {
        this.port = port;
        this.ws_retries = 0;
        this.ws = null;
        this.retry = false;
      }
      /**
       * Initiates the connection process, with optional retry logic.
       * @param {boolean} [retry=false] Whether to attempt a reconnection.
       */
      async connect(retry = false) {
        this.retry = retry;
        if (!this.can_attempt_connection(retry))
          return;
        if (retry)
          await this.calculate_backoff(retry);
        if (typeof this.is_server_running === "function") {
          const is_running = await this.is_server_running();
          if (!is_running) {
            console.log("Smart Connect is not running, will try to connect again later");
            this.connect(true);
            return;
          }
        }
        try {
          await this.initialize_websocket();
        } catch (err) {
          if (retry && (this.ws_retries < 10 || typeof this.is_server_running === "function")) {
            await this.handle_connection_error(true, err);
          } else {
            this.on_fail_to_reconnect();
          }
        }
      }
      /**
       * Checks if a new connection attempt can be made.
       * @param {boolean} retry Indicates if this is a retry attempt.
       * @returns {boolean} True if a connection attempt can be made, false otherwise.
       */
      can_attempt_connection(retry) {
        retry = retry || this.retry;
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
          console.log("WebSocket is already connected. Aborting new connection attempt.");
          return false;
        }
        if (retry && this.ws_retries >= 10) {
          console.error("Failed to reconnect after 10 attempts");
          this.on_fail_to_reconnect();
          return false;
        }
        return true;
      }
      /**
       * Calculates and applies a backoff delay for reconnection attempts.
       * @param {boolean} retry Indicates if this is a retry attempt.
       * @returns {Promise<void>} A promise that resolves after the backoff delay.
       */
      calculate_backoff(retry) {
        if (retry || this.retry) {
          this.ws_retries += 1;
          const backoff_time = Math.min(1e3 * Math.pow(2, this.ws_retries), 6e4);
          console.log(`Attempting to reconnect in ${backoff_time / 1e3} seconds...`);
          return new Promise((resolve) => setTimeout(resolve, backoff_time));
        }
        return Promise.resolve();
      }
      /**
       * Initializes the WebSocket connection.
       * @returns {Promise<void>} A promise that resolves when the WebSocket is successfully opened.
       */
      async initialize_websocket() {
        this.cleanup_websocket();
        await new Promise((resolve, reject) => {
          const timeout_id = setTimeout(() => {
            var _a;
            if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
              (_a = this.ws) == null ? void 0 : _a.close();
              reject(new Error("WebSocket failed to connect"));
            }
          }, 1e4);
          this.ws = new WebSocket(`ws://localhost:${this.port}`);
          this.ws.onopen = () => {
            clearTimeout(timeout_id);
            this.on_open();
            this.ws_retries = 0;
            this.retry = true;
            resolve();
          };
          this.ws.onclose = (event) => {
            this.cleanup_websocket();
            reject(new Error("WebSocket closed"));
            this.on_close();
          };
          this.ws.onerror = (err) => {
            this.cleanup_websocket();
            reject(err);
            this.on_error(err);
          };
          this.ws.onmessage = this.handle_message.bind(this);
        });
      }
      cleanup_websocket() {
        if (this.ws) {
          this.ws.onopen = null;
          this.ws.onclose = null;
          this.ws.onerror = null;
          this.ws.onmessage = null;
          if (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING) {
            this.ws.close();
          }
          this.ws = null;
        }
      }
      /**
       * Handles connection errors and decides whether to retry.
       * @param {boolean} retry Indicates if this is a retry attempt.
       * @param {Error} err The error that occurred during connection.
       */
      async handle_connection_error(retry, err) {
        console.log("Handling WebSocket connection error on port " + this.port);
        if (retry && this.ws_retries < 10) {
          await this.connect(true);
        } else if (!retry || this.ws_retries >= 10) {
          console.error("Failed to connect to WebSocket after retries:");
          console.log(err);
          this.on_fail_to_reconnect();
        }
      }
      /**
       * Placeholder for error handling logic.
       * @param {Error} err The error encountered.
       */
      on_error(err) {
      }
      /**
       * Handles WebSocket closure and attempts reconnection.
       */
      on_close() {
        console.log("Disconnected from WebSocket");
        if (this.retry && this.should_attempt_reconnect) {
          this.connect(true);
        } else {
          console.log("Reconnection not attempted due to policy (intentional disconnection or retry limit reached).");
        }
      }
      get should_attempt_reconnect() {
        return this.ws_retries < 10;
      }
      /**
       * Logs successful WebSocket connection.
       */
      on_open() {
        console.log(`Connected to WebSocket on port ${this.port}`);
      }
      /**
       * Handles incoming WebSocket messages.
       * @param {MessageEvent} event The message event.
       */
      handle_message(event) {
        console.log("Message from server", event.data);
      }
      /**
       * Handles failure to reconnect after multiple attempts.
       */
      on_fail_to_reconnect() {
        console.error("Failed to reconnect, will not retry...");
      }
      /**
       * Closes the WebSocket connection.
       */
      unload() {
        this.cleanup_websocket();
      }
    };
    exports2.SmartSocket = SmartSocket;
  }
});

// src/dataview_socket.js
var require_dataview_socket = __commonJS({
  "src/dataview_socket.js"(exports2) {
    var { SmartSocket } = require_smart_socket();
    var DataviewSocket = class extends SmartSocket {
      constructor(env, port) {
        super(port);
        this.env = env;
        this.brain = this.env;
        this.dataview_api = null;
      }
      static async create(env, port) {
        const smart_socket = new DataviewSocket(env, port);
        env.dv_ws = smart_socket;
        await smart_socket.init();
        return smart_socket;
      }
      async init() {
        await this.get_dataview_api();
        await this.connect();
      }
      async is_server_running() {
        var _a;
        try {
          const sc_local = await ((_a = this.env.main.obsidian) == null ? void 0 : _a.requestUrl({ url: "http://localhost:37421/", method: "GET" }));
          console.log(sc_local);
          return (sc_local == null ? void 0 : sc_local.status) === 200;
        } catch (err) {
          return false;
        }
      }
      async get_dataview_api(retries = 0) {
        this.dataview_api = window["DataviewAPI"];
        if (!this.dataview_api) {
          if (retries < 10) {
            await new Promise((resolve) => setTimeout(resolve, retries * 1e3));
            return this.get_dataview_api(retries + 1);
          } else {
            this.brain.main.show_notice("Dataview API not found");
          }
        }
      }
      async handle_message(event) {
        console.log("Message from server ", event.data);
        console.log(typeof event.data);
        const data = JSON.parse(event.data);
        try {
          const resp = await this.dataview_api.queryMarkdown(data.query, data.rel_path, null);
          console.log(resp);
          this.ws.send(JSON.stringify(resp));
        } catch (err) {
          console.error(err);
          this.ws.send(JSON.stringify({ status: "error", message: err }));
        }
      }
    };
    exports2.DataviewSocket = DataviewSocket;
  }
});

// build/views.json
var require_views = __commonJS({
  "build/views.json"(exports2, module2) {
    module2.exports = {
      attribution: '<div class="sc-brand">\n  <svg viewBox="0 0 100 100" class="svg-icon smart-connections">\n    <path d="M50,20 L80,40 L80,60 L50,100" stroke="currentColor" stroke-width="4" fill="none"></path>\n    <path d="M30,50 L55,70" stroke="currentColor" stroke-width="5" fill="none"></path>\n    <circle cx="50" cy="20" r="9" fill="currentColor"></circle>\n    <circle cx="80" cy="40" r="9" fill="currentColor"></circle>\n    <circle cx="80" cy="70" r="9" fill="currentColor"></circle>\n    <circle cx="50" cy="100" r="9" fill="currentColor"></circle>\n    <circle cx="30" cy="50" r="9" fill="currentColor"></circle>\n  </svg>\n  <p><a style="font-weight: 700;" href="https://smartconnections.app/">Smart Connections</a></p>\n</div>',
      sc_change: '<div class="sc-change">\n  <div class="actions">\n    <button>Accept</button>\n    <button>Reject</button>\n    <button>Show Old</button>\n    <button style="display: none;">Hide Old</button>\n    <div>Time saved: <%= time_saved %></div>\n    <%- this.attribution %>\n  </div>\n  <div class="old-content" style="display: none;"></div>\n  <div class="new-content"></div>\n</div>\n\n',
      smart_chat: `<div class="workspace-leaf-content" data-type="smart-connections-chat-view">
  <div class="sc-chat-container">
    <div class="sc-top-bar-container">
      <input class="sc-chat-name-input" type="text" value="<%= name %>" placeholder="Chat Name">
      <button title="Open Conversation Note"><%- this.get_icon('external-link') %></button>
      <button title="Chat History"><%- this.get_icon('history') %></button>
      <button title="Settings"><%- this.get_icon('gear') %></button>
      <button title="New Chat"><%- this.get_icon('plus') %></button>
    </div>
    <div class="sc-chat-box">
      <div class="sc-message-container">
        <div class="sc-message assistant">
          <div class="sc-message-content">
            <span>
              Hi there, welcome to the Smart Chat.&nbsp;Ask me a question about your notes and I'll try to answer it.
            </span>
          </div>
        </div>
        <%- messages %>
      </div>
    </div>
    <div class="sc-chat-form"><textarea class="sc-chat-input"
        placeholder="Try &quot;Based on my notes&quot; or &quot;Summarize [[this note]]&quot; or &quot;Important tasks in /folder/&quot;"></textarea>
      <div class="sc-button-container">
        <span id="sc-abort-button" style="display: none;"><%- this.get_icon('square') %></span>
        <button class="send-button" id="sc-send-button">Send</button>
      </div>
    </div>
    <div id="settings"></div>
  </div>
  <%- this.attribution %>
</div>`,
      smart_chat_msg: `<div class="sc-message <%= role %>">
  <div class="sc-message-content" data-content="<%= content %>">
    <span><%= content %></span>
    <span class="sc-msg-button" title="Copy message to clipboard"><%- this.get_icon('copy') %></span>
    <!-- TODO: Copy context to clipboard (icon: eye) -->
    <!-- TODO: Copy prompt to clipboard (icon: files) -->
  </div>
</div>`,
      smart_chat_settings: '<div class="setting-component"\n  data-name="Model Platform"\n  data-setting="chat_model_platform_key"\n  data-type="dropdown"\n  data-description="Select a model platform to use with Smart Chat."\n  <%- chat_platforms.map((platform, i) => `data-option-${i + 1}="${platform.key}|${platform.description}"`).join(\'\\n\') %>\n  data-callback="changed_smart_chat_model"\n></div>\n<% if(chat_platform.fetch_models) { %>\n  <% if(settings[settings.chat_model_platform_key]?.api_key) { %>\n    <div class="setting-component"\n      data-name="Model Name"\n      data-type="dropdown"\n      data-setting="<%= settings.chat_model_platform_key %>.model_name"\n      data-callback="changed_smart_chat_model"\n      <%- platform_chat_models.map((model, i) => `data-option-${i}="${model.key}|${model.model_name} (${model.description})"`).join(\'\\n\') %>\n    ></div>\n  <% } %>\n  <% if(!platform_chat_models.length) { %>\n    <div class="setting-component"\n      data-name="Refresh Models List"\n      data-type="button"\n      data-callback="changed_smart_chat_model"\n    ></div>\n  <% } %>\n  <div class="setting-component"\n    data-name="<%= chat_platform.description %> API Key"\n    data-type="text"\n    data-setting="<%= settings.chat_model_platform_key %>.api_key"\n    <% if(chat_platform.signup_url) { %>\n      data-description="<a href=\'<%= chat_platform.signup_url %>\'>Get API Key</a> for <%= chat_platform.description %>."\n    <% } else { %>\n      data-description="API Key for <%= chat_platform.description %>."\n    <% } %>\n    data-placeholder="Enter an API Key"\n    data-button="Save"\n    data-callback="test_chat_api_key"\n  ></div>\n<% } %>\n<% if (settings.chat_model_platform_key.startsWith(\'custom_local\')) { %>\n  <h3>Custom Local Model</h3>\n  <div class="setting-component"\n    data-name="Model Name"\n    data-type="text"\n    data-setting="custom_local.model_name"\n    data-description="Name of the custom model."\n    data-placeholder="Enter a model name"\n    data-callback="changed_smart_chat_model"\n  ></div>\n  <div class="setting-component"\n    data-name="protocol"\n    data-type="text"\n    data-setting="custom_local.protocol"\n    data-description="Protocol for chat server (http or https)."\n    data-placeholder="Enter a protocol"\n    data-callback="changed_smart_chat_model"\n  ></div>\n  <div class="setting-component"\n    data-name="hostname"\n    data-type="text"\n    data-setting="custom_local.hostname"\n    data-description="Host for local chat server."\n    data-placeholder="Enter a host"\n    data-callback="changed_smart_chat_model"\n  ></div>\n  <div class="setting-component"\n    data-name="port"\n    data-type="number"\n    data-setting="custom_local.port"\n    data-description="Port for local chat server."\n    data-placeholder="Enter a port number"\n    data-callback="changed_smart_chat_model"\n  ></div>\n  <div class="setting-component"\n    data-name="path"\n    data-type="text"\n    data-setting="custom_local.path"\n    data-description="Path for local chat server."\n    data-placeholder="Enter a path"\n    data-callback="changed_smart_chat_model"\n  ></div>\n  <div class="setting-component"\n    data-name="streaming"\n    data-type="toggle"\n    data-setting="custom_local.streaming"\n    data-description="Enable streaming for local chat server. Disable if you are getting CORS errors."\n    data-callback="changed_smart_chat_model"\n  ></div>\n  <div class="setting-component"\n    data-name="Max input tokens"\n    data-description="Maximum number of tokens for input to the model."\n    data-type="number"\n    data-setting="custom_local.max_input_tokens"\n    data-placeholder="Enter a number"\n    data-callback="changed_smart_chat_model"\n  ></div>\n<% } else if(settings.chat_model_platform_key.startsWith(\'custom_api\')) { %>\n  <h3>Custom Server</h3>\n  <div class="setting-component"\n    data-name="Model Name"\n    data-type="text"\n    data-setting="custom_api.model_name"\n    data-description="Name of the custom model."\n    data-placeholder="Enter a model name"\n    data-callback="changed_smart_chat_model"\n  ></div>\n  <div class="setting-component"\n    data-name="protocol"\n    data-type="text"\n    data-setting="custom_api.protocol"\n    data-description="Protocol for chat server (http or https)."\n    data-placeholder="Enter a protocol"\n    data-callback="changed_smart_chat_model"\n  ></div>\n  <div class="setting-component"\n    data-name="hostname"\n    data-type="text"\n    data-setting="custom_api.hostname"\n    data-description="Host for chat server."\n    data-placeholder="Enter a host"\n    data-callback="changed_smart_chat_model"\n  ></div>\n  <div class="setting-component"\n    data-name="path"\n    data-type="text"\n    data-setting="custom_api.path"\n    data-description="Path for chat server."\n    data-placeholder="Enter a path"\n    data-callback="changed_smart_chat_model"\n  ></div>\n  <div class="setting-component"\n    data-name="streaming"\n    data-type="toggle"\n    data-setting="custom_api.streaming"\n    data-description="Enable streaming for chat server. Disable if you are getting CORS errors."\n    data-callback="changed_smart_chat_model"\n  ></div>\n  <div class="setting-component"\n    data-name="Max input tokens"\n    data-description="Maximum number of tokens for input to the model."\n    data-type="number"\n    data-setting="custom_api.max_input_tokens"\n    data-placeholder="Enter a number"\n    data-callback="changed_smart_chat_model"\n  ></div>\n  <div class="setting-component"\n    data-name="API Key"\n    data-type="text"\n    data-setting="custom_api.api_key"\n    data-description="API Key for the custom server sent as a header (bearer token)."\n    data-placeholder="Enter an API Key"\n    data-button="Save"\n    data-callback="test_chat_api_key"\n  ></div>\n<% } %>',
      smart_chat_system_msg: '<div class="sc-<%= role %>">\n  <div class="" data-content="<%= content %>">\n    <span><%= content %></span>\n  </div>\n</div>',
      smart_connections: `<div class="sc-top-bar">
  <p class="sc-context">
    <%- current_path %>
    <%- this.notes %> (<%- this.blocks %>)
  </p>
  <button class="sc-fold-all"><%- this.get_icon('fold-vertical') %></button>
  <button class="sc-unfold-all"><%- this.get_icon('unfold-vertical') %></button>
  <button class="sc-search-button"><%- this.get_icon('search') %></button>
  <button title="Settings"><%- this.get_icon('gear') %></button>
</div>
<div class="sc-list">
  <% for (let result of results) { %>
  <div class="search-result<%- !this.settings.expanded_view ? ' sc-collapsed' : '' %>" data-path="<%- result.path %>">
    <span class="header">
      <%- this.get_icon('right-triangle') %>
      <a class="search-result-file-title" title="<%- result.path %>" draggable="true">
        <small><%- [result.score?.toFixed(2), result.name].join(' | ') %></small>
      </a>
    </span>
    <ul draggable="true">
      <li class="search-result-file-title" title="<%- result.path %>" data-collection="<%= result.collection_name %>"></li>
    </ul>
  </div>
  <% } %>
</div>
<div id="settings"></div>
<%- this.attribution %>`,
      smart_embed_settings: `<div class="setting-component"
  data-name="Notes Embedding Model"
  data-setting="smart_notes_embed_model"
  data-type="dropdown"
  data-description="Select a model to use for embedding your notes."
  <%- embedding_models.map((model, i) => \`data-option-\${i + 1}="\${model.key}|\${model.name} (\${model.description})"\`).join('\\n') %>
  data-callback="restart_plugin"
></div>
<div class="setting-component"
  data-name="Blocks Embedding Model"
  data-setting="smart_blocks_embed_model"
  data-type="dropdown"
  data-description="Select a model to use for embedding your blocks."
  data-option-0="None|None"
  <%- embedding_models.map((model, i) => \`data-option-\${i + 1}="\${model.key}|\${model.name} (\${model.description})"\`).join('\\n') %>
  data-callback="restart_plugin"
></div>
<div class="setting-component"
  data-name="Minimum Embedding Length"
  data-description="Minimum length of note to embed."
  data-type="number"
  data-setting="embed_input_min_chars"
  data-placeholder="Enter a number"
  data-callback="reload_env"
></div>
<% if(!settings.smart_notes_embed_model.includes('/') || !settings.smart_blocks_embed_model.includes('/')) { %>
<div class="setting-component"
  data-name="OpenAI API Key for embeddings"
  data-type="text"
  data-setting="api_key"
  data-placeholder="Enter your OpenAI API Key"
  data-button="Save"
  data-callback="test_api_key_openai_embeddings"
></div>
<% } %>
<% if(settings.smart_notes_embed_model.includes('/') || settings.smart_blocks_embed_model.includes('/')) { %>
<div class="setting-component"
  data-name="Local Embedding Max Tokens"
  data-description="Reduce max tokens depending on available resources (CPU, RAM)." 
  data-type="dropdown"
  data-setting="local_embedding_max_tokens"
  data-option-1="512"
  data-option-2="1024"
  data-option-3="2048|2048 (default)"
  data-option-4="4096"
  data-option-5="8192"
  data-callback="reload_env"
></div>

<div class="setting-component"
  data-name="Connect to Smart Connect"
  data-description="<a href='https://github.com/brianpetro/smart-connect'>Smart Connect</a> is free to use for faster local embeddings."
  data-type="button"
  data-callback="connect_to_smart_connect"
></div>
<% } %>
<div class="setting-component"
  data-name="Show Full Path"
  data-description="Show full path in view."
  data-type="toggle"
  data-setting="show_full_path"
  data-callback="refresh_smart_view"
></div>`,
      smart_settings: `<div data-callout-metadata="" data-callout-fold="" data-callout="info" class="callout">
  <div class="callout-title">
    <div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
        class="svg-icon lucide-info">
        <circle cx="12" cy="12" r="10"></circle>
        <path d="M12 16v-4"></path>
        <path d="M12 8h.01"></path>
      </svg></div>
    <div class="callout-title-inner">
      <blockquote>
        <p><b>User Agreement:</b> By using Smart Connections you agree to share how it helps you with at least one other person
          \u{1F60A}\u{1F334}</p>
      </blockquote>
    </div>
  </div>
</div>
<h1>Supporter Features</h1>
<p>As a Smart Connections "Supporter", fast-track your PKM journey with priority perks and pioneering innovations.</p>
<ul>
  <li>Access to the supporter-only <a href="https://chat.smartconnections.app">private chat</a>:
    <ul>
      <li>Swift, top-priority support.</li>
      <li>Learn about the latest features and improvements before they are released.</li>
      <li>Opportunity to influence the future of Smart Connections.</li>
      <li>Ask questions and share your insights with other supporters.</li>
    </ul>
  </li>
  <li>Early access to new &amp; experimental features:
    <ul>
      <li>Coming soon in v2.2: Multi-modal Smart Chat</li>
      <li>Coming soon in v2.2: Re-ranking in the Smart View</li>
      <li>Coming soon in v2.2: Actions in the Smart Chat</li>
      <li>Coming soon in v2.2: Advanced filters in the Smart View</li>
    </ul>
  </li>
  <li><i>For a limited time</i>: Early access to Smart Connect: Use ChatGPT with your notes <i>without</i> uploading your notes to the cloud using <a href="https://chat.openai.com/g/g-9Xb1mRJYl-smart-connect-obsidian">Smart Connect - Obsidian</a> GPT.</li>
</ul>
<div class="setting-component"
  data-name="Supporter License Key"
  data-type="text"
  data-setting="license_key"
  data-description="Note: this is not required to use Smart Connections."
  data-placeholder="Enter your license_key"
></div>
<div class="setting-component"
  data-name="Smart Connect - Obsidian GPT"
  data-btn-text="Open GPT"
  data-description='Chat with your notes in ChatGPT without uploading your notes to the cloud!'
  data-type="button"
  data-href="https://chat.openai.com/g/g-9Xb1mRJYl-smart-connections-2"
></div>
<div class="setting-component"
  data-name="Become a Supporter"
  data-description="Become a Supporter"
  data-type="button"
  data-href="https://buy.stripe.com/9AQ7sWemT48u1LGcN4"
></div>
<h1>Smart View & Embeddings</h1>
<p>Notes about embedding models:</p>
<ul>
  <li>Local model compatibility depends on available CPU and RAM. Try reducing the max tokens (context) if a local model if failing.</li>
  <li>API models are not dependent on local compute, but they require an API key and send your notes to third-party servers for processing.</li>
</ul>
<%- smart_embed_settings %>
<h1>Smart Chat</h1>
<%- smart_chat_settings %>
<h3>System Prompts</h3>
<div class="setting-component"
  data-name="System Prompts Folder"
  data-description="Folder to store system prompts. Available in chat by typing '@'"
  data-type="text"
  data-setting="system_prompts_folder"
  data-placeholder="Enter a folder name"
  data-callback="update_system_prompts_folder"
  data-button="Save"
></div>
<div class="setting-component"
  data-name="Default Language"
  data-setting="language"
  data-type="dropdown"
  data-description="Default language to use for Smart Chat. Changes which self-referential pronouns will trigger lookup of your notes."
  data-option-1="en|English"
  data-option-2="es|Spanish"
  data-option-3="fr|French"
  data-option-4="de|German"
  data-option-5="it|Italian"
  data-callback="update_language"
></div>
<span id="self-referential-pronouns">Current: my, I, me, mine, our, ours, us, we</span>
<h1>Exclusions</h1>
<p id="file-counts">Included files: <%= included_files %> / Total files: <%= total_files %></p>
<div class="setting-component"
  data-name="File Exclusions"
  data-description="'Excluded file' matchers separated by a comma."
  data-type="text"
  data-setting="file_exclusions"
  data-placeholder="drawings,prompts/logs"
  data-callback="update_exclusions"
></div>
<div class="setting-component"
  data-name="Folder Exclusions"
  data-description="'Excluded folder' matchers separated by a comma."
  data-type="text"
  data-setting="folder_exclusions"
  data-placeholder="drawings,prompts/logs"
  data-callback="update_exclusions"
></div>
<div class="setting-component"
  data-name="Exclude all top-level folders"
  data-description="Set folder exclusions to exclude all top-level folders."
  data-type="button"
  data-callback="exclude_all_top_level_folders"
></div>
<div class="setting-component"
  data-name="Heading Exclusions"
  data-description="'Excluded header' matchers separated by a comma. Works for 'blocks' only."
  data-type="text"
  data-setting="excluded_headings"
  data-placeholder="drawings,prompts/logs"
></div>
<h3>Data Management</h3>
<div class="setting-component"
  data-name="Refresh Notes"
  data-description="Clear notes data and reprocess."
  data-type="button"
  data-callback="refresh_notes"
></div>
<div class="setting-component"
  data-name="Smart Connections Folder"
  data-description="Folder to store Smart Connections data."
  data-type="text"
  data-setting="smart_connections_folder"
  data-placeholder="Enter a folder name"
  data-callback="update_smart_connections_folder"
  data-button="rename"
></div>
<div class="setting-component"
  data-name="Smart Chat History Folder"
  data-description="Folder to store Smart Chat history."
  data-type="text"
  data-setting="smart_chat_folder"
  data-placeholder="Enter a folder name"
  data-callback="update_smart_chat_folder"
  data-button="rename"
></div>
<div class="setting-component"
  data-name="Embedding file per note (EXPERIMENTAL)"
  data-description="Save embedding data in a separate file per note."
  data-type="toggle"
  data-setting="embedding_file_per_note"
  data-callback="restart_plugin"
></div>
<h1>Force Refresh</h1>
<div class="setting-component"
  data-name="force_refresh"
  data-description="WARNING: DO NOT use unless you know what you are doing! This will delete all of your current embeddings from OpenAI and trigger reprocessing of your entire vault!"
  data-confirm="Are you sure you want to Force Refresh? By clicking yes you confirm that you understand the consequences of this action."
  data-type="button"
  data-callback="force_refresh"
></div>
<!-- Native JS confirm focussing bug -->
<!--  
<h3>Force Refresh</h3>
<div class="setting-component"
  data-name="force_refresh"
  data-description="WARNING: DO NOT use unless you know what you are doing! This will delete all of your current embeddings from OpenAI and trigger reprocessing of your entire vault!"
  data-confirm="Are you sure you want to Force Refresh? By clicking yes you confirm that you understand the consequences of this action."
  data-type="button"
  data-callback="force_refresh"
></div> -->
<h1>Muted Notices</h1>
<% if(muted_notices && Object.keys(muted_notices).length) { %>
  <% for(const notice in muted_notices) { %>
    <div class="setting-component"
      data-name="<%= notice %>"
      data-setting="muted_notices.<%= notice %>"
      data-type="button"
      data-btn-text="Unmute"
      data-callback="unmute_notice"
    ></div>
  <% } %>
<% } else { %>
  <p>No muted notices.</p>
<% } %>
<hr>
<h5 name="og-gpt" id="og-gpt">The Original Smart Connections GPT</h5>
<div data-callout-metadata="" data-callout-fold="" data-callout="warning" class="callout">
  <div class="callout-title">
    <div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
        class="svg-icon lucide-alert-triangle">
        <path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"></path>
        <path d="M12 9v4"></path>
        <path d="M12 17h.01"></path>
      </svg></div>
    <div class="callout-title-inner"><p><i>This will be removed in a future version.</i> Please use the <a href="https://chat.openai.com/g/g-9Xb1mRJYl-smart-connect-obsidian">Smart Connect - Obsidian</a> GPT for more advanced features like creating notes and embedding search.</p></div>
  </div>
</div>
<p>This GPT can browser folders and read notes. It requires manually synchronization for your notes to be accessible by ChatGPT.</p>
<div class="setting-component"
  data-name="ChatGPT Integration (supporter-only)"
  data-btn-text="Sync Notes"
  data-description="Sync your notes for use with the Smart Connections GPT and ChatGPT Plugin. Respects your file and folder exclusion settings. Required to use the Smart Connections GPT."
  data-type="button"
  data-callback="sync_for_chatgpt"
></div>
<div class="setting-component"
  data-name="Open Smart Connections GPT"
  data-btn-text="Open"
  data-description='Chat with your notes in ChatGPT. Requires a ChatGPT Plus account.'
  data-type="button"
  data-href="https://chat.openai.com/g/g-SlDDp07bm-smart-connections-for-obsidian"
></div>`
    };
  }
});

// ejs.min.js
var require_ejs_min = __commonJS({
  "ejs.min.js"(exports2, module2) {
    (function(f) {
      if (typeof exports2 === "object" && typeof module2 !== "undefined") {
        module2.exports = f();
      } else if (typeof define === "function" && define.amd) {
        define([], f);
      } else {
        var g;
        if (typeof window !== "undefined") {
          g = window;
        } else if (typeof global !== "undefined") {
          g = global;
        } else if (typeof self !== "undefined") {
          g = self;
        } else {
          g = this;
        }
        g.ejs = f();
      }
    })(function() {
      var define2, module3, exports3;
      return function() {
        function r(e, n, t) {
          function o(i2, f) {
            if (!n[i2]) {
              if (!e[i2]) {
                var c = "function" == typeof require && require;
                if (!f && c)
                  return c(i2, true);
                if (u)
                  return u(i2, true);
                var a = new Error("Cannot find module '" + i2 + "'");
                throw a.code = "MODULE_NOT_FOUND", a;
              }
              var p = n[i2] = { exports: {} };
              e[i2][0].call(p.exports, function(r2) {
                var n2 = e[i2][1][r2];
                return o(n2 || r2);
              }, p, p.exports, r, e, n, t);
            }
            return n[i2].exports;
          }
          for (var u = "function" == typeof require && require, i = 0; i < t.length; i++)
            o(t[i]);
          return o;
        }
        return r;
      }()({ 1: [function(require2, module4, exports4) {
        "use strict";
        var fs = require2("fs");
        var path = require2("path");
        var utils = require2("./utils");
        var scopeOptionWarned = false;
        var _VERSION_STRING = require2("../package.json").version;
        var _DEFAULT_OPEN_DELIMITER = "<";
        var _DEFAULT_CLOSE_DELIMITER = ">";
        var _DEFAULT_DELIMITER = "%";
        var _DEFAULT_LOCALS_NAME = "locals";
        var _NAME = "ejs";
        var _REGEX_STRING = "(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)";
        var _OPTS_PASSABLE_WITH_DATA = ["delimiter", "scope", "context", "debug", "compileDebug", "client", "_with", "rmWhitespace", "strict", "filename", "async"];
        var _OPTS_PASSABLE_WITH_DATA_EXPRESS = _OPTS_PASSABLE_WITH_DATA.concat("cache");
        var _BOM = /^\uFEFF/;
        var _JS_IDENTIFIER = /^[a-zA-Z_$][0-9a-zA-Z_$]*$/;
        exports4.cache = utils.cache;
        exports4.fileLoader = fs.readFileSync;
        exports4.localsName = _DEFAULT_LOCALS_NAME;
        exports4.promiseImpl = new Function("return this;")().Promise;
        exports4.resolveInclude = function(name, filename, isDir) {
          var dirname = path.dirname;
          var extname = path.extname;
          var resolve = path.resolve;
          var includePath = resolve(isDir ? filename : dirname(filename), name);
          var ext = extname(name);
          if (!ext) {
            includePath += ".ejs";
          }
          return includePath;
        };
        function resolvePaths(name, paths) {
          var filePath;
          if (paths.some(function(v) {
            filePath = exports4.resolveInclude(name, v, true);
            return fs.existsSync(filePath);
          })) {
            return filePath;
          }
        }
        function getIncludePath(path2, options) {
          var includePath;
          var filePath;
          var views = options.views;
          var match = /^[A-Za-z]+:\\|^\//.exec(path2);
          if (match && match.length) {
            path2 = path2.replace(/^\/*/, "");
            if (Array.isArray(options.root)) {
              includePath = resolvePaths(path2, options.root);
            } else {
              includePath = exports4.resolveInclude(path2, options.root || "/", true);
            }
          } else {
            if (options.filename) {
              filePath = exports4.resolveInclude(path2, options.filename);
              if (fs.existsSync(filePath)) {
                includePath = filePath;
              }
            }
            if (!includePath && Array.isArray(views)) {
              includePath = resolvePaths(path2, views);
            }
            if (!includePath && typeof options.includer !== "function") {
              throw new Error('Could not find the include file "' + options.escapeFunction(path2) + '"');
            }
          }
          return includePath;
        }
        function handleCache(options, template) {
          var func;
          var filename = options.filename;
          var hasTemplate = arguments.length > 1;
          if (options.cache) {
            if (!filename) {
              throw new Error("cache option requires a filename");
            }
            func = exports4.cache.get(filename);
            if (func) {
              return func;
            }
            if (!hasTemplate) {
              template = fileLoader(filename).toString().replace(_BOM, "");
            }
          } else if (!hasTemplate) {
            if (!filename) {
              throw new Error("Internal EJS error: no file name or template provided");
            }
            template = fileLoader(filename).toString().replace(_BOM, "");
          }
          func = exports4.compile(template, options);
          if (options.cache) {
            exports4.cache.set(filename, func);
          }
          return func;
        }
        function tryHandleCache(options, data, cb) {
          var result;
          if (!cb) {
            if (typeof exports4.promiseImpl == "function") {
              return new exports4.promiseImpl(function(resolve, reject) {
                try {
                  result = handleCache(options)(data);
                  resolve(result);
                } catch (err) {
                  reject(err);
                }
              });
            } else {
              throw new Error("Please provide a callback function");
            }
          } else {
            try {
              result = handleCache(options)(data);
            } catch (err) {
              return cb(err);
            }
            cb(null, result);
          }
        }
        function fileLoader(filePath) {
          return exports4.fileLoader(filePath);
        }
        function includeFile(path2, options) {
          var opts = utils.shallowCopy(utils.createNullProtoObjWherePossible(), options);
          opts.filename = getIncludePath(path2, opts);
          if (typeof options.includer === "function") {
            var includerResult = options.includer(path2, opts.filename);
            if (includerResult) {
              if (includerResult.filename) {
                opts.filename = includerResult.filename;
              }
              if (includerResult.template) {
                return handleCache(opts, includerResult.template);
              }
            }
          }
          return handleCache(opts);
        }
        function rethrow(err, str, flnm, lineno, esc) {
          var lines = str.split("\n");
          var start = Math.max(lineno - 3, 0);
          var end = Math.min(lines.length, lineno + 3);
          var filename = esc(flnm);
          var context = lines.slice(start, end).map(function(line, i) {
            var curr = i + start + 1;
            return (curr == lineno ? " >> " : "    ") + curr + "| " + line;
          }).join("\n");
          err.path = filename;
          err.message = (filename || "ejs") + ":" + lineno + "\n" + context + "\n\n" + err.message;
          throw err;
        }
        function stripSemi(str) {
          return str.replace(/;(\s*$)/, "$1");
        }
        exports4.compile = function compile(template, opts) {
          var templ;
          if (opts && opts.scope) {
            if (!scopeOptionWarned) {
              console.warn("`scope` option is deprecated and will be removed in EJS 3");
              scopeOptionWarned = true;
            }
            if (!opts.context) {
              opts.context = opts.scope;
            }
            delete opts.scope;
          }
          templ = new Template(template, opts);
          return templ.compile();
        };
        exports4.render = function(template, d, o) {
          var data = d || utils.createNullProtoObjWherePossible();
          var opts = o || utils.createNullProtoObjWherePossible();
          if (arguments.length == 2) {
            utils.shallowCopyFromList(opts, data, _OPTS_PASSABLE_WITH_DATA);
          }
          return handleCache(opts, template)(data);
        };
        exports4.renderFile = function() {
          var args = Array.prototype.slice.call(arguments);
          var filename = args.shift();
          var cb;
          var opts = { filename };
          var data;
          var viewOpts;
          if (typeof arguments[arguments.length - 1] == "function") {
            cb = args.pop();
          }
          if (args.length) {
            data = args.shift();
            if (args.length) {
              utils.shallowCopy(opts, args.pop());
            } else {
              if (data.settings) {
                if (data.settings.views) {
                  opts.views = data.settings.views;
                }
                if (data.settings["view cache"]) {
                  opts.cache = true;
                }
                viewOpts = data.settings["view options"];
                if (viewOpts) {
                  utils.shallowCopy(opts, viewOpts);
                }
              }
              utils.shallowCopyFromList(opts, data, _OPTS_PASSABLE_WITH_DATA_EXPRESS);
            }
            opts.filename = filename;
          } else {
            data = utils.createNullProtoObjWherePossible();
          }
          return tryHandleCache(opts, data, cb);
        };
        exports4.Template = Template;
        exports4.clearCache = function() {
          exports4.cache.reset();
        };
        function Template(text, opts) {
          opts = opts || utils.createNullProtoObjWherePossible();
          var options = utils.createNullProtoObjWherePossible();
          this.templateText = text;
          this.mode = null;
          this.truncate = false;
          this.currentLine = 1;
          this.source = "";
          options.client = opts.client || false;
          options.escapeFunction = opts.escape || opts.escapeFunction || utils.escapeXML;
          options.compileDebug = opts.compileDebug !== false;
          options.debug = !!opts.debug;
          options.filename = opts.filename;
          options.openDelimiter = opts.openDelimiter || exports4.openDelimiter || _DEFAULT_OPEN_DELIMITER;
          options.closeDelimiter = opts.closeDelimiter || exports4.closeDelimiter || _DEFAULT_CLOSE_DELIMITER;
          options.delimiter = opts.delimiter || exports4.delimiter || _DEFAULT_DELIMITER;
          options.strict = opts.strict || false;
          options.context = opts.context;
          options.cache = opts.cache || false;
          options.rmWhitespace = opts.rmWhitespace;
          options.root = opts.root;
          options.includer = opts.includer;
          options.outputFunctionName = opts.outputFunctionName;
          options.localsName = opts.localsName || exports4.localsName || _DEFAULT_LOCALS_NAME;
          options.views = opts.views;
          options.async = opts.async;
          options.destructuredLocals = opts.destructuredLocals;
          options.legacyInclude = typeof opts.legacyInclude != "undefined" ? !!opts.legacyInclude : true;
          if (options.strict) {
            options._with = false;
          } else {
            options._with = typeof opts._with != "undefined" ? opts._with : true;
          }
          this.opts = options;
          this.regex = this.createRegex();
        }
        Template.modes = { EVAL: "eval", ESCAPED: "escaped", RAW: "raw", COMMENT: "comment", LITERAL: "literal" };
        Template.prototype = { createRegex: function() {
          var str = _REGEX_STRING;
          var delim = utils.escapeRegExpChars(this.opts.delimiter);
          var open = utils.escapeRegExpChars(this.opts.openDelimiter);
          var close = utils.escapeRegExpChars(this.opts.closeDelimiter);
          str = str.replace(/%/g, delim).replace(/</g, open).replace(/>/g, close);
          return new RegExp(str);
        }, compile: function() {
          var src;
          var fn;
          var opts = this.opts;
          var prepended = "";
          var appended = "";
          var escapeFn = opts.escapeFunction;
          var ctor;
          var sanitizedFilename = opts.filename ? JSON.stringify(opts.filename) : "undefined";
          if (!this.source) {
            this.generateSource();
            prepended += '  var __output = "";\n  function __append(s) { if (s !== undefined && s !== null) __output += s }\n';
            if (opts.outputFunctionName) {
              if (!_JS_IDENTIFIER.test(opts.outputFunctionName)) {
                throw new Error("outputFunctionName is not a valid JS identifier.");
              }
              prepended += "  var " + opts.outputFunctionName + " = __append;\n";
            }
            if (opts.localsName && !_JS_IDENTIFIER.test(opts.localsName)) {
              throw new Error("localsName is not a valid JS identifier.");
            }
            if (opts.destructuredLocals && opts.destructuredLocals.length) {
              var destructuring = "  var __locals = (" + opts.localsName + " || {}),\n";
              for (var i = 0; i < opts.destructuredLocals.length; i++) {
                var name = opts.destructuredLocals[i];
                if (!_JS_IDENTIFIER.test(name)) {
                  throw new Error("destructuredLocals[" + i + "] is not a valid JS identifier.");
                }
                if (i > 0) {
                  destructuring += ",\n  ";
                }
                destructuring += name + " = __locals." + name;
              }
              prepended += destructuring + ";\n";
            }
            if (opts._with !== false) {
              prepended += "  with (" + opts.localsName + " || {}) {\n";
              appended += "  }\n";
            }
            appended += "  return __output;\n";
            this.source = prepended + this.source + appended;
          }
          if (opts.compileDebug) {
            src = "var __line = 1\n  , __lines = " + JSON.stringify(this.templateText) + "\n  , __filename = " + sanitizedFilename + ";\ntry {\n" + this.source + "} catch (e) {\n  rethrow(e, __lines, __filename, __line, escapeFn);\n}\n";
          } else {
            src = this.source;
          }
          if (opts.client) {
            src = "escapeFn = escapeFn || " + escapeFn.toString() + ";\n" + src;
            if (opts.compileDebug) {
              src = "rethrow = rethrow || " + rethrow.toString() + ";\n" + src;
            }
          }
          if (opts.strict) {
            src = '"use strict";\n' + src;
          }
          if (opts.debug) {
            console.log(src);
          }
          if (opts.compileDebug && opts.filename) {
            src = src + "\n//# sourceURL=" + sanitizedFilename + "\n";
          }
          try {
            if (opts.async) {
              try {
                ctor = new Function("return (async function(){}).constructor;")();
              } catch (e) {
                if (e instanceof SyntaxError) {
                  throw new Error("This environment does not support async/await");
                } else {
                  throw e;
                }
              }
            } else {
              ctor = Function;
            }
            fn = new ctor(opts.localsName + ", escapeFn, include, rethrow", src);
          } catch (e) {
            if (e instanceof SyntaxError) {
              if (opts.filename) {
                e.message += " in " + opts.filename;
              }
              e.message += " while compiling ejs\n\n";
              e.message += "If the above error is not helpful, you may want to try EJS-Lint:\n";
              e.message += "https://github.com/RyanZim/EJS-Lint";
              if (!opts.async) {
                e.message += "\n";
                e.message += "Or, if you meant to create an async function, pass `async: true` as an option.";
              }
            }
            throw e;
          }
          var returnedFn = opts.client ? fn : function anonymous(data) {
            var include = function(path2, includeData) {
              var d = utils.shallowCopy(utils.createNullProtoObjWherePossible(), data);
              if (includeData) {
                d = utils.shallowCopy(d, includeData);
              }
              return includeFile(path2, opts)(d);
            };
            return fn.apply(opts.context, [data || utils.createNullProtoObjWherePossible(), escapeFn, include, rethrow]);
          };
          if (opts.filename && typeof Object.defineProperty === "function") {
            var filename = opts.filename;
            var basename = path.basename(filename, path.extname(filename));
            try {
              Object.defineProperty(returnedFn, "name", { value: basename, writable: false, enumerable: false, configurable: true });
            } catch (e) {
            }
          }
          return returnedFn;
        }, generateSource: function() {
          var opts = this.opts;
          if (opts.rmWhitespace) {
            this.templateText = this.templateText.replace(/[\r\n]+/g, "\n").replace(/^\s+|\s+$/gm, "");
          }
          this.templateText = this.templateText.replace(/[ \t]*<%_/gm, "<%_").replace(/_%>[ \t]*/gm, "_%>");
          var self2 = this;
          var matches = this.parseTemplateText();
          var d = this.opts.delimiter;
          var o = this.opts.openDelimiter;
          var c = this.opts.closeDelimiter;
          if (matches && matches.length) {
            matches.forEach(function(line, index) {
              var closing;
              if (line.indexOf(o + d) === 0 && line.indexOf(o + d + d) !== 0) {
                closing = matches[index + 2];
                if (!(closing == d + c || closing == "-" + d + c || closing == "_" + d + c)) {
                  throw new Error('Could not find matching close tag for "' + line + '".');
                }
              }
              self2.scanLine(line);
            });
          }
        }, parseTemplateText: function() {
          var str = this.templateText;
          var pat = this.regex;
          var result = pat.exec(str);
          var arr = [];
          var firstPos;
          while (result) {
            firstPos = result.index;
            if (firstPos !== 0) {
              arr.push(str.substring(0, firstPos));
              str = str.slice(firstPos);
            }
            arr.push(result[0]);
            str = str.slice(result[0].length);
            result = pat.exec(str);
          }
          if (str) {
            arr.push(str);
          }
          return arr;
        }, _addOutput: function(line) {
          if (this.truncate) {
            line = line.replace(/^(?:\r\n|\r|\n)/, "");
            this.truncate = false;
          }
          if (!line) {
            return line;
          }
          line = line.replace(/\\/g, "\\\\");
          line = line.replace(/\n/g, "\\n");
          line = line.replace(/\r/g, "\\r");
          line = line.replace(/"/g, '\\"');
          this.source += '    ; __append("' + line + '")\n';
        }, scanLine: function(line) {
          var self2 = this;
          var d = this.opts.delimiter;
          var o = this.opts.openDelimiter;
          var c = this.opts.closeDelimiter;
          var newLineCount = 0;
          newLineCount = line.split("\n").length - 1;
          switch (line) {
            case o + d:
            case o + d + "_":
              this.mode = Template.modes.EVAL;
              break;
            case o + d + "=":
              this.mode = Template.modes.ESCAPED;
              break;
            case o + d + "-":
              this.mode = Template.modes.RAW;
              break;
            case o + d + "#":
              this.mode = Template.modes.COMMENT;
              break;
            case o + d + d:
              this.mode = Template.modes.LITERAL;
              this.source += '    ; __append("' + line.replace(o + d + d, o + d) + '")\n';
              break;
            case d + d + c:
              this.mode = Template.modes.LITERAL;
              this.source += '    ; __append("' + line.replace(d + d + c, d + c) + '")\n';
              break;
            case d + c:
            case "-" + d + c:
            case "_" + d + c:
              if (this.mode == Template.modes.LITERAL) {
                this._addOutput(line);
              }
              this.mode = null;
              this.truncate = line.indexOf("-") === 0 || line.indexOf("_") === 0;
              break;
            default:
              if (this.mode) {
                switch (this.mode) {
                  case Template.modes.EVAL:
                  case Template.modes.ESCAPED:
                  case Template.modes.RAW:
                    if (line.lastIndexOf("//") > line.lastIndexOf("\n")) {
                      line += "\n";
                    }
                }
                switch (this.mode) {
                  case Template.modes.EVAL:
                    this.source += "    ; " + line + "\n";
                    break;
                  case Template.modes.ESCAPED:
                    this.source += "    ; __append(escapeFn(" + stripSemi(line) + "))\n";
                    break;
                  case Template.modes.RAW:
                    this.source += "    ; __append(" + stripSemi(line) + ")\n";
                    break;
                  case Template.modes.COMMENT:
                    break;
                  case Template.modes.LITERAL:
                    this._addOutput(line);
                    break;
                }
              } else {
                this._addOutput(line);
              }
          }
          if (self2.opts.compileDebug && newLineCount) {
            this.currentLine += newLineCount;
            this.source += "    ; __line = " + this.currentLine + "\n";
          }
        } };
        exports4.escapeXML = utils.escapeXML;
        exports4.__express = exports4.renderFile;
        exports4.VERSION = _VERSION_STRING;
        exports4.name = _NAME;
        if (typeof window != "undefined") {
          window.ejs = exports4;
        }
      }, { "../package.json": 6, "./utils": 2, fs: 3, path: 4 }], 2: [function(require2, module4, exports4) {
        "use strict";
        var regExpChars = /[|\\{}()[\]^$+*?.]/g;
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var hasOwn = function(obj, key) {
          return hasOwnProperty.apply(obj, [key]);
        };
        exports4.escapeRegExpChars = function(string) {
          if (!string) {
            return "";
          }
          return String(string).replace(regExpChars, "\\$&");
        };
        var _ENCODE_HTML_RULES = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&#34;", "'": "&#39;" };
        var _MATCH_HTML = /[&<>'"]/g;
        function encode_char(c) {
          return _ENCODE_HTML_RULES[c] || c;
        }
        var escapeFuncStr = `var _ENCODE_HTML_RULES = {
      "&": "&amp;"
    , "<": "&lt;"
    , ">": "&gt;"
    , '"': "&#34;"
    , "'": "&#39;"
    }
  , _MATCH_HTML = /[&<>'"]/g;
function encode_char(c) {
  return _ENCODE_HTML_RULES[c] || c;
};
`;
        exports4.escapeXML = function(markup) {
          return markup == void 0 ? "" : String(markup).replace(_MATCH_HTML, encode_char);
        };
        function escapeXMLToString() {
          return Function.prototype.toString.call(this) + ";\n" + escapeFuncStr;
        }
        try {
          if (typeof Object.defineProperty === "function") {
            Object.defineProperty(exports4.escapeXML, "toString", { value: escapeXMLToString });
          } else {
            exports4.escapeXML.toString = escapeXMLToString;
          }
        } catch (err) {
          console.warn("Unable to set escapeXML.toString (is the Function prototype frozen?)");
        }
        exports4.shallowCopy = function(to, from) {
          from = from || {};
          if (to !== null && to !== void 0) {
            for (var p in from) {
              if (!hasOwn(from, p)) {
                continue;
              }
              if (p === "__proto__" || p === "constructor") {
                continue;
              }
              to[p] = from[p];
            }
          }
          return to;
        };
        exports4.shallowCopyFromList = function(to, from, list) {
          list = list || [];
          from = from || {};
          if (to !== null && to !== void 0) {
            for (var i = 0; i < list.length; i++) {
              var p = list[i];
              if (typeof from[p] != "undefined") {
                if (!hasOwn(from, p)) {
                  continue;
                }
                if (p === "__proto__" || p === "constructor") {
                  continue;
                }
                to[p] = from[p];
              }
            }
          }
          return to;
        };
        exports4.cache = { _data: {}, set: function(key, val) {
          this._data[key] = val;
        }, get: function(key) {
          return this._data[key];
        }, remove: function(key) {
          delete this._data[key];
        }, reset: function() {
          this._data = {};
        } };
        exports4.hyphenToCamel = function(str) {
          return str.replace(/-[a-z]/g, function(match) {
            return match[1].toUpperCase();
          });
        };
        exports4.createNullProtoObjWherePossible = function() {
          if (typeof Object.create == "function") {
            return function() {
              return /* @__PURE__ */ Object.create(null);
            };
          }
          if (!({ __proto__: null } instanceof Object)) {
            return function() {
              return { __proto__: null };
            };
          }
          return function() {
            return {};
          };
        }();
      }, {}], 3: [function(require2, module4, exports4) {
      }, {}], 4: [function(require2, module4, exports4) {
        (function(process2) {
          function normalizeArray(parts, allowAboveRoot) {
            var up = 0;
            for (var i = parts.length - 1; i >= 0; i--) {
              var last = parts[i];
              if (last === ".") {
                parts.splice(i, 1);
              } else if (last === "..") {
                parts.splice(i, 1);
                up++;
              } else if (up) {
                parts.splice(i, 1);
                up--;
              }
            }
            if (allowAboveRoot) {
              for (; up--; up) {
                parts.unshift("..");
              }
            }
            return parts;
          }
          exports4.resolve = function() {
            var resolvedPath = "", resolvedAbsolute = false;
            for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
              var path = i >= 0 ? arguments[i] : process2.cwd();
              if (typeof path !== "string") {
                throw new TypeError("Arguments to path.resolve must be strings");
              } else if (!path) {
                continue;
              }
              resolvedPath = path + "/" + resolvedPath;
              resolvedAbsolute = path.charAt(0) === "/";
            }
            resolvedPath = normalizeArray(filter(resolvedPath.split("/"), function(p) {
              return !!p;
            }), !resolvedAbsolute).join("/");
            return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
          };
          exports4.normalize = function(path) {
            var isAbsolute = exports4.isAbsolute(path), trailingSlash = substr(path, -1) === "/";
            path = normalizeArray(filter(path.split("/"), function(p) {
              return !!p;
            }), !isAbsolute).join("/");
            if (!path && !isAbsolute) {
              path = ".";
            }
            if (path && trailingSlash) {
              path += "/";
            }
            return (isAbsolute ? "/" : "") + path;
          };
          exports4.isAbsolute = function(path) {
            return path.charAt(0) === "/";
          };
          exports4.join = function() {
            var paths = Array.prototype.slice.call(arguments, 0);
            return exports4.normalize(filter(paths, function(p, index) {
              if (typeof p !== "string") {
                throw new TypeError("Arguments to path.join must be strings");
              }
              return p;
            }).join("/"));
          };
          exports4.relative = function(from, to) {
            from = exports4.resolve(from).substr(1);
            to = exports4.resolve(to).substr(1);
            function trim(arr) {
              var start = 0;
              for (; start < arr.length; start++) {
                if (arr[start] !== "")
                  break;
              }
              var end = arr.length - 1;
              for (; end >= 0; end--) {
                if (arr[end] !== "")
                  break;
              }
              if (start > end)
                return [];
              return arr.slice(start, end - start + 1);
            }
            var fromParts = trim(from.split("/"));
            var toParts = trim(to.split("/"));
            var length = Math.min(fromParts.length, toParts.length);
            var samePartsLength = length;
            for (var i = 0; i < length; i++) {
              if (fromParts[i] !== toParts[i]) {
                samePartsLength = i;
                break;
              }
            }
            var outputParts = [];
            for (var i = samePartsLength; i < fromParts.length; i++) {
              outputParts.push("..");
            }
            outputParts = outputParts.concat(toParts.slice(samePartsLength));
            return outputParts.join("/");
          };
          exports4.sep = "/";
          exports4.delimiter = ":";
          exports4.dirname = function(path) {
            if (typeof path !== "string")
              path = path + "";
            if (path.length === 0)
              return ".";
            var code = path.charCodeAt(0);
            var hasRoot = code === 47;
            var end = -1;
            var matchedSlash = true;
            for (var i = path.length - 1; i >= 1; --i) {
              code = path.charCodeAt(i);
              if (code === 47) {
                if (!matchedSlash) {
                  end = i;
                  break;
                }
              } else {
                matchedSlash = false;
              }
            }
            if (end === -1)
              return hasRoot ? "/" : ".";
            if (hasRoot && end === 1) {
              return "/";
            }
            return path.slice(0, end);
          };
          function basename(path) {
            if (typeof path !== "string")
              path = path + "";
            var start = 0;
            var end = -1;
            var matchedSlash = true;
            var i;
            for (i = path.length - 1; i >= 0; --i) {
              if (path.charCodeAt(i) === 47) {
                if (!matchedSlash) {
                  start = i + 1;
                  break;
                }
              } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
              }
            }
            if (end === -1)
              return "";
            return path.slice(start, end);
          }
          exports4.basename = function(path, ext) {
            var f = basename(path);
            if (ext && f.substr(-1 * ext.length) === ext) {
              f = f.substr(0, f.length - ext.length);
            }
            return f;
          };
          exports4.extname = function(path) {
            if (typeof path !== "string")
              path = path + "";
            var startDot = -1;
            var startPart = 0;
            var end = -1;
            var matchedSlash = true;
            var preDotState = 0;
            for (var i = path.length - 1; i >= 0; --i) {
              var code = path.charCodeAt(i);
              if (code === 47) {
                if (!matchedSlash) {
                  startPart = i + 1;
                  break;
                }
                continue;
              }
              if (end === -1) {
                matchedSlash = false;
                end = i + 1;
              }
              if (code === 46) {
                if (startDot === -1)
                  startDot = i;
                else if (preDotState !== 1)
                  preDotState = 1;
              } else if (startDot !== -1) {
                preDotState = -1;
              }
            }
            if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
              return "";
            }
            return path.slice(startDot, end);
          };
          function filter(xs, f) {
            if (xs.filter)
              return xs.filter(f);
            var res = [];
            for (var i = 0; i < xs.length; i++) {
              if (f(xs[i], i, xs))
                res.push(xs[i]);
            }
            return res;
          }
          var substr = "ab".substr(-1) === "b" ? function(str, start, len) {
            return str.substr(start, len);
          } : function(str, start, len) {
            if (start < 0)
              start = str.length + start;
            return str.substr(start, len);
          };
        }).call(this, require2("_process"));
      }, { _process: 5 }], 5: [function(require2, module4, exports4) {
        var process2 = module4.exports = {};
        var cachedSetTimeout;
        var cachedClearTimeout;
        function defaultSetTimout() {
          throw new Error("setTimeout has not been defined");
        }
        function defaultClearTimeout() {
          throw new Error("clearTimeout has not been defined");
        }
        (function() {
          try {
            if (typeof setTimeout === "function") {
              cachedSetTimeout = setTimeout;
            } else {
              cachedSetTimeout = defaultSetTimout;
            }
          } catch (e) {
            cachedSetTimeout = defaultSetTimout;
          }
          try {
            if (typeof clearTimeout === "function") {
              cachedClearTimeout = clearTimeout;
            } else {
              cachedClearTimeout = defaultClearTimeout;
            }
          } catch (e) {
            cachedClearTimeout = defaultClearTimeout;
          }
        })();
        function runTimeout(fun) {
          if (cachedSetTimeout === setTimeout) {
            return setTimeout(fun, 0);
          }
          if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
          }
          try {
            return cachedSetTimeout(fun, 0);
          } catch (e) {
            try {
              return cachedSetTimeout.call(null, fun, 0);
            } catch (e2) {
              return cachedSetTimeout.call(this, fun, 0);
            }
          }
        }
        function runClearTimeout(marker) {
          if (cachedClearTimeout === clearTimeout) {
            return clearTimeout(marker);
          }
          if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
          }
          try {
            return cachedClearTimeout(marker);
          } catch (e) {
            try {
              return cachedClearTimeout.call(null, marker);
            } catch (e2) {
              return cachedClearTimeout.call(this, marker);
            }
          }
        }
        var queue = [];
        var draining = false;
        var currentQueue;
        var queueIndex = -1;
        function cleanUpNextTick() {
          if (!draining || !currentQueue) {
            return;
          }
          draining = false;
          if (currentQueue.length) {
            queue = currentQueue.concat(queue);
          } else {
            queueIndex = -1;
          }
          if (queue.length) {
            drainQueue();
          }
        }
        function drainQueue() {
          if (draining) {
            return;
          }
          var timeout = runTimeout(cleanUpNextTick);
          draining = true;
          var len = queue.length;
          while (len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
              if (currentQueue) {
                currentQueue[queueIndex].run();
              }
            }
            queueIndex = -1;
            len = queue.length;
          }
          currentQueue = null;
          draining = false;
          runClearTimeout(timeout);
        }
        process2.nextTick = function(fun) {
          var args = new Array(arguments.length - 1);
          if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
            }
          }
          queue.push(new Item(fun, args));
          if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
          }
        };
        function Item(fun, array) {
          this.fun = fun;
          this.array = array;
        }
        Item.prototype.run = function() {
          this.fun.apply(null, this.array);
        };
        process2.title = "browser";
        process2.browser = true;
        process2.env = {};
        process2.argv = [];
        process2.version = "";
        process2.versions = {};
        function noop() {
        }
        process2.on = noop;
        process2.addListener = noop;
        process2.once = noop;
        process2.off = noop;
        process2.removeListener = noop;
        process2.removeAllListeners = noop;
        process2.emit = noop;
        process2.prependListener = noop;
        process2.prependOnceListener = noop;
        process2.listeners = function(name) {
          return [];
        };
        process2.binding = function(name) {
          throw new Error("process.binding is not supported");
        };
        process2.cwd = function() {
          return "/";
        };
        process2.chdir = function(dir) {
          throw new Error("process.chdir is not supported");
        };
        process2.umask = function() {
          return 0;
        };
      }, {}], 6: [function(require2, module4, exports4) {
        module4.exports = { name: "ejs", description: "Embedded JavaScript templates", keywords: ["template", "engine", "ejs"], version: "3.1.9", author: "Matthew Eernisse <mde@fleegix.org> (http://fleegix.org)", license: "Apache-2.0", bin: { ejs: "./bin/cli.js" }, main: "./lib/ejs.js", jsdelivr: "ejs.min.js", unpkg: "ejs.min.js", repository: { type: "git", url: "git://github.com/mde/ejs.git" }, bugs: "https://github.com/mde/ejs/issues", homepage: "https://github.com/mde/ejs", dependencies: { jake: "^10.8.5" }, devDependencies: { browserify: "^16.5.1", eslint: "^6.8.0", "git-directory-deploy": "^1.5.1", jsdoc: "^4.0.2", "lru-cache": "^4.0.1", mocha: "^10.2.0", "uglify-js": "^3.3.16" }, engines: { node: ">=0.10.0" }, scripts: { test: "mocha -u tdd" } };
      }, {}] }, {}, [1])(1);
    });
  }
});

// src/ScTranslations.json
var require_ScTranslations = __commonJS({
  "src/ScTranslations.json"(exports2, module2) {
    module2.exports = {
      en: {
        pronouns: ["my", "I", "me", "mine", "our", "ours", "us", "we"],
        prompt: "Based on your notes",
        initial_message: "Hi, I'm ChatGPT with access to your notes via Smart Connections. Ask me a question about your notes and I'll try to answer it."
      },
      es: {
        pronouns: ["mi", "yo", "m\xED", "t\xFA"],
        prompt: "Bas\xE1ndose en sus notas",
        initial_message: "Hola, soy ChatGPT con acceso a tus apuntes a trav\xE9s de Smart Connections. Hazme una pregunta sobre tus apuntes e intentar\xE9 responderte."
      },
      fr: {
        pronouns: ["me", "mon", "ma", "mes", "moi", "nous", "notre", "nos", "je", "j'", "m'"],
        prompt: "D'apr\xE8s vos notes",
        initial_message: "Bonjour, je suis ChatGPT et j'ai acc\xE8s \xE0 vos notes via Smart Connections. Posez-moi une question sur vos notes et j'essaierai d'y r\xE9pondre."
      },
      de: {
        pronouns: ["mein", "meine", "meinen", "meiner", "meines", "mir", "uns", "unser", "unseren", "unserer", "unseres"],
        prompt: "Basierend auf Ihren Notizen",
        initial_message: "Hallo, ich bin ChatGPT und habe \xFCber Smart Connections Zugang zu Ihren Notizen. Stellen Sie mir eine Frage zu Ihren Notizen und ich werde versuchen, sie zu beantworten."
      },
      it: {
        pronouns: ["mio", "mia", "miei", "mie", "noi", "nostro", "nostri", "nostra", "nostre"],
        prompt: "Sulla base degli appunti",
        initial_message: "Ciao, sono ChatGPT e ho accesso ai tuoi appunti tramite Smart Connections. Fatemi una domanda sui vostri appunti e cercher\xF2 di rispondervi."
      }
    };
  }
});

// node_modules/smart-chat-model/adapters/anthropic.js
var require_anthropic = __commonJS({
  "node_modules/smart-chat-model/adapters/anthropic.js"(exports2) {
    var AnthropicAdapter = class {
      /**
       * Prepares the request body for the Anthropic API by converting ChatML format to a format compatible with Anthropic.
       * @param {Object} opts - The options object containing messages and other parameters in ChatML format.
       * @returns {Object} The request body formatted for the Anthropic API.
       */
      prepare_request_body(opts) {
        return chatml_to_anthropic(opts);
      }
      /**
       * Counts the tokens in the input by estimating them, as the Anthropic model does not provide a direct method.
       * @param {string|Object} input - The input text or object to count tokens in.
       * @returns {Promise<number>} The estimated number of tokens in the input.
       */
      async count_tokens(input) {
        return this.estimate_tokens(input);
      }
      /**
       * Estimates the number of tokens in the input based on a rough average token size.
       * @param {string|Object} input - The input text or object to estimate tokens in.
       * @returns {number} The estimated number of tokens.
       */
      estimate_tokens(input) {
        if (typeof input === "object")
          input = JSON.stringify(input);
        return Math.ceil(input.length / 6);
      }
      /**
       * Extracts the first tool call from the JSON response content.
       * @param {Object} json - The JSON response from which to extract the tool call.
       * @returns {Object|null} The first tool call found, or null if none exist.
       */
      get_tool_call(json) {
        return json.content.find((msg) => msg.type === "tool_use");
      }
      /**
       * Retrieves the input content of a tool call.
       * @param {Object} tool_call - The tool call object from which to extract the input.
       * @returns {Object} The input of the tool call.
       */
      get_tool_call_content(tool_call) {
        return tool_call.input;
      }
      /**
       * Retrieves the name of the tool from a tool call object.
       * @param {Object} tool_call - The tool call object from which to extract the name.
       * @returns {string} The name of the tool.
       */
      get_tool_name(tool_call) {
        return tool_call.name;
      }
      /**
       * Extracts the first message from the JSON response content.
       * @param {Object} json - The JSON response from which to extract the message.
       * @returns {Object|null} The first message found, or null if none exist.
       */
      get_message(json) {
        var _a;
        return (_a = json.content) == null ? void 0 : _a[0];
      }
      /**
       * Retrieves the content of the first message from the JSON response.
       * @param {Object} json - The JSON response from which to extract the message content.
       * @returns {string|null} The content of the first message, or null if no message is found.
       */
      get_message_content(json) {
        var _a, _b;
        return (_b = this.get_message(json)) == null ? void 0 : _b[(_a = this.get_message(json)) == null ? void 0 : _a.type];
      }
    };
    exports2.AnthropicAdapter = AnthropicAdapter;
    function chatml_to_anthropic(opts) {
      const messages = opts.messages.filter((msg) => msg.role !== "system").map((m) => {
        if (typeof m.content === "string")
          return { role: m.role, content: m.content };
        if (Array.isArray(m.content)) {
          const content = m.content.filter((c) => c.type === "text").map((c) => c.text).join("\n");
          return { role: m.role, content };
        }
        return m;
      });
      const { model, max_tokens, temperature, tools } = opts;
      const last_system_idx = opts.messages.findLastIndex((msg) => msg.role === "system" && msg.content.includes("---BEGIN"));
      if (last_system_idx > -1) {
        const system_prompt = "<context>\n" + opts.messages[last_system_idx].content + "\n</context>\n";
        messages[messages.length - 1].content = system_prompt + messages[messages.length - 1].content;
      }
      console.log(messages);
      const out = {
        messages,
        model,
        max_tokens,
        temperature
      };
      if (tools) {
        out.tools = tools.map((tool) => ({
          name: tool.function.name,
          description: tool.function.description,
          input_schema: tool.function.parameters
        }));
        const tool_prompt = `Use the "${out.tools[0].name}" tool!`;
        const last_user_idx = out.messages.findLastIndex((msg) => msg.role === "user");
        out.messages[last_user_idx].content += "\n" + tool_prompt;
        out.system = `Required: use the "${out.tools[0].name}" tool!`;
      }
      const last_non_context_system_idx = opts.messages.findLastIndex((msg) => msg.role === "system" && !msg.content.includes("---BEGIN"));
      if (last_non_context_system_idx > -1)
        out.system = opts.messages[last_non_context_system_idx].content;
      return out;
    }
    exports2.chatml_to_anthropic = chatml_to_anthropic;
  }
});

// node_modules/smart-chat-model/adapters/cohere.js
var require_cohere = __commonJS({
  "node_modules/smart-chat-model/adapters/cohere.js"(exports2) {
    var CohereAdapter = class {
      /**
       * Converts a ChatML object to a format suitable for a request to the Cohere API.
       * @param {Object} chatml - The ChatML object containing the chat history and other parameters.
       * @returns {Object} The request body formatted for the Cohere API.
       */
      prepare_request_body(chatml) {
        return chatml_to_cohere(chatml);
      }
      /**
       * Extracts the message content from a JSON response from the Cohere API.
       * @param {Object} json - The JSON response object from which to extract the text content.
       * @returns {string} The extracted text content from the response.
       */
      get_message_content(json) {
        return json.text;
      }
      /**
       * Processes streaming data received from the Cohere API and extracts text chunks.
       * This method handles the accumulation of text data over multiple events and manages the state of the stream.
       * @param {Object} event - The event object containing streaming data.
       * @returns {string} The accumulated text chunk extracted from the stream.
       */
      get_text_chunk_from_stream(event) {
        if (!this.last_line_index)
          this.last_line_index = 0;
        clearTimeout(this.last_line_timeout);
        this.last_line_timeout = setTimeout(() => {
          this.last_line_index = 0;
        }, 1e4);
        const data = event.source.xhr.responseText;
        const lines = data.split("\n").slice(this.last_line_index);
        console.log(lines);
        this.last_line_index += lines.length;
        const text_chunk = lines.filter((line) => line.trim() !== "").map((line) => {
          console.log(line);
          const json = JSON.parse(line);
          if (json.event_type === "stream-end") {
            console.log("stream-end");
            this.end_of_stream = true;
            setTimeout(() => {
              this.end_of_stream = false;
            }, 3e3);
            return "";
          }
          return json.text;
        }).join("");
        console.log(text_chunk);
        return text_chunk;
      }
      /**
       * Determines if the end of the stream has been reached based on the event data.
       * @param {Object} event - The event object that may indicate the end of the stream.
       * @returns {boolean} True if the end of the stream is indicated, false otherwise.
       */
      is_end_of_stream(event) {
        return this.end_of_stream;
      }
    };
    exports2.CohereAdapter = CohereAdapter;
    function chatml_to_cohere(chatml) {
      const cohere = {
        model: chatml.model,
        // skip last user message
        chat_history: chatml.messages.slice(0, -1).map((message) => ({
          role: message.role,
          message: parse_message_content_to_string(message)
        })),
        message: parse_message_content_to_string(chatml.messages[chatml.messages.length - 1]),
        temperature: chatml.temperature
        // stream: chatml.stream // currently not supported
      };
      return cohere;
    }
    exports2.chatml_to_cohere = chatml_to_cohere;
    function parse_message_content_to_string(message) {
      return Array.isArray(message.content) ? message.content.filter((c) => c.type === "text").map((c) => c.text).join("\n") : message.content;
    }
  }
});

// node_modules/smart-chat-model/adapters/gemini.js
var require_gemini = __commonJS({
  "node_modules/smart-chat-model/adapters/gemini.js"(exports2) {
    var GeminiAdapter = class {
      /**
       * Constructs a GeminiAdapter instance with a specified model configuration.
       * @param {Object} model - The model configuration object.
       */
      constructor(model) {
        this.model = model;
      }
      /**
       * Prepares the request body for the Gemini API by converting ChatML format to a format compatible with Gemini.
       * @param {Object} body - The options object containing messages and other parameters in ChatML format.
       * @returns {Object} The request body formatted for the Gemini API.
       */
      prepare_request_body(body) {
        return chatml_to_gemini(body);
      }
      /**
       * Extracts the first tool call from the JSON response content.
       * @param {Object} json - The JSON response from which to extract the tool call.
       * @returns {Object|null} The first tool call found, or null if none exist.
       */
      get_tool_call(json) {
        var _a, _b, _c, _d, _e;
        return (_e = (_d = (_c = (_b = (_a = json.candidates) == null ? void 0 : _a[0]) == null ? void 0 : _b.content) == null ? void 0 : _c.parts) == null ? void 0 : _d[0]) == null ? void 0 : _e.functionCall;
      }
      /**
       * Retrieves the name of the tool from a tool call object.
       * @param {Object} tool_call - The tool call object from which to extract the name.
       * @returns {string|null} The name of the tool, or null if not available.
       */
      get_tool_name(tool_call) {
        return tool_call == null ? void 0 : tool_call.name;
      }
      /**
       * Retrieves the input content of a tool call.
       * @param {Object} tool_call - The tool call object from which to extract the input.
       * @returns {Object|null} The input of the tool call, or null if not available.
       */
      get_tool_call_content(tool_call) {
        return tool_call == null ? void 0 : tool_call.args;
      }
      /**
       * Extracts the first message from the JSON response content.
       * @param {Object} json - The JSON response from which to extract the message.
       * @returns {Object|null} The first message found, or null if none exist.
       */
      get_message(json) {
        var _a;
        return (_a = json.candidates) == null ? void 0 : _a[0];
      }
      /**
       * Retrieves the content of the first message from the JSON response.
       * @param {Object} json - The JSON response from which to extract the message content.
       * @returns {string|null} The content of the first message, or null if no message is found.
       */
      get_message_content(json) {
        var _a, _b;
        return (_b = (_a = this.get_message(json)) == null ? void 0 : _a.content) == null ? void 0 : _b.parts.map((part) => part.text).join("");
      }
      /**
       * Handles escaped newlines in a streaming text chunk.
       * @param {Object} event - The streaming event containing the data.
       * @returns {string} The text chunk with escaped newlines replaced.
       */
      get_text_chunk_from_stream(event) {
        return event.data.replace(/\\n/g, "\n");
      }
      /**
       * Determines if the streaming response has ended based on the readyState of the XMLHttpRequest.
       * @param {Object} event - The streaming event.
       * @returns {boolean} True if the stream has ended, false otherwise.
       */
      is_end_of_stream(event) {
        return event.source.xhr.readyState === 4;
      }
      /**
       * Counts the tokens in the input by making an API request to the Gemini token counting endpoint.
       * @param {string|Object} input - The input text or object to count tokens in.
       * @returns {Promise<number>} The total number of tokens in the input.
       */
      async count_tokens(input) {
        var _a;
        const req = {
          url: `https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:countTokens?key=${this.model.api_key}`,
          method: "POST",
          headers: { "Content-Type": "application/json" }
        };
        let body;
        if (typeof input === "string")
          body = chatml_to_gemini({ messages: [{ role: "user", content: input }] });
        else if (Array.isArray(input))
          body = chatml_to_gemini({ messages: input });
        else if (typeof input === "object")
          body = chatml_to_gemini(input);
        else
          return console.error("Invalid input for count_tokens", input);
        delete body.generationConfig;
        delete body.safetySettings;
        req.body = JSON.stringify(body);
        const resp = await this.model.request_adapter(req);
        return (_a = resp == null ? void 0 : resp.json) == null ? void 0 : _a.totalTokens;
      }
      /**
       * Getter for the standard API endpoint with the API key appended.
       * @returns {string} The formatted endpoint URL for non-streaming requests.
       */
      get endpoint() {
        return this.model.config.endpoint.replace("MODEL_NAME", this.model.model_name) + "?key=" + this.model.api_key;
      }
      /**
       * Getter for the streaming API endpoint with the API key appended.
       * @returns {string} The formatted endpoint URL for streaming requests.
       */
      get endpoint_streaming() {
        return this.model.config.endpoint_streaming.replace("MODEL_NAME", this.model.model_name) + "?key=" + this.model.api_key;
      }
    };
    exports2.GeminiAdapter = GeminiAdapter;
    function chatml_to_gemini(opts) {
      const messages = opts.messages.filter((msg) => msg.role !== "system");
      const last_system_idx = opts.messages.findLastIndex((msg) => msg.role === "system" && msg.content.includes("---BEGIN"));
      if (last_system_idx > -1) {
        const system_prompt = "---BEGIN IMPORTANT CONTEXT---\n" + opts.messages[last_system_idx].content + "\n---END IMPORTANT CONTEXT---\n\n";
        messages[messages.length - 1].content = system_prompt + messages[messages.length - 1].content;
      }
      const body = {
        contents: messages.filter((msg) => msg.role !== "system").map((msg) => ({
          role: msg.role === "assistant" ? "model" : msg.role,
          parts: Array.isArray(msg.content) ? [{ text: msg.content.filter((c) => c.type === "text").map((c) => c.text).join("\n") }] : [{ text: msg.content }]
        })),
        generationConfig: {
          temperature: opts.temperature || 0.9,
          topK: opts.topK || 1,
          topP: opts.topP || 1,
          maxOutputTokens: opts.max_tokens || 2048,
          stopSequences: opts.stopSequences || [],
          candidate_count: opts.n || 1
        },
        safetySettings: [
          {
            category: "HARM_CATEGORY_HARASSMENT",
            threshold: "BLOCK_NONE"
          },
          {
            category: "HARM_CATEGORY_HATE_SPEECH",
            threshold: "BLOCK_NONE"
          },
          {
            category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
            threshold: "BLOCK_NONE"
          },
          {
            category: "HARM_CATEGORY_DANGEROUS_CONTENT",
            threshold: "BLOCK_NONE"
          }
        ]
      };
      const system_instructions = opts.messages.filter((msg) => msg.role === "system" && !msg.content.includes("---BEGIN"));
      if (system_instructions.length > 0)
        body.systemInstruction = { parts: system_instructions.map((msg) => ({ text: msg.content })) };
      if (opts.tools) {
        body.tools = [{
          function_declarations: opts.tools.map((tool) => ({
            name: tool.function.name,
            description: tool.function.description,
            parameters: tool.function.parameters
          }))
        }];
        body.tool_config = {
          function_calling_config: {
            mode: "ANY"
          }
        };
        const tool_prompt = `Use the "${body.tools[0].function_declarations[0].name}" tool!`;
        const last_user_idx = body.contents.findLastIndex((msg) => msg.role === "user");
        body.contents[last_user_idx].parts[0].text += "\n" + tool_prompt;
      }
      return body;
    }
    exports2.chatml_to_gemini = chatml_to_gemini;
  }
});

// node_modules/smart-chat-model/adapters.js
var require_adapters2 = __commonJS({
  "node_modules/smart-chat-model/adapters.js"(exports2) {
    var { AnthropicAdapter } = require_anthropic();
    var { CohereAdapter } = require_cohere();
    var { GeminiAdapter } = require_gemini();
    exports2.Anthropic = AnthropicAdapter;
    exports2.Cohere = CohereAdapter;
    exports2.Gemini = GeminiAdapter;
  }
});

// node_modules/smart-chat-model/platforms.json
var require_platforms = __commonJS({
  "node_modules/smart-chat-model/platforms.json"(exports2, module2) {
    module2.exports = {
      openai: {
        description: "OpenAI",
        type: "API",
        endpoint: "https://api.openai.com/v1/chat/completions",
        streaming: true,
        actions: true,
        fetch_models: true,
        default_model: "gpt-3.5-turbo",
        signup_url: "https://platform.openai.com/api-keys"
      },
      google_gemini: {
        description: "Google Gemini",
        type: "API",
        api_key_header: "none",
        endpoint: "https://generativelanguage.googleapis.com/v1beta/models/MODEL_NAME:generateContent",
        endpoint_streaming: "https://generativelanguage.googleapis.com/v1beta/models/MODEL_NAME:streamGenerateContent",
        streaming: true,
        actions: true,
        adapter: "Gemini",
        fetch_models: true,
        default_model: "gemini-1.0-pro",
        signup_url: "https://ai.google.dev/"
      },
      open_router: {
        description: "Open Router",
        type: "API",
        endpoint: "https://openrouter.ai/api/v1/chat/completions",
        streaming: true,
        fetch_models: true,
        default_model: "mistralai/mistral-7b-instruct:free",
        signup_url: "https://accounts.openrouter.ai/sign-up?redirect_url=https%3A%2F%2Fopenrouter.ai%2Fkeys"
      },
      cohere: {
        description: "Cohere Command-R",
        type: "API",
        endpoint: "https://api.cohere.ai/v1/chat",
        streaming: false,
        adapter: "Cohere",
        fetch_models: true,
        default_model: "command-r",
        signup_url: "https://dashboard.cohere.com/welcome/register?redirect_uri=%2Fapi-keys"
      },
      anthropic: {
        description: "Anthropic Claude",
        type: "API",
        endpoint: "https://api.anthropic.com/v1/messages",
        streaming: false,
        api_key_header: "x-api-key",
        headers: {
          "anthropic-version": "2023-06-01",
          "anthropic-beta": "tools-2024-04-04"
        },
        adapter: "Anthropic",
        actions: true,
        fetch_models: true,
        default_model: "claude-3-sonnet-20240229",
        signup_url: "https://console.anthropic.com/login?returnTo=%2Fsettings%2Fkeys"
      },
      custom_local: {
        model_name: "custom_local",
        description: "Custom Local (OpenAI format)",
        type: "API"
      },
      custom_api: {
        model_name: "custom_api",
        description: "Custom API (OpenAI format)",
        type: "API"
      }
    };
  }
});

// node_modules/smart-chat-model/utils/is_valid_tool_call.js
var require_is_valid_tool_call = __commonJS({
  "node_modules/smart-chat-model/utils/is_valid_tool_call.js"(exports2) {
    function is_valid_tool_call(tool, tool_call_content) {
      var _a;
      const props = tool.function.parameters.properties;
      if (Object.keys(tool_call_content).length === 0)
        throw new Error(`Invalid tool call: object is empty`);
      Object.entries(tool_call_content).forEach(([key, value]) => {
        if (!props[key])
          throw new Error(`Invalid tool call: missing key ${key} in tool spec`, props);
        if (Array.isArray(value) && props[key].type === "array") {
          const itemType = typeof value[0];
          if (!value.every((item) => typeof item === itemType))
            throw new Error(`Invalid tool call: array items are not of the same type`);
          if (props[key].items.type !== itemType)
            throw new Error(`Invalid tool call: array items are not of the same type as the spec`);
        } else if (props[key].type !== typeof value) {
          if (props[key].type === "number" && typeof value === "string") {
            if (isNaN(Number(value)))
              throw new Error(`Invalid tool call: value ${value} is not a valid number`);
            tool_call_content[key] = Number(value);
          } else
            throw new Error(`Invalid tool call: value ${value} is not of type ${props[key].type}`);
        }
        if (props[key].enum && !props[key].enum.includes(value))
          throw new Error(`Invalid tool call: value ${value} is not in enum ${props[key].enum}`);
      });
      (_a = tool.function.parameters.required) == null ? void 0 : _a.forEach((key) => {
        if (!tool_call_content[key])
          throw new Error(`Invalid tool call: missing required key ${key}`);
      });
      return true;
    }
    exports2.is_valid_tool_call = is_valid_tool_call;
  }
});

// node_modules/smart-chat-model/streamer.js
var require_streamer = __commonJS({
  "node_modules/smart-chat-model/streamer.js"(exports2) {
    var _setReadyState, setReadyState_fn, _onStreamFailure, onStreamFailure_fn, _onStreamAbort, onStreamAbort_fn, _onStreamProgress, onStreamProgress_fn, _onStreamLoaded, onStreamLoaded_fn, _parseEventChunk, parseEventChunk_fn, _checkStreamClosed, checkStreamClosed_fn;
    var SmartStreamer = class {
      constructor(url, options = {}) {
        // private methods
        __privateAdd(this, _setReadyState);
        __privateAdd(this, _onStreamFailure);
        __privateAdd(this, _onStreamAbort);
        __privateAdd(this, _onStreamProgress);
        __privateAdd(this, _onStreamLoaded);
        __privateAdd(this, _parseEventChunk);
        __privateAdd(this, _checkStreamClosed);
        const {
          method = "GET",
          headers = {},
          body = null,
          withCredentials = false
        } = options;
        this.url = url;
        this.method = method;
        this.headers = headers;
        this.body = body;
        this.withCredentials = withCredentials;
        this.listeners = {};
        this.readyState = this.CONNECTING;
        this.progress = 0;
        this.chunk = "";
        this.last_event_id = "";
        this.xhr = null;
        this.FIELD_SEPARATOR = ":";
        this.INITIALIZING = -1;
        this.CONNECTING = 0;
        this.OPEN = 1;
        this.CLOSED = 2;
      }
      /**
       * Adds an event listener for the specified event type.
       *
       * @param {string} type - The type of the event.
       * @param {Function} listener - The listener function to be called when the event is triggered.
       */
      addEventListener(type, listener) {
        if (!this.listeners[type])
          this.listeners[type] = [];
        if (!this.listeners[type].includes(listener))
          this.listeners[type].push(listener);
      }
      /**
       * Removes an event listener from the SmartStreamer instance.
       *
       * @param {string} type - The type of event to remove the listener from.
       * @param {Function} listener - The listener function to remove.
       */
      removeEventListener(type, listener) {
        if (!this.listeners[type])
          return;
        this.listeners[type] = this.listeners[type].filter((callback) => callback !== listener);
        if (this.listeners[type].length === 0)
          delete this.listeners[type];
      }
      /**
       * Dispatches an event to the appropriate event handlers.
       *
       * @param {Event} event - The event to be dispatched.
       * @returns {boolean} - Returns true if the event was successfully dispatched, false otherwise.
       */
      dispatchEvent(event) {
        if (!event)
          return true;
        event.source = this;
        const onHandler = "on" + event.type;
        if (Object.prototype.hasOwnProperty.call(this, onHandler)) {
          this[onHandler].call(this, event);
          if (event.defaultPrevented)
            return false;
        }
        if (this.listeners[event.type]) {
          this.listeners[event.type].forEach((callback) => {
            callback(event);
            return !event.defaultPrevented;
          });
        }
        return true;
      }
      /**
       * Initiates the streaming process.
       */
      stream() {
        __privateMethod(this, _setReadyState, setReadyState_fn).call(this, this.CONNECTING);
        this.xhr = new XMLHttpRequest();
        this.xhr.addEventListener("progress", __privateMethod(this, _onStreamProgress, onStreamProgress_fn).bind(this));
        this.xhr.addEventListener("load", __privateMethod(this, _onStreamLoaded, onStreamLoaded_fn).bind(this));
        this.xhr.addEventListener("readystatechange", __privateMethod(this, _checkStreamClosed, checkStreamClosed_fn).bind(this));
        this.xhr.addEventListener("error", __privateMethod(this, _onStreamFailure, onStreamFailure_fn).bind(this));
        this.xhr.addEventListener("abort", __privateMethod(this, _onStreamAbort, onStreamAbort_fn).bind(this));
        this.xhr.open(this.method, this.url);
        for (const header in this.headers) {
          this.xhr.setRequestHeader(header, this.headers[header]);
        }
        if (this.last_event_id)
          this.xhr.setRequestHeader("Last-Event-ID", this.last_event_id);
        this.xhr.withCredentials = this.withCredentials;
        this.xhr.send(this.body);
      }
      /**
       * Ends the streamer connection.
       * Aborts the current XHR request and sets the ready state to CLOSED.
       */
      end() {
        if (this.readyState === this.CLOSED)
          return;
        this.xhr.abort();
        this.xhr = null;
        __privateMethod(this, _setReadyState, setReadyState_fn).call(this, this.CLOSED);
      }
    };
    _setReadyState = new WeakSet();
    setReadyState_fn = function(state) {
      const event = new CustomEvent("readyStateChange");
      event.readyState = state;
      this.readyState = state;
      this.dispatchEvent(event);
    };
    _onStreamFailure = new WeakSet();
    onStreamFailure_fn = function(e) {
      const event = new CustomEvent("error");
      event.data = e.currentTarget.response;
      this.dispatchEvent(event);
      this.end();
    };
    _onStreamAbort = new WeakSet();
    onStreamAbort_fn = function(e) {
      const event = new CustomEvent("abort");
      this.end();
    };
    _onStreamProgress = new WeakSet();
    onStreamProgress_fn = function(e) {
      if (!this.xhr)
        return;
      if (this.xhr.status !== 200) {
        __privateMethod(this, _onStreamFailure, onStreamFailure_fn).call(this, e);
        return;
      }
      if (this.readyState === this.CONNECTING) {
        this.dispatchEvent(new CustomEvent("open"));
        __privateMethod(this, _setReadyState, setReadyState_fn).call(this, this.OPEN);
      }
      const data = this.xhr.responseText.substring(this.progress);
      this.progress += data.length;
      data.split(/(\r\n|\r|\n)/g).forEach((part) => {
        if (part.trim().length === 0) {
          this.dispatchEvent(__privateMethod(this, _parseEventChunk, parseEventChunk_fn).call(this, this.chunk.trim()));
          this.chunk = "";
        } else {
          this.chunk += part;
        }
      });
    };
    _onStreamLoaded = new WeakSet();
    onStreamLoaded_fn = function(e) {
      __privateMethod(this, _onStreamProgress, onStreamProgress_fn).call(this, e);
      this.dispatchEvent(__privateMethod(this, _parseEventChunk, parseEventChunk_fn).call(this, this.chunk));
      this.chunk = "";
    };
    _parseEventChunk = new WeakSet();
    parseEventChunk_fn = function(chunk) {
      if (!chunk || chunk.length === 0)
        return null;
      const e = { id: null, retry: null, data: "", event: "message", text: "" };
      chunk.split(/(\r\n|\r|\n)/).forEach((line) => {
        line = line.trim();
        const index = line.indexOf(this.FIELD_SEPARATOR);
        if (index <= 0)
          return;
        const field = line.substring(0, index).replace(/^"|"$/g, "");
        if (!["id", "retry", "data", "event", "text"].includes(field))
          return;
        const value = line.substring(index + 1).trim().replace(/^"|"$/g, "");
        e.data += value;
      });
      if (e.id)
        this.last_event_id = e.id;
      const event = new CustomEvent(e.event || "message");
      event.id = e.id;
      event.data = e.data || "";
      event.last_event_id = this.last_event_id;
      return event;
    };
    _checkStreamClosed = new WeakSet();
    checkStreamClosed_fn = function() {
      if (!this.xhr)
        return;
      if (this.xhr.readyState === XMLHttpRequest.DONE)
        __privateMethod(this, _setReadyState, setReadyState_fn).call(this, this.CLOSED);
    };
    exports2.SmartStreamer = SmartStreamer;
  }
});

// node_modules/smart-chat-model/models/open_router.js
var require_open_router = __commonJS({
  "node_modules/smart-chat-model/models/open_router.js"(exports2) {
    async function fetch_open_router_models() {
      try {
        const response = await fetch("https://openrouter.ai/api/v1/models");
        if (!response.ok) {
          throw new Error("Network response was not ok");
        }
        const data = await response.json();
        console.log("Model data retrieved:", data);
        return data.data.map((model) => ({
          model_name: model.id,
          key: model.id,
          max_input_tokens: model.context_length,
          description: model.name,
          actions: model.description.includes("tool use") || model.description.includes("function call")
        }));
      } catch (error) {
        console.error("Failed to fetch model data:", error);
        return [];
      }
    }
    exports2.fetch_open_router_models = fetch_open_router_models;
  }
});

// node_modules/smart-chat-model/models/openai.js
var require_openai = __commonJS({
  "node_modules/smart-chat-model/models/openai.js"(exports2) {
    var model_context = {
      "gpt-3.5-turbo": {
        "context": 16385,
        "max_out": 4096
      },
      "gpt-3.5-turbo-0125": {
        "context": 16385,
        "max_out": 4096
      },
      "gpt-3.5-turbo-0301": {
        "context": 4097,
        "max_out": 4097
      },
      "gpt-3.5-turbo-0613": {
        "context": 4097,
        "max_out": 4097
      },
      "gpt-3.5-turbo-1106": {
        "context": 16385,
        "max_out": 4096
      },
      "gpt-3.5-turbo-16k": {
        "context": 16385,
        "max_out": 16385
      },
      "gpt-3.5-turbo-16k-0613": {
        "context": 16385,
        "max_out": 16385
      },
      "gpt-4": {
        "context": 8192,
        "max_out": 8192
      },
      "gpt-4-0125-preview": {
        "context": 128e3,
        "max_out": 4096
      },
      "gpt-4-0314": {
        "context": 8192,
        "max_out": 8192
      },
      "gpt-4-0613": {
        "context": 8192,
        "max_out": 8192
      },
      "gpt-4-1106-preview": {
        "context": 128e3,
        "max_out": 4096
      },
      "gpt-4-1106-vision-preview": {
        "context": 128e3,
        "max_out": 4096
      },
      "gpt-4-32k": {
        "context": 32768,
        "max_out": 32768
      },
      "gpt-4-32k-0314": {
        "context": 32768,
        "max_out": 32768
      },
      "gpt-4-32k-0613": {
        "context": 32768,
        "max_out": 32768
      },
      "gpt-4-turbo": {
        "context": 128e3,
        "max_out": 4096
      },
      "gpt-4-turbo-preview": {
        "context": 128e3,
        "max_out": 4096
      },
      "gpt-4-vision-preview": {
        "context": 128e3,
        "max_out": 4096
      }
    };
    async function fetch_openai_models(api_key) {
      if (!api_key) {
        console.error("No API key provided");
        return [];
      }
      try {
        const response = await fetch("https://api.openai.com/v1/models", {
          headers: {
            "Authorization": `Bearer ${api_key}`
          }
        });
        if (!response.ok) {
          throw new Error("Network response was not ok");
        }
        const data = await response.json();
        console.log("Model data retrieved:", data);
        return data.data.filter((model) => model.id.startsWith("gpt-") && !model.id.includes("-instruct")).map((model) => {
          const out = { model_name: model.id, key: model.id };
          if (model_context[model.id]) {
            out.max_input_tokens = model_context[model.id].context;
            out.description = `context: ${model_context[model.id].context}, output: ${model_context[model.id].max_out}`;
          }
          return out;
        });
      } catch (error) {
        console.error("Failed to fetch model data:", error);
        return [];
      }
    }
    exports2.fetch_openai_models = fetch_openai_models;
  }
});

// node_modules/smart-chat-model/models/google_gemini.js
var require_google_gemini = __commonJS({
  "node_modules/smart-chat-model/models/google_gemini.js"(exports2) {
    async function fetch_google_gemini_models(api_key) {
      if (!api_key) {
        console.error("No API key provided");
        return [];
      }
      try {
        const response = await fetch("https://generativelanguage.googleapis.com/v1beta/models?key=" + api_key);
        if (!response.ok) {
          throw new Error("Network response was not ok");
        }
        const data = await response.json();
        console.log("Model data retrieved:", data);
        return data.models.filter((model) => model.name.startsWith("models/gemini")).map((model) => {
          const out = {
            model_name: model.name.split("/").pop(),
            key: model.name.split("/").pop(),
            max_input_tokens: model.inputTokenLimit,
            max_output_tokens: model.maxOutputTokens,
            description: model.description
          };
          return out;
        });
      } catch (error) {
        console.error("Failed to fetch model data:", error);
        return [];
      }
    }
    exports2.fetch_google_gemini_models = fetch_google_gemini_models;
  }
});

// node_modules/smart-chat-model/models/cohere.js
var require_cohere2 = __commonJS({
  "node_modules/smart-chat-model/models/cohere.js"(exports2) {
    async function fetch_cohere_models(api_key) {
      if (!api_key) {
        console.error("No API key provided");
        return [];
      }
      try {
        const response = await fetch("https://api.cohere.ai/v1/models", {
          headers: {
            "Authorization": `Bearer ${api_key}`
          }
        });
        if (!response.ok) {
          throw new Error("Network response was not ok");
        }
        const data = await response.json();
        console.log("Model data retrieved:", data);
        return data.models.filter((model) => model.name.startsWith("command-")).map((model) => {
          const out = {
            model_name: model.name,
            key: model.name,
            max_input_tokens: model.context_length,
            tokenizer_url: model.tokenizer_url,
            finetuned: model.finetuned,
            description: `Max input tokens: ${model.context_length}, Finetuned: ${model.finetuned}`
          };
          return out;
        });
      } catch (error) {
        console.error("Failed to fetch model data:", error);
        return [];
      }
    }
    exports2.fetch_cohere_models = fetch_cohere_models;
  }
});

// node_modules/smart-chat-model/models/anthropic.js
var require_anthropic2 = __commonJS({
  "node_modules/smart-chat-model/models/anthropic.js"(exports2) {
    async function fetch_anthropic_models() {
      return [
        {
          "key": "claude-3-opus-20240229",
          "model_name": "claude-3-opus-20240229",
          "description": "Anthropic's Claude model",
          "max_input_tokens": 2e5,
          "max_output_tokens": 4e3
        },
        {
          key: "claude-3-sonnet-20240229",
          "model_name": "claude-3-sonnet-20240229",
          "description": "Anthropic's Sonnet model",
          "max_input_tokens": 2e5,
          "max_output_tokens": 4e3
        },
        {
          key: "claude-3-haiku-20240307",
          "model_name": "claude-3-haiku-20240307",
          "description": "Anthropic's Haiku model",
          "max_input_tokens": 2e5,
          "max_output_tokens": 4e3
        }
      ];
    }
    exports2.fetch_anthropic_models = fetch_anthropic_models;
  }
});

// node_modules/smart-chat-model/models/fetch.js
var require_fetch = __commonJS({
  "node_modules/smart-chat-model/models/fetch.js"(exports2) {
    var { fetch_open_router_models } = require_open_router();
    var { fetch_openai_models } = require_openai();
    var { fetch_google_gemini_models } = require_google_gemini();
    var { fetch_cohere_models } = require_cohere2();
    var { fetch_anthropic_models } = require_anthropic2();
    exports2.open_router = fetch_open_router_models;
    exports2.openai = fetch_openai_models;
    exports2.google_gemini = fetch_google_gemini_models;
    exports2.cohere = fetch_cohere_models;
    exports2.anthropic = fetch_anthropic_models;
  }
});

// node_modules/smart-chat-model/smart_chat_model.js
var require_smart_chat_model = __commonJS({
  "node_modules/smart-chat-model/smart_chat_model.js"(exports2) {
    var adapters = require_adapters2();
    var platforms = require_platforms();
    var { is_valid_tool_call } = require_is_valid_tool_call();
    var { SmartStreamer } = require_streamer();
    var fetch_models = require_fetch();
    var SmartChatModel = class {
      /**
       * Constructs an instance of SmartChatModel with specified environment, model key, and options.
       * @param {Object} main - The main environment context, typically containing configurations and state.
       * @param {string} platform_key - Key to select the specific model configuration from models.json.
       * @param {Object} model_config - Optional parameters to override model configurations.
       */
      constructor(main, platform_key, model_config = {}) {
        this.env = main;
        this.main = this.env;
        this.config = {
          ...platforms[platform_key] || {},
          ...model_config
          // override default platform config
        };
        this.platform_key = platform_key;
        this.active_stream = null;
        this._request_adapter = null;
        this.platforms = platforms;
        if (this.config.adapter)
          this.adapter = new adapters[this.config.adapter](this);
        console.log(this.adapter);
      }
      static get models() {
        return platforms;
      }
      get default_opts() {
        return {
          temperature: 0.3,
          top_p: 1,
          presence_penalty: 0,
          frequency_penalty: 0,
          n: 1,
          model: this.model_name,
          max_tokens: this.max_output_tokens
        };
      }
      async request_middlewares(opts) {
        return opts;
      }
      /**
       * Completes the chat interaction by processing the provided options, making an API request, and handling the response.
       * This method supports both streaming and non-streaming responses, and can handle tool calls if specified in the response.
       *
       * @param {Object} opts - The options for the chat completion which may include settings like temperature, max tokens, etc.
       * @param {boolean} render - Flag to determine if the response should be rendered in the UI.
       * @returns {Promise<string|void>} - Returns the chat response content or handles tool outputs recursively. In case of errors, it may return an error message.
       */
      async complete(opts = {}, render = true) {
        var _a, _b, _c, _d;
        if (!this.base_model_config) {
          this.base_model_config = await this.get_base_model_config();
          this.config = {
            ...this.base_model_config,
            ...this.config
          };
        }
        opts = {
          ...this.default_opts,
          messages: ((_b = await ((_a = this.current) == null ? void 0 : _a.get_chat_ml())) == null ? void 0 : _b.messages) || [],
          ...opts
        };
        if (opts.stream !== false && this.config.streaming && !this.current.tool_choice)
          opts.stream = true;
        else
          opts.stream = false;
        opts = await this.request_middlewares(JSON.parse(JSON.stringify(opts)));
        const req = {
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${this.api_key}`
          },
          method: "POST"
        };
        if (this.config.headers)
          req.headers = { ...req.headers, ...this.config.headers };
        if (this.config.api_key_header) {
          if (this.config.api_key_header !== "none")
            req.headers[this.config.api_key_header] = this.api_key;
          delete req.headers.Authorization;
        }
        const body = typeof ((_c = this.env.actions) == null ? void 0 : _c.prepare_request_body) === "function" ? this.env.actions.prepare_request_body(opts) : { ...opts };
        req.body = JSON.stringify(typeof ((_d = this.adapter) == null ? void 0 : _d.prepare_request_body) === "function" ? this.adapter.prepare_request_body(body) : body);
        console.log(req);
        try {
          if (opts.stream)
            return await this.stream(req);
          const resp_json = await this.request(req);
          if (resp_json.error) {
            console.error(resp_json.error);
            if (render)
              this.done_handler("*API Error. See console logs for details.*");
            return;
          }
          const tool_call = this.get_tool_call(resp_json);
          if (tool_call) {
            this.env.chats.current.tool_choice = null;
            const tool_name = this.get_tool_name(tool_call);
            const tool_call_content = this.get_tool_call_content(tool_call);
            const tool = body.tools.find((t) => t.function.name === tool_name);
            if (is_valid_tool_call(tool, tool_call_content)) {
              await this.current.add_message({ role: "assistant", tool_calls: [{
                function: {
                  name: tool_name,
                  arguments: JSON.stringify(tool_call_content)
                }
              }] });
              const tool_handler = this.get_tool_handler(tool_name);
              if (!tool_handler)
                return console.error(`Tool ${tool_name} not found`);
              const tool_output = await tool_handler(this.env, tool_call_content);
              if (tool_output) {
                await this.current.add_tool_output(tool_name, tool_output);
                return this.complete({});
              }
            } else {
              console.error(`Invalid tool call: ${tool_call}`);
              if (render)
                this.done_handler("*Invalid tool call. See console logs for details.*");
              return "*Invalid tool call. See console logs for details.*";
            }
          }
          if (render)
            this.done_handler(this.get_message_content(resp_json));
          return this.get_message_content(resp_json);
        } catch (err) {
          console.error(err);
        }
      }
      // HANDLE TOOLS
      /**
       * Retrieves the tool handler function based on the tool name from the environment's actions.
       * This method can be overridden to use custom logic for handling tools.
       * 
       * @param {string} tool_name - The name of the tool for which the handler is to be retrieved.
       * @returns {Function} The handler function for the specified tool.
       */
      get_tool_handler(tool_name) {
        return this.env.actions.actions[tool_name].handler;
      }
      /**
       * Extracts the tool call information from a JSON response. This method supports adapter-specific logic.
       * If no adapter method is provided, it defaults to the expected OpenAI JSON format.
       * 
       * @param {Object} json - The JSON response from which to extract the tool call.
       * @returns {Object} The first tool call found in the response.
       */
      get_tool_call(json) {
        var _a, _b, _c;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.get_tool_call) === "function")
          return this.adapter.get_tool_call(json);
        return (_c = (_b = json.choices) == null ? void 0 : _b[0].message.tool_calls) == null ? void 0 : _c[0];
      }
      /**
       * Determines the tool name from a tool call object. Supports adapter-specific implementations.
       * Defaults to extracting the name directly from the tool call structure.
       * 
       * @param {Object} tool_call - The tool call object from which to extract the tool name.
       * @returns {string} The name of the tool.
       */
      get_tool_name(tool_call) {
        var _a;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.get_tool_name) === "function")
          return this.adapter.get_tool_name(tool_call);
        return tool_call.function.name;
      }
      /**
       * Extracts the tool call content from a tool call object. Supports adapter-specific logic.
       * Defaults to parsing the 'arguments' field of the tool call function as JSON.
       * 
       * @param {Object} tool_call - The tool call object from which to extract the content.
       * @returns {Object} The parsed arguments of the tool call.
       */
      get_tool_call_content(tool_call) {
        var _a;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.get_tool_call_content) === "function")
          return this.adapter.get_tool_call_content(tool_call);
        return JSON.parse(tool_call.function.arguments);
      }
      // HANDLE MESSAGES
      /**
       * Retrieves the message object from a JSON response. Supports adapter-specific implementations.
       * Defaults to handling both OpenAI and Ollama formats by checking for message structures in 'choices'.
       * 
       * @param {Object} json - The JSON response from which to extract the message.
       * @returns {Object} The message object extracted from the response.
       */
      get_message(json) {
        var _a, _b;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.get_message) === "function")
          return this.adapter.get_message(json);
        return ((_b = json.choices) == null ? void 0 : _b[0].message) || json.message;
      }
      /**
       * Extracts the content of a message from a JSON response. Supports adapter-specific implementations.
       * This method relies on `get_message` to first retrieve the message object.
       * 
       * @param {Object} json - The JSON response from which to extract the message content.
       * @returns {string} The content of the message.
       */
      get_message_content(json) {
        var _a;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.get_message_content) === "function")
          return this.adapter.get_message_content(json);
        return this.get_message(json).content;
      }
      async request(req) {
        req.url = this.endpoint;
        req.throw = false;
        const resp = this._request_adapter ? await this._request_adapter(req) : await fetch(this.endpoint, req);
        console.log(resp);
        const resp_json = await this.get_resp_json(resp);
        console.log(resp_json);
        return resp_json;
      }
      async get_resp_json(resp) {
        return typeof resp.json === "function" ? await resp.json() : await resp.json;
      }
      get request_adapter() {
        return this._request_adapter;
      }
      async stream(req) {
        console.log("Streaming Request: ");
        console.log(req);
        const full_text = await new Promise((resolve, reject) => {
          try {
            this.active_stream = new SmartStreamer(this.endpoint_streaming, req);
            let curr_text = "";
            this.active_stream.addEventListener("message", (e) => {
              if (this.is_end_of_stream(e)) {
                this.stop_stream();
                return resolve(curr_text);
              }
              let text_chunk = this.get_text_chunk_from_stream(e);
              if (!text_chunk)
                return;
              curr_text += text_chunk;
              this.chunk_handler(text_chunk);
            });
            this.active_stream.addEventListener("readystatechange", (e) => {
              if (e.readyState >= 2)
                console.log("ReadyState: " + e.readyState);
            });
            this.active_stream.addEventListener("error", (e) => {
              console.error(e);
              this.done_handler("*API Error. See console logs for details.*");
              this.stop_stream();
              reject(e);
            });
            this.active_stream.stream();
          } catch (err) {
            console.error(err);
            this.stop_stream();
            reject(err);
          }
        });
        this.done_handler(full_text);
        return full_text;
      }
      get_text_chunk_from_stream(event) {
        var _a;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.get_text_chunk_from_stream) === "function")
          return this.adapter.get_text_chunk_from_stream(event);
        let resp = null;
        let text_chunk = "";
        try {
          resp = JSON.parse(event.data);
          text_chunk = resp.choices[0].delta.content;
        } catch (err) {
          console.log(err);
          console.log(event.data);
          if (event.data.indexOf("}{") > -1)
            event.data = event.data.replace(/}{/g, "},{");
          resp = JSON.parse(`[${event.data}]`);
          resp.forEach((r) => {
            if (r.choices)
              text_chunk += r.choices[0].delta.content;
          });
        }
        return text_chunk;
      }
      is_end_of_stream(event) {
        var _a;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.is_end_of_stream) === "function")
          return this.adapter.is_end_of_stream(event);
        return event.data === "[DONE]";
      }
      stop_stream() {
        if (this.active_stream) {
          this.active_stream.end();
          this.active_stream = null;
        }
      }
      done_handler(full_str) {
        if (typeof this.main.done_handler === "function")
          this.main.done_handler(full_str);
      }
      chunk_handler(text_chunk) {
        if (typeof this.main.chunk_handler === "function")
          this.main.chunk_handler(text_chunk);
      }
      async count_tokens(input) {
        var _a;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.count_tokens) === "function")
          return await this.adapter.count_tokens(input);
        return this.estimate_tokens(input);
      }
      estimate_tokens(input) {
        var _a;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.estimate_tokens) === "function")
          return this.adapter.estimate_tokens(input);
        if (typeof input === "object")
          input = JSON.stringify(input);
        return input.length / 4;
      }
      async test_api_key() {
        console.log(this.api_key);
        try {
          const request2 = {
            messages: [
              { role: "user", content: "Hello" }
            ],
            temperature: 0,
            max_tokens: 100,
            stream: false,
            n: 1
          };
          if (this.config.fetch_models) {
            request2.model = this.config.default_model;
          }
          const resp = await this.complete(request2, false);
          console.log(resp);
          if (!resp)
            return false;
          return true;
        } catch (err) {
          console.error(err);
          return false;
        }
      }
      async get_models() {
        var _a;
        if (((_a = this.platforms[this.platform_key]) == null ? void 0 : _a.fetch_models) && typeof fetch_models[this.platform_key] === "function") {
          const models = await fetch_models[this.platform_key](this.api_key);
          if (models) {
            models.sort((a, b) => a.model_name.localeCompare(b.model_name));
            return models;
          } else
            console.error(`No models found for ${this.platform_key}`, models);
        }
        return [];
      }
      async get_base_model_config() {
        const models = await this.get_models();
        return models.find((m) => m.key === this.model_name);
      }
      // getters
      get api_key() {
        return this.config.api_key;
      }
      get current() {
        var _a;
        return (_a = this.env.chats) == null ? void 0 : _a.current;
      }
      // use endpoint of combine protocol, hostname, port, and path
      get endpoint() {
        var _a;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.endpoint) !== "undefined")
          return this.adapter.endpoint.replace("MODEL_NAME", this.model_name);
        return this.config.endpoint || this.config.protocol + "://" + this.config.hostname + (this.config.port ? ":" + this.config.port : "") + this.endpoint_path;
      }
      get endpoint_streaming() {
        var _a;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.endpoint_streaming) !== "undefined")
          return this.adapter.endpoint_streaming.replace("MODEL_NAME", this.model_name);
        return this.config.endpoint_streaming || this.endpoint;
      }
      get endpoint_path() {
        return this.config.path.startsWith("/") ? this.config.path : "/" + this.config.path;
      }
      get max_input_tokens() {
        return this.config.max_input_tokens;
      }
      get max_output_tokens() {
        return this.config.max_output_tokens;
      }
      get model_name() {
        return this.config.model_name || this.config.default_model;
      }
    };
    exports2.SmartChatModel = SmartChatModel;
  }
});

// src/sc_chat_model.js
var require_sc_chat_model = __commonJS({
  "src/sc_chat_model.js"(exports2) {
    var ScTranslations = require_ScTranslations();
    var { SmartChatModel } = require_smart_chat_model();
    var ScChatModel = class extends SmartChatModel {
      async done_handler(full_str) {
        await this.env.chat_ui.new_message(full_str, "assistant");
        this.env.chats.current.add_message({ role: "assistant", content: full_str });
        this.env.chat_ui.clear_streaming_ux();
      }
      async chunk_handler(text_chunk) {
        await this.env.chat_ui.new_message(text_chunk, "assistant", true);
      }
      async request_middlewares(opts) {
        await Promise.all(opts.messages.map(async (msg, i) => {
          const context_start = "```sc-context";
          if (msg.role === "tool" && msg.tool_call_id === "lookup") {
            msg.role = "system";
            msg.content = context_start + "\n" + JSON.parse(msg.content).map((c) => c.path).join("\n") + "\n```";
          }
          if (msg.role === "system" && msg.content.includes(context_start)) {
            const context_start_i = msg.content.indexOf(context_start) + context_start.length;
            const context_end_i = msg.content.substring(context_start_i).indexOf("```");
            const raw_contents = msg.content.substring(context_start_i, context_start_i + context_end_i);
            const entities = this.env.plugin.get_entities_from_context_codeblock(raw_contents);
            let context = [];
            let tokens = [];
            await Promise.all(entities.map(async (entity, i2) => {
              if (!(entity == null ? void 0 : entity.get_as_context))
                return console.log(entity);
              context[i2] = await entity.get_as_context({ i: i2 });
              tokens[i2] = await this.count_tokens(context[i2]);
            }));
            let total_tokens = 0;
            let ct = 0;
            context = context.reduce((acc, c, i2) => {
              if (!c)
                return acc;
              if (total_tokens + tokens[i2] > this.max_input_tokens)
                return acc;
              total_tokens += tokens[i2];
              ct++;
              if (acc)
                acc += "\n";
              return acc + c;
            }, "");
            msg.content = this.get_prompt_context_prefix({ ct }) + "\n" + context;
          }
          const sys_start = "```sc-system";
          if (msg.role === "system" && msg.content.includes(sys_start)) {
            const sys_start_i = msg.content.indexOf(sys_start) + sys_start.length;
            const sys_end_i = msg.content.substring(sys_start_i).indexOf("```");
            const sys_prompts = msg.content.substring(sys_start_i, sys_start_i + sys_end_i).split("\n").filter((ln) => ln.trim());
            console.log(sys_prompts);
            msg.content = "";
            for (const sys_prompt of sys_prompts) {
              const tfile = this.env.system_prompts.find((file) => file.basename === sys_prompt);
              const note_content = await this.env.plugin.brain.cached_read(tfile);
              if (msg.content)
                msg.content += "\n";
              msg.content += note_content;
            }
          }
          return msg;
        }));
        opts.messages = opts.messages.filter((msg) => msg.role !== "assistant" || msg.content);
        console.log(opts.messages);
        return opts;
      }
      get_prompt_context_prefix(params = {}) {
        return `Anticipate the type of answer desired by the user. Imagine the following${params.ct ? " " + params.ct : ""} notes were written by the user and contain all the necessary information to answer the user's question. Begin responses with "${ScTranslations[this.env.plugin.settings.language].prompt}..."`;
      }
    };
    exports2.ScChatModel = ScChatModel;
  }
});

// node_modules/smart-chats/utils/message_content_array_to_markdown.js
var require_message_content_array_to_markdown = __commonJS({
  "node_modules/smart-chats/utils/message_content_array_to_markdown.js"(exports2) {
    function message_content_array_to_markdown(content) {
      let markdown = "";
      content.forEach((c, i) => {
        var _a;
        if (c.type === "text") {
          if (c.text.startsWith("Image caption: ")) {
            if (((_a = content[i - 1]) == null ? void 0 : _a.type) === "image_url") {
              markdown = markdown.split("\n").slice(0, -2).join("\n");
              markdown += `
![${c.text.split(":")[1].trim()}](${content[i - 1].image_url.url})`;
            } else {
              markdown += `${c.text}`;
            }
          } else {
            markdown += `${c.text}`;
          }
        } else if (c.type === "image_url")
          markdown += `![](${c.image_url.url})`;
        markdown += "\n";
      });
      return markdown.trim();
    }
    exports2.message_content_array_to_markdown = message_content_array_to_markdown;
  }
});

// node_modules/smart-chats/smart_chats_ui.js
var require_smart_chats_ui = __commonJS({
  "node_modules/smart-chats/smart_chats_ui.js"(exports2) {
    var { message_content_array_to_markdown } = require_message_content_array_to_markdown();
    var SmartChatsUI = class {
      /**
       * Creates an instance of SmartChatsUI.
       * @param {Object} env - The environment object containing configurations and utilities.
       * @param {HTMLElement} container - The HTML container element for the chat UI.
       */
      constructor(env, container) {
        this.env = env;
        this.main = this.env;
        this.container = container;
        this.templates = this.env.templates;
      }
      /**
       * Provides a context for the view rendering. Should be overridden in subclasses.
       * @returns {Object} The context object for the view.
       */
      get view_context() {
        return {
          /* override */
        };
      }
      /**
       * Renders templates using the environment's rendering engine.
       * @param {...any} args - Arguments including template and data to render.
       * @returns {Promise<string>} The rendered HTML string.
       */
      async render(...args) {
        return await this.env.ejs.render(...args);
      }
      /**
       * Displays a notice message in the console.
       * @param {string} message - The message to display.
       */
      show_notice(message) {
        console.log(message);
      }
      /**
       * Initializes the chat UI by clearing the container and rendering the initial chat template.
       */
      async init() {
        console.log("init SmartChatRenderer");
        console.log(this.container);
        this.container.innerHTML = "";
        console.log(this.env.chats.current);
        const data = await this.get_view_data();
        this.container.innerHTML = await this.render(this.templates.smart_chat, data, { context: this.view_context, rmWhitespace: true });
        this.post_process();
      }
      /**
       * Handles new user messages, updates the UI, and triggers rendering of typing indicator.
       * @param {string} user_input - The user's input message.
       */
      async new_user_message(user_input) {
        await this.new_message(user_input, "user");
        this.set_streaming_ux();
        await this.render_dotdotdot();
      }
      /**
       * Post-initialization processing, such as adding listeners and processing messages.
       */
      async post_process() {
        this.add_listeners();
        this.messages.forEach(this.message_post_process.bind(this));
      }
      /**
       * Placeholder for adding listeners. Should be overridden in subclasses.
       */
      add_listeners() {
      }
      /**
       * Placeholder for message post-processing. Should be overridden in subclasses.
       * @param {HTMLElement} msg_elm - The message element to process.
       */
      message_post_process(msg_elm) {
      }
      /**
       * Retrieves view data for rendering the chat interface.
       * @returns {Promise<Object>} An object containing data for the view.
       */
      add_message_listeners(msg_elm) {
      }
      // OVERRIDE
      async get_view_data() {
        var _a;
        const data = {
          name: ((_a = this.env.chats.current) == null ? void 0 : _a.name) || "UNTITLED CHAT",
          messages: await this.env.chats.current.get_messages_html()
        };
        return data;
      }
      /**
       * Adds input listeners to the chat form for handling special keys and sending messages.
       */
      add_chat_input_listeners() {
        const chat_input = this.container.querySelector(".sc-chat-form");
        const textarea = chat_input.querySelector("textarea");
        this.brackets_ct = 0;
        this.prevent_input = false;
        chat_input.addEventListener("keyup", (e) => {
          if (["[", "/", "@"].indexOf(e.key) === -1)
            return;
          const caret_pos = textarea.selectionStart;
          if (e.key === "[") {
            if (textarea.value[caret_pos - 2] === "[") {
              this.open_file_suggestion_modal();
              return;
            }
          } else {
            this.brackets_ct = 0;
          }
          if (e.key === "/") {
            if (textarea.value.length === 1 || textarea.value[caret_pos - 2] === " ") {
              this.open_folder_suggestion_modal();
              return;
            }
          }
          if (e.key === "@") {
            if (textarea.value.length === 1 || textarea.value[caret_pos - 2] === " ") {
              this.open_system_prompt_modal();
              return;
            }
          }
        });
        chat_input.addEventListener("keydown", (e) => {
          if (e.key === "Enter" && e.shiftKey) {
            e.preventDefault();
            if (this.prevent_input) {
              this.show_notice("Wait until current response is finished.");
              return;
            }
            let user_input = textarea.value;
            textarea.value = "";
            this.env.chats.current.new_user_message(user_input);
          }
          textarea.style.height = "auto";
          textarea.style.height = textarea.scrollHeight + "px";
        });
        const abort_button = this.container.querySelector("#sc-abort-button");
        abort_button.addEventListener("click", () => {
          this.env.chat_model.stop_stream();
        });
        const button = this.container.querySelector("#sc-send-button");
        button.addEventListener("click", () => {
          if (this.prevent_input) {
            this.show_notice("Wait until current response is finished.");
            return;
          }
          let user_input = textarea.value;
          textarea.value = "";
          this.env.chats.current.new_user_message(user_input);
        });
      }
      // render message
      async new_message(content, role = "assistant", append_last = false) {
        if (this.dotdotdot_interval) {
          if (!this.last_msg)
            this.message_container.insertAdjacentHTML("beforeend", await this.get_message_html(role, content));
          clearInterval(this.dotdotdot_interval);
          this.dotdotdot_interval = null;
          this.last_msg_content.innerHTML = "";
          this.last_msg.dataset.content = "";
        }
        if (this.last_msg && !this.last_msg.dataset.content)
          this.last_msg.dataset.content = "";
        if (append_last) {
          this.last_msg_content.innerHTML += content;
          this.last_msg.dataset.content += content;
          if (content.indexOf("\n") > -1)
            this.render_md_as_html(this.last_msg);
        } else {
          if (this.last_from !== role) {
            const html = await this.get_message_html(role, content);
            this.message_container.insertAdjacentHTML("beforeend", html);
            this.last_from = role;
            this.last_msg.dataset.content = content;
          } else {
            this.last_msg_content.innerHTML = content;
            this.last_msg.dataset.content = content;
          }
          this.message_post_process(this.last_msg);
        }
        this.message_container.scrollTop = this.message_container.scrollHeight;
      }
      /**
       * Generates HTML for a message based on the role and content.
       * @param {string} role - The role of the message sender.
       * @param {string} content - The content of the message.
       * @returns {Promise<string>} The HTML string for the message.
       */
      async get_message_html(role, content) {
        if (Array.isArray(content))
          content = message_content_array_to_markdown(content);
        return await this.render(this.templates.smart_chat_msg, { role, content }, { context: this.view_context, rmWhitespace: true });
      }
      async get_system_message_html(msg) {
        let { content, role } = msg;
        if (content.includes("```sc-system")) {
          content = content.replace(/```sc-system|```/g, "").trim();
          content = "system prompts: " + content.split("\n").filter((ln) => ln.trim()).join(", ");
        }
        if (content.includes("```sc-context")) {
          content = content.replace(/```sc-context|```/g, "").trim();
          content = "context: " + content.split("\n").filter((ln) => ln.trim()).join(", ");
          if (content.length > 100)
            content = content.substring(0, 100) + "...";
        }
        return await this.render(this.templates.smart_chat_system_msg, { content, role }, { context: this.view_context, rmWhitespace: true });
      }
      /**
       * Inserts selected text from a suggestion modal into the chat input.
       * @param {string} insert_text - The text to insert.
       */
      insert_selection(insert_text) {
        const textarea = this.container.querySelector(".sc-chat-form textarea");
        let caret_pos = textarea.selectionStart;
        let text_before = textarea.value.substring(0, caret_pos);
        let text_after = textarea.value.substring(caret_pos, textarea.value.length);
        textarea.value = text_before + insert_text + text_after;
        textarea.selectionStart = caret_pos + insert_text.length;
        textarea.selectionEnd = caret_pos + insert_text.length;
        textarea.focus();
      }
      /**
       * Renders a typing indicator ("...") and sets an interval to animate it.
       */
      async render_dotdotdot() {
        if (this.dotdotdot_interval)
          clearInterval(this.dotdotdot_interval);
        await this.new_message("...", "assistant");
        let dots = 0;
        const curr_msg = this.last_msg_content;
        curr_msg.innerHTML = "...";
        this.dotdotdot_interval = setInterval(() => {
          dots++;
          if (dots > 3)
            dots = 1;
          curr_msg.innerHTML = ".".repeat(dots);
        }, 500);
      }
      /**
       * Returns the message container element.
       * @returns {HTMLElement} The message container.
       */
      get message_container() {
        return this.container.querySelector(".sc-message-container");
      }
      /**
       * Returns the last message content element.
       * @returns {HTMLElement} The last message content element.
       */
      get last_msg() {
        return this.container.querySelector(".sc-message-container").lastElementChild.querySelector(".sc-message-content");
      }
      /**
       * Returns the last message content span element.
       * @returns {HTMLElement} The last message content span element.
       */
      get last_msg_content() {
        return this.last_msg.querySelector("span:not(.sc-msg-button)");
      }
      /**
       * Returns all message content elements.
       * @returns {NodeListOf<HTMLElement>} A NodeList of message content elements.
       */
      get messages() {
        return this.container.querySelectorAll(".sc-message-container .sc-message-content");
      }
      /**
       * Sets the user interface to a "streaming" mode, disabling input and showing an abort button.
       */
      set_streaming_ux() {
        this.prevent_input = true;
        if (this.container.querySelector("#sc-send-button"))
          this.container.querySelector("#sc-send-button").style.display = "none";
        if (this.container.querySelector("#sc-abort-button"))
          this.container.querySelector("#sc-abort-button").style.display = "block";
      }
      /**
       * Resets the user interface from "streaming" mode to normal.
       */
      unset_streaming_ux() {
        this.prevent_input = false;
        if (this.container.querySelector("#sc-send-button"))
          this.container.querySelector("#sc-send-button").style.display = "";
        if (this.container.querySelector("#sc-abort-button"))
          this.container.querySelector("#sc-abort-button").style.display = "none";
      }
      /**
       * Clears any streaming user interface effects, such as intervals and temporary elements.
       */
      clear_streaming_ux() {
        this.unset_streaming_ux();
        if (this.dotdotdot_interval) {
          clearInterval(this.dotdotdot_interval);
          this.dotdotdot_interval = null;
          this.active_elm.parentElement.remove();
          this.active_elm = null;
        }
      }
    };
    exports2.SmartChatsUI = SmartChatsUI;
  }
});

// src/smart_obsidian_view.js
var require_smart_obsidian_view = __commonJS({
  "src/smart_obsidian_view.js"(exports2) {
    var { ItemView } = require("obsidian");
    var views = require_views();
    var ejs = require_ejs_min();
    var SmartObsidianView = class extends ItemView {
      constructor(leaf, plugin) {
        super(leaf);
        this.app = plugin.app;
        this.plugin = plugin;
        this.settings = plugin.settings;
        this.templates = views;
        this.ejs = ejs;
      }
      render_template(template_name, data) {
        if (!this.templates[template_name])
          throw new Error(`Template '${template_name}' not found.`);
        return ejs.render(this.templates[template_name], data, { context: this.view_context });
      }
      get view_context() {
        return {
          // app: this.plugin.app,
          attribution: this.templates.attribution,
          get_icon: this.get_icon.bind(this),
          settings: this.plugin.settings
        };
      }
      get_icon(name) {
        return this.plugin.obsidian.getIcon(name).outerHTML;
      }
      static get view_type() {
      }
      static get_leaf(workspace) {
        var _a;
        return (_a = workspace.getLeavesOfType(this.view_type)) == null ? void 0 : _a.find((leaf) => leaf.view instanceof this);
      }
      static get_view(workspace) {
        var _a;
        return (_a = this.get_leaf(workspace)) == null ? void 0 : _a.view;
      }
      static open(workspace, active = true) {
        if (this.get_leaf(workspace))
          this.get_leaf(workspace).setViewState({ type: this.view_type, active });
        else
          workspace.getRightLeaf(false).setViewState({ type: this.view_type, active });
        if (workspace.rightSplit.collapsed)
          workspace.rightSplit.toggle();
      }
      static is_open(workspace) {
        var _a;
        return ((_a = this.get_leaf(workspace)) == null ? void 0 : _a.view) instanceof this;
      }
    };
    exports2.SmartObsidianView = SmartObsidianView;
  }
});

// src/sc_chat_view.js
var require_sc_chat_view = __commonJS({
  "src/sc_chat_view.js"(exports2) {
    var { SmartObsidianView } = require_smart_obsidian_view();
    var ScChatView2 = class extends SmartObsidianView {
      constructor(leaf, plugin) {
        super(leaf, plugin);
        this.plugin = plugin;
        this.env = this.plugin.env;
        this.config = this.plugin.settings;
      }
      static get view_type() {
        return "smart-connections-chat-view";
      }
      getDisplayText() {
        return "Smart Connections Chat";
      }
      getIcon() {
        return "message-square";
      }
      getViewType() {
        return ScChatView2.view_type;
      }
      async onOpen() {
        this.app.workspace.onLayoutReady(this.initialize.bind(this));
      }
      async initialize() {
        if (!this.env.entities_loaded) {
          this.containerEl.innerHTML = "Loading Smart Connections...";
          while (!this.env.entities_loaded)
            await new Promise((r) => setTimeout(r, 2e3));
        }
        if (this.env.chat_ui)
          this.env.chat_ui.container = this.containerEl;
        while (!this.env.chats)
          await new Promise((r) => setTimeout(r, 300));
        await this.env.chats.new();
        this.app.workspace.registerHoverLinkSource(ScChatView2.view_type, {
          display: "Smart Chat Links",
          defaultMod: true
        });
      }
      onClose() {
        this.app.workspace.unregisterHoverLinkSource(ScChatView2.view_type);
      }
    };
    exports2.ScChatView = ScChatView2;
  }
});

// src/smart_settings.js
var require_smart_settings = __commonJS({
  "src/smart_settings.js"(exports2) {
    var { Setting } = require("obsidian");
    var SmartSettings = class {
      constructor(env, container, template_name = "smart_settings") {
        this.env = env;
        this.plugin = this.env.plugin;
        this.settings = this.plugin.settings;
        this.container = container;
        this.template_name = template_name;
        this.ejs = this.env.ejs;
        this.templates = this.env.templates;
      }
      async render() {
        const view_data = typeof this.get_view_data === "function" ? await this.get_view_data() : this.view_data;
        this.render_template(view_data);
        this.render_components();
      }
      render_template(view_data = null) {
        if (!this.template)
          throw new Error(`Settings template not found.`);
        this.container.empty();
        this.container.innerHTML = this.ejs.render(this.template, view_data || this.view_data, { context: this });
      }
      async update(setting, value) {
        console.log("saving setting: " + setting);
        if (setting.includes(".")) {
          let parts = setting.split(".");
          let obj = this.plugin.settings;
          for (let i = 0; i < parts.length - 1; i++) {
            if (!obj[parts[i]])
              obj[parts[i]] = {};
            obj = obj[parts[i]];
          }
          obj[parts[parts.length - 1]] = typeof value === "string" ? value.trim() : value;
        } else {
          this.plugin.settings[setting] = typeof value === "string" ? value.trim() : value;
        }
        await this.plugin.save_settings(true);
        console.log("saved settings");
        console.log(this.plugin.settings);
      }
      render_components() {
        this.container.querySelectorAll(".setting-component").forEach((elm) => {
          const setting_elm = new Setting(elm);
          if (elm.dataset.name)
            setting_elm.setName(elm.dataset.name);
          if (elm.dataset.description)
            setting_elm.descEl.innerHTML = elm.dataset.description;
          const setting = elm.dataset.setting;
          if (elm.dataset.type === "text") {
            setting_elm.addText((text) => {
              text.setPlaceholder(elm.dataset.placeholder || "");
              text.setValue(this.get_setting(setting));
              let debounceTimer;
              if (elm.dataset.button) {
                setting_elm.addButton((button) => {
                  button.setButtonText(elm.dataset.button);
                  button.onClick(async () => this.handle_on_change(setting, text.getValue(), elm));
                });
              } else {
                text.onChange(async (value) => {
                  clearTimeout(debounceTimer);
                  debounceTimer = setTimeout(() => this.handle_on_change(setting, value, elm), 2e3);
                });
              }
            });
          } else if (elm.dataset.type === "number") {
            setting_elm.addText((number) => {
              number.inputEl.type = "number";
              number.setPlaceholder(elm.dataset.placeholder || "");
              number.inputEl.value = parseInt(this.get_setting(setting));
              number.inputEl.min = elm.dataset.min || 0;
              if (elm.dataset.max)
                number.inputEl.max = elm.dataset.max;
              let debounceTimer;
              number.onChange(async (value) => {
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(() => this.handle_on_change(setting, parseInt(value), elm), 2e3);
              });
            });
          } else if (elm.dataset.type === "dropdown") {
            setting_elm.addDropdown((dropdown) => {
              Object.entries(elm.dataset).filter(([k, v]) => k.startsWith("option")).forEach(([k, v]) => {
                const [value, name] = v.split("|");
                dropdown.addOption(value, name || value);
              });
              dropdown.onChange(async (value) => this.handle_on_change(setting, value, elm));
              dropdown.setValue(this.get_setting(setting));
            });
          } else if (elm.dataset.type === "button") {
            setting_elm.addButton((button) => {
              button.setButtonText(elm.dataset.btnText || elm.dataset.name);
              button.onClick(async () => {
                if (elm.dataset.confirm) {
                  const confirmation_message = elm.dataset.confirm;
                  if (!confirm(confirmation_message))
                    return;
                }
                if (elm.dataset.href)
                  window.open(elm.dataset.href);
                if (elm.dataset.callback)
                  this[elm.dataset.callback](setting);
              });
            });
          } else if (elm.dataset.type === "toggle") {
            setting_elm.addToggle((toggle) => {
              toggle.setValue(this.get_setting(setting));
              toggle.onChange(async (value) => this.handle_on_change(setting, value, elm));
            });
          }
          if (elm.dataset.disabled)
            setting_elm.setDisabled(true);
        });
      }
      async handle_on_change(setting, value, elm) {
        await this.update(setting, value);
        if (elm.dataset.callback)
          this[elm.dataset.callback](setting, value, elm);
      }
      get_setting(setting) {
        if (setting.includes(".")) {
          let parts = setting.split(".");
          let obj = this.plugin.settings;
          for (let part of parts.slice(0, -1)) {
            if (obj[part] === void 0)
              return this.plugin.constructor.defaults[setting];
            obj = obj[part];
          }
          return obj[parts[parts.length - 1]] || this.plugin.constructor.defaults[setting];
        } else {
          return this.plugin.settings[setting] || this.plugin.constructor.defaults[setting];
        }
      }
      // override in subclass (required)
      get template() {
        return "";
      }
      // ejs template string
      get view_data() {
        return {};
      }
      // object properties available in template
    };
    exports2.SmartSettings = SmartSettings;
  }
});

// src/smart_chat_settings.js
var require_smart_chat_settings = __commonJS({
  "src/smart_chat_settings.js"(exports2) {
    var ScTranslations = require_ScTranslations();
    var { SmartSettings } = require_smart_settings();
    var SmartChatSettings = class extends SmartSettings {
      update_smart_chat_folder() {
        this.plugin.update_smart_chat_folder();
      }
      async changed_smart_chat_model(render = true) {
        const platform_config = this.plugin.env.chat_model.platforms[this.plugin.settings.chat_model_platform_key];
        const smart_chat_model_config = platform_config || {};
        if (smart_chat_model_config.model_name) {
          const platform_models = await this.plugin.env.chat_model.get_models();
          const model_config = platform_models.find((m) => m.model_name === smart_chat_model_config.model_name);
          console.log("model_config", model_config);
          if (model_config)
            Object.assign(smart_chat_model_config, model_config);
          console.log("smart_chat_model_config", smart_chat_model_config);
        }
        this.plugin.save_settings(true);
        this.plugin.env.chat_model = null;
        this.plugin.env.init_chat_model();
        if (render)
          this.render();
      }
      async test_chat_api_key() {
        await this.changed_smart_chat_model();
        const resp = await this.plugin.env.chat_model.test_api_key();
        if (resp)
          return this.plugin.notices.show("api key test pass", "Success! API key is valid");
        this.plugin.notices.show("api key test fail", "Error: API key is invalid!");
      }
      get self_ref_list() {
        return "Current: " + ScTranslations[this.config.language].pronouns.join(", ");
      }
      get template() {
        return this.templates["smart_chat_settings"];
      }
      async get_view_data() {
        var _a;
        const view_data = {
          settings: this.plugin.settings,
          chat_platform: this.env.chat_model.platforms[this.plugin.settings.chat_model_platform_key],
          chat_platforms: ((_a = this.env.chat_model) == null ? void 0 : _a.platforms) ? Object.keys(this.env.chat_model.platforms).map((platform_key) => {
            var _a2;
            return { key: platform_key, ...((_a2 = this.env.chat_model) == null ? void 0 : _a2.platforms[platform_key]) || {} };
          }) : []
        };
        view_data.platform_chat_models = await this.plugin.env.chat_model.get_models();
        view_data.smart_chat_settings = this.ejs.render(this.template, view_data);
        return view_data;
      }
    };
    exports2.SmartChatSettings = SmartChatSettings;
  }
});

// src/sc_chats_ui.js
var require_sc_chats_ui = __commonJS({
  "src/sc_chats_ui.js"(exports2) {
    var { SmartChatsUI } = require_smart_chats_ui();
    var { ScChatView: ScChatView2 } = require_sc_chat_view();
    var { FuzzySuggestModal } = require("obsidian");
    var { SmartChatSettings } = require_smart_chat_settings();
    var ScChatsUI = class extends SmartChatsUI {
      get view_context() {
        return {
          attribution: this.templates.attribution,
          get_icon: this.env.plugin.chat_view.get_icon.bind(this.env.plugin.chat_view)
        };
      }
      get obsidian() {
        return this.env.plugin.obsidian;
      }
      show_notice(message) {
        this.env.plugin.show_notice(message);
      }
      add_listeners() {
        const chat_name_input = this.container.querySelector(".sc-chat-name-input");
        chat_name_input.addEventListener("change", (event) => {
          this.env.chats.current.rename(event.target.value);
        });
        const open_in_note_btn = this.container.querySelector("button[title='Open Conversation Note']");
        open_in_note_btn.addEventListener("click", () => {
          const link_tfile = this.env.plugin.app.metadataCache.getFirstLinkpathDest(this.env.chats.current.name, "/");
          let leaf = this.env.plugin.app.workspace.getLeaf(true);
          leaf.openFile(link_tfile);
        });
        const settings_btn = this.container.querySelector("button[title='Settings']");
        settings_btn.addEventListener("click", async () => {
          const settings_container = this.container.querySelector("#settings");
          if (settings_container.innerHTML)
            return settings_container.innerHTML = "";
          if (!this.chat_settings)
            this.chat_settings = new SmartChatSettings(this.env, settings_container);
          else
            this.chat_settings.container = settings_container;
          this.chat_settings.render();
          settings_container.style.transition = "background-color 0.5s ease-in-out";
          settings_container.style.backgroundColor = "var(--bold-color)";
          setTimeout(() => {
            settings_container.style.backgroundColor = "";
          }, 500);
        });
        const history_btn = this.container.querySelector("button[title='Chat History']");
        history_btn.addEventListener("click", () => {
          this.env.chats.open_modal();
        });
        const new_chat_btn = this.container.querySelector("button[title='New Chat']");
        new_chat_btn.addEventListener("click", () => {
          this.env.chats.new();
        });
        this.add_chat_input_listeners();
      }
      async message_post_process(msg_elm) {
        await this.render_md_as_html(msg_elm);
        this.handle_links_in_message(msg_elm);
        this.add_message_listeners(msg_elm);
      }
      async render_md_as_html(msg_elm) {
        const text_elm = msg_elm.querySelector("span:not(.sc-msg-button)");
        const text = msg_elm.getAttribute("data-content") || text_elm.textContent;
        text_elm.innerHTML = "";
        await this.obsidian.MarkdownRenderer.render(this.env.plugin.app, text, text_elm, "?no-dataview", new this.obsidian.Component());
      }
      handle_links_in_message(msg_elm) {
        const links = msg_elm.querySelectorAll("a");
        if (links.length > 0) {
          for (let i = 0; i < links.length; i++) {
            const link = links[i];
            const link_text = link.getAttribute("data-href");
            link.addEventListener("mouseover", (event) => {
              this.env.plugin.app.workspace.trigger("hover-link", {
                event,
                source: ScChatView2.view_type,
                hoverParent: link.parentElement,
                targetEl: link,
                // extract link text from a.data-href
                linktext: link_text
              });
            });
            link.addEventListener("click", (event) => {
              const link_tfile = this.env.plugin.app.metadataCache.getFirstLinkpathDest(link_text, "/");
              const mod = this.obsidian.Keymap.isModEvent(event);
              let leaf = this.env.plugin.app.workspace.getLeaf(mod);
              leaf.openFile(link_tfile);
            });
          }
        }
      }
      add_message_listeners(msg_elm) {
        const copy_button = msg_elm.querySelector("span.sc-msg-button[title='Copy message to clipboard']");
        copy_button == null ? void 0 : copy_button.addEventListener("click", (e) => {
          console.log("copy message to clipboard");
          const msg_content_elm = e.target.closest(".sc-message-content");
          console.log(msg_content_elm);
          const msg_content = msg_content_elm.getAttribute("data-content") || msg_content_elm.querySelector("span:not(.sc-msg-button)").textContent;
          console.log(msg_content);
          navigator.clipboard.writeText(msg_content);
          this.env.plugin.show_notice("Message copied to clipboard");
        });
      }
      // open file suggestion modal
      open_file_suggestion_modal() {
        if (!this.file_selector)
          this.file_selector = new ScFileSelectModal(this.env.plugin.app, this.env);
        this.file_selector.open();
      }
      // open folder suggestion modal
      async open_folder_suggestion_modal() {
        if (!this.folder_selector) {
          const folders = await this.env.plugin.get_folders();
          this.folder_selector = new ScFolderSelectModal(this.env.plugin.app, this.env, folders);
        }
        this.folder_selector.open();
      }
      async open_system_prompt_modal() {
        if (!this.system_prompt_selector)
          this.system_prompt_selector = new ScSystemPromptSelectModal(this.env.plugin.app, this.env);
        this.system_prompt_selector.open();
      }
    };
    exports2.ScChatsUI = ScChatsUI;
    var ScFileSelectModal = class extends FuzzySuggestModal {
      constructor(app, env) {
        super(app);
        this.app = app;
        this.env = env;
        this.setPlaceholder("Type the name of a file...");
      }
      // get all markdown files
      getItems() {
        return this.app.vault.getMarkdownFiles().sort((a, b) => a.basename.localeCompare(b.basename));
      }
      getItemText(item) {
        return item.basename;
      }
      onChooseItem(file) {
        this.env.chat_ui.insert_selection(file.basename + "]] ");
      }
    };
    var ScFolderSelectModal = class extends FuzzySuggestModal {
      constructor(app, env, folders) {
        super(app);
        this.app = app;
        this.env = env;
        this.folders = folders;
        this.setPlaceholder("Type the name of a folder...");
      }
      getItems() {
        return this.folders;
      }
      getItemText(item) {
        return item;
      }
      onChooseItem(folder) {
        this.env.chat_ui.insert_selection(folder + "/ ");
      }
    };
    var ScSystemPromptSelectModal = class extends FuzzySuggestModal {
      constructor(app, env) {
        super(app);
        this.app = app;
        this.env = env;
        this.setPlaceholder("Type the name of a system prompt...");
      }
      // getItems() { return this.env.system_prompts; }
      getItems() {
        return this.env.system_prompts;
      }
      getItemText(item) {
        return item.basename;
      }
      onChooseItem(prompt) {
        this.env.chat_ui.insert_selection('"' + prompt.basename + '"');
      }
    };
  }
});

// node_modules/smart-chats/smart_chat.js
var require_smart_chat = __commonJS({
  "node_modules/smart-chats/smart_chat.js"(exports2) {
    var SmartChat = class {
      constructor(env, key, data = "") {
        this.env = env;
        this.chats = this.env.chats;
        this.key = key;
        this.data = data;
        this.scope = {};
        if (this.chats)
          this.chats.items[this.key] = this;
      }
      /**
       * Factory method to create a new SmartChat instance with a unique key or a default one.
       * 
       * @static
       * @param {SmartEnv} env - The SmartChat environment object.
       * @param {string} [key=null] - Optional key for the chat session. If not provided, a default is generated.
       * @param {string} [data=''] - Initial data for the chat session.
       * @returns {SmartChat} A new instance of SmartChat.
       */
      static create(env, key = null, data = "") {
        if (!key)
          key = "UNTITLED CHAT " + get_file_date_string();
        const chat = new this(env, key, data);
        return chat;
      }
      /**
       * Computes the file path for the current chat session based on its key and file type.
       * 
       * @returns {string} The file path for the chat session.
       */
      get file_path() {
        return `${this.chats.folder}/${this.key}.${this.file_type}`;
      }
      /**
       * Returns the name (key) of the chat session.
       * 
       * @returns {string} The key of the chat session.
       */
      get name() {
        return this.key;
      }
      /**
       * Renames the current chat session and updates the storage references.
       * 
       * @param {string} new_id - The new identifier for the chat session.
       * @returns {Promise<void>}
       */
      async rename(new_id) {
        if (this.key === new_id)
          return;
        if (await this.exists())
          await this.delete();
        delete this.chats.items[this.key];
        this.key = new_id;
        this.chats.items[this.key] = this;
        await this.save();
      }
      /**
       * Retrieves all messages from the chat session and converts them to HTML format.
       * 
       * @returns {Promise<string>} A string containing all messages in HTML format.
       */
      async get_messages_html() {
        const messages = await this.get_messages();
        const html = await Promise.all(messages.map(async (msg) => {
          if (!msg.content)
            return "";
          if (msg.role === "system")
            return await this.env.chat_ui.get_system_message_html(msg);
          return await this.env.chat_ui.get_message_html(msg.role, msg.content);
        }));
        return html.join("");
      }
      /**
       * Adds a new message to the chat session.
       * 
       * @param {Object} [msg={}] - The message object to add.
       * @returns {Promise<void>}
       */
      async add_message(msg = {}) {
        const chat_ml = await this.get_chat_ml();
        chat_ml.messages.push(msg);
        await this.update(chat_ml);
      }
      /**
       * Adds output from a tool to the chat session as a message.
       * 
       * @param {string} tool_name - The name of the tool.
       * @param {*} tool_output - The output from the tool.
       * @returns {Promise<void>}
       */
      async add_tool_output(tool_name, tool_output) {
        if (typeof this.env.actions.parse_tool_output === "function") {
          const message = await this.env.actions.parse_tool_output(tool_name, tool_output);
          if (message)
            return await this.add_message(message);
        }
        await this.add_message({ role: "tool", tool_call_id: tool_name, content: JSON.stringify(tool_output) });
      }
      // file-type specific parsing and formatting overrides
      /**
       * Updates the chat session data with the provided ChatML object and saves it.
       * 
       * @param {Object} chat_ml - The ChatML object to update the session with.
       * @returns {Promise<void>}
       */
      async update(chat_ml) {
        this.data = this.from_chatml(chat_ml);
        await this.save();
      }
      /**
       * Saves the current chat session data to the file system.
       * 
       * @returns {Promise<void>}
       */
      async save() {
        return await this.chats.save(this.file_path, this.data);
      }
      /**
       * Deletes the chat session file from the file system.
       * 
       * @returns {Promise<void>}
       */
      async delete() {
        return await this.chats.delete(this.file_path);
      }
      /**
       * Checks if the chat session file exists in the file system.
       * 
       * @returns {Promise<boolean>} True if the file exists, false otherwise.
       */
      async exists() {
        return await this.chats.exists(this.file_path);
      }
      /**
       * Loads the chat session data from the file system.
       * 
       * @returns {Promise<string>} The loaded data.
       */
      async load() {
        if (!await this.exists())
          return this.data = "";
        return this.data = await this.chats.read(this.file_path);
      }
      /**
       * Retrieves the ChatML object from the current session data.
       * 
       * @returns {Promise<Object>} The ChatML object.
       */
      async get_chat_ml() {
        await this.load();
        const chat_ml = this.to_chatml(this.data);
        return chat_ml;
      }
      /**
       * Retrieves all messages from the ChatML object of the current session.
       * 
       * @returns {Promise<Array>} An array of message objects.
       */
      async get_messages() {
        return (await this.get_chat_ml()).messages;
      }
      /**
       * Processes a new user message, updates UI/UX, and adds it to the chat session.
       * 
       * @param {string} content - The content of the user message.
       * @returns {Promise<void>}
       */
      async new_user_message(content) {
        var _a, _b, _c, _d, _e;
        content = await this.parse_user_message(content);
        if (typeof ((_b = (_a = this.env) == null ? void 0 : _a.chat_ui) == null ? void 0 : _b.new_user_message) === "function")
          await this.env.chat_ui.new_user_message(content);
        if (typeof ((_d = (_c = this.env) == null ? void 0 : _c.actions) == null ? void 0 : _d.new_user_message) === "function")
          await this.env.actions.new_user_message(content);
        if (typeof ((_e = this.chats) == null ? void 0 : _e.new_user_message) === "function")
          await this.chats.new_user_message(content);
        await this.add_message({ role: "user", content });
        await this.env.chat_model.complete({});
      }
      // Override these for file-type specific parsing and formatting in subclasses
      /**
       * Returns the file type for the chat session, used in file operations.
       * 
       * @returns {string} The file type, default is 'json'.
       */
      get file_type() {
        return "json";
      }
      /**
       * Converts the provided data into a ChatML object. This method should be overridden in subclasses.
       * 
       * @param {string} data - The data to convert.
       * @returns {Object} The ChatML object.
       */
      to_chatml(data) {
        return data;
      }
      /**
       * Converts a ChatML object back into a string or suitable format for storage. This method should be overridden in subclasses.
       * 
       * @param {Object} data - The ChatML object to convert.
       * @returns {string} The string or formatted data.
       */
      from_chatml(data) {
        return data;
      }
      /**
       * Parses the user message content before adding it to the chat. This method can be overridden to include custom parsing logic.
       * 
       * @param {string} content - The content to parse.
       * @returns {Promise<string>} The parsed content.
       */
      async parse_user_message(content) {
        return content;
      }
    };
    function get_file_date_string() {
      return (/* @__PURE__ */ new Date()).toISOString().replace(/(T|:|\..*)/g, " ").trim();
    }
    exports2.SmartChat = SmartChat;
  }
});

// node_modules/smart-chats/utils/chat_ml_to_markdown.js
var require_chat_ml_to_markdown = __commonJS({
  "node_modules/smart-chats/utils/chat_ml_to_markdown.js"(exports2) {
    var { message_content_array_to_markdown } = require_message_content_array_to_markdown();
    function chat_ml_to_markdown(chat_ml) {
      console.log("chat_ml");
      console.log(chat_ml);
      let markdown = "";
      let has_md = false;
      chat_ml.messages.forEach((msg) => {
        if (msg.role && msg.content) {
          if (markdown.length > 0)
            markdown += "\n\n";
          markdown += `##### ${msg.role}
`;
          if (msg.role === "tool") {
            console.log(msg);
            markdown += "```";
            if (msg.tool_call_id)
              markdown += `${msg.tool_call_id}
`;
            if (msg.content)
              markdown += `${msg.content}
`;
            markdown += "```";
          } else if (Array.isArray(msg.content)) {
            markdown += message_content_array_to_markdown(msg.content);
          } else if (msg.content.indexOf("---BEGIN NOTE") > -1) {
            markdown += "```sc-context";
            const lines = msg.content.split("\n").filter((line) => line.trim().length && line.startsWith("---BEGIN NOTE") && line.indexOf("[[") > -1);
            lines.forEach((line, i) => {
              const link = line.substring(line.indexOf("[[") + 2, line.indexOf("]]"));
              if (i > 0)
                markdown += "\n";
              if (link)
                markdown += `${link}`;
            });
            markdown += "\n```";
          } else if (msg.content.indexOf("#") === 0 || msg.content.indexOf("\n#") > -1) {
            markdown += "```md";
            const content = msg.content.replace(/\n[`]{3}/g, "\n\\```");
            markdown += `
${content}`;
            markdown += "\n```";
          } else
            markdown += `${msg.content}`;
        }
        if (msg.tool_calls) {
          msg.tool_calls.forEach((tool_call) => {
            var _a, _b, _c;
            if (markdown.length > 0)
              markdown += "\n\n";
            markdown += `##### assistant
`;
            markdown += `\`\`\`${(_a = tool_call == null ? void 0 : tool_call.function) == null ? void 0 : _a.name}`;
            try {
              markdown += `
${JSON.stringify(JSON.parse((_b = tool_call == null ? void 0 : tool_call.function) == null ? void 0 : _b.arguments))}`;
            } catch (err) {
              markdown += `
${(_c = tool_call == null ? void 0 : tool_call.function) == null ? void 0 : _c.arguments}`;
            }
            markdown += "\n```";
          });
        }
      });
      return markdown.trim();
    }
    exports2.chat_ml_to_markdown = chat_ml_to_markdown;
  }
});

// node_modules/smart-chats/utils/add_content_to_message.js
var require_add_content_to_message = __commonJS({
  "node_modules/smart-chats/utils/add_content_to_message.js"(exports2) {
    function add_content_to_message(curr_msg, content) {
      if (typeof content === "string")
        content = content.trim();
      else
        content = content.map((c) => c.type === "text" ? { type: "text", text: c.text.trim() } : c);
      if (Array.isArray(content)) {
        if (typeof curr_msg.content === "string")
          curr_msg.content = [{ type: "text", text: curr_msg.content }];
        else if (typeof curr_msg.content === "undefined")
          curr_msg.content = [];
        curr_msg.content.push(...content);
      } else {
        if (Array.isArray(curr_msg.content)) {
          if (curr_msg.content[curr_msg.content.length - 1].type === "text")
            curr_msg.content[curr_msg.content.length - 1].text += "\n" + content;
          else
            curr_msg.content.push({ type: "text", text: content });
        } else {
          if (!curr_msg.content)
            curr_msg.content = "";
          else
            curr_msg.content += "\n";
          if (content.startsWith("\\```"))
            content = content.substring(1);
          curr_msg.content += content;
        }
      }
    }
    exports2.add_content_to_message = add_content_to_message;
  }
});

// node_modules/smart-chats/utils/markdown_to_chat_ml.js
var require_markdown_to_chat_ml = __commonJS({
  "node_modules/smart-chats/utils/markdown_to_chat_ml.js"(exports2) {
    var { add_content_to_message } = require_add_content_to_message();
    function markdown_to_chat_ml(markdown) {
      const lines = markdown.split("\n");
      const chat_ml = { messages: [] };
      let current_role = "";
      let tool_name = null;
      let curr_msg = null;
      let is_code_block = false;
      lines.forEach((line) => {
        if (tool_name && curr_msg.role === "tool")
          curr_msg.tool_call_id = tool_name;
        if (line.startsWith("##### ") && !is_code_block) {
          tool_name = null;
          if (curr_msg)
            chat_ml.messages.push({ ...curr_msg });
          current_role = line.substring(6).trim();
          curr_msg = {
            role: current_role
          };
        } else if (line.startsWith("```")) {
          is_code_block = !is_code_block;
          if (line.trim().length > 5 && line.trim().indexOf(" ") < 0) {
            tool_name = line.substring(3).trim();
            if (tool_name === "md")
              return;
            if (["js", "javascript", "dataview"].includes(tool_name))
              return add_content_to_message(curr_msg, line);
            if (["sc-context", "sc-system"].includes(tool_name))
              return add_content_to_message(curr_msg, line);
            if (curr_msg.role === "tool")
              return;
            if (!curr_msg.tool_calls)
              curr_msg.tool_calls = [];
            curr_msg.tool_calls.push({
              id: tool_name,
              type: "function",
              function: {
                name: tool_name,
                arguments: ""
              }
            });
          } else if (["sc-context", "sc-system", "md", "javascript", "js", "dataview"].includes(tool_name)) {
            add_content_to_message(curr_msg, line);
          }
        } else if (line.trim() !== "" && curr_msg) {
          if (tool_name && curr_msg.tool_calls)
            curr_msg.tool_calls[curr_msg.tool_calls.length - 1].function.arguments += line;
          else if (line.match(/!\[.*?\]\((.*?)\)/)) {
            const image_matches = line.matchAll(/^!\[(?<caption>[^\]]*?)\]\((?<imageUrl>[^\)]*?)\)/g);
            const content = [];
            for (const match of image_matches) {
              const caption = match.groups.caption || match.groups.obsidianCaption;
              const imageUrl = match.groups.imageUrl || match.groups.obsidianLink;
              content.push({ type: "image_url", image_url: { url: imageUrl } });
              if (caption)
                content.push({ type: "text", text: `Image caption: ${caption}` });
            }
            add_content_to_message(curr_msg, content);
          } else
            add_content_to_message(curr_msg, line);
        }
      });
      if (curr_msg)
        chat_ml.messages.push({ ...curr_msg });
      return chat_ml;
    }
    exports2.markdown_to_chat_ml = markdown_to_chat_ml;
  }
});

// node_modules/smart-chats/smart_chat_md.js
var require_smart_chat_md = __commonJS({
  "node_modules/smart-chats/smart_chat_md.js"(exports2) {
    var { SmartChat } = require_smart_chat();
    var { chat_ml_to_markdown } = require_chat_ml_to_markdown();
    var { markdown_to_chat_ml } = require_markdown_to_chat_ml();
    var SmartChatMD = class extends SmartChat {
      /**
       * Returns the file type associated with this class.
       * @returns {string} The file type, which is 'md' for markdown.
       */
      get file_type() {
        return "md";
      }
      /**
       * Updates the internal data with the provided ChatML and saves it.
       * @param {Object} chat_ml - The ChatML object to update the data with.
       */
      async update(chat_ml) {
        this.data = this.from_chatml(chat_ml);
        await this.save();
      }
      // file-type specific parsing and formatting overrides
      /**
       * Retrieves the ChatML representation of the current data.
       * @returns {Promise<Object>} The ChatML object.
       */
      async get_chat_ml() {
        await this.load();
        const chat_ml = this.to_chatml(this.data);
        return chat_ml;
      }
      /**
       * Converts markdown text to a ChatML object.
       * @param {string} markdown - The markdown string to convert.
       * @returns {Object} The converted ChatML object.
       */
      to_chatml(markdown) {
        return markdown_to_chat_ml(markdown);
      }
      /**
       * Converts a ChatML object to markdown text.
       * @param {Object} chatml - The ChatML object to convert.
       * @returns {string} The converted markdown string.
       */
      from_chatml(chatml) {
        return chat_ml_to_markdown(chatml);
      }
    };
    exports2.SmartChatMD = SmartChatMD;
    exports2.chat_ml_to_markdown = chat_ml_to_markdown;
    exports2.markdown_to_chat_ml = markdown_to_chat_ml;
  }
});

// node_modules/smart-chats/smart_chats.js
var require_smart_chats = __commonJS({
  "node_modules/smart-chats/smart_chats.js"(exports2) {
    var { SmartChatMD } = require_smart_chat_md();
    var { SmartChat } = require_smart_chat();
    var SmartChats = class {
      /**
       * Creates an instance of SmartChats.
       * @param {Object} env - The environment context, used across the chat system.
       * @param {Object} [opts={}] - Optional parameters to configure the SmartChats instance.
       */
      constructor(env, opts = {}) {
        this.env = env;
        this.folder = "smart-chats";
        this.items = {};
        this.formats = {
          md: SmartChatMD,
          json: SmartChat
        };
        this.default_file_type = "md";
        Object.assign(this, opts);
      }
      /**
       * Creates a new chat instance and initializes the chat UI.
       */
      async new() {
        if (this.current) {
          await this.current.save();
          this.current = null;
        }
        this.current = this.file_format.create(this.env);
        console.log(this.current);
        await this.env.chat_ui.init();
      }
      /**
       * Loads all conversations from the filesystem and initializes them.
       */
      async load_all() {
        if (!await this.exists(this.folder))
          await this.create_folder(this.folder);
        const convos = await this.get_conversation_ids_and_file_types();
        convos.forEach(([conversation_id, file_type]) => {
          if (!this.formats[file_type])
            console.log("Unsupported file type", [conversation_id, file_type]);
          this.items[conversation_id] = this.formats[file_type].create(this.env, conversation_id);
        });
      }
      /**
       * Saves a chat conversation by its key.
       * If the chat does not exist, it creates a new one.
       * @param {string} key - The key identifier for the chat.
       * @param {string} chat_ml - The chat content in markup language.
       */
      async save(key, chat_ml) {
        let chat = this.items[key];
        if (!chat) {
          console.log("Creating new conversation");
          chat = this.file_format.create(this.env, key, chat_ml);
        }
        await chat.save(chat_ml);
      }
      /**
       * Getter for the file format based on the default file type.
       * @returns {Object} The chat format class.
       */
      get file_format() {
        return this.formats[this.default_file_type];
      }
      /**
       * Retrieves conversation IDs and their corresponding file types from the filesystem.
       * @returns {Promise<Array<Array<string>>>} An array of conversation IDs and file types.
       */
      async get_conversation_ids_and_file_types() {
        console.log("get_conversation_ids_and_file_types");
        const folder = await this.list(this.folder);
        console.log(folder);
        const files = folder.files.map((file) => {
          const file_type = file.split(".").pop();
          const conversation_id = file.replace(this.folder + "/", "").replace("." + file_type, "");
          return [conversation_id, file_type];
        });
        return files;
      }
      // Platform-specific methods to be overridden in subclasses or instances
      async open(conversation_id) {
      }
      async load(path) {
      }
      async save(path, file_content) {
      }
      async delete(path) {
      }
      async exists(path) {
      }
      async create_folder(path) {
      }
      async list(path) {
      }
    };
    exports2.SmartChats = SmartChats;
    exports2.SmartChat = SmartChat;
    exports2.SmartChatMD = SmartChatMD;
  }
});

// src/extract_folder_references.js
var require_extract_folder_references = __commonJS({
  "src/extract_folder_references.js"(exports2) {
    function extract_folder_references(folders, user_input) {
      folders = folders.slice();
      const matches = folders.sort((a, b) => b.length - a.length).map((folder) => {
        if (user_input.indexOf(folder) !== -1) {
          user_input = user_input.replace(folder, "");
          return folder;
        }
        return false;
      }).filter((folder) => folder);
      console.log(matches);
      if (matches)
        return matches;
      return false;
    }
    exports2.extract_folder_references = extract_folder_references;
  }
});

// src/contains_internal_link.js
var require_contains_internal_link = __commonJS({
  "src/contains_internal_link.js"(exports2) {
    function contains_internal_link(user_input) {
      if (user_input.indexOf("[[") === -1)
        return false;
      if (user_input.indexOf("]]") === -1)
        return false;
      return true;
    }
    exports2.contains_internal_link = contains_internal_link;
  }
});

// src/contains_folder_reference.js
var require_contains_folder_reference = __commonJS({
  "src/contains_folder_reference.js"(exports2) {
    function contains_folder_reference(user_input) {
      const first_slash = user_input.indexOf("/");
      if (first_slash === -1)
        return false;
      const last_slash = user_input.lastIndexOf("/");
      if (last_slash - first_slash <= 1)
        return false;
      const first_open_parentheses = user_input.indexOf("(");
      const first_close_parentheses = user_input.indexOf(")");
      if (first_open_parentheses > first_slash && first_close_parentheses < last_slash)
        return true;
      if (first_open_parentheses !== -1 && first_close_parentheses !== -1) {
        const start = user_input.indexOf("(");
        const end = user_input.indexOf(")");
        const without_content_in_parentheses = user_input.slice(0, start) + user_input.slice(end + 1);
        if (without_content_in_parentheses.indexOf("/") !== -1)
          return false;
        if (without_content_in_parentheses.indexOf("/") === without_content_in_parentheses.lastIndexOf("/"))
          return false;
      }
      return true;
    }
    exports2.contains_folder_reference = contains_folder_reference;
  }
});

// src/sc_chat_md.js
var require_sc_chat_md = __commonJS({
  "src/sc_chat_md.js"(exports2) {
    var { SmartChatMD } = require_smart_chat_md();
    var { extract_folder_references } = require_extract_folder_references();
    var { contains_internal_link } = require_contains_internal_link();
    var { contains_folder_reference } = require_contains_folder_reference();
    var ScChatMD = class extends SmartChatMD {
      /**
       * Parses a user message to handle special syntax like mentions and converts them into system messages.
       * @param {string} content - The user message content.
       * @returns {Promise<string>} The processed content with mentions handled.
       */
      async parse_user_message(content) {
        this.env.chats.current.scope = {};
        if (content.includes('@"')) {
          const mention_pattern = /@\"([^"]+)\"/;
          const mention = content.match(mention_pattern)[1];
          const sys_msg = {
            role: "system",
            content: "```sc-system\n" + mention + "\n```"
          };
          await this.add_message(sys_msg);
          const sys_msg_html = await this.env.chat_ui.get_system_message_html(sys_msg);
          await this.env.chat_ui.message_container.insertAdjacentHTML("beforeend", sys_msg_html);
          content = content.replace(mention_pattern, "").trim();
        }
        if (contains_internal_link(content)) {
          const notes = extract_internal_links(this.env, content);
          console.log(notes);
          if (notes.length) {
            const context = "```sc-context\n" + notes.map((n) => `${n.path}`).join("\n") + "\n```";
            const context_msg = { role: "system", content: context };
            await this.add_message(context_msg);
            const context_msg_html = await this.env.chat_ui.get_system_message_html(context_msg);
            await this.env.chat_ui.message_container.insertAdjacentHTML("beforeend", context_msg_html);
          }
        }
        if (contains_folder_reference(content)) {
          const folders = await this.env.plugin.get_folders();
          const folder_refs = extract_folder_references(folders, content);
          console.log(folder_refs);
          if (folder_refs)
            this.env.chats.current.scope.key_starts_with_any = folder_refs;
          console.log(this.env.chats.current.scope);
        }
        return content;
      }
      async add_tool_output(tool_name, tool_output) {
        await super.add_tool_output(tool_name, tool_output);
        await this.env.chat_ui.init();
        await this.env.chat_ui.render_dotdotdot();
      }
    };
    exports2.ScChatMD = ScChatMD;
    function extract_internal_links(env, user_input) {
      const matches = user_input.match(/\[\[(.*?)\]\]/g);
      console.log(matches);
      if (matches)
        return matches.map((match) => {
          const tfile = env.plugin.app.metadataCache.getFirstLinkpathDest(match.replace("[[", "").replace("]]", ""), "/");
          return tfile;
        });
      return [];
    }
    exports2.extract_internal_links = extract_internal_links;
  }
});

// src/sc_chats.js
var require_sc_chats = __commonJS({
  "src/sc_chats.js"(exports2) {
    var { SmartChats } = require_smart_chats();
    var { ScChatMD } = require_sc_chat_md();
    var { FuzzySuggestModal } = require("obsidian");
    var ScChats = class extends SmartChats {
      constructor(env, opts = {}) {
        super(env, opts);
        this.plugin = this.env.plugin;
        this.folder = this.env.config.smart_chat_folder || this.folder;
        this.formats.md = ScChatMD;
      }
      async new_user_message(message) {
        var _a;
        if (this.env.config.chat_model_platform_key === "open_router" && !((_a = this.env.config.open_router) == null ? void 0 : _a.api_key)) {
          this.env.config.free_chat_uses = this.env.config.free_chat_uses || 0;
          this.env.config.free_chat_uses++;
          if (this.env.config.free_chat_uses > 2) {
            this.env.plugin.notices.show("shared usage", "Your chats are currently using a community account with very limited usage. Please add your own API key in the Smart Chat settings to enable unlimited personal usage and prevent exhausting the shared account limit.", { immutable: true, timeout: 2e4 });
          }
          return;
        }
        return message;
      }
      // platform specific overrides
      open(key) {
        this.current = this.items[key];
        this.env.chat_ui.init();
      }
      async read(path) {
        return await this.plugin.app.vault.adapter.read(path);
      }
      normalize_path(path) {
        return this.plugin.obsidian.normalizePath(path);
      }
      async save(path, file_content) {
        await this.plugin.app.vault.adapter.write(this.normalize_path(path), file_content);
      }
      async delete(path) {
        await this.plugin.app.vault.adapter.remove(path);
      }
      async exists(path) {
        return await this.plugin.app.vault.adapter.exists(path);
      }
      async create_folder(path) {
        return await this.plugin.app.vault.adapter.mkdir(path);
      }
      async list(path) {
        return await this.plugin.app.vault.adapter.list(path);
      }
      // CUSTOM
      open_modal() {
        if (!this.modal)
          this.modal = new ScChatHistoryModal(this.plugin.app, this.env);
        this.modal.open();
      }
      // // backwords compatibility
      // async import_v1_chats() {
      //   const files = await this.list('.smart-connections/chats');
      //   console.log(files);
      //   for (let i = 0; i < files.files.length; i++) {
      //     const file = files.files[i];
      //     const chat_id = file.replace('.smart-connections/chats/', '').replace('.json', '');
      //     const messages = [];
      //     JSON.parse(await this.read(file))
      //       .map(msg => msg[0])
      //       .forEach(msg => {
      //         if (msg.role === "user") return messages.push({
      //           role: "user",
      //           content: msg.content,
      //         });
      //         if (msg.hyd) messages.push({
      //           role: "assistant",
      //           content: null,
      //           tool_calls: [{
      //             function: {
      //               name: "find_notes",
      //               args: JSON.stringify({ hypotheticals: [msg.hyd] })
      //             }
      //           }]
      //         });
      //         if (msg.context) {
      //           // const context_links = [];
      //           // msg.context.split('\n').forEach((line, i, arr) => {
      //           //   if(line.startsWith('---BEGIN') && arr[i+1]){
      //           //     const breadcrumbs = arr[i+1].replace(': ', '#').split(' > '); // remove last char (:) and split by ' > '
      //           //     const link_path = breadcrumbs.map(breadcrumb => breadcrumb.trim()).join('/');
      //           //     context_links.push(link_path);
      //           //   }
      //           // });
      //           // messages.push({
      //           //   role: "system",
      //           //   content: 'BEGIN NOTES AS CONTEXT:\n[['+context_links.join(']]\n[[')+']]'
      //           // });
      //           messages.push({
      //             role: "system",
      //             content: "```smart-connections\n" + msg.hyd + "\n```"
      //           });
      //           // // get last user message from messages and add again
      //           // const last_user_msg = messages[messages.findLastIndex(m => m.role === "user")];
      //           // messages.push(last_user_msg);
      //         }
      //         if (msg.role === "assistant") return messages.push({
      //           role: "assistant",
      //           content: msg.content,
      //         });
      //       });
      //     console.log(messages);
      //     const convo = this.conversation_format.create(this, chat_id, chat_ml_to_markdown({ messages }));
      //     await convo.save();
      //   }
      // }
    };
    exports2.ScChats = ScChats;
    var ScChatHistoryModal = class extends FuzzySuggestModal {
      constructor(app, env) {
        super(app);
        this.app = app;
        this.env = env;
        this.setPlaceholder("Type the name of a chat session...");
      }
      // getItems() { return (this.view.files) ? this.view.files : []; }
      getItems() {
        return Object.keys(this.env.chats.items);
      }
      // if not UNTITLED, remove date after last em dash
      getItemText(item) {
        return item.indexOf("UNTITLED") === -1 ? item.replace(/—[^—]*$/, "") : item;
      }
      // onChooseItem(session) { this.view.open_chat(session); }
      onChooseItem(conversation_id) {
        this.env.chats.open(conversation_id);
      }
    };
  }
});

// build/actions_openapi.json
var require_actions_openapi = __commonJS({
  "build/actions_openapi.json"(exports2, module2) {
    module2.exports = {
      openapi: "3.0.0",
      paths: {
        "/lookup": {
          post: {
            operationId: "lookup",
            summary: "Semantic search",
            description: "Performs a semantic search of the user's data. Required: hypothetical_1 and hypothetical_2. Optional: hypothetical_3.",
            requestBody: {
              content: {
                "application/json": {
                  schema: {
                    type: "object",
                    properties: {
                      hypothetical_1: {
                        type: "string",
                        description: "Short hypothetical notes predicted to be semantically similar to the notes necessary to fulfill the user's request. At least three hypotheticals per request. The hypothetical notes may contain paragraphs, lists, or checklists in markdown format. Hypothetical notes always begin with breadcrumbs containing the anticipated folder(s), file name, and relevant headings separated by ' > ' (no slashes). Example: PARENT FOLDER NAME > CHILD FOLDER NAME > FILE NAME > HEADING 1 > HEADING 2 > HEADING 3: HYPOTHETICAL NOTE CONTENTS."
                      },
                      hypothetical_2: {
                        type: "string",
                        description: "Must be distinct from and not share any breadcrumbs with hypothetical_1."
                      },
                      hypothetical_3: {
                        type: "string",
                        description: "Must be distinct from hypothetical_1 and hypothetical_2."
                      }
                    },
                    required: [
                      "hypothetical_1",
                      "hypothetical_2"
                    ]
                  }
                }
              }
            }
          }
        }
      },
      components: {},
      tags: []
    };
  }
});

// src/actions/lookup.js
var require_lookup = __commonJS({
  "src/actions/lookup.js"(exports2) {
    async function lookup(env, params = {}) {
      var _a, _b, _c, _d, _e;
      console.log("lookup", params);
      const { hypotheticals = [], hypothetical_1, hypothetical_2, hypothetical_3 } = params;
      if (hypothetical_1)
        hypotheticals.push(hypothetical_1);
      if (hypothetical_2)
        hypotheticals.push(hypothetical_2);
      if (hypothetical_3)
        hypotheticals.push(hypothetical_3);
      if (!hypotheticals)
        return { error: "hypotheticals is required" };
      const collection = ((_a = env.smart_blocks) == null ? void 0 : _a.smart_embed) ? env.smart_blocks : env.smart_notes;
      console.log(collection);
      if (!collection || !collection.smart_embed)
        return { error: "Embedding search is not enabled." };
      const embeddings = await collection.smart_embed.embed_batch(hypotheticals.map((h) => ({ embed_input: h })));
      console.log(embeddings);
      console.log({ scope: (_c = (_b = env.chats) == null ? void 0 : _b.current) == null ? void 0 : _c.scope });
      const filter = {
        ...((_e = (_d = env.chats) == null ? void 0 : _d.current) == null ? void 0 : _e.scope) || {},
        ...params.filter || {}
      };
      console.log({ filter });
      const results = embeddings.flatMap((embedding, i) => {
        return collection.nearest(embedding.vec, filter);
      });
      results.sort((a, b) => {
        if (a.sim === b.sim)
          return 0;
        return a.sim > b.sim ? -1 : 1;
      });
      const k = params.k || env.config.lookup_k || 10;
      let top_k = await Promise.all(
        results.slice(0, k).filter((r, i, a) => a.findIndex((t) => t.data.path === r.data.path) === i).map(async (r) => {
          return {
            score: r.sim,
            path: r.data.path
          };
        })
      );
      console.log(top_k);
      console.log(`Found and returned ${top_k.length} ${collection.collection_name}.`);
      return top_k;
    }
    exports2.lookup = lookup;
    function cos_sim(vector1, vector2) {
      const dotProduct = vector1.reduce((acc, val, i) => acc + val * vector2[i], 0);
      const normA = Math.sqrt(vector1.reduce((acc, val) => acc + val * val, 0));
      const normB = Math.sqrt(vector2.reduce((acc, val) => acc + val * val, 0));
      return normA === 0 || normB === 0 ? 0 : dotProduct / (normA * normB);
    }
    function top_acc(_acc, item, ct = 10) {
      if (_acc.items.size < ct) {
        _acc.items.add(item);
      } else if (item.sim > _acc.min) {
        _acc.items.add(item);
        _acc.items.delete(_acc.minItem);
        _acc.minItem = Array.from(_acc.items).reduce((min, curr) => curr.sim < min.sim ? curr : min);
        _acc.min = _acc.minItem.sim;
      }
    }
    exports2.top_acc = top_acc;
    function get_nearest_until_next_dev_exceeds_std_dev(nearest) {
      if (nearest.length === 0)
        return [];
      const sims = nearest.map((n) => n.sim);
      const mean = sims.reduce((a, b) => a + b) / sims.length;
      let std_dev = Math.sqrt(sims.map((x) => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / sims.length);
      let slice_i = 0;
      while (slice_i < nearest.length) {
        const next = nearest[slice_i + 1];
        if (next) {
          const next_dev = Math.abs(next.sim - nearest[slice_i].sim);
          if (next_dev > std_dev) {
            if (slice_i < 3)
              std_dev = std_dev * 1.5;
            else
              break;
          }
        }
        slice_i++;
      }
      nearest = nearest.slice(0, slice_i + 1);
      return nearest;
    }
    exports2.get_nearest_until_next_dev_exceeds_std_dev = get_nearest_until_next_dev_exceeds_std_dev;
    function sort_by_len_adjusted_similarity(nearest) {
      nearest = nearest.sort((a, b) => {
        const a_score = a.sim / a.tokens;
        const b_score = b.sim / b.tokens;
        if (a_score > b_score)
          return -1;
        if (a_score < b_score)
          return 1;
        return 0;
      });
      return nearest;
    }
    exports2.sort_by_len_adjusted_similarity = sort_by_len_adjusted_similarity;
    function get_top_k_by_sim(results, opts) {
      return Array.from(results.reduce((acc, item) => {
        var _a;
        if (!((_a = item.data.embedding) == null ? void 0 : _a.vec))
          return acc;
        item.sim = cos_sim(opts.vec, item.data.embedding.vec);
        top_acc(acc, item, opts.k);
        return acc;
      }, { min: 0, items: /* @__PURE__ */ new Set() }).items);
    }
    exports2.get_top_k_by_sim = get_top_k_by_sim;
  }
});

// src/actions/_actions.js
var require_actions = __commonJS({
  "src/actions/_actions.js"(exports2) {
    var { lookup } = require_lookup();
    exports2.lookup = lookup;
  }
});

// src/sc_actions.js
var require_sc_actions = __commonJS({
  "src/sc_actions.js"(exports2) {
    var ScTranslations = require_ScTranslations();
    var openapi_spec = require_actions_openapi();
    var handlers = require_actions();
    var { lookup } = require_lookup();
    var ScActions = class {
      constructor(env, opts = {}) {
        this.env = env;
        this.plugin = this.env.plugin;
        this.app = this.plugin.app;
        this.config = this.plugin.settings;
        this.actions = {};
      }
      init() {
        const actions = Object.entries(openapi_spec.paths).flatMap(
          ([path, methods]) => Object.entries(methods).map(([method, { operationId, requestBody, description }]) => {
            var _a, _b;
            return {
              type: "function",
              function: {
                name: operationId,
                description,
                parameters: {
                  type: "object",
                  properties: (_b = (_a = requestBody == null ? void 0 : requestBody.content["application/json"]) == null ? void 0 : _a.schema) == null ? void 0 : _b.properties
                }
              }
            };
          })
        );
        actions.forEach((action) => {
          this.actions[action.function.name] = {
            json: action,
            handler: handlers[action.function.name]
          };
        });
      }
      prepare_request_body(body) {
        var _a, _b;
        if ((_a = this.env.chats) == null ? void 0 : _a.current.tool_choice) {
          const tool_choice = this.env.chats.current.tool_choice;
          if (body.tool_choice !== "auto") {
            const tool_json = (_b = this.actions[tool_choice]) == null ? void 0 : _b.json;
            if (tool_json) {
              body.tool_choice = {
                type: "function",
                function: { name: tool_choice }
              };
              body.tools = [tool_json];
            }
          } else {
            body.tool_choice = "auto";
            body.tools = this.env.actions.actions.map((t) => t.json);
          }
        }
        console.log(body);
        return body;
      }
      // v2.1
      async new_user_message(user_input) {
        if (this.should_trigger_retrieval(user_input)) {
          console.log("should trigger retrieval");
          if (this.actions.lookup && this.env.chat_model.config.actions) {
            this.env.chats.current.tool_choice = "lookup";
          } else {
            await this.get_context_hyde(user_input);
          }
        }
      }
      should_trigger_retrieval(user_input) {
        if (this.contains_self_referential_keywords(user_input))
          return true;
        if (this.env.chats.current.scope.key_starts_with_any)
          return true;
        return false;
      }
      // check if includes keywords referring to one's own notes
      contains_self_referential_keywords(user_input) {
        if (user_input.match(new RegExp(`\\b(${ScTranslations[this.config.language].pronouns.join("|")})\\b`, "gi")))
          return true;
        return false;
      }
      // BACKWARD COMPATIBILITY for non-function-calling models
      async get_context_hyde(user_input) {
        console.log("get_context_hyde");
        const hyd_input = `Anticipate what the user is seeking. Respond in the form of a hypothetical note written by the user. The note may contain statements as paragraphs, lists, or checklists in markdown format with no headings. Please respond with one hypothetical note and abstain from any other commentary. Use the format: PARENT FOLDER NAME > CHILD FOLDER NAME > FILE NAME > HEADING 1 > HEADING 2 > HEADING 3: HYPOTHETICAL NOTE CONTENTS.`;
        const chatml = [
          { role: "system", content: hyd_input },
          { role: "user", content: user_input }
        ];
        const hyd = await this.env.chat_model.complete(
          {
            messages: chatml,
            stream: false,
            temperature: 0,
            max_tokens: 420
            // n: 3, // DO: multiple completions (unavailable in Anthropic Claude)
          },
          false
          // skip render
        );
        this.env.chats.current.add_message({
          role: "assistant",
          tool_calls: [{
            function: {
              name: "lookup",
              arguments: JSON.stringify({ hypotheticals: [hyd] })
            }
          }]
        });
        const results = await lookup(this.env, { hypotheticals: [hyd] });
        await this.env.chats.current.add_tool_output("lookup", results);
        return;
      }
      parse_tool_output(tool_name, tool_output) {
        if (tool_name === "lookup")
          return parse_lookup_tool_output(tool_output);
      }
    };
    exports2.ScActions = ScActions;
    function parse_lookup_tool_output(tool_output) {
      let content = "```sc-context\n";
      tool_output.forEach((note, i) => {
        content += `${note.path}
`;
      });
      content += "```";
      return { role: "system", content };
    }
  }
});

// src/sc_env.js
var require_sc_env = __commonJS({
  "src/sc_env.js"(exports2) {
    var { Brain } = require_Brain();
    var { SmartMarkdown } = require_smart_chunks();
    var {
      SmartNotes,
      SmartBlocks,
      SmartNote,
      SmartBlock
    } = require_sc_entities();
    var { DataviewSocket } = require_dataview_socket();
    var templates = require_views();
    var ejs = require_ejs_min();
    var { ScChatModel } = require_sc_chat_model();
    var { ScChatsUI } = require_sc_chats_ui();
    var { ScChats } = require_sc_chats();
    var { ScActions } = require_sc_actions();
    var ScEnv2 = class extends Brain {
      constructor(plugin, ltm_adapter) {
        super(ltm_adapter);
        this.plugin = plugin;
        this.main = this.plugin;
        this.config = this.plugin.settings;
        this.data_path = this.config.smart_connections_folder;
        this.collections = {
          smart_notes: SmartNotes,
          smart_blocks: SmartBlocks
        };
        this.item_types = {
          SmartNote,
          SmartBlock
        };
        this.save_timeout = null;
        this.smart_embed_active_models = {};
        this.local_model_type = "Web";
        this.dv_ws = null;
        this.chat = null;
        this.ejs = ejs;
        this.templates = templates;
      }
      async reload() {
        this.unload();
        this.config = this.plugin.settings;
        await this.init();
      }
      unload() {
        this.unload_entities();
        this.smart_embed_active_models = {};
        if (this.dv_ws)
          this.dv_ws.unload();
      }
      unload_entities() {
        this.entities_loaded = false;
        if (this.smart_notes)
          this.smart_notes.unload();
        this.smart_notes = null;
        if (this.smart_blocks)
          this.smart_blocks.unload();
        this.smart_blocks = null;
      }
      async reload_entities() {
        this.unload_entities();
        if (this.plugin.is_initializing_entities)
          this.plugin.is_initializing_entities = false;
        await this.init_entities();
      }
      async init() {
        this.init_chat_model();
        DataviewSocket.create(this, 37042);
        this.smart_markdown = new SmartMarkdown({ ...this.config, skip_blocks_with_headings_only: true });
        await this.init_entities();
        await this.init_import();
        await this.init_chat();
      }
      // load one at a time to re-use embed models
      async init_entities() {
        if (this.plugin.is_initializing_entities)
          return console.log("already init entities");
        this.plugin.is_initializing_entities = true;
        if (this.config.embedding_file_per_note) {
          this.smart_notes = new SmartNotes(this);
          this.smart_blocks = new SmartBlocks(this);
          this.smart_notes.merge_defaults();
          this.smart_blocks.merge_defaults();
          await this.smart_blocks.load_smart_embed();
          await this.smart_notes.load();
        } else {
          await Promise.all(Object.values(this.collections).map(async (static_collection) => await static_collection.load(this)));
        }
        this.plugin.is_initializing_entities = false;
        this.entities_loaded = true;
      }
      // initiate import of smart notes, shows notice before starting embedding
      async init_import() {
        if (this.smart_notes.smart_embed || this.smart_blocks.smart_embed)
          this.smart_notes.import(this.files, { reset: true, show_notice: true });
      }
      init_chat_model() {
        var _a, _b;
        let chat_model_config = {};
        if (this.config.chat_model_platform_key === "open_router" && !((_a = this.config[this.config.chat_model_platform_key]) == null ? void 0 : _a.api_key))
          chat_model_config.api_key = "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";
        else
          chat_model_config = (_b = this.config[this.config.chat_model_platform_key]) != null ? _b : {};
        this.chat_model = new ScChatModel(this, this.config.chat_model_platform_key, { ...chat_model_config });
        this.chat_model._request_adapter = this.plugin.obsidian.requestUrl;
      }
      async init_chat() {
        var _a;
        this.actions = new ScActions(this);
        this.actions.init();
        while (!((_a = this.plugin.chat_view) == null ? void 0 : _a.containerEl))
          await new Promise((r) => setTimeout(r, 300));
        this.chat_ui = new ScChatsUI(this, this.plugin.chat_view.containerEl);
        this.chats = new ScChats(this);
        await this.chats.load_all();
      }
      get_tfile(file_path) {
        return this.plugin.app.vault.getAbstractFileByPath(file_path);
      }
      async cached_read(file) {
        const t_file = typeof file === "string" ? this.get_tfile(file) : file;
        if (!(t_file instanceof this.plugin.obsidian.TFile))
          return null;
        return await this.plugin.app.vault.cachedRead(t_file);
      }
      async force_refresh() {
        this.smart_blocks.clear();
        this.smart_notes.clear();
        this.smart_notes.import(this.files);
      }
      // prevent saving too often (large files can cause lag)
      save() {
        if (this.save_timeout)
          clearTimeout(this.save_timeout);
        this.save_timeout = setTimeout(async () => {
          if (this.plugin.last_user_activity && Date.now() - this.plugin.last_user_activity < 6e4)
            return this.save();
          await this._save();
          this.save_timeout = null;
        }, 2e4);
      }
      async _save() {
        await Promise.all(Object.keys(this.collections).map(async (collection_name) => await this[collection_name]._save()));
      }
      // getters
      get all_files() {
        return this.plugin.app.vault.getFiles().filter((file) => file instanceof this.plugin.obsidian.TFile && (file.extension === "md" || file.extension === "canvas"));
      }
      // no exclusions
      get files() {
        return this.plugin.app.vault.getFiles().filter((file) => file instanceof this.plugin.obsidian.TFile && (file.extension === "md" || file.extension === "canvas") && this.is_included(file.path));
      }
      is_included(file_path) {
        return !this.file_exclusions.some((exclusion) => file_path.includes(exclusion));
      }
      get file_exclusions() {
        var _a;
        if (this._file_exclusions)
          return this._file_exclusions;
        this._file_exclusions = ((_a = this.plugin.settings.file_exclusions) == null ? void 0 : _a.length) ? this.plugin.settings.file_exclusions.split(",").map((file) => file.trim()) : [];
        return this._file_exclusions = this._file_exclusions.concat(this.folder_exclusions);
      }
      get folder_exclusions() {
        var _a;
        if (this._folder_exclusions)
          return this._folder_exclusions;
        return this._folder_exclusions = ((_a = this.plugin.settings.folder_exclusions) == null ? void 0 : _a.length) ? this.plugin.settings.folder_exclusions.split(",").map((folder) => {
          folder = folder.trim();
          if (folder.slice(-1) !== "/")
            return folder + "/";
          return folder;
        }) : [];
      }
      get excluded_headings() {
        var _a;
        if (this._excluded_headings)
          return this._excluded_headings;
        return this._excluded_headings = ((_a = this.plugin.settings.excluded_headings) == null ? void 0 : _a.length) ? this.plugin.settings.excluded_headings.split(",").map((heading) => heading.trim()) : [];
      }
      get system_prompts() {
        return this.plugin.app.vault.getMarkdownFiles().filter((file) => file.path.includes(this.config.system_prompts_folder) || file.path.includes(".prompt") || file.path.includes(".sp"));
      }
    };
    exports2.ScEnv = ScEnv2;
  }
});

// src/default_settings.js
var require_default_settings = __commonJS({
  "src/default_settings.js"(exports2) {
    function default_settings2() {
      return {
        settings: {
          new_user: true,
          chat_folder: "smart chat",
          smart_notes_embed_model: "TaylorAI/bge-micro-v2",
          smart_blocks_embed_model: "None",
          smart_connections_folder: ".smart-connections",
          smart_connections_folder_last: ".smart-connections",
          system_prompts_folder: "smart prompts",
          smart_chat_folder: "smart-chats",
          smart_chat_folder_last: "smart-chats",
          local_embedding_max_tokens: 2048,
          embedding_file_per_note: false,
          chat_model_platform_key: "open_router",
          open_router: {},
          // Smart Blocks Settings (chunking)
          embed_input_min_chars: 50,
          multi_heading_blocks: true,
          // V1
          api_key: "",
          excluded_headings: "",
          file_exclusions: "Untitled",
          folder_exclusions: "smart-chats",
          show_full_path: false,
          expanded_view: true,
          language: "en",
          log_render: false,
          log_render_files: false,
          recently_sent_retry_notice: false,
          version: ""
          // smart_chat_model: "gpt-3.5-turbo-0125",
          // skip_sections: false, // DEPRECATED
          // group_nearest_by_file: false, // DEPRECATED
          // path_only: "", // DEPRECATED
          // header_exclusions: "", // DEPRECATED use excluded_headings instead
        },
        api: null,
        embeddings_loaded: false,
        folders: [],
        has_new_embeddings: false,
        nearest_cache: {},
        render_log: {
          deleted_embeddings: 0,
          exclusions_logs: {},
          failed_embeddings: [],
          files: [],
          new_embeddings: 0,
          skipped_low_delta: {},
          token_usage: 0,
          tokens_saved_by_cache: 0
        },
        retry_notice_timeout: null,
        save_timeout: null,
        sc_branding: {},
        update_available: false
      };
    }
    exports2.default_settings = default_settings2;
  }
});

// src/smart_embed_settings.js
var require_smart_embed_settings = __commonJS({
  "src/smart_embed_settings.js"(exports2) {
    var { SmartSettings } = require_smart_settings();
    var smart_embed_models = require_models();
    var SmartEmbedSettings = class extends SmartSettings {
      refresh_smart_view() {
        this.plugin.smart_connections_view.render_nearest();
      }
      async connect_to_smart_connect() {
        var _a, _b;
        if ((_b = (_a = this.plugin.env.smart_notes) == null ? void 0 : _a.smart_embed) == null ? void 0 : _b.is_smart_connect) {
          this.plugin.notices.show("smart connect already connected", "Already connected to local Smart Connect for embedding.");
          return;
        }
        try {
          await this.plugin.obsidian.requestUrl({ url: "http://localhost:37421/", method: "GET" });
          this.plugin.notices.show("smart connect found", "Local Smart Connect server found. Connecting...");
          this.plugin.restart_plugin();
        } catch (err) {
          this.plugin.notices.show("smart connect not found", "Could not connect to local Smart Connect server");
        }
      }
      async test_api_key_openai_embeddings() {
        var _a, _b, _c, _d;
        const req = {
          url: `https://api.openai.com/v1/embeddings`,
          method: "POST",
          body: JSON.stringify({ model: "text-embedding-ada-002", input: "test" }),
          headers: { "Content-Type": "application/json", "Authorization": `Bearer ${this.plugin.settings.api_key}` }
        };
        try {
          const resp = await this.plugin.obsidian.requestUrl(req);
          if ((_d = (_c = (_b = (_a = resp == null ? void 0 : resp.json) == null ? void 0 : _a.data) == null ? void 0 : _b[0]) == null ? void 0 : _c.embedding) == null ? void 0 : _d.length) {
            await this.changed_smart_chat_model();
            return this.plugin.notices.show("api key test pass", "Success! OpenAI API key is valid");
          }
          this.plugin.notices.show("api key test fail", "Error: OpenAI API key is invalid!");
        } catch (err) {
          this.plugin.notices.show("api key test fail", "Error: OpenAI API key is invalid!");
          console.error("Smart Connections: Error testing OpenAI API key", err);
        }
      }
      reload_env() {
        this.env.reload();
      }
      // DEPRECATED
      restart_plugin() {
        this.plugin.restart_plugin();
      }
      get template() {
        return this.templates["smart_embed_settings"];
      }
      async get_view_data() {
        const view_data = {
          settings: this.plugin.settings,
          embedding_models: Object.keys(smart_embed_models).map((model_key) => ({ key: model_key, ...smart_embed_models[model_key] }))
        };
        view_data.smart_embed_settings = this.ejs.render(this.template, view_data);
        return view_data;
      }
    };
    exports2.SmartEmbedSettings = SmartEmbedSettings;
  }
});

// src/sc_smart_view.js
var require_sc_smart_view = __commonJS({
  "src/sc_smart_view.js"(exports2) {
    var { SmartObsidianView } = require_smart_obsidian_view();
    var { SmartEmbedSettings } = require_smart_embed_settings();
    var SUPPORTED_FILE_TYPES = ["md", "canvas"];
    var ScSmartView2 = class extends SmartObsidianView {
      static get view_type() {
        return "smart-connections-view";
      }
      // Obsidian
      getViewType() {
        return this.constructor.view_type;
      }
      getDisplayText() {
        return "Smart Connections Files";
      }
      getIcon() {
        return "smart-connections";
      }
      async onOpen() {
        this.app.workspace.onLayoutReady(this.initialize.bind(this));
      }
      async initialize() {
        var _a;
        this.env = this.plugin.brain;
        this.brain = this.env;
        this.last_parent_id = (_a = this.constructor.get_leaf(this.app.workspace)) == null ? void 0 : _a.parent.id;
        this.container = this.containerEl.children[1];
        this.container.empty();
        this.nearest_cache = {};
        this.plugin.smart_connections_view = this;
        this.register_plugin_events();
        this.app.workspace.registerHoverLinkSource(this.constructor.view_type, { display: "Smart Connections Files", defaultMod: true });
        this.container.innerHTML = this.render_template("smart_connections", { current_path: "", results: [] });
        this.add_top_bar_listeners();
      }
      async onClose() {
        console.log("closing smart connections view");
        this.app.workspace.unregisterHoverLinkSource(this.constructor.view_type);
      }
      onResize() {
        if (this.constructor.get_leaf(this.app.workspace).parent.id !== this.last_parent_id) {
          console.log("Parent changed, reloading");
          this.initialize();
        }
      }
      // getters
      // DEPRECATED
      // get path_only() { return (this.settings.path_only?.length) ? this.settings.path_only.split(",").map((path) => path.trim()) : []; }
      // Smart Connections
      register_plugin_events() {
        this.plugin.registerEvent(this.app.workspace.on("file-open", (file) => {
          this.update_last_user_activity_timestamp();
          if (!file)
            return;
          if (this.container.checkVisibility() === false)
            return console.log("View inactive, skipping render nearest");
          this.render_nearest(file);
        }));
        this.plugin.registerEvent(this.app.workspace.on("active-leaf-change", (leaf) => {
          var _a;
          this.update_last_user_activity_timestamp();
          if (leaf.view instanceof this.constructor) {
            if (leaf.view.container.querySelectorAll(".search-result").length && leaf.view.last_note === ((_a = this.app.workspace.getActiveFile()) == null ? void 0 : _a.path))
              return;
            return this.render_nearest();
          }
        }));
        this.plugin.registerEvent(this.app.workspace.on("editor-change", (editor) => {
          this.update_last_user_activity_timestamp();
        }));
        this.plugin.registerEvent(this.app.workspace.on("quit", async () => {
          if (this.env.save_timeout) {
            clearTimeout(this.env.save_timeout);
            await this.env._save();
            console.log("Smart Connections saved");
          }
        }));
      }
      // used in brain.save timeout to reset if recent activity (prevent saving blocking UX during user activity)
      update_last_user_activity_timestamp() {
        this.last_user_activity = Date.now();
      }
      // Smart Connections Views
      get view_context() {
        var _a, _b;
        return {
          ...super.view_context,
          blocks: (_a = this.env.smart_blocks) == null ? void 0 : _a.keys.length,
          notes: (_b = this.env.smart_notes) == null ? void 0 : _b.keys.length
        };
      }
      async render_nearest(context, container = this.container) {
        var _a;
        if (!this.env.entities_loaded) {
          container.innerHTML = "Loading Smart Connections...";
          while (!this.env.entities_loaded)
            await new Promise((r) => setTimeout(r, 2e3));
        }
        let results;
        if (typeof context === "string")
          results = await this.plugin.api.search(context);
        if (typeof context === "undefined")
          context = this.app.workspace.getActiveFile();
        if (context instanceof this.plugin.obsidian.TFile) {
          if (SUPPORTED_FILE_TYPES.indexOf(context.extension) === -1)
            return this.plugin.notices.show("unsupported file type", [
              "File: " + context.name,
              "Unsupported file type (Supported: " + SUPPORTED_FILE_TYPES.join(", ") + ")"
            ]);
          if (!this.env.smart_notes.get(context.path)) {
            if (this.env.is_included(context.path)) {
              await this.env.smart_notes.import(this.env.files);
            } else {
              return this.plugin.notices.show("excluded file", "File is excluded: " + context.path, { timeout: 3e3 });
            }
          }
          results = (_a = this.env.smart_notes.get(context.path)) == null ? void 0 : _a.find_connections();
        }
        if (context instanceof this.env.item_types.SmartBlock)
          results = context.find_connections();
        if (context instanceof this.env.item_types.SmartNote)
          results = context.find_connections();
        if (!results)
          return this.plugin.notices.show("no smart connections found", "No Smart Connections found.");
        if (typeof context === "object")
          context = context.key || context.path;
        this.last_note = this.app.workspace.getActiveFile().path;
        container.innerHTML = this.render_template("smart_connections", { current_path: context, results });
        this.add_top_bar_listeners(container);
        container.querySelectorAll(".search-result").forEach((elm, i) => this.add_link_listeners(elm, results[i]));
        container.querySelectorAll(".search-result:not(.sc-collapsed) ul li").forEach(this.render_result.bind(this));
      }
      async render_result(elm, i = 0) {
        var _a;
        if (elm.innerHTML)
          return console.log("already rendered");
        await new Promise((r) => setTimeout(r, 20 * i));
        if (!isElementVisible(elm)) {
          const parent = elm.closest(".search-result");
          if (parent.classList.contains("sc-collapsed"))
            return;
          if (!isElementVisible(parent)) {
            const observer = new IntersectionObserver((entries, observer2) => {
              if (entries[0].isIntersecting) {
                this.render_result(elm);
                observer2.unobserve(parent);
              }
            }, { threshold: 0.5 });
            observer.observe(parent);
            return;
          }
        }
        console.log("rendering result");
        const entity_key = elm.title;
        const collection_name = elm.dataset.collection;
        const entity = this.brain[collection_name].get(entity_key);
        if (should_render_embed())
          return this.plugin.obsidian.MarkdownRenderer.render(this.app, entity.embed_link, elm, entity_key, new this.plugin.obsidian.Component());
        const content = (_a = await (entity == null ? void 0 : entity.get_content())) == null ? void 0 : _a.replace(/```dataview/g, "```\\dataview");
        if (!entity || !content) {
          elm.createEl("p", { text: "Block not found: " + entity_key });
          const refresh_button = elm.createEl("button", { text: "Refresh embeddings" });
          refresh_button.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();
            this.env.smart_notes.import(this.env.files, { reset: true });
          });
        }
        this.plugin.obsidian.MarkdownRenderer.render(this.app, content, elm, entity_key, new this.plugin.obsidian.Component());
        function isElementVisible(elem) {
          const rect = elem.getBoundingClientRect();
          return rect.top >= 0 && rect.left >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && rect.right <= (window.innerWidth || document.documentElement.clientWidth);
        }
        function should_render_embed() {
          var _a2, _b;
          if (!entity)
            return false;
          if (entity.is_canvas)
            return true;
          if (entity.is_excalidraw)
            return true;
          if ((_a2 = entity.note) == null ? void 0 : _a2.is_canvas)
            return true;
          if ((_b = entity.note) == null ? void 0 : _b.is_excalidraw)
            return true;
          return false;
        }
      }
      add_link_listeners(elm, item) {
        elm.addEventListener("click", this.handle_search_result_click.bind(this));
        elm.setAttr("draggable", "true");
        elm.addEventListener("dragstart", (event) => {
          const dragManager = this.app.dragManager;
          const file_path = item.path.split("#")[0];
          const file = this.app.metadataCache.getFirstLinkpathDest(file_path, "");
          const dragData = dragManager.dragFile(event, file);
          dragManager.onDragStart(event, dragData);
        });
        if (item.path.indexOf("{") > -1)
          return;
        elm.addEventListener("mouseover", (event) => {
          this.app.workspace.trigger("hover-link", {
            event,
            source: this.constructor.view_type,
            hoverParent: elm.parentElement,
            targetEl: elm,
            linktext: item.path
          });
        });
      }
      handle_search_result_click(event) {
        event.preventDefault();
        event.stopPropagation();
        const search_result = event.target.classList.contains(".search-result") ? event.target : event.target.closest(".search-result");
        if (event.target instanceof SVGElement)
          return this.toggle_search_result_visibility(search_result);
        if (search_result.classList.contains("sc-collapsed")) {
          if (this.plugin.obsidian.Keymap.isModEvent(event))
            this.plugin.open_note(search_result.dataset.path, event);
          else
            this.toggle_search_result_visibility(search_result);
        } else
          this.plugin.open_note(search_result.dataset.path, event);
      }
      toggle_search_result_visibility(search_result_elm) {
        search_result_elm.classList.toggle("sc-collapsed");
        this.render_result(search_result_elm.querySelector("li"));
      }
      add_top_bar_listeners(container = this.container) {
        const top_bar = container.querySelector(".sc-top-bar");
        const search_button = container.querySelector(".sc-search-button");
        search_button.addEventListener("click", () => {
          const og_top_bar = top_bar.innerHTML;
          top_bar.empty();
          const search_container = top_bar.createEl("div", { cls: "search-input-container" });
          const input = search_container.createEl("input", {
            cls: "sc-search-input",
            type: "search",
            placeholder: "Type to start search..."
          });
          input.focus();
          input.addEventListener("keydown", (event) => {
            if (event.key === "Escape") {
              if (this.search_timeout)
                clearTimeout(this.search_timeout);
              top_bar.innerHTML = og_top_bar;
              this.add_top_bar_listeners(container);
            }
          });
          input.addEventListener("keyup", (event) => {
            if (this.search_timeout)
              clearTimeout(this.search_timeout);
            const search_term = input.value;
            if (event.key === "Enter" && search_term !== "")
              this.render_nearest(search_term);
            else if (search_term !== "") {
              if (this.search_timeout)
                clearTimeout(this.search_timeout);
              this.search_timeout = setTimeout(() => this.render_nearest(search_term), 700);
            }
          });
        });
        const fold_all_button = container.querySelector(".sc-fold-all");
        fold_all_button.addEventListener("click", (e) => {
          container.querySelectorAll(".search-result").forEach((elm) => elm.classList.add("sc-collapsed"));
          this.plugin.settings.expanded_view = false;
          this.plugin.save_settings();
        });
        const unfold_all_button = container.querySelector(".sc-unfold-all");
        unfold_all_button.addEventListener("click", () => {
          container.querySelectorAll(".search-result").forEach((elm) => {
            elm.classList.remove("sc-collapsed");
            this.render_result(elm.querySelector("li"));
          });
          this.plugin.settings.expanded_view = true;
          this.plugin.save_settings();
        });
        const settings_btn = this.container.querySelector("button[title='Settings']");
        settings_btn.addEventListener("click", async () => {
          const settings_container = this.container.querySelector("#settings");
          if (settings_container.innerHTML)
            return settings_container.innerHTML = "";
          if (!this.embed_settings)
            this.embed_settings = new SmartEmbedSettings(this.env, settings_container);
          else
            this.embed_settings.container = settings_container;
          this.embed_settings.render();
          settings_container.style.transition = "background-color 0.5s ease-in-out";
          settings_container.style.backgroundColor = "var(--bold-color)";
          setTimeout(() => {
            settings_container.style.backgroundColor = "";
          }, 500);
        });
      }
    };
    exports2.ScSmartView = ScSmartView2;
  }
});

// src/smart_search.js
var require_smart_search = __commonJS({
  "src/smart_search.js"(exports2) {
    var SmartSearch2 = class {
      constructor(plugin) {
        this.main = plugin;
        this.plugin = plugin;
      }
      async search(search_text, filter = {}) {
        var _a, _b, _c, _d, _e, _f;
        try {
          if (!((_b = (_a = this.plugin.env) == null ? void 0 : _a.smart_blocks) == null ? void 0 : _b.smart_embed) && !((_d = (_c = this.plugin.env) == null ? void 0 : _c.smart_notes) == null ? void 0 : _d.smart_embed)) {
            this.plugin.notices.show("embed model not loaded", "Embed model not loaded. Please wait for the model to load and try again.");
            return [];
          }
          const collection = ((_f = (_e = this.plugin.env) == null ? void 0 : _e.smart_blocks) == null ? void 0 : _f.smart_embed) ? this.plugin.env.smart_blocks : this.plugin.env.smart_notes;
          const embedding = await collection.smart_embed.embed(search_text);
          if (!(embedding == null ? void 0 : embedding.vec)) {
            this.main.notices.show("embed search text failed", "Failed to embed search text.");
            return [];
          }
          return collection.nearest(embedding.vec, filter).sort((a, b) => {
            if (a.sim > b.sim)
              return -1;
            if (a.sim < b.sim)
              return 1;
            return 0;
          });
        } catch (e) {
          this.main.notices.show("error in embedding search", "Error in embedding search. See console for details.", { timeout: 0 });
          console.error(e);
          return [];
        }
      }
    };
    exports2.SmartSearch = SmartSearch2;
  }
});

// src/smart_notices.js
var require_smart_notices = __commonJS({
  "src/smart_notices.js"(exports2) {
    var { setIcon } = require("obsidian");
    var SmartNotices2 = class {
      constructor(main) {
        this.main = main;
        this.active = {};
      }
      show(id, message, opts = {}) {
        var _a, _b;
        if (typeof opts.timeout === "undefined")
          opts.timeout = 5e3;
        if ((_a = this.main.settings.muted_notices) == null ? void 0 : _a[id]) {
          if (opts.confirm && typeof opts.confirm.callback === "function")
            opts.confirm.callback.call();
          return;
        }
        const content = this.build(id, message, opts);
        if (this.active[id] && ((_b = this.active[id].noticeEl) == null ? void 0 : _b.parentElement)) {
          return this.active[id].setMessage(content, opts.timeout);
        }
        return this.render(id, content, opts);
      }
      render(id, content, opts) {
        this.active[id] = new this.main.obsidian.Notice(content, opts.timeout);
        return this.active[id];
      }
      build(id, message, opts = {}) {
        const frag = document.createDocumentFragment();
        const head = frag.createEl("p", { cls: "sc-notice-head", text: "[Smart Connections]" });
        const content = frag.createEl("p", { cls: "sc-notice-content" });
        const actions = frag.createEl("div", { cls: "sc-notice-actions" });
        if (typeof message === "string")
          content.innerText = message;
        else if (Array.isArray(message))
          content.innerHTML = message.join("<br>");
        if (!opts.immutable)
          this.add_mute_btn(id, actions);
        if (opts.confirm)
          this.add_btn(opts.confirm, actions);
        if (opts.button)
          this.add_btn(opts.button, actions);
        return frag;
      }
      add_btn(button, container) {
        const btn = document.createElement("button");
        btn.innerHTML = button.text;
        btn.addEventListener("click", (e) => {
          if (button.stay_open) {
            e.preventDefault();
            e.stopPropagation();
          }
          button.callback();
        });
        container.appendChild(btn);
      }
      add_mute_btn(id, container) {
        const btn = document.createElement("button");
        setIcon(btn, "bell-off");
        btn.addEventListener("click", () => {
          if (!this.main.settings.muted_notices)
            this.main.settings.muted_notices = {};
          this.main.settings.muted_notices[id] = true;
          this.main.save_settings();
          this.show("Notice muted", "Notice muted", { timeout: 2e3 });
        });
        container.appendChild(btn);
      }
      unload() {
        for (let id in this.active) {
          this.remove(id);
        }
      }
      remove(id) {
        var _a;
        (_a = this.active[id]) == null ? void 0 : _a.hide();
        delete this.active[id];
      }
      // begin plugin specific methods
      show_requires_smart_view() {
        const btn = { text: "Open Smart View", callback: () => {
          this.main.open_view(false);
        } };
        const msg = 'Smart View must be open to utilize all Smart Chat features. For example, asking things like "Based on my notes..." requires Smart View to be open.';
        this.show("requires smart view", msg, { button: btn, timeout: 0 });
      }
    };
    exports2.SmartNotices = SmartNotices2;
  }
});

// src/sc_settings.js
var require_sc_settings = __commonJS({
  "src/sc_settings.js"(exports2) {
    var { SmartSettings } = require_smart_settings();
    var smart_embed_models = require_models();
    var { PluginSettingTab } = require("obsidian");
    var { SmartChatSettings } = require_smart_chat_settings();
    var { SmartEmbedSettings } = require_smart_embed_settings();
    var ScSettingsTab2 = class extends PluginSettingTab {
      constructor(app, plugin) {
        super(app, plugin);
        this.plugin = plugin;
        this.config = plugin.settings;
      }
      display() {
        this.smart_settings = new ScSettings(this.plugin.env, this.containerEl);
        return this.smart_settings.render();
      }
    };
    exports2.ScSettingsTab = ScSettingsTab2;
    var ScSettings = class extends SmartSettings {
      constructor(env, container, template_name = "smart_settings") {
        super(env, container, template_name);
        this.chat_settings = new SmartChatSettings(env, container, template_name);
        this.embed_settings = new SmartEmbedSettings(env, container, template_name);
      }
      update_smart_chat_folder() {
        this.chat_settings.update_smart_chat_folder();
      }
      async changed_smart_chat_model() {
        await this.chat_settings.changed_smart_chat_model(false);
        this.render();
      }
      async test_chat_api_key() {
        await this.chat_settings.test_chat_api_key();
      }
      get self_ref_list() {
        return this.chat_settings.self_ref_list;
      }
      async refresh_notes() {
        this.env.smart_notes.import(this.env.files, { reset: true });
      }
      reload_env() {
        this.env.reload();
      }
      // DEPRECATED
      restart_plugin() {
        this.plugin.restart_plugin();
      }
      force_refresh() {
        this.env.force_refresh();
      }
      sync_for_chatgpt() {
        this.plugin.sync_notes();
      }
      update_smart_connections_folder() {
        this.plugin.update_smart_connections_folder();
      }
      refresh_smart_view() {
        this.embed_settings.refresh_smart_view();
      }
      async connect_to_smart_connect() {
        await this.embed_settings.connect_to_smart_connect();
      }
      // test API key
      async test_api_key_openai_embeddings() {
        await this.embed_settings.test_api_key_openai_embeddings();
      }
      async exclude_all_top_level_folders() {
        const folders = (await this.app.vault.adapter.list("/")).folders;
        const input = this.container.querySelector("div[data-setting='folder_exclusions'] input");
        input.value = folders.join(", ");
        input.dispatchEvent(new Event("input"));
        this.update_exclusions();
      }
      async update_language(setting, value, elm) {
        await this.update("language", value);
        const self_ref_pronouns_list = this.container.querySelector("#self-referential-pronouns");
        self_ref_pronouns_list.setText(this.self_ref_list);
      }
      async update_exclusions() {
        this.plugin.env._file_exclusions = null;
        this.plugin.env._folder_exclusions = null;
        console.log("render_file_counts");
        const elm = this.container.querySelector("#file-counts");
        console.log("elm", elm);
        const total_files = this.plugin.env.all_files.length;
        const included_files = this.plugin.env.files.length;
        elm.setText(`Included files: ${included_files} / Total files: ${total_files}`);
      }
      get template() {
        return this.templates["smart_settings"];
      }
      async get_view_data() {
        const view_data = {
          settings: this.plugin.settings,
          embedding_models: Object.keys(smart_embed_models).map((model_key) => ({ key: model_key, ...smart_embed_models[model_key] })),
          included_files: this.plugin.env.files.length,
          total_files: this.plugin.env.all_files.length,
          muted_notices: this.plugin.settings.muted_notices || false,
          ...await this.chat_settings.get_view_data() || {},
          ...await this.embed_settings.get_view_data() || {}
        };
        return view_data;
      }
      unmute_notice(setting) {
        const id = setting.split(".")[1];
        console.log("unmute_notice", id);
        delete this.plugin.settings.muted_notices[id];
        this.update("muted_notices", this.plugin.settings.muted_notices);
        this.render();
      }
      // DO: REMOVE FROM STABLE RELEASE
      revert_to_v20() {
        this.plugin.revert_to_v20();
      }
    };
    exports2.ScSettings = ScSettings;
  }
});

// src/sc_actions_ux.js
var require_sc_actions_ux = __commonJS({
  "src/sc_actions_ux.js"(exports2) {
    var ejs = require_ejs_min();
    var views = require_views();
    var ScActionsUx2 = class {
      constructor(plugin, container) {
        this.plugin = plugin;
        this.container = container;
      }
      change_code_block(code) {
        const active_file = this.plugin.app.workspace.getActiveFile();
        const note_path = active_file.path;
        const old_content = code.substring(code.indexOf("<<<<<<< ORIGINAL\n") + "<<<<<<< ORIGINAL\n".length, code.indexOf("======="));
        const new_content = code.substring(code.indexOf("=======\n") + "=======\n".length, code.indexOf(">>>>>>>"));
        const time_saved = (Math.round(new_content.split(" ").length / 50) || 1) + " min";
        this.container.innerHTML = this.render_template("sc_change", { new_content, old_content, time_saved });
        console.log(this.container);
        const new_content_container = this.container.querySelector(".new-content");
        const old_content_container = this.container.querySelector(".old-content");
        this.plugin.obsidian.MarkdownRenderer.renderMarkdown(new_content, new_content_container, note_path, new this.plugin.obsidian.Component());
        this.plugin.obsidian.MarkdownRenderer.renderMarkdown(old_content, old_content_container, note_path, new this.plugin.obsidian.Component());
        const show_old_button = this.get_button_by_text("Show Old");
        const hide_old_button = this.get_button_by_text("Hide Old");
        show_old_button.onclick = () => {
          old_content_container.style.display = "block";
          show_old_button.style.display = "none";
          hide_old_button.style.display = "inline-block";
        };
        hide_old_button.onclick = () => {
          old_content_container.style.display = "none";
          show_old_button.style.display = "inline-block";
          hide_old_button.style.display = "none";
        };
        const approve_button = this.get_button_by_text("Accept");
        approve_button.onclick = async () => {
          const content = await this.plugin.app.vault.cachedRead(active_file);
          const updated_content = content.replace("```sc-change\n" + code + "\n```", new_content.trim());
          await this.plugin.app.vault.modify(active_file, updated_content);
          await this.append_accepted_changes({ note_path, old_content, new_content, time_saved });
        };
        const reject_button = this.get_button_by_text("Reject");
        reject_button.onclick = async () => {
          const content = await this.plugin.app.vault.cachedRead(active_file);
          const updated_content = content.replace("```sc-change\n" + code + "\n```", old_content.trim());
          await this.plugin.app.vault.modify(active_file, updated_content);
        };
      }
      async append_accepted_changes(change) {
        const file_path = this.plugin.settings.smart_connections_folder + "/accepted_changes.ndjson";
        if (!await this.plugin.app.vault.exists(file_path)) {
          console.log("File does not exist, creating it");
          await this.plugin.app.vault.create(file_path, "");
        }
        await this.plugin.app.vault.adapter.append(file_path, JSON.stringify(change) + "\n");
      }
      render_template(template_name, data) {
        if (!views[template_name])
          throw new Error(`Template '${template_name}' not found.`);
        return ejs.render(views[template_name], data, { context: this });
      }
      get_button_by_text(text) {
        return get_button_by_text(this.container, text);
      }
      get_icon(name) {
        return this.plugin.obsidian.getIcon(name).outerHTML;
      }
      get attribution() {
        return views.attribution;
      }
    };
    function get_button_by_text(container, text) {
      return Array.from(container.querySelectorAll("button")).find((button) => button.textContent === text);
    }
    exports2.ScActionsUx = ScActionsUx2;
  }
});

// src/open_note.js
var require_open_note = __commonJS({
  "src/open_note.js"(exports2) {
    async function open_note2(plugin, target_path, event = null) {
      let targetFile;
      let heading;
      if (target_path[target_path.length - 1] === "#")
        target_path = target_path.slice(0, -1);
      if (target_path.indexOf("#") > -1) {
        targetFile = plugin.app.metadataCache.getFirstLinkpathDest(target_path.split("#")[0], "");
        const target_file_cache = plugin.app.metadataCache.getFileCache(targetFile);
        let heading_text = target_path.split("#").pop();
        let occurence = 0;
        if (heading_text.indexOf("{") > -1) {
          occurence = parseInt(heading_text.split("{")[1].split("}")[0]);
          heading_text = heading_text.split("{")[0];
        }
        const headings = target_file_cache.headings;
        for (let i = 0; i < headings.length; i++) {
          if (headings[i].heading === heading_text) {
            if (occurence === 0) {
              heading = headings[i];
              break;
            }
            occurence--;
          }
        }
      } else {
        targetFile = plugin.app.metadataCache.getFirstLinkpathDest(target_path, "");
      }
      let leaf;
      if (event) {
        const mod = plugin.obsidian.Keymap.isModEvent(event);
        leaf = plugin.app.workspace.getLeaf(mod);
      } else {
        leaf = plugin.app.workspace.getMostRecentLeaf();
      }
      await leaf.openFile(targetFile);
      if (heading) {
        let { editor } = leaf.view;
        const pos = { line: heading.position.start.line, ch: 0 };
        editor.setCursor(pos);
        editor.scrollIntoView({ to: pos, from: pos }, true);
      }
    }
    exports2.open_note = open_note2;
  }
});

// src/index.js
var {
  addIcon,
  Keymap,
  MarkdownRenderer,
  Notice,
  Plugin,
  request,
  requestUrl,
  TAbstractFile,
  TFile
} = require("obsidian");
var { ObsAJSON } = require_ObsAJSON();
var { ObsMultiAJSON } = require_ObsMultiAJSON();
var { ScEnv } = require_sc_env();
var { default_settings } = require_default_settings();
var { ScSmartView } = require_sc_smart_view();
var { SmartSearch } = require_smart_search();
var { SmartNotices } = require_smart_notices();
var { ScChatView } = require_sc_chat_view();
var { ScSettingsTab } = require_sc_settings();
var embed_models = require_models();
var { ScActionsUx } = require_sc_actions_ux();
var { open_note } = require_open_note();
var SmartConnectionsPlugin = class extends Plugin {
  static get defaults() {
    return default_settings();
  }
  get item_views() {
    return {
      ScSmartView,
      ScChatView
    };
  }
  async open_note(target_path, event = null) {
    await open_note(this, target_path, event);
  }
  async load_settings() {
    Object.assign(this.settings, await this.loadData());
    this.handle_deprecated_settings();
  }
  async onload() {
    this.app.workspace.onLayoutReady(this.initialize.bind(this));
  }
  // initialize when layout is ready
  onunload() {
    var _a, _b;
    console.log("unloading plugin");
    (_a = this.env) == null ? void 0 : _a.unload();
    this.env = null;
    this.brain = null;
    (_b = this.notices) == null ? void 0 : _b.unload();
  }
  async initialize() {
    console.log("Loading Smart Connections v2...");
    Object.assign(this, this.constructor.defaults);
    await this.load_settings();
    this.smart_connections_view = null;
    this.add_commands();
    this.register_views();
    this.addSettingTab(new ScSettingsTab(this.app, this, "smart_settings_21"));
    this.check_for_updates();
    this.add_to_gitignore("\n\n# Ignore Smart Connections folder\n.smart-connections");
    this.api = new SmartSearch(this);
    (window["SmartSearch"] = this.api) && this.register(() => delete window["SmartSearch"]);
    addIcon("smart-connections", `<path d="M50,20 L80,40 L80,60 L50,100" stroke="currentColor" stroke-width="4" fill="none"/>
    <path d="M30,50 L55,70" stroke="currentColor" stroke-width="5" fill="none"/>
    <circle cx="50" cy="20" r="9" fill="currentColor"/>
    <circle cx="80" cy="40" r="9" fill="currentColor"/>
    <circle cx="80" cy="70" r="9" fill="currentColor"/>
    <circle cx="50" cy="100" r="9" fill="currentColor"/>
    <circle cx="30" cy="50" r="9" fill="currentColor"/>`);
    this.addRibbonIcon("smart-connections", "Open: View Smart Connections", () => {
      this.open_view();
    });
    this.addRibbonIcon("message-square", "Open: Smart Chat Conversation", () => {
      this.open_chat();
    });
    this.registerMarkdownCodeBlockProcessor("smart-connections", this.render_code_block.bind(this));
    this.registerMarkdownCodeBlockProcessor("sc-context", this.render_code_block_context.bind(this));
    this.registerMarkdownCodeBlockProcessor("sc-change", this.change_code_block.bind(this));
    this.notices = new SmartNotices(this);
    this.obsidian = require("obsidian");
    this.new_user();
    await this.load_env();
    console.log("Smart Connections v2 loaded");
  }
  async load_env() {
    this.env = new ScEnv(this, this.settings.embedding_file_per_note ? ObsMultiAJSON : ObsAJSON);
    this.brain = this.env;
    await this.env.init();
  }
  new_user() {
    if (!this.settings.new_user)
      return;
    this.settings.new_user = false;
    this.settings.version = this.manifest.version;
    this.open_view();
    this.open_chat();
    if (this.app.workspace.rightSplit.collapsed)
      this.app.workspace.rightSplit.toggle();
    this.save_settings();
  }
  register_views() {
    Object.values(this.item_views).forEach((View) => {
      this.registerView(View.view_type, (leaf) => new View(leaf, this));
    });
  }
  async check_for_updates() {
    if (this.settings.version !== this.manifest.version) {
      this.settings.version = this.manifest.version;
      await this.save_settings();
    }
    setTimeout(this.check_for_update.bind(this), 3e3);
    setInterval(this.check_for_update.bind(this), 108e5);
  }
  // check for update
  async check_for_update() {
    try {
      const { json: response } = await requestUrl({
        url: "https://api.github.com/repos/brianpetro/obsidian-smart-connections/releases/latest",
        method: "GET",
        headers: {
          "Content-Type": "application/json"
        },
        contentType: "application/json"
      });
      const latest_release = response.tag_name;
      if (latest_release !== this.manifest.version) {
        new Notice(`[Smart Connections] A new version is available! (v${latest_release})`);
        this.update_available = true;
      }
    } catch (error) {
      console.log(error);
    }
  }
  async restart_plugin() {
    await this.saveData(this.settings);
    await new Promise((r) => setTimeout(r, 3e3));
    window.restart_plugin = async (id) => {
      console.log("restarting plugin", id);
      await window.app.plugins.disablePlugin(id);
      await window.app.plugins.enablePlugin(id);
      console.log("plugin restarted", id);
    };
    window.restart_plugin(this.manifest.id);
  }
  add_commands() {
    this.addCommand({
      id: "sc-find-notes",
      name: "Find: Make Smart Connections",
      icon: "pencil_icon",
      hotkeys: [],
      editorCallback: (editor) => {
        var _a;
        if (editor.somethingSelected())
          this.view.render_nearest(editor.getSelection());
        else if ((_a = editor.getCursor()) == null ? void 0 : _a.line) {
          const line = editor.getCursor().line;
          const block = this.brain.smart_notes.current_note.get_block_by_line(line);
          console.log(block);
          console.log(line);
          this.view.render_nearest(block);
        } else
          this.view.render_nearest();
      }
    });
    this.addCommand({
      id: "sc-refresh-connections",
      name: "Refresh & Make Connections",
      icon: "pencil_icon",
      hotkeys: [],
      editorCallback: async (editor) => {
        var _a;
        const curr_file = this.app.workspace.getActiveFile();
        (_a = this.view) == null ? true : delete _a.nearest_cache[curr_file.path];
        this.env.smart_notes.delete(curr_file.path);
        await this.env.smart_notes.import([curr_file]);
        setTimeout(() => {
          this.view.render_nearest();
        }, 1e3);
      }
    });
    this.addCommand({
      id: "smart-connections-view",
      name: "Open: View Smart Connections",
      callback: () => {
        this.open_view();
      }
    });
    this.addCommand({
      id: "smart-connections-chat",
      name: "Open: Smart Chat Conversation",
      callback: () => {
        this.open_chat();
      }
    });
    this.addCommand({
      id: "smart-connections-random",
      name: "Open: Random Note from Smart Connections",
      callback: () => {
        var _a;
        const curr_file = this.app.workspace.getActiveFile();
        const curr_note = (_a = this.brain) == null ? void 0 : _a.smart_notes.get(curr_file.path);
        const nearest = curr_note.find_connections();
        const rand = Math.floor(Math.random() * nearest.length / 2);
        const rand_entity = nearest[rand];
        this.open_note(rand_entity.path);
      }
    });
  }
  async make_connections(selected_text = null) {
    if (!this.view)
      await this.open_view();
    await this.view.render_nearest(selected_text);
  }
  async save_settings(rerender = false) {
    await this.saveData(this.settings);
    await this.load_settings();
    if (rerender) {
      this.nearest_cache = {};
      console.log("rerendering view");
      await this.make_connections();
    }
  }
  // utils
  async add_to_gitignore(ignore, message = null) {
    if (!await this.app.vault.adapter.exists(".gitignore"))
      return;
    let gitignore_file = await this.app.vault.adapter.read(".gitignore");
    if (gitignore_file.indexOf(ignore) < 0) {
      await this.app.vault.adapter.append(".gitignore", `

${message ? "# " + message + "\n" : ""}${ignore}`);
      console.log("Added to .gitignore: " + ignore);
    }
  }
  show_notice(message, opts = {}) {
    console.log("old showing notice");
    const notice_id = typeof message === "string" ? message : message[0];
    return this.notices.show(notice_id, message, opts);
  }
  open_view(active = true) {
    ScSmartView.open(this.app.workspace, active);
  }
  open_chat() {
    ScChatView.open(this.app.workspace);
  }
  get view() {
    return ScSmartView.get_view(this.app.workspace);
  }
  get chat_view() {
    return ScChatView.get_view(this.app.workspace);
  }
  // get folders, traverse non-hidden sub-folders
  async get_folders(path = "/") {
    const folders = (await this.app.vault.adapter.list(path)).folders;
    let folder_list = [];
    for (let i = 0; i < folders.length; i++) {
      if (folders[i].startsWith("."))
        continue;
      folder_list.push(folders[i]);
      folder_list = folder_list.concat(await this.get_folders(folders[i] + "/"));
    }
    return folder_list;
  }
  // SUPPORTERS
  async sync_notes() {
    if (!this.settings.license_key) {
      new Notice("Smart Connections: Supporter license key is required to sync notes to the ChatGPT Plugin server.");
      return;
    }
    console.log("syncing notes");
    const files = this.brain.files;
    const notes = await this.build_notes_object(files);
    const response = await requestUrl({
      url: "https://sync.smartconnections.app/sync",
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      contentType: "application/json",
      body: JSON.stringify({
        license_key: this.settings.license_key,
        notes
      })
    });
    console.log(response);
  }
  async build_notes_object(files) {
    let output = {};
    for (let i = 0; i < files.length; i++) {
      let file = files[i];
      let parts = file.path.split("/");
      let current = output;
      for (let ii = 0; ii < parts.length; ii++) {
        let part = parts[ii];
        if (ii === parts.length - 1) {
          current[part] = await this.app.vault.cachedRead(file);
        } else {
          if (!current[part]) {
            current[part] = {};
          }
          current = current[part];
        }
      }
    }
    return output;
  }
  async render_code_block(contents, container, ctx) {
    console.log(container);
    return this.view.render_nearest(contents.trim().length ? contents : ctx.sourcePath, container);
  }
  async render_code_block_context(results, container, ctx) {
    results = this.get_entities_from_context_codeblock(results);
    console.log(results);
    container.innerHTML = this.view.render_template("smart_connections", { current_path: "context", results });
    container.querySelectorAll(".search-result").forEach((elm, i) => this.view.add_link_listeners(elm, results[i]));
    container.querySelectorAll(".search-result:not(.sc-collapsed) ul li").forEach(this.view.render_result.bind(this.view));
  }
  get_entities_from_context_codeblock(results) {
    return results.split("\n").map((key) => {
      const entity = key.includes("#") ? this.brain.smart_blocks.get(key) : this.brain.smart_notes.get(key);
      return entity ? entity : { name: "Not found: " + key };
    });
  }
  // change code block
  async change_code_block(source, el, ctx) {
    console.log(source);
    const renderer = new ScActionsUx(this, el);
    renderer.change_code_block(source);
  }
  // update smart connections folder
  async update_smart_connections_folder() {
    if (this.settings.smart_connections_folder === this.settings.smart_connections_folder_last)
      return;
    if (!confirm("Are you sure you want to update the Smart Connections folder? This will move all Smart Connections files to the new folder and restart the plugin.")) {
      this.settings.smart_connections_folder = this.settings.smart_connections_folder_last;
      return;
    }
    await this.app.vault.adapter.rename(this.settings.smart_connections_folder_last, this.settings.smart_connections_folder);
    this.settings.smart_connections_folder_last = this.settings.smart_connections_folder;
    await this.save_settings();
    this.restart_plugin();
  }
  // update smart chat folder
  async update_smart_chat_folder() {
    if (this.settings.smart_chat_folder === this.settings.smart_chat_folder_last)
      return;
    if (!confirm("Are you sure you want to update the Smart Chats folder? This will move all Smart Chat files to the new folder.")) {
      this.settings.smart_chat_folder = this.settings.smart_chat_folder_last;
      return;
    }
    await this.app.vault.adapter.rename(this.settings.smart_chat_folder_last, this.settings.smart_chat_folder);
    this.settings.smart_chat_folder_last = this.settings.smart_chat_folder;
    await this.save_settings();
    this.env.chats.folder = this.settings.smart_chat_folder;
  }
  // is smart view open
  // is_smart_view_open() { return ScSmartView.is_open(this.app.workspace); }
  // backwards compatibility
  async handle_deprecated_settings() {
    Object.entries(this.settings).forEach(([key, value]) => {
      var _a;
      if (key.includes("-")) {
        const new_key = key.replace(/-/g, "_");
        this.settings[new_key] = value;
        delete this.settings[key];
        this.save_settings();
      }
      if (key.startsWith("api_key_")) {
        const platform = key.replace(/^api_key_/, "");
        if (!this.settings[platform])
          this.settings[platform] = {};
        if (!this.settings[platform].api_key)
          this.settings[platform].api_key = value;
        if ((_a = this.settings.smart_chat_model) == null ? void 0 : _a.startsWith(platform)) {
          const model_name = this.settings.smart_chat_model.replace(platform + "-", "");
          if (!this.settings[platform].model_name)
            this.settings[platform].model_name = model_name;
          delete this.settings.smart_chat_model;
        }
        delete this.settings[key];
        this.save_settings();
      }
    });
    if (!this.settings.file_exclusions.includes("Untitled")) {
      if (this.settings.file_exclusions.length)
        this.settings.file_exclusions += ",";
      this.settings.file_exclusions += "Untitled";
      this.save_settings();
    }
    if (this.settings.smart_notes_embed_model === "None") {
      this.settings.smart_notes_embed_model = "TaylorAI/bge-micro-v2";
      this.save_settings();
    }
    if (!embed_models[this.settings.smart_notes_embed_model]) {
      this.settings.smart_notes_embed_model = this.constructor.defaults.smart_notes_embed_model;
      this.save_settings();
    }
    if (!embed_models[this.settings.smart_blocks_embed_model] && this.settings.smart_blocks_embed_model !== "None") {
      this.settings.smart_blocks_embed_model = this.constructor.defaults.smart_blocks_embed_model;
      this.save_settings();
    }
    if (this.settings.header_exclusions) {
      this.settings.excluded_headings = this.settings.header_exclusions;
      delete this.settings.header_exclusions;
    }
  }
};
module.exports = SmartConnectionsPlugin;
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWNvbGxlY3Rpb25zL2xvbmdfdGVybV9tZW1vcnkuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWNvbGxlY3Rpb25zL09ic0FKU09OLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zbWFydC1jb2xsZWN0aW9ucy9PYnNNdWx0aUFKU09OLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zbWFydC1jb2xsZWN0aW9ucy9lbnYuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWNvbGxlY3Rpb25zL0JyYWluLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zbWFydC1jaHVua3MvU21hcnRNYXJrZG93bi5qcyIsICIuLi9ub2RlX21vZHVsZXMvc21hcnQtY2h1bmtzL3NtYXJ0LWNodW5rcy5qcyIsICIuLi9ub2RlX21vZHVsZXMvc21hcnQtY29sbGVjdGlvbnMvaGVscGVycy5qcyIsICIuLi9ub2RlX21vZHVsZXMvc21hcnQtY29sbGVjdGlvbnMvQ29sbGVjdGlvbkl0ZW0uanMiLCAiLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWNvbGxlY3Rpb25zL0NvbGxlY3Rpb24uanMiLCAiLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWVtYmVkLW1vZGVsL2FkYXB0ZXJzL2FkYXB0ZXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWVtYmVkLW1vZGVsL2FkYXB0ZXJzL2FwaS5qcyIsICIuLi9ub2RlX21vZHVsZXMvc21hcnQtZW1iZWQtbW9kZWwvYWRhcHRlcnMvbG9jYWxfYXBpLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zbWFydC1lbWJlZC1tb2RlbC9hZGFwdGVycy90cmFuc2Zvcm1lcnMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWVtYmVkLW1vZGVsL3dlYl9jb25uZWN0b3IuanNvbiIsICIuLi9ub2RlX21vZHVsZXMvc21hcnQtZW1iZWQtbW9kZWwvYWRhcHRlcnMvaWZyYW1lLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zbWFydC1lbWJlZC1tb2RlbC9hZGFwdGVycy5qcyIsICIuLi9ub2RlX21vZHVsZXMvc21hcnQtZW1iZWQtbW9kZWwvbW9kZWxzLmpzb24iLCAiLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWVtYmVkLW1vZGVsL3NtYXJ0X2VtYmVkX21vZGVsLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zbWFydC1lbnRpdGllcy9zbWFydF9lbnRpdGllcy5qcyIsICIuLi9zcmMvcmVuZGVyX2RhdGF2aWV3X2NvZGVibG9ja3MuanMiLCAiLi4vc3JjL3NjX2VudGl0aWVzLmpzIiwgIi4uL3NyYy9zbWFydF9zb2NrZXQuanMiLCAiLi4vc3JjL2RhdGF2aWV3X3NvY2tldC5qcyIsICIuLi9idWlsZC92aWV3cy5qc29uIiwgIi4uL2Vqcy5taW4uanMiLCAiLi4vc3JjL1NjVHJhbnNsYXRpb25zLmpzb24iLCAiLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWNoYXQtbW9kZWwvYWRhcHRlcnMvYW50aHJvcGljLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zbWFydC1jaGF0LW1vZGVsL2FkYXB0ZXJzL2NvaGVyZS5qcyIsICIuLi9ub2RlX21vZHVsZXMvc21hcnQtY2hhdC1tb2RlbC9hZGFwdGVycy9nZW1pbmkuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWNoYXQtbW9kZWwvYWRhcHRlcnMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWNoYXQtbW9kZWwvcGxhdGZvcm1zLmpzb24iLCAiLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWNoYXQtbW9kZWwvdXRpbHMvaXNfdmFsaWRfdG9vbF9jYWxsLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zbWFydC1jaGF0LW1vZGVsL3N0cmVhbWVyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zbWFydC1jaGF0LW1vZGVsL21vZGVscy9vcGVuX3JvdXRlci5qcyIsICIuLi9ub2RlX21vZHVsZXMvc21hcnQtY2hhdC1tb2RlbC9tb2RlbHMvb3BlbmFpLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zbWFydC1jaGF0LW1vZGVsL21vZGVscy9nb29nbGVfZ2VtaW5pLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zbWFydC1jaGF0LW1vZGVsL21vZGVscy9jb2hlcmUuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWNoYXQtbW9kZWwvbW9kZWxzL2FudGhyb3BpYy5qcyIsICIuLi9ub2RlX21vZHVsZXMvc21hcnQtY2hhdC1tb2RlbC9tb2RlbHMvZmV0Y2guanMiLCAiLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWNoYXQtbW9kZWwvc21hcnRfY2hhdF9tb2RlbC5qcyIsICIuLi9zcmMvc2NfY2hhdF9tb2RlbC5qcyIsICIuLi9ub2RlX21vZHVsZXMvc21hcnQtY2hhdHMvdXRpbHMvbWVzc2FnZV9jb250ZW50X2FycmF5X3RvX21hcmtkb3duLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zbWFydC1jaGF0cy9zbWFydF9jaGF0c191aS5qcyIsICIuLi9zcmMvc21hcnRfb2JzaWRpYW5fdmlldy5qcyIsICIuLi9zcmMvc2NfY2hhdF92aWV3LmpzIiwgIi4uL3NyYy9zbWFydF9zZXR0aW5ncy5qcyIsICIuLi9zcmMvc21hcnRfY2hhdF9zZXR0aW5ncy5qcyIsICIuLi9zcmMvc2NfY2hhdHNfdWkuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWNoYXRzL3NtYXJ0X2NoYXQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWNoYXRzL3V0aWxzL2NoYXRfbWxfdG9fbWFya2Rvd24uanMiLCAiLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWNoYXRzL3V0aWxzL2FkZF9jb250ZW50X3RvX21lc3NhZ2UuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWNoYXRzL3V0aWxzL21hcmtkb3duX3RvX2NoYXRfbWwuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWNoYXRzL3NtYXJ0X2NoYXRfbWQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWNoYXRzL3NtYXJ0X2NoYXRzLmpzIiwgIi4uL3NyYy9leHRyYWN0X2ZvbGRlcl9yZWZlcmVuY2VzLmpzIiwgIi4uL3NyYy9jb250YWluc19pbnRlcm5hbF9saW5rLmpzIiwgIi4uL3NyYy9jb250YWluc19mb2xkZXJfcmVmZXJlbmNlLmpzIiwgIi4uL3NyYy9zY19jaGF0X21kLmpzIiwgIi4uL3NyYy9zY19jaGF0cy5qcyIsICIuLi9idWlsZC9hY3Rpb25zX29wZW5hcGkuanNvbiIsICIuLi9zcmMvYWN0aW9ucy9sb29rdXAuanMiLCAiLi4vc3JjL2FjdGlvbnMvX2FjdGlvbnMuanMiLCAiLi4vc3JjL3NjX2FjdGlvbnMuanMiLCAiLi4vc3JjL3NjX2Vudi5qcyIsICIuLi9zcmMvZGVmYXVsdF9zZXR0aW5ncy5qcyIsICIuLi9zcmMvc21hcnRfZW1iZWRfc2V0dGluZ3MuanMiLCAiLi4vc3JjL3NjX3NtYXJ0X3ZpZXcuanMiLCAiLi4vc3JjL3NtYXJ0X3NlYXJjaC5qcyIsICIuLi9zcmMvc21hcnRfbm90aWNlcy5qcyIsICIuLi9zcmMvc2Nfc2V0dGluZ3MuanMiLCAiLi4vc3JjL3NjX2FjdGlvbnNfdXguanMiLCAiLi4vc3JjL29wZW5fbm90ZS5qcyIsICIuLi9zcmMvaW5kZXguanMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgbG9uZy10ZXJtIG1lbW9yeSBzdG9yYWdlIGZvciBjb2xsZWN0aW9ucy5cbiAqL1xuY2xhc3MgTG9uZ1Rlcm1NZW1vcnkge1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBMb25nVGVybU1lbW9yeS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbGxlY3Rpb24gLSBUaGUgY29sbGVjdGlvbiBvYmplY3QgY29udGFpbmluZyB0aGUgZW52aXJvbm1lbnQgYW5kIGl0ZW1zLlxuICAgKi9cbiAgY29uc3RydWN0b3IoY29sbGVjdGlvbikge1xuICAgIHRoaXMuZW52ID0gY29sbGVjdGlvbi5lbnY7XG4gICAgdGhpcy5icmFpbiA9IHRoaXMuZW52O1xuICAgIHRoaXMuY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gICAgdGhpcy5zYXZlX3RpbWVvdXQgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXRpYyBtZXRob2QgdG8gaW5pdGlhbGl6ZSBhIExvbmdUZXJtTWVtb3J5IGluc3RhbmNlIHVzaW5nIGEgc3BlY2lmaWMgYWRhcHRlci5cbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbGxlY3Rpb24gLSBUaGUgY29sbGVjdGlvbiBvYmplY3QgdG8gYmUgdXNlZC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gYWRhcHRlciAtIFRoZSBhZGFwdGVyIGNsYXNzIHRvIGJlIGluc3RhbnRpYXRlZC5cbiAgICogQHJldHVybnMge0xvbmdUZXJtTWVtb3J5fSBBbiBpbnN0YW5jZSBvZiB0aGUgYWRhcHRlciBjbGFzcy5cbiAgICovXG4gIHN0YXRpYyB3YWtlX3VwKGNvbGxlY3Rpb24sIGFkYXB0ZXIpIHtcbiAgICBjb25zdCBsdG0gPSBuZXcgYWRhcHRlcihjb2xsZWN0aW9uKTtcbiAgICByZXR1cm4gbHRtO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG5hbWUgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgKi9cbiAgZ2V0IGNvbGxlY3Rpb25fbmFtZSgpIHsgcmV0dXJuIHRoaXMuY29sbGVjdGlvbi5jb2xsZWN0aW9uX25hbWU7IH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbmFtZSBvZiB0aGUgaXRlbSBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIGl0ZW0uXG4gICAqL1xuICBnZXQgaXRlbV9uYW1lKCkgeyByZXR1cm4gdGhpcy5jb2xsZWN0aW9uLml0ZW1fbmFtZTsgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBkYXRhIHBhdGggZnJvbSB0aGUgZW52aXJvbm1lbnQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBkYXRhIHBhdGguXG4gICAqL1xuICBnZXQgZGF0YV9wYXRoKCkgeyByZXR1cm4gdGhpcy5lbnYuZGF0YV9wYXRoOyB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGZpbGUgbmFtZSwgZGVmYXVsdGluZyB0byB0aGUgY29sbGVjdGlvbiBuYW1lIGlmIG5vdCBleHBsaWNpdGx5IHNldC5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGZpbGUgbmFtZS5cbiAgICovXG4gIGdldCBmaWxlX25hbWUoKSB7IHJldHVybiB0aGlzLmNvbGxlY3Rpb24uZmlsZV9uYW1lIHx8IHRoaXMuY29sbGVjdGlvbi5jb2xsZWN0aW9uX25hbWU7IH1cblxuICAvKipcbiAgICogQ29uc3RydWN0cyB0aGUgZnVsbCBmaWxlIHBhdGggZm9yIHRoZSBjb2xsZWN0aW9uJ3MgZGF0YS5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGZ1bGwgZmlsZSBwYXRoLlxuICAgKi9cbiAgZ2V0IGZpbGVfcGF0aCgpIHsgcmV0dXJuIHRoaXMuZGF0YV9wYXRoICsgJy8nICsgdGhpcy5maWxlX25hbWU7IH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgaXRlbXMgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gVGhlIGl0ZW1zIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgKi9cbiAgZ2V0IGl0ZW1zKCkgeyByZXR1cm4gdGhpcy5jb2xsZWN0aW9uLml0ZW1zOyB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGl0ZW1zIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgKiBAcGFyYW0ge0FycmF5fSBpdGVtcyAtIFRoZSBuZXcgaXRlbXMgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAqL1xuICBzZXQgaXRlbXMoaXRlbXMpIHsgdGhpcy5jb2xsZWN0aW9uLml0ZW1zID0gaXRlbXM7IH1cblxuICAvKipcbiAgICogR2V0cyB0aGUga2V5cyBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBUaGUga2V5cyBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICovXG4gIGdldCBrZXlzKCkgeyByZXR1cm4gdGhpcy5jb2xsZWN0aW9uLmtleXM7IH1cblxuICAvKipcbiAgICogUGxhY2Vob2xkZXIgZm9yIGxvYWRpbmcgZGF0YSwgdG8gYmUgaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3Nlcy5cbiAgICovXG4gIGFzeW5jIGxvYWQoKSB7IH1cblxuICAvKipcbiAgICogRGVmYXVsdCBzYXZlIG1ldGhvZCwgbG9ncyBhIG1lc3NhZ2UgaWYgbm90IG92ZXJyaWRkZW4uXG4gICAqL1xuICBzYXZlKCkgeyBpZiAodGhpcy5jb25zdHJ1Y3Rvci5uYW1lICE9PSAnTG9uZ1Rlcm1NZW1vcnknKSBjb25zb2xlLmxvZyhcImNhbGxlZCBkZWZhdWx0LCBvdmVycmlkZSBtZVwiKTsgfVxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IGFzeW5jaHJvbm91cyBzYXZlIG1ldGhvZCwgbG9ncyBhIG1lc3NhZ2UgaWYgbm90IG92ZXJyaWRkZW4uXG4gICAqL1xuICBhc3luYyBfc2F2ZSgpIHsgaWYgKHRoaXMuY29uc3RydWN0b3IubmFtZSAhPT0gJ0xvbmdUZXJtTWVtb3J5JykgY29uc29sZS5sb2coXCJjYWxsZWQgZGVmYXVsdCwgb3ZlcnJpZGUgbWVcIik7IH1cblxuICAvKipcbiAgICogUmV2aXZlcyBhIHZhbHVlIGZyb20gYSBrZXktdmFsdWUgcGFpci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgaW4gdGhlIGtleS12YWx1ZSBwYWlyLlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIGluIHRoZSBrZXktdmFsdWUgcGFpci5cbiAgICogQHJldHVybnMgeyp9IFRoZSBwb3NzaWJseSB0cmFuc2Zvcm1lZCB2YWx1ZS5cbiAgICovXG4gIHJldml2ZXIoa2V5LCB2YWx1ZSkgeyByZXR1cm4gdGhpcy5jb2xsZWN0aW9uLnJldml2ZXIoa2V5LCB2YWx1ZSk7IH1cblxuICAvKipcbiAgICogUmVwbGFjZXMgYSB2YWx1ZSBiZWZvcmUgaXQgaXMgc2VyaWFsaXplZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgaW4gdGhlIGtleS12YWx1ZSBwYWlyLlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIGluIHRoZSBrZXktdmFsdWUgcGFpci5cbiAgICogQHJldHVybnMgeyp9IFRoZSBwb3NzaWJseSB0cmFuc2Zvcm1lZCB2YWx1ZS5cbiAgICovXG4gIHJlcGxhY2VyKGtleSwgdmFsdWUpIHsgcmV0dXJuIHRoaXMuY29sbGVjdGlvbi5yZXBsYWNlcihrZXksIHZhbHVlKTsgfVxufVxuXG4vLyBFWFBPUlRTXG5leHBvcnRzLkxvbmdUZXJtTWVtb3J5ID0gTG9uZ1Rlcm1NZW1vcnk7IiwgImNvbnN0IHsgTG9uZ1Rlcm1NZW1vcnkgfSA9IHJlcXVpcmUoJy4vbG9uZ190ZXJtX21lbW9yeScpO1xuLyoqXG4gKiBDbGFzcyBPYnNBSlNPTiBleHRlbmRzIExvbmdUZXJtTWVtb3J5IHRvIGhhbmRsZSBKU09OLWJhc2VkIHN0b3JhZ2Ugb2YgY29sbGVjdGlvbnMuXG4gKiBUaGlzIGNsYXNzIHByb3ZpZGVzIG1ldGhvZHMgdG8gbG9hZCBhbmQgc2F2ZSBjb2xsZWN0aW9ucyB0byBhIEpTT04gZmlsZSB3aXRoIGFzeW5jaHJvbm91cyBvcGVyYXRpb25zLFxuICogZW5zdXJpbmcgZGF0YSBpbnRlZ3JpdHkgYW5kIGVycm9yIGhhbmRsaW5nLiBJdCB1c2VzIGFuIGFkYXB0ZXIgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgZmlsZSBzeXN0ZW0uXG4gKi9cbmNsYXNzIE9ic0FKU09OIGV4dGVuZHMgTG9uZ1Rlcm1NZW1vcnkge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhbiBpbnN0YW5jZSBvZiBPYnNBSlNPTi5cbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbGxlY3Rpb24gLSBUaGUgY29sbGVjdGlvbiB0byBiZSBtYW5hZ2VkLlxuICAgKi9cbiAgY29uc3RydWN0b3IoY29sbGVjdGlvbikge1xuICAgIHN1cGVyKGNvbGxlY3Rpb24pO1xuICAgIHRoaXMuYWRhcHRlciA9IHRoaXMuZW52Lm1haW4uYXBwLnZhdWx0LmFkYXB0ZXI7XG4gIH1cblxuICAvKipcbiAgICogQXN5bmNocm9ub3VzbHkgbG9hZHMgdGhlIGNvbGxlY3Rpb24gZnJvbSBhIEpTT04gZmlsZS5cbiAgICogUGFyc2VzIHRoZSBmaWxlIGNvbnRlbnQgYW5kIGluaXRpYWxpemVzIGNvbGxlY3Rpb24gaXRlbXMgYmFzZWQgb24gdGhlIHN0b3JlZCBkYXRhLlxuICAgKiBIYW5kbGVzIGZpbGUgbm90IGZvdW5kIGVycm9ycyBieSBjcmVhdGluZyBuZWNlc3NhcnkgZGlyZWN0b3JpZXMgYW5kIGZpbGVzLlxuICAgKi9cbiAgYXN5bmMgbG9hZCgpIHtcbiAgICBjb25zb2xlLmxvZyhcIkxvYWRpbmc6IFwiICsgdGhpcy5maWxlX3BhdGgpO1xuICAgIHRyeSB7XG4gICAgICAoYXdhaXQgdGhpcy5hZGFwdGVyLnJlYWQodGhpcy5maWxlX3BhdGgpKVxuICAgICAgICAuc3BsaXQoXCIsXFxuXCIpXG4gICAgICAgIC5maWx0ZXIoYmF0Y2ggPT4gYmF0Y2gpIC8vIHJlbW92ZSBlbXB0eSBzdHJpbmdzXG4gICAgICAgIC5mb3JFYWNoKChiYXRjaCwgaSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGl0ZW1zID0gSlNPTi5wYXJzZShgeyR7YmF0Y2h9fWApO1xuICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGl0ZW1zKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29sbGVjdGlvbi5pdGVtc1trZXldID0gbmV3ICh0aGlzLmVudi5pdGVtX3R5cGVzW3ZhbHVlLmNsYXNzX25hbWVdKSh0aGlzLmVudiwgdmFsdWUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgO1xuICAgICAgY29uc29sZS5sb2coXCJMb2FkZWQ6IFwiICsgdGhpcy5maWxlX25hbWUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5sb2coXCJFcnJvciBsb2FkaW5nOiBcIiArIHRoaXMuZmlsZV9wYXRoKTtcbiAgICAgIGNvbnNvbGUubG9nKGVyci5zdGFjayk7IC8vIHN0YWNrIHRyYWNlXG4gICAgICAvLyBDcmVhdGUgZm9sZGVyIGFuZCBmaWxlIGlmIHRoZXkgZG9uJ3QgZXhpc3RcbiAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgICAgdGhpcy5pdGVtcyA9IHt9O1xuICAgICAgICAvLyB0aGlzLmtleXMgPSBbXTsgLy8gcmVwbGFjZWQgYnkgZ2V0dGVyXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5hZGFwdGVyLm1rZGlyKHRoaXMuZGF0YV9wYXRoKTtcbiAgICAgICAgICBhd2FpdCB0aGlzLmFkYXB0ZXIud3JpdGUodGhpcy5maWxlX3BhdGgsIFwiXCIpO1xuICAgICAgICB9IGNhdGNoIChjcmVhdGlvbkVycikge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiRmFpbGVkIHRvIGNyZWF0ZSBmb2xkZXIgb3IgZmlsZTogXCIsIGNyZWF0aW9uRXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHdyYXBzIF9zYXZlIGluIHRpbWVvdXQgdG8gcHJldmVudCBtdWx0aXBsZSBzYXZlcyBhdCBvbmNlXG4gIHNhdmUoKSB7XG4gICAgaWYodGhpcy5zYXZlX3RpbWVvdXQpIGNsZWFyVGltZW91dCh0aGlzLnNhdmVfdGltZW91dCk7XG4gICAgdGhpcy5zYXZlX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHsgdGhpcy5fc2F2ZSgpOyB9LCAxMDAwMCk7XG4gIH1cblxuICAvKipcbiAgICogU2F2ZXMgdGhlIGNvbGxlY3Rpb24gdG8gYSBKU09OIGZpbGUuIFRoaXMgbWV0aG9kIGlzIHRocm90dGxlZCB0byBwcmV2ZW50IG11bHRpcGxlIHNhdmVzIGF0IG9uY2UuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmNlPWZhbHNlXSAtIEZvcmNlcyB0aGUgc2F2ZSBvcGVyYXRpb24gZXZlbiBpZiBjdXJyZW50bHkgc2F2aW5nLlxuICAgKi9cbiAgYXN5bmMgX3NhdmUoZm9yY2U9ZmFsc2UpIHtcbiAgICBpZih0aGlzLnNhdmVfdGltZW91dCkgY2xlYXJUaW1lb3V0KHRoaXMuc2F2ZV90aW1lb3V0KTtcbiAgICB0aGlzLnNhdmVfdGltZW91dCA9IG51bGw7XG4gICAgaWYodGhpcy5fc2F2aW5nKSByZXR1cm4gY29uc29sZS5sb2coXCJBbHJlYWR5IHNhdmluZzogXCIgKyB0aGlzLmZpbGVfbmFtZSk7XG4gICAgdGhpcy5fc2F2aW5nID0gdHJ1ZTsgLy8gcHJldmVudCBtdWx0aXBsZSBzYXZlcyBhdCBvbmNlXG4gICAgc2V0VGltZW91dCgoKSA9PiB7IHRoaXMuX3NhdmluZyA9IGZhbHNlOyB9LCAxMDAwMCk7IC8vIHNldCBfc2F2aW5nIHRvIGZhbHNlIGFmdGVyIDEwIHNlY29uZHNcbiAgICBjb25zdCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgY29uc29sZS5sb2coXCJTYXZpbmc6IFwiICsgdGhpcy5maWxlX25hbWUpO1xuICAgIC8vIHJlbmFtZSB0ZW1wIGZpbGVcbiAgICBjb25zdCB0ZW1wX2ZpbGVfcGF0aCA9IHRoaXMuZmlsZV9wYXRoLnJlcGxhY2UoJy5hanNvbicsICcudGVtcC5hanNvbicpO1xuICAgIGlmKGF3YWl0IHRoaXMuYWRhcHRlci5leGlzdHModGVtcF9maWxlX3BhdGgpKSBhd2FpdCB0aGlzLmFkYXB0ZXIucmVtb3ZlKHRlbXBfZmlsZV9wYXRoKTtcbiAgICB0cnkge1xuICAgICAgLy8gaW5pdCB0ZW1wIGZpbGVcbiAgICAgIGF3YWl0IHRoaXMuYWRhcHRlci53cml0ZSh0ZW1wX2ZpbGVfcGF0aCwgXCJcIik7XG4gICAgICBsZXQgZmlsZV9jb250ZW50ID0gW107XG4gICAgICBjb25zdCBpdGVtcyA9IE9iamVjdC52YWx1ZXModGhpcy5pdGVtcykuZmlsdGVyKGkgPT4gaS52ZWMpO1xuICAgICAgY29uc3QgYmF0Y2hlcyA9IE1hdGguY2VpbChpdGVtcy5sZW5ndGggLyAxMDAwKTtcbiAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBiYXRjaGVzOyBpKyspIHtcbiAgICAgICAgZmlsZV9jb250ZW50ID0gaXRlbXMuc2xpY2UoaSAqIDEwMDAsIChpICsgMSkgKiAxMDAwKS5tYXAoaSA9PiBpLmFqc29uKTtcbiAgICAgICAgY29uc3QgYmF0Y2hfY29udGVudCA9IGZpbGVfY29udGVudC5qb2luKFwiLFwiKTtcbiAgICAgICAgYXdhaXQgdGhpcy5hZGFwdGVyLmFwcGVuZCh0ZW1wX2ZpbGVfcGF0aCwgYmF0Y2hfY29udGVudCArIFwiLFxcblwiKTtcbiAgICAgIH1cbiAgICAgIC8vIGFwcGVuZCBsYXN0IGJhdGNoXG4gICAgICBpZihpdGVtcy5sZW5ndGggPiBiYXRjaGVzICogMTAwMCkge1xuICAgICAgICBhd2FpdCB0aGlzLmFkYXB0ZXIuYXBwZW5kKHRlbXBfZmlsZV9wYXRoLCBpdGVtcy5zbGljZShiYXRjaGVzICogMTAwMCkubWFwKGkgPT4gaS5hanNvbikuam9pbihcIixcIikgKyBcIixcXG5cIik7XG4gICAgICB9XG4gICAgICBjb25zdCBlbmQgPSBEYXRlLm5vdygpOyAvLyBsb2cgdGltZVxuICAgICAgY29uc3QgdGltZSA9IGVuZCAtIHN0YXJ0O1xuICAgICAgaWYoZm9yY2UgfHwgYXdhaXQgdGhpcy52YWxpZGF0ZV9zYXZlKHRlbXBfZmlsZV9wYXRoLCB0aGlzLmZpbGVfcGF0aCkpIHtcbiAgICAgICAgaWYoYXdhaXQgdGhpcy5hZGFwdGVyLmV4aXN0cyh0aGlzLmZpbGVfcGF0aCkpIGF3YWl0IHRoaXMuYWRhcHRlci5yZW1vdmUodGhpcy5maWxlX3BhdGgpO1xuICAgICAgICBhd2FpdCB0aGlzLmFkYXB0ZXIucmVuYW1lKHRlbXBfZmlsZV9wYXRoLCB0aGlzLmZpbGVfcGF0aCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiU2F2ZWQgXCIgKyB0aGlzLmZpbGVfbmFtZSArIFwiIGluIFwiICsgdGltZSArIFwibXNcIik7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgY29uc29sZS5sb2coXCJOb3Qgc2F2aW5nIFwiICsgdGhpcy5maWxlX25hbWUgKyBcIiBiZWNhdXNlIG5ldyBmaWxlIGlzIGxlc3MgdGhhbiA1MCUgb2Ygb2xkIGZpbGVcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igc2F2aW5nOiBcIiArIHRoaXMuZmlsZV9uYW1lKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyLnN0YWNrKTtcbiAgICAgIC8vIHNldCBuZXcgZmlsZSB0byBcImZhaWxlZFwiIGFuZCByZW5hbWUgdG8gaW5sY2x1ZGUgZGF0ZXRpbWVcbiAgICAgIGNvbnN0IGZhaWxlZF9maWxlX3BhdGggPSB0ZW1wX2ZpbGVfcGF0aC5yZXBsYWNlKCcudGVtcC4nLCAnLmZhaWxlZC0nICsgRGF0ZS5ub3coKSArICcuJyk7XG4gICAgICBhd2FpdCB0aGlzLmFkYXB0ZXIucmVuYW1lKHRlbXBfZmlsZV9wYXRoLCBmYWlsZWRfZmlsZV9wYXRoKTtcbiAgICB9XG4gICAgdGhpcy5fc2F2aW5nID0gZmFsc2U7XG4gICAgLy8gcmVtb3ZlIHRlbXAgZmlsZSBhZnRlciBuZXcgZmlsZSBpcyBzYXZlZFxuICAgIGlmKGF3YWl0IHRoaXMuYWRhcHRlci5leGlzdHModGVtcF9maWxlX3BhdGgpICYmIGF3YWl0IHRoaXMuYWRhcHRlci5leGlzdHModGhpcy5maWxlX3BhdGgpKSBhd2FpdCB0aGlzLmFkYXB0ZXIucmVtb3ZlKHRlbXBfZmlsZV9wYXRoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhlIG5ldyBmaWxlIHNpemUgYWdhaW5zdCB0aGUgb2xkIGZpbGUgc2l6ZSB0byBlbnN1cmUgZGF0YSBpbnRlZ3JpdHkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuZXdfZmlsZV9wYXRoIC0gUGF0aCB0byB0aGUgbmV3IGZpbGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvbGRfZmlsZV9wYXRoIC0gUGF0aCB0byB0aGUgb2xkIGZpbGUuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSBUcnVlIGlmIHRoZSBuZXcgZmlsZSBzaXplIGlzIG1vcmUgdGhhbiA1MCUgb2YgdGhlIG9sZCBmaWxlIHNpemUsIG90aGVyd2lzZSBmYWxzZS5cbiAgICovXG4gIGFzeW5jIHZhbGlkYXRlX3NhdmUobmV3X2ZpbGVfcGF0aCwgb2xkX2ZpbGVfcGF0aCkge1xuICAgIGNvbnN0IG5ld19maWxlX3NpemUgPSAoYXdhaXQgdGhpcy5hZGFwdGVyLnN0YXQobmV3X2ZpbGVfcGF0aCkpPy5zaXplO1xuICAgIGNvbnN0IG9sZF9maWxlX3NpemUgPSAoYXdhaXQgdGhpcy5hZGFwdGVyLnN0YXQob2xkX2ZpbGVfcGF0aCkpPy5zaXplO1xuICAgIGlmKCFvbGRfZmlsZV9zaXplKSByZXR1cm4gdHJ1ZTtcbiAgICBjb25zb2xlLmxvZyhcIk5ldyBmaWxlIHNpemU6IFwiICsgbmV3X2ZpbGVfc2l6ZSArIFwiIGJ5dGVzXCIpO1xuICAgIGNvbnNvbGUubG9nKFwiT2xkIGZpbGUgc2l6ZTogXCIgKyBvbGRfZmlsZV9zaXplICsgXCIgYnl0ZXNcIik7XG4gICAgcmV0dXJuIG5ld19maWxlX3NpemUgPiAob2xkX2ZpbGVfc2l6ZSAqIDAuNSk7XG4gIH1cblxuICBnZXQgZmlsZV9uYW1lKCkgeyByZXR1cm4gc3VwZXIuZmlsZV9uYW1lICsgJy5hanNvbic7IH1cbn1cblxuZXhwb3J0cy5PYnNBSlNPTiA9IE9ic0FKU09OOyIsICJjb25zdCB7IExvbmdUZXJtTWVtb3J5IH0gPSByZXF1aXJlKCcuL2xvbmdfdGVybV9tZW1vcnknKTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBzcGVjaWFsaXplZCBmb3JtIG9mIExvbmdUZXJtTWVtb3J5IHRoYXQgaGFuZGxlcyBtdWx0aXBsZSAuYWpzb24gZmlsZXMuXG4gKiBJdCBleHRlbmRzIHRoZSBMb25nVGVybU1lbW9yeSBjbGFzcyB0byBtYW5hZ2UgY29sbGVjdGlvbnMgb2YgaXRlbXMgc3RvcmVkIGluIC5hanNvbiBmb3JtYXQuXG4gKi9cbmNsYXNzIE9ic011bHRpQUpTT04gZXh0ZW5kcyBMb25nVGVybU1lbW9yeSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIE9ic011bHRpQUpTT04uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb2xsZWN0aW9uIC0gVGhlIGNvbGxlY3Rpb24gb2YgaXRlbXMgdG8gYmUgbWFuYWdlZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbGxlY3Rpb24pIHtcbiAgICBzdXBlcihjb2xsZWN0aW9uKTtcbiAgICB0aGlzLmFkYXB0ZXIgPSB0aGlzLmVudi5tYWluLmFwcC52YXVsdC5hZGFwdGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzeW5jaHJvbm91c2x5IGxvYWRzIGNvbGxlY3Rpb24gaXRlbXMgZnJvbSAuYWpzb24gZmlsZXMgd2l0aGluIHRoZSBzcGVjaWZpZWQgZGF0YSBwYXRoLlxuICAgKiBJdCBlbnN1cmVzIHRoYXQgb25seSAuYWpzb24gZmlsZXMgYXJlIHByb2Nlc3NlZCBhbmQgaGFuZGxlcyBKU09OIHBhcnNpbmcgYW5kIGl0ZW0gaW5zdGFudGlhdGlvbi5cbiAgICovXG4gIGFzeW5jIGxvYWQoKSB7XG4gICAgY29uc29sZS5sb2coXCJMb2FkaW5nIGNvbGxlY3Rpb24gaXRlbXNcIik7XG4gICAgaWYoIShhd2FpdCB0aGlzLmFkYXB0ZXIuZXhpc3RzKHRoaXMuZGF0YV9wYXRoKSkpIGF3YWl0IHRoaXMuYWRhcHRlci5ta2Rpcih0aGlzLmRhdGFfcGF0aCk7XG4gICAgY29uc3QgZmlsZXMgPSAoYXdhaXQgdGhpcy5hZGFwdGVyLmxpc3QodGhpcy5kYXRhX3BhdGgpKS5maWxlczsgLy8gTGlzdCBhbGwgZmlsZXMgaW4gdGhlIGRpcmVjdG9yeVxuICAgIGZvciAoY29uc3QgZmlsZV9wYXRoIG9mIGZpbGVzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZmlsZV9wYXRoLmVuZHNXaXRoKCcuYWpzb24nKSkgeyAvLyBFbnN1cmUgaXQncyBhbiAuYWpzb24gZmlsZVxuICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLmFkYXB0ZXIucmVhZChmaWxlX3BhdGgpO1xuICAgICAgICAgIC8vIGlmIGxhc3QgY2hhciBpcyAsIHJlbW92ZSBpdCBiZWZvcmUgd3JhcHBpbmcgaW4ge30gYW5kIHBhcnNlXG4gICAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoYHske2NvbnRlbnQuZW5kc1dpdGgoJywnKSA/IGNvbnRlbnQuc2xpY2UoMCwgLTEpIDogY29udGVudH19YCk7XG4gICAgICAgICAgbGV0IHBydW5lZCA9ICcnO1xuICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGRhdGEpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZW50aXR5ID0gbmV3ICh0aGlzLmVudi5pdGVtX3R5cGVzW3ZhbHVlLmNsYXNzX25hbWVdKSh0aGlzLmVudiwgdmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5lbnZbZW50aXR5LmNvbGxlY3Rpb25fbmFtZV0uaXRlbXNba2V5XSA9IGVudGl0eTtcbiAgICAgICAgICAgIHBydW5lZCArPSBlbnRpdHkuYWpzb24gKyAnLFxcbic7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgLy8gcGFyc2VkIGRhdGEgcmVtb3ZlcyBhbnkgZHVwbGljYXRlIGtleXMgKHBydW5lZClcbiAgICAgICAgICBhd2FpdCB0aGlzLmFkYXB0ZXIud3JpdGUoZmlsZV9wYXRoLCBwcnVuZWQudHJpbSgpKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiRXJyb3IgbG9hZGluZyBmaWxlOiBcIiArIGZpbGVfcGF0aCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGVyci5zdGFjayk7IC8vIHN0YWNrIHRyYWNlXG4gICAgICB9XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKFwiTG9hZGVkIGNvbGxlY3Rpb24gaXRlbXNcIik7XG4gIH1cblxuICAvKipcbiAgICogU2NoZWR1bGVzIGEgc2F2ZSBvcGVyYXRpb24gdG8gcHJldmVudCBtdWx0aXBsZSBzYXZlcyBoYXBwZW5pbmcgYXQgdGhlIHNhbWUgdGltZS5cbiAgICovXG4gIHNhdmUoKSB7XG4gICAgaWYodGhpcy5zYXZlX3RpbWVvdXQpIGNsZWFyVGltZW91dCh0aGlzLnNhdmVfdGltZW91dCk7XG4gICAgdGhpcy5zYXZlX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHsgdGhpcy5fc2F2ZSgpOyB9LCAxMDAwMCk7XG4gIH1cblxuICAvKipcbiAgICogQXN5bmNocm9ub3VzbHkgc2F2ZXMgbW9kaWZpZWQgY29sbGVjdGlvbiBpdGVtcyB0byB0aGVpciByZXNwZWN0aXZlIC5hanNvbiBmaWxlcy5cbiAgICogQHBhcmFtIHtib29sZWFufSBbZm9yY2U9ZmFsc2VdIC0gRm9yY2VzIHRoZSBzYXZlIG9wZXJhdGlvbiBldmVuIGlmIGl0J3MgY3VycmVudGx5IGZsYWdnZWQgYXMgc2F2aW5nLlxuICAgKi9cbiAgYXN5bmMgX3NhdmUoZm9yY2UgPSBmYWxzZSkge1xuICAgIGxldCBzYXZlZF9jdCA9IDA7XG4gICAgaWYodGhpcy5fc2F2aW5nKSByZXR1cm4gY29uc29sZS5sb2coXCJBbHJlYWR5IHNhdmluZ1wiKTtcbiAgICB0aGlzLl9zYXZpbmcgPSB0cnVlOyAvLyBwcmV2ZW50IG11bHRpcGxlIHNhdmVzIGF0IG9uY2VcbiAgICBzZXRUaW1lb3V0KCgpID0+IHsgdGhpcy5fc2F2aW5nID0gZmFsc2U7IH0sIDEwMDAwKTsgLy8gc2V0IF9zYXZpbmcgdG8gZmFsc2UgYWZ0ZXIgMTAgc2Vjb25kc1xuICAgIGNvbnN0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zb2xlLmxvZyhcIlNhdmluZyBjb2xsZWN0aW9uIGl0ZW1zXCIpO1xuICAgIC8vIGVuc3VyZSBkYXRhX3BhdGggZXhpc3RzXG4gICAgaWYoIShhd2FpdCB0aGlzLmFkYXB0ZXIuZXhpc3RzKHRoaXMuZGF0YV9wYXRoKSkpIGF3YWl0IHRoaXMuYWRhcHRlci5ta2Rpcih0aGlzLmRhdGFfcGF0aCk7XG4gICAgY29uc3QgaXRlbXMgPSBPYmplY3QudmFsdWVzKHRoaXMuaXRlbXMpLmZpbHRlcihpID0+IGkudmVjICYmIGkuY2hhbmdlZCk7XG4gICAgaWYoaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLl9zYXZpbmcgPSBmYWxzZTtcbiAgICAgIGNvbnNvbGUubG9nKFwiTm90aGluZyB0byBzYXZlXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1fZmlsZV9wYXRoID0gYCR7dGhpcy5kYXRhX3BhdGh9LyR7aXRlbS5tdWx0aV9hanNvbl9maWxlX25hbWV9LmFqc29uYDsgLy8gVXNlIGl0ZW0uZmlsZV9uYW1lIGZvciBmaWxlIG5hbWluZ1xuICAgICAgICBhd2FpdCB0aGlzLmFkYXB0ZXIuYXBwZW5kKGl0ZW1fZmlsZV9wYXRoLCAnXFxuJyArIGl0ZW0uYWpzb24gKyAnLCcpO1xuICAgICAgICBzYXZlZF9jdCsrO1xuICAgICAgfVxuICAgICAgY29uc3QgZW5kID0gRGF0ZS5ub3coKTsgLy8gbG9nIHRpbWVcbiAgICAgIGNvbnN0IHRpbWUgPSBlbmQgLSBzdGFydDtcbiAgICAgIGNvbnNvbGUubG9nKGBTYXZlZCAke3NhdmVkX2N0fSBjb2xsZWN0aW9uIGl0ZW1zIGluICR7dGltZX1tc2ApO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHNhdmluZyBjb2xsZWN0aW9uIGl0ZW1zXCIpO1xuICAgICAgY29uc29sZS5lcnJvcihlcnIuc3RhY2spO1xuICAgIH1cbiAgICB0aGlzLl9zYXZpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhlIHNhdmUgb3BlcmF0aW9uIGJ5IGNvbXBhcmluZyB0aGUgZmlsZSBzaXplcyBvZiB0aGUgbmV3IGFuZCBvbGQgZmlsZXMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuZXdfZmlsZV9wYXRoIC0gUGF0aCB0byB0aGUgbmV3IGZpbGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvbGRfZmlsZV9wYXRoIC0gUGF0aCB0byB0aGUgb2xkIGZpbGUuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSAtIFRydWUgaWYgdGhlIG5ldyBmaWxlIHNpemUgaXMgYXQgbGVhc3QgNTAlIG9mIHRoZSBvbGQgZmlsZSBzaXplLCBvdGhlcndpc2UgZmFsc2UuXG4gICAqL1xuICBhc3luYyB2YWxpZGF0ZV9zYXZlKG5ld19maWxlX3BhdGgsIG9sZF9maWxlX3BhdGgpIHtcbiAgICBjb25zdCBuZXdfZmlsZV9zaXplID0gKGF3YWl0IHRoaXMuYWRhcHRlci5zdGF0KG5ld19maWxlX3BhdGgpKT8uc2l6ZTtcbiAgICBjb25zdCBvbGRfZmlsZV9zaXplID0gKGF3YWl0IHRoaXMuYWRhcHRlci5zdGF0KG9sZF9maWxlX3BhdGgpKT8uc2l6ZTtcbiAgICBpZighb2xkX2ZpbGVfc2l6ZSkgcmV0dXJuIHRydWU7XG4gICAgY29uc29sZS5sb2coXCJOZXcgZmlsZSBzaXplOiBcIiArIG5ld19maWxlX3NpemUgKyBcIiBieXRlc1wiKTtcbiAgICBjb25zb2xlLmxvZyhcIk9sZCBmaWxlIHNpemU6IFwiICsgb2xkX2ZpbGVfc2l6ZSArIFwiIGJ5dGVzXCIpO1xuICAgIHJldHVybiBuZXdfZmlsZV9zaXplID4gKG9sZF9maWxlX3NpemUgKiAwLjUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGRhdGEgcGF0aCBmb3Igc3RvcmluZyAuYWpzb24gZmlsZXMsIGFwcGVuZGluZyAnL211bHRpJyB0byB0aGUgYmFzZSBwYXRoLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZGF0YSBwYXRoIGZvciAuYWpzb24gZmlsZXMuXG4gICAqL1xuICBnZXQgZGF0YV9wYXRoKCkgeyByZXR1cm4gc3VwZXIuZGF0YV9wYXRoICsgJy9tdWx0aSc7IH1cbn1cblxuZXhwb3J0cy5PYnNNdWx0aUFKU09OID0gT2JzTXVsdGlBSlNPTjsiLCAiY29uc3QgeyBMb25nVGVybU1lbW9yeTogTFRNIH0gPSByZXF1aXJlKCcuL2xvbmdfdGVybV9tZW1vcnkuanMnKTtcbi8vIE9SQ0hFU1RSQVRPUiBDTEFTU1xuY2xhc3MgU21hcnRFbnYge1xuICBjb25zdHJ1Y3RvcihsdG1fYWRhcHRlciA9IExUTSkge1xuICAgIHRoaXMuY29uZmlnID0ge307XG4gICAgdGhpcy5pdGVtX3R5cGVzID0ge307XG4gICAgdGhpcy5jb2xsZWN0aW9ucyA9IHt9O1xuICAgIHRoaXMubHRtX2FkYXB0ZXIgPSBsdG1fYWRhcHRlcjtcbiAgICB0aGlzLmRhdGFfcGF0aCA9ICcuL3Rlc3QvZGF0YSc7XG4gIH1cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmxvYWRfY29sbGVjdGlvbnMoKTtcbiAgfVxuICBsb2FkX2NvbGxlY3Rpb25zKCkge1xuICAgIE9iamVjdC5lbnRyaWVzKHRoaXMuY29sbGVjdGlvbnMpLm1hcCgoW2NvbGxlY3Rpb25fbmFtZSwgY29sbGVjdGlvbl0pID0+IHRoaXNbY29sbGVjdGlvbl9uYW1lXSA9IGNvbGxlY3Rpb24ubG9hZCh0aGlzKSk7XG4gIH1cbiAgZ2V0X3JlZihyZWYpIHsgcmV0dXJuIHRoaXNbcmVmLmNvbGxlY3Rpb25fbmFtZV0uZ2V0KHJlZi5rZXkpOyB9XG59XG5leHBvcnRzLlNtYXJ0RW52ID0gU21hcnRFbnY7XG5cbiIsICJjb25zdCB7IFNtYXJ0RW52IH0gPSByZXF1aXJlKCcuL2Vudi5qcycpO1xuLy8gY29uc3QgeyBMb25nVGVybU1lbW9yeTogTFRNIH0gPSByZXF1aXJlKCcuL2xvbmdfdGVybV9tZW1vcnkuanMnKTtcbi8vIE9SQ0hFU1RSQVRPUiBDTEFTU1xuLy8gY2xhc3MgQnJhaW4ge1xuLy8gICBjb25zdHJ1Y3RvcihsdG1fYWRhcHRlciA9IExUTSkge1xuLy8gICAgIHRoaXMuY29uZmlnID0ge307XG4vLyAgICAgdGhpcy5pdGVtX3R5cGVzID0ge307XG4vLyAgICAgdGhpcy5jb2xsZWN0aW9ucyA9IHt9O1xuLy8gICAgIHRoaXMubHRtX2FkYXB0ZXIgPSBsdG1fYWRhcHRlcjtcbi8vICAgICB0aGlzLmRhdGFfcGF0aCA9ICcuL3Rlc3QvZGF0YSc7XG4vLyAgIH1cbi8vICAgaW5pdCgpIHtcbi8vICAgICB0aGlzLmxvYWRfY29sbGVjdGlvbnMoKTtcbi8vICAgfVxuLy8gICBsb2FkX2NvbGxlY3Rpb25zKCkge1xuLy8gICAgIE9iamVjdC5lbnRyaWVzKHRoaXMuY29sbGVjdGlvbnMpLm1hcCgoW2NvbGxlY3Rpb25fbmFtZSwgY29sbGVjdGlvbl0pID0+IHRoaXNbY29sbGVjdGlvbl9uYW1lXSA9IGNvbGxlY3Rpb24ubG9hZCh0aGlzKSk7XG4vLyAgIH1cbi8vICAgZ2V0X3JlZihyZWYpIHsgcmV0dXJuIHRoaXNbcmVmLmNvbGxlY3Rpb25fbmFtZV0uZ2V0KHJlZi5rZXkpOyB9XG4vLyB9XG5leHBvcnRzLkJyYWluID0gU21hcnRFbnY7IiwgIi8qKlxuICogU21hcnRNYXJrZG93biBpcyBhIGNsYXNzIGRlc2lnbmVkIHRvIHBhcnNlIGFuZCBtYW5pcHVsYXRlIG1hcmtkb3duIGNvbnRlbnRcbiAqIGJhc2VkIG9uIHNwZWNpZmllZCBjb25maWd1cmF0aW9ucy4gSXQgcHJvdmlkZXMgZnVuY3Rpb25hbGl0aWVzIHRvIGV4dHJhY3RcbiAqIHNwZWNpZmljIGJsb2NrcyBvZiB0ZXh0IGJhc2VkIG9uIGhlYWRpbmcgcGF0aHMsIGhhbmRsZSBleGNsdXNpb25zIG9mIGNlcnRhaW5cbiAqIGhlYWRpbmdzLCBhbmQgbWFuYWdlIHRoZSBzaXplIG9mIHRleHQgYmxvY2tzIGFjY29yZGluZyB0byBtYXhpbXVtIGFuZCBtaW5pbXVtXG4gKiBjaGFyYWN0ZXIgbGltaXRzLlxuICovXG5jbGFzcyBTbWFydE1hcmtkb3duIHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBmb3IgdGhlIFNtYXJ0TWFya2Rvd24gcGFyc2VyLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBEZWZhdWx0IGNvbmZpZ3VyYXRpb24gc2V0dGluZ3MuXG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBleGNsdWRlZF9oZWFkaW5nczogbnVsbCwgLy8gY29tbWEgc2VwYXJhdGVkIGxpc3Qgb2YgaGVhZGluZ3MgdG8gZXhjbHVkZVxuICAgICAgZW1iZWRfaW5wdXRfbWF4X2NoYXJzOiAxMDAwLCAvLyBtYXggbGVuZ3RoIG9mIGJsb2NrXG4gICAgICBlbWJlZF9pbnB1dF9taW5fY2hhcnM6IDUwLCAvLyBtaW4gbGVuZ3RoIG9mIGJsb2NrXG4gICAgICBza2lwX2Jsb2Nrc193aXRoX2hlYWRpbmdzX29ubHk6IGZhbHNlLCAvLyBza2lwIGJsb2NrcyB0aGF0IG9ubHkgY29udGFpbiBoZWFkaW5nc1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgU21hcnRNYXJrZG93biB3aXRoIHRoZSBnaXZlbiBjb25maWd1cmF0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIC0gVXNlci1kZWZpbmVkIGNvbmZpZ3VyYXRpb24gc2V0dGluZ3MuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IHsuLi5TbWFydE1hcmtkb3duLmRlZmF1bHRzLCAuLi5jb25maWd9O1xuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGxpc3Qgb2YgaGVhZGluZ3MgdG8gYmUgZXhjbHVkZWQgZnJvbSBwYXJzaW5nLCBpZiBhbnkuXG4gICAqIEByZXR1cm5zIHtBcnJheXxudWxsfSBBbiBhcnJheSBvZiBoZWFkaW5ncyB0byBleGNsdWRlLCBvciBudWxsIGlmIG5vbmUuXG4gICAqL1xuICBnZXQgZXhjbHVkZWRfaGVhZGluZ3MoKSB7ICh0aGlzLmNvbmZpZy5leGNsdWRlZF9oZWFkaW5ncz8ubGVuZ3RoKSA/IHRoaXMuY29uZmlnLmV4Y2x1ZGVkX2hlYWRpbmdzLnNwbGl0KFwiLFwiKS5tYXAoKGhlYWRlcikgPT4gaGVhZGVyLnRyaW0oKSkgOiBudWxsOyB9XG4gIC8qKlxuICAgKiBBbmFseXplcyB0aGUgbWFya2Rvd24gY29udGVudCB0byBleHRyYWN0IG1ldGFkYXRhIGFib3V0IGVhY2ggaGVhZGluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnQgLSBUaGUgbWFya2Rvd24gY29udGVudCB0byBhbmFseXplLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IG9mIG9iamVjdHMgY29udGFpbmluZyBtZXRhZGF0YSBhYm91dCBlYWNoIGhlYWRpbmcuXG4gICAqLyAgXG4gIC8vIFdJUFxuICBnZXRfaGVhZGluZ3NfbWV0YShjb250ZW50KSB7XG4gICAgcmV0dXJuIGNvbnRlbnQuc3BsaXQoJ1xcbicpLnJlZHVjZSgoYWNjLCBsaW5lLCBsaW5lX2ksIGxpbmVzKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuaXNfaGVhZGluZyhsaW5lKSkgcmV0dXJuIGFjYztcbiAgICAgIGNvbnN0IGNoYXJzX3VudGlsX25leHRfaGVhZGluZyA9IGxpbmVzLnNsaWNlKGxpbmVfaSArIDEpLmZpbmRJbmRleChsaW5lID0+IHRoaXMuaXNfaGVhZGluZyhsaW5lKSk7XG4gICAgICBjb25zdCBoZWFkaW5nX2xldmVsID0gbGluZS5zcGxpdCgnIycpLmxlbmd0aCAtIDE7XG4gICAgICBjb25zdCBoZWFkaW5nX3RleHQgPSBsaW5lLnJlcGxhY2UoLyMvZywgJycpLnRyaW0oKTtcbiAgICAgIGFjYy5wdXNoID0geyBsaW5lX2ksIGhlYWRpbmdfbGV2ZWwsIGhlYWRpbmdfdGV4dCwgY2hhcnNfdW50aWxfbmV4dF9oZWFkaW5nIH07XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKTtcbiAgfVxuXG4gIC8vIHYxXG4gIC8vIGdldCBibG9jayBmcm9tIHBhdGhcbiAgLyoqXG4gICAqIEV4dHJhY3RzIGEgc3BlY2lmaWMgYmxvY2sgb2YgbWFya2Rvd24gYmFzZWQgb24gYSBoZWFkaW5nIHBhdGguXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBibG9ja19wYXRoIC0gVGhlIHBhdGggdG8gdGhlIGJsb2NrLCBzcGVjaWZpZWQgYXMgYSBzZXJpZXMgb2YgaGVhZGluZ3MuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrZG93biAtIFRoZSBtYXJrZG93biBjb250ZW50IHRvIHBhcnNlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIE9wdGlvbnMgZm9yIGJsb2NrIGV4dHJhY3Rpb24sIHN1Y2ggYXMgY2hhcmFjdGVyIGxpbWl0cyBwZXIgbGluZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGV4dHJhY3RlZCBibG9jayBvZiBtYXJrZG93biB0ZXh0LlxuICAgKi9cbiAgZ2V0X2Jsb2NrX2Zyb21fcGF0aChibG9ja19wYXRoLCBtYXJrZG93biwgb3B0cz17fSl7XG4gICAgLy8gaWYgYmxvY2tfcGF0aCBlbmRzIHdpdGggIyBhbmQgb25seSBvbmUgIyB0aGVuIHJldHVybnMgY29udGVudCBwcmlvciB0byBmaXJzdCBoZWFkaW5nXG4gICAgaWYoYmxvY2tfcGF0aC5lbmRzV2l0aCgnIycpICYmIGJsb2NrX3BhdGguc3BsaXQoJyMnKS5sZW5ndGggPT09IDIpIHJldHVybiBtYXJrZG93bi5zcGxpdCgnIycpWzBdO1xuICAgIGlmKCF0aGlzLnZhbGlkYXRlX2Jsb2NrX3BhdGgoYmxvY2tfcGF0aCkpIHJldHVybiBtYXJrZG93bjtcbiAgICBjb25zdCB7XG4gICAgICBjaGFyc19wZXJfbGluZSA9IG51bGwsXG4gICAgICBtYXhfY2hhcnMgPSB0aGlzLmNvbmZpZy5lbWJlZF9pbnB1dF9tYXhfY2hhcnMsXG4gICAgICBtaW5fY2hhcnMgPSB0aGlzLmNvbmZpZy5lbWJlZF9pbnB1dF9taW5fY2hhcnMsXG4gICAgfSA9IG9wdHM7XG4gICAgY29uc3QgYmxvY2sgPSBbXTtcbiAgICBjb25zdCBibG9ja19oZWFkaW5ncyA9IGJsb2NrX3BhdGguc3BsaXQoXCIjXCIpLnNsaWNlKDEpO1xuICAgIGxldCBjdXJyZW50SGVhZGVycyA9IFtdO1xuICAgIGxldCBiZWdpbl9saW5lID0gMDtcbiAgICBsZXQgaXNfY29kZSA9IGZhbHNlO1xuICAgIGxldCBjaGFyX2NvdW50ID0gMDtcbiAgICBsZXQgaGVhZGluZ19vY2N1cnJlbmNlID0gMDtcbiAgICBsZXQgb2NjdXJyZW5jZV9jb3VudCA9IDA7XG4gICAgaWYoYmxvY2tfaGVhZGluZ3NbYmxvY2tfaGVhZGluZ3MubGVuZ3RoLTFdLmluZGV4T2YoJ3snKSA+IC0xKSB7XG4gICAgICBoZWFkaW5nX29jY3VycmVuY2UgPSBwYXJzZUludChibG9ja19oZWFkaW5nc1tibG9ja19oZWFkaW5ncy5sZW5ndGgtMV0uc3BsaXQoJ3snKVsxXS5yZXBsYWNlKCd9JywgJycpKTsgLy8gZ2V0IHRoZSBvY2N1cnJlbmNlIG51bWJlclxuICAgICAgYmxvY2tfaGVhZGluZ3NbYmxvY2tfaGVhZGluZ3MubGVuZ3RoLTFdID0gYmxvY2tfaGVhZGluZ3NbYmxvY2tfaGVhZGluZ3MubGVuZ3RoLTFdLnNwbGl0KCd7JylbMF07IC8vIHJlbW92ZSB0aGUgb2NjdXJyZW5jZSBmcm9tIHRoZSBsYXN0IGhlYWRpbmdcbiAgICB9XG4gICAgY29uc3QgbGluZXMgPSBtYXJrZG93bi5zcGxpdCgnXFxuJyk7XG4gICAgbGV0IGJsb2NrX2hlYWRpbmdfbGV2ZWwgPSAwO1xuICAgIC8vIEZJTkQgSEVBRElOR1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXTtcbiAgICAgIGlmKGxpbmUuaW5kZXhPZignYGBgJykgPT09IDApIGlzX2NvZGUgPSAhaXNfY29kZTsgLy8gaWYgbGluZSBiZWdpbnMgd2l0aCB0aHJlZSBiYWNrdGlja3MgdGhlbiB0b2dnbGUgaXNfY29kZVxuICAgICAgaWYoaXNfY29kZSkgY29udGludWU7IC8vIGlmIGlzX2NvZGUgaXMgdHJ1ZSB0aGVuIGFkZCBsaW5lIHdpdGggcHJlY2VkaW5nIHRhYiBhbmQgY29udGludWVcbiAgICAgIGlmKFsnLSAnLCAnLSBbIF0gJ10uaW5kZXhPZihsaW5lKSA+IC0xKSBjb250aW51ZTsgLy8gc2tpcCBpZiBsaW5lIGlzIGVtcHR5IGJ1bGxldCBvciBjaGVja2JveFxuICAgICAgaWYgKCF0aGlzLmlzX2hlYWRpbmcobGluZSkpIGNvbnRpbnVlOyAvLyBza2lwIGlmIGxpbmUgaXMgbm90IGEgaGVhZGluZ1xuICAgICAgYmxvY2tfaGVhZGluZ19sZXZlbCA9IHRoaXMuaGVhZGluZ19sZXZlbChsaW5lKTsgLy8gZ2V0IHRoZSBoZWFkaW5nICdsZXZlbCdcbiAgICAgIGNvbnN0IGhlYWRpbmdfdGV4dCA9IGxpbmUucmVwbGFjZSgvIy9nLCAnJykudHJpbSgpOyAvLyBnZXQgdGhlIGhlYWRpbmcgdGV4dFxuICAgICAgY29uc3QgaGVhZGluZ19pbmRleCA9IGJsb2NrX2hlYWRpbmdzLmluZGV4T2YoaGVhZGluZ190ZXh0KTtcbiAgICAgIGlmIChoZWFkaW5nX2luZGV4IDwgMCkgY29udGludWU7IC8vIGNvbnRpbnVlIGlmIGhlYWRpbmcgdGV4dCBpcyBub3QgaW4gYmxvY2tfaGVhZGluZ3NcbiAgICAgIGlmIChjdXJyZW50SGVhZGVycy5sZW5ndGggIT09IGhlYWRpbmdfaW5kZXgpIGNvbnRpbnVlOyAvLyBpZiBjdXJyZW50SGVhZGVycy5sZW5ndGggIT09IGhlYWRpbmdfaW5kZXggdGhlbiB3ZSBoYXZlIGEgbWlzbWF0Y2hcbiAgICAgIGN1cnJlbnRIZWFkZXJzLnB1c2goaGVhZGluZ190ZXh0KTsgLy8gcHVzaCB0aGUgaGVhZGluZyB0ZXh0IHRvIHRoZSBjdXJyZW50SGVhZGVycyBhcnJheVxuICAgICAgaWYgKGN1cnJlbnRIZWFkZXJzLmxlbmd0aCA9PT0gYmxvY2tfaGVhZGluZ3MubGVuZ3RoKSB7IC8vIGlmIGN1cnJlbnRIZWFkZXJzLmxlbmd0aCA9PT0gYmxvY2tfaGVhZGluZ3MubGVuZ3RoIHRoZW4gd2UgaGF2ZSBhIG1hdGNoXG4gICAgICAgIGlmKGhlYWRpbmdfb2NjdXJyZW5jZSA9PT0gMCl7XG4gICAgICAgICAgYmVnaW5fbGluZSA9IGkgKyAxO1xuICAgICAgICAgIGJyZWFrOyAvLyBicmVhayBvdXQgb2YgbG9vcFxuICAgICAgICB9XG4gICAgICAgIGlmKG9jY3VycmVuY2VfY291bnQgPT09IGhlYWRpbmdfb2NjdXJyZW5jZSl7XG4gICAgICAgICAgYmVnaW5fbGluZSA9IGkgKyAxO1xuICAgICAgICAgIGJyZWFrOyAvLyBicmVhayBvdXQgb2YgbG9vcFxuICAgICAgICB9XG4gICAgICAgIG9jY3VycmVuY2VfY291bnQrKzsgLy8gaW5jcmVtZW50IG9jY3VycmVuY2VfY291bnRcbiAgICAgICAgY3VycmVudEhlYWRlcnMucG9wKCk7IC8vIHJlc2V0IGN1cnJlbnRIZWFkZXJzXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBCVUlMRCBCTE9DS1xuICAgIGlmIChiZWdpbl9saW5lID09PSAwKSByZXR1cm4gJyc7IC8vIGlmIG5vIGJlZ2luX2xpbmUgdGhlbiBoZWFkaW5nIG5vdCBmb3VuZFxuICAgIGlzX2NvZGUgPSBmYWxzZTsgLy8gaXRlcmF0ZSB0aHJvdWdoIGxpbmVzIHN0YXJ0aW5nIGF0IGJlZ2luX2xpbmVcbiAgICBmb3IgKGxldCBpID0gYmVnaW5fbGluZTsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgLy8gaWYobGluZS50cmltKCkubGVuZ3RoID09PSAwKSBjb250aW51ZTsgLy8gaWYgbGluZSBpcyBlbXB0eSwgc2tpcCAvLyBETzogbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZVxuICAgICAgaWYodGhpcy5pc19oZWFkaW5nKGxpbmUpICYmICh0aGlzLmhlYWRpbmdfbGV2ZWwobGluZSkgPD0gYmxvY2tfaGVhZGluZ19sZXZlbCkpIGJyZWFrOyAvLyBpZiBsaW5lIGlzIGEgaGVhZGluZyBhbmQgaGVhZGluZ19sZXZlbCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYmxvY2tfaGVhZGluZ19sZXZlbCwgYnJlYWtcbiAgICAgIC8vIHZhbGlkYXRlL2Zvcm1hdFxuICAgICAgaWYgKGNoYXJzX3Blcl9saW5lICYmIChsaW5lLmxlbmd0aCA+IGNoYXJzX3Blcl9saW5lKSkgbGluZSA9IGxpbmUuc2xpY2UoMCwgY2hhcnNfcGVyX2xpbmUpICsgXCIuLi5cIjsgLy8gbGltaXQgbGVuZ3RoIG9mIGxpbmUgdG8gTiBjaGFyYWN0ZXJzXG4gICAgICBpZiAobGluZS5zdGFydHNXaXRoKFwiYGBgXCIpKSBpc19jb2RlID0gIWlzX2NvZGU7IC8vIGlmIGxpbmUgaXMgYSBjb2RlIGJsb2NrLCBza2lwXG4gICAgICBibG9jay5wdXNoKGxpbmUpOyAvLyBhZGQgbGluZSB0byBibG9ja1xuICAgICAgY2hhcl9jb3VudCArPSBsaW5lLmxlbmd0aDsgLy8gaW5jcmVtZW50IGNoYXJfY291bnRcbiAgICAgIGlmKG1heF9jaGFycyAmJiAoY2hhcl9jb3VudCA+IG1heF9jaGFycykpe1xuICAgICAgICBjb25zdCBkaWZmID0gY2hhcl9jb3VudCAtIG1heF9jaGFycztcbiAgICAgICAgYmxvY2tbYmxvY2subGVuZ3RoLTFdID0gYmxvY2tbYmxvY2subGVuZ3RoLTFdLnNsaWNlKDAsIGJsb2NrW2Jsb2NrLmxlbmd0aC0xXS5sZW5ndGggLSBkaWZmKSArIFwiLi4uXCI7XG4gICAgICAgIGJyZWFrOyAvLyBicmVhayBpZiBjaGFyX2NvdW50IGlzIGdyZWF0ZXIgdGhhbiBtYXhfY2hhcnNcbiAgICAgIH1cbiAgICAgIGlmKG1heF9jaGFycyAmJiAobWF4X2NoYXJzIC0gY2hhcl9jb3VudCA8IDEwKSkgYnJlYWs7IC8vIGJyZWFrIGlmIG1heF9jaGFycyAtIGNoYXJfY291bnQgaXMgbGVzcyB0aGFuIHRocmVzaG9sZFxuICAgIH1cbiAgICBpZiAoaXNfY29kZSkgYmxvY2sucHVzaChcImBgYFwiKTsgLy8gY2xvc2UgY29kZSBibG9jayBpZiBvcGVuXG4gICAgcmV0dXJuIGJsb2NrLmpvaW4oXCJcXG5cIikudHJpbSgpO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZXMgdGhlIG1hcmtkb3duIGNvbnRlbnQgYW5kIG9yZ2FuaXplcyBpdCBpbnRvIHN0cnVjdHVyZWQgYmxvY2tzIGJhc2VkIG9uIGhlYWRpbmdzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gUGFyYW1ldGVycyBjb250YWluaW5nIGNvbnRlbnQgYW5kIG9wdGlvbmFsIGZpbGUgcGF0aC5cbiAgICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgcGFyc2VkIGJsb2NrcyBhbmQgb3RoZXIgbWV0YWRhdGEuXG4gICAqL1xuICBwYXJzZSh7IGNvbnRlbnQsIGZpbGVfcGF0aD0nJyB9KSB7XG4gICAgY29uc3QgZmlsZV9icmVhZGNydW1icyA9IHRoaXMuZmlsZV9wYXRoX3RvX2JyZWFkY3J1bWJzKGZpbGVfcGF0aCkgKyBcIjogXCI7IC8vIGFkZCBcIjpcIiB0byBpbmRpY2F0ZSBiZWdpbm5pbmcgb2YgaGVhZGluZyBicmVhZGNydW1ic1xuICAgIC8vIGlmIGlzIGV4Y2FsaWRyYXcgZmlsZSwgYmxvY2sgZm9yICdUZXh0IEVsZW1lbnRzJyBoZWFkaW5nIG9ubHlcbiAgICBpZihmaWxlX3BhdGguZW5kc1dpdGgoJy5leGNhbGlkcmF3Lm1kJykpIHtcbiAgICAgIGNvbnN0IGV4Y2FsaWRyYXdfYmxvY2sgPSB0aGlzLmdldF9ibG9ja19mcm9tX3BhdGgoZmlsZV9wYXRoICsgXCIjVGV4dCBFbGVtZW50c1wiLCBjb250ZW50KS5yZXBsYWNlKCdcXG4lJScsICcnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJsb2NrczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRleHQ6IGV4Y2FsaWRyYXdfYmxvY2ssXG4gICAgICAgICAgICBwYXRoOiBmaWxlX3BhdGggKyBcIiNUZXh0IEVsZW1lbnRzXCIsXG4gICAgICAgICAgICBsZW5ndGg6IGV4Y2FsaWRyYXdfYmxvY2subGVuZ3RoLFxuICAgICAgICAgICAgaGVhZGluZzogXCJUZXh0IEVsZW1lbnRzXCIsXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBsb2c6IFtdLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBvdXRwdXQgPSBjb250ZW50LnNwbGl0KCdcXG4nKSAvLyBzcGxpdCB0aGUgbWFya2Rvd24gaW50byBsaW5lc1xuICAgICAgLnJlZHVjZSgoYWNjLCBsaW5lLCBpLCBhcnIpID0+IHtcbiAgICAgICAgLy8gaWYgbGluZSBpcyBhIGhlYWRpbmcgb3IgbGFzdCBsaW5lXG4gICAgICAgIGlmKHRoaXMuaXNfaGVhZGluZyhsaW5lKSAmJiAoIWFjYy5jdXJyX2xldmVsIHx8ICF0aGlzLmNvbmZpZy5tdWx0aV9oZWFkaW5nX2Jsb2NrcyB8fCAodGhpcy5oZWFkaW5nX2xldmVsKGxpbmUpIDw9IGFjYy5jdXJyX2xldmVsKSB8fCAoYWNjLmN1cnIubGVuZ3RoID4gdGhpcy5jb25maWcuZW1iZWRfaW5wdXRfbWF4X2NoYXJzKSkpe1xuICAgICAgICAgIHRoaXMub3V0cHV0X2Jsb2NrKGFjYyk7XG4gICAgICAgICAgYWNjLmN1cnJfbGV2ZWwgPSB0aGlzLmhlYWRpbmdfbGV2ZWwobGluZSk7IC8vIGdldCB0aGUgaGVhZGluZyAnbGV2ZWwnXG4gICAgICAgICAgYWNjLmN1cnJlbnRfaGVhZGVycyA9IGFjYy5jdXJyZW50X2hlYWRlcnMuZmlsdGVyKGhlYWRlciA9PiBoZWFkZXIubGV2ZWwgPCBhY2MuY3Vycl9sZXZlbCk7IC8vIHJlbW92ZSBhbnkgaGVhZGVycyBmcm9tIHRoZSBjdXJyZW50IGhlYWRlcnMgYXJyYXkgdGhhdCBhcmUgaGlnaGVyIHRoYW4gdGhlIGN1cnJlbnQgaGVhZGVyIGxldmVsXG4gICAgICAgICAgYWNjLmN1cnJlbnRfaGVhZGVycy5wdXNoKHsgaGVhZGVyOiBsaW5lLnJlcGxhY2UoLyMvZywgJycpLnRyaW0oKSwgbGV2ZWw6IGFjYy5jdXJyX2xldmVsIH0pOyAvLyBhZGQgaGVhZGVyIGFuZCBsZXZlbCB0byBjdXJyZW50IGhlYWRlcnMgYXJyYXksIHRyaW0gdGhlIGhlYWRlciB0byByZW1vdmUgXCIjXCIgYW5kIGFueSB0cmFpbGluZyBzcGFjZXNcbiAgICAgICAgICBhY2Muc3RhcnRfbGluZSA9IGk7IC8vIHNldCB0aGUgc3RhcnQgbGluZVxuICAgICAgICAgIGFjYy5jdXJyID0gZmlsZV9icmVhZGNydW1iczsgLy8gaW5pdGlhbGl6ZSB0aGUgYmxvY2sgYnJlYWRjcnVtYnMgd2l0aCBmaWxlLnBhdGggdGhlIGN1cnJlbnQgaGVhZGVyc1xuICAgICAgICAgIGFjYy5jdXJyICs9IGFjYy5jdXJyZW50X2hlYWRlcnMubWFwKGhlYWRlciA9PiBoZWFkZXIuaGVhZGVyKS5qb2luKCcgPiAnKTtcbiAgICAgICAgICBhY2MuYmxvY2tfaGVhZGluZ3MgPSBcIiNcIiArIGFjYy5jdXJyZW50X2hlYWRlcnMubWFwKGhlYWRlciA9PiBoZWFkZXIuaGVhZGVyKS5qb2luKCcjJyk7XG4gICAgICAgICAgdGhpcy5oYW5kbGVfZHVwbGljYXRlX2hlYWRpbmdzKGFjYyk7XG4gICAgICAgICAgYWNjLmJsb2NrX2hlYWRpbmdzX2xpc3QucHVzaChhY2MuYmxvY2tfaGVhZGluZ3MpO1xuICAgICAgICAgIGFjYy5ibG9ja19wYXRoID0gZmlsZV9wYXRoICsgYWNjLmJsb2NrX2hlYWRpbmdzO1xuICAgICAgICAgIGFjYy5jdXJyX2hlYWRpbmcgPSBsaW5lLnJlcGxhY2UoLyMvZywgJycpLnRyaW0oKTtcbiAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGxpbmUgaXMgbm90IGEgaGVhZGluZywgYWRkIGxpbmUgdG8gY3VycmVudCBibG9ja1xuICAgICAgICBpZih0aGlzLmlzX2NvbnRlbnRfbGluZShsaW5lKSl7XG4gICAgICAgICAgaWYoYWNjLmN1cnIuaW5kZXhPZihcIlxcblwiKSA9PT0gLTEpIGFjYy5jdXJyICs9IFwiOlwiOyAvLyBhZGQgXCI6XCIgdG8gaW5kaWNhdGUgZW5kIG9mIGhlYWRpbmcgYnJlYWRjcnVtYnNcbiAgICAgICAgICBhY2MuY3VyciArPSBcIlxcblwiICsgbGluZTsgLy8gZmlsdGVyIG91dCBlbXB0eSBsaW5lcyBhbmQgYnVsbGV0c1xuICAgICAgICAgIGFjYy5jdXJyX2xpbmUgPSBpOyAvLyBzZXQgdGhlIGN1cnJlbnQgbGluZVxuICAgICAgICB9XG4gICAgICAgIGlmIChpID09PSBhcnIubGVuZ3RoIC0gMSkgdGhpcy5vdXRwdXRfYmxvY2soYWNjKTsgLy8gaWYgbGFzdCBsaW5lLCBvdXRwdXQgdGhlIGJsb2NrXG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LCB7IGJsb2NrX2hlYWRpbmdzOiAnJywgYmxvY2tfaGVhZGluZ3NfbGlzdDogW10sIGJsb2NrX3BhdGg6IGZpbGVfcGF0aCArIFwiI1wiLCBjdXJyOiBmaWxlX2JyZWFkY3J1bWJzLCBjdXJyZW50X2hlYWRlcnM6IFtdLCBibG9ja3M6IFtdLCBsb2c6IFtdLCBzdGFydF9saW5lOiAwLCBjdXJyX2xpbmU6IDAsIGN1cnJfaGVhZGluZzogbnVsbCB9KVxuICAgIDtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ub3V0cHV0LFxuICAgICAgZmlsZV9wYXRoLFxuICAgICAgLy8gcmVtb3ZlIHByb3BlcnRpZXMgdGhhdCBhcmUgZXhjbHVzaXZlIHRvIHRoZSByZWR1Y2UgZnVuY3Rpb25cbiAgICAgIGJsb2NrX2hlYWRpbmdzOiB1bmRlZmluZWQsXG4gICAgICBibG9ja19oZWFkaW5nc19saXN0OiB1bmRlZmluZWQsXG4gICAgICBibG9ja19wYXRoOiB1bmRlZmluZWQsXG4gICAgICBjdXJyOiB1bmRlZmluZWQsXG4gICAgICBjdXJyZW50X2hlYWRlcnM6IHVuZGVmaW5lZCxcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIGR1cGxpY2F0ZSBoZWFkaW5ncyBieSBhcHBlbmRpbmcgYSB1bmlxdWUgaWRlbnRpZmllciB0byB0aGUgaGVhZGluZyBwYXRoLlxuICAgKiBAcGFyYW0ge09iamVjdH0gYWNjIC0gVGhlIGFjY3VtdWxhdG9yIG9iamVjdCB1c2VkIGluIHJlZHVjZSBmdW5jdGlvbi5cbiAgICovXG4gIC8vIGlmIGJsb2NrX2hlYWRpbmdzIGlzIGFscmVhZHkgaW4gYmxvY2tfaGVhZGluZ3NfbGlzdCB0aGVuIGFkZCBhIG51bWJlciB0byB0aGUgZW5kXG4gIGhhbmRsZV9kdXBsaWNhdGVfaGVhZGluZ3MoYWNjKSB7XG4gICAgaWYgKCFhY2MuYmxvY2tfaGVhZGluZ3NfbGlzdC5pbmNsdWRlcyhhY2MuYmxvY2tfaGVhZGluZ3MpKSByZXR1cm47IC8vIGlmIGJsb2NrX2hlYWRpbmdzIGlzIG5vdCBpbiBibG9ja19oZWFkaW5nc19saXN0IHRoZW4gcmV0dXJuXG4gICAgbGV0IGNvdW50ID0gMTtcbiAgICBjb25zdCB1bmlxdWVIZWFkaW5ncyA9IG5ldyBTZXQoYWNjLmJsb2NrX2hlYWRpbmdzX2xpc3QpO1xuICAgIHdoaWxlICh1bmlxdWVIZWFkaW5ncy5oYXMoYCR7YWNjLmJsb2NrX2hlYWRpbmdzfXske2NvdW50fX1gKSkgeyBjb3VudCsrOyB9XG4gICAgYWNjLmJsb2NrX2hlYWRpbmdzID0gYCR7YWNjLmJsb2NrX2hlYWRpbmdzfXske2NvdW50fX1gO1xuICB9XG4gIC8qKlxuICAgKiBPdXRwdXRzIHRoZSBjdXJyZW50IGJsb2NrIGludG8gdGhlIHN0cnVjdHVyZWQgYmxvY2tzIGFycmF5IGFmdGVyIHZhbGlkYXRpb24uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhY2MgLSBUaGUgYWNjdW11bGF0b3Igb2JqZWN0IHVzZWQgaW4gcmVkdWNlIGZ1bmN0aW9uLlxuICAgKi9cbiAgLy8gcHVzaCB0aGUgY3VycmVudCBibG9jayB0byB0aGUgYmxvY2tzIGFycmF5XG4gIG91dHB1dF9ibG9jayhhY2MpIHtcbiAgICBjb25zdCB7IGVtYmVkX2lucHV0X21heF9jaGFycywgZW1iZWRfaW5wdXRfbWluX2NoYXJzIH0gPSB0aGlzLmNvbmZpZztcbiAgICBpZihhY2MuY3Vyci5pbmRleE9mKFwiXFxuXCIpID09PSAtMSkgcmV0dXJuIGFjYy5sb2cucHVzaChgU2tpcHBpbmcgZW1wdHkgYmxvY2s6ICR7YWNjLmN1cnJ9YCk7IC8vIGluZGljYXRlZCBieSBubyBuZXdsaW5lcyBpbiBibG9ja1xuICAgIGlmKCF0aGlzLnZhbGlkYXRlX2hlYWRpbmcoYWNjLmJsb2NrX2hlYWRpbmdzKSkgcmV0dXJuIGFjYy5sb2cucHVzaChgU2tpcHBpbmcgZXhjbHVkZWQgaGVhZGluZzogJHthY2MuYmxvY2tfaGVhZGluZ3N9YCk7XG4gICAgaWYoYWNjLmN1cnIubGVuZ3RoID4gZW1iZWRfaW5wdXRfbWF4X2NoYXJzKSBhY2MuY3VyciA9IGFjYy5jdXJyLnN1YnN0cmluZygwLCBlbWJlZF9pbnB1dF9tYXhfY2hhcnMpOyAvLyB0cmltIGJsb2NrIHRvIG1heCBsZW5ndGhcbiAgICBjb25zdCBicmVhZGNydW1ic19sZW5ndGggPSBhY2MuY3Vyci5pbmRleE9mKFwiXFxuXCIpICsgMTsgLy8gYnJlYWRjcnVtYnMgbGVuZ3RoIChmaXJzdCBsaW5lIG9mIGJsb2NrKVxuICAgIGNvbnN0IGJsb2NrX2xlbmd0aCA9IGFjYy5jdXJyLmxlbmd0aCAtIGJyZWFkY3J1bWJzX2xlbmd0aDtcbiAgICBpZihibG9ja19sZW5ndGggPCBlbWJlZF9pbnB1dF9taW5fY2hhcnMpIHJldHVybiBhY2MubG9nLnB1c2goYFNraXBwaW5nIGJsb2NrIHNob3J0ZXIgdGhhbiBtaW4gbGVuZ3RoOiAke2FjYy5jdXJyfWApOyAvLyBza2lwIGlmIGJsb2NrIGlzIHNob3J0ZXIgdGhhbiBtaW4gbGVuZ3RoXG4gICAgaWYodGhpcy5jb25maWcuc2tpcF9ibG9ja3Nfd2l0aF9oZWFkaW5nc19vbmx5KXsgLy8gc2tpcCBpZiBhbGwgbGluZXMgYXJlIGhlYWRpbmdzIChleGNlcHQgZmlyc3QgbGluZSB3aGljaCBpcyBicmVhZGNydW1icylcbiAgICAgIGNvbnN0IGJsb2NrX2xpbmVzID0gYWNjLmN1cnIuc3BsaXQoJ1xcbicpO1xuICAgICAgY29uc3QgYmxvY2tfaGVhZGluZ3MgPSBibG9ja19saW5lcy5zbGljZSgxKS5maWx0ZXIobGluZSA9PiB0aGlzLmlzX2hlYWRpbmcobGluZSkpO1xuICAgICAgaWYoYmxvY2tfaGVhZGluZ3MubGVuZ3RoID09PSBibG9ja19saW5lcy5sZW5ndGggLSAxKSByZXR1cm4gYWNjLmxvZy5wdXNoKGBTa2lwcGluZyBibG9jayB3aXRoIG9ubHkgaGVhZGluZ3M6ICR7YWNjLmN1cnJ9YCk7XG4gICAgfVxuICAgIGFjYy5ibG9ja3MucHVzaCh7XG4gICAgICB0ZXh0OiBhY2MuY3Vyci50cmltKCksXG4gICAgICBwYXRoOiBhY2MuYmxvY2tfcGF0aCxcbiAgICAgIGxlbmd0aDogYmxvY2tfbGVuZ3RoLFxuICAgICAgaGVhZGluZzogYWNjLmN1cnJfaGVhZGluZyxcbiAgICAgIGxpbmVzOiBbYWNjLnN0YXJ0X2xpbmUsIGFjYy5jdXJyX2xpbmVdLFxuICAgIH0pOyAvLyBhZGQgYmxvY2sgdG8gYmxvY2tzIGFycmF5XG4gIH1cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgYSBsaW5lIG9mIHRleHQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYXMgY29udGVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGxpbmUgLSBUaGUgbGluZSBvZiB0ZXh0IHRvIGV2YWx1YXRlLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgbGluZSBpcyBjb250ZW50LCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc19jb250ZW50X2xpbmUobGluZSkge1xuICAgIC8vIGlmIChsaW5lID09PSAnJykgcmV0dXJuIGZhbHNlOyAvLyBza2lwIGlmIGxpbmUgaXMgZW1wdHkgLy8gRE86IG1ha2UgdGhpcyBjb25maWd1cmFibGVcbiAgICBpZiAoWyctICcsICctIFsgXSAnXS5pbmRleE9mKGxpbmUpID4gLTEpIHJldHVybiBmYWxzZTsgLy8gc2tpcCBpZiBsaW5lIGlzIGVtcHR5IGJ1bGxldCBvciBjaGVja2JveFxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIGZpbGUgcGF0aCB0byBhIGJyZWFkY3J1bWIgc3RyaW5nIGZvcm1hdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVfcGF0aCAtIFRoZSBmaWxlIHBhdGggdG8gY29udmVydC5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGJyZWFkY3J1bWIgc3RyaW5nLlxuICAgKi9cbiAgZmlsZV9wYXRoX3RvX2JyZWFkY3J1bWJzKGZpbGVfcGF0aCkgeyByZXR1cm4gZmlsZV9wYXRoLnJlcGxhY2UoJy5tZCcsICcnKS5zcGxpdCgnLycpLm1hcChjcnVtYiA9PiBjcnVtYi50cmltKCkpLmZpbHRlcihjcnVtYiA9PiBjcnVtYiAhPT0gJycpLmpvaW4oJyA+ICcpOyB9IC8vIHJlbW92ZSAubWQgZmlsZSBleHRlbnNpb24gYW5kIGNvbnZlcnQgZmlsZV9wYXRoIHRvIGJyZWFkY3J1bWIgZm9ybWF0dGluZ1xuICAvKipcbiAgICogRGV0ZXJtaW5lcyB0aGUgbGV2ZWwgb2YgYSBoZWFkaW5nIGJhc2VkIG9uIHRoZSBudW1iZXIgb2YgJyMnIGNoYXJhY3RlcnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsaW5lIC0gVGhlIGhlYWRpbmcgbGluZSB0byBldmFsdWF0ZS5cbiAgICogQHJldHVybnMge251bWJlcn0gVGhlIGxldmVsIG9mIHRoZSBoZWFkaW5nLlxuICAgKi8gIFxuICBoZWFkaW5nX2xldmVsKGxpbmUpIHsgcmV0dXJuIGxpbmUuc3BsaXQoJyMnKS5sZW5ndGggLSAxOyB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBsaW5lIGlzIGEgaGVhZGluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGxpbmUgLSBUaGUgbGluZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIGxpbmUgaXMgYSBoZWFkaW5nLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsaW5lIC0gVGhlIGxpbmUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBsaW5lIGlzIGEgaGVhZGluZywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAqL1xuICBpc19oZWFkaW5nKGxpbmUpIHsgcmV0dXJuIGxpbmUuc3RhcnRzV2l0aCgnIycpICYmIChbJyMnLCAnICddLmluZGV4T2YobGluZVsxXSkgPiAtMSk7IH0gLy8gY2hlY2sgaWYgbGluZSBpcyBhIGhlYWRpbmcgKHN0YXJ0cyB3aXRoICMgYW5kIHNlY29uZCBjaGFyYWN0ZXIgaXMgc3BhY2Ugb3IgIyBpbmRpY2F0aW5nIG5vdCBhIHRhZylcbiAgLyoqXG4gICAqIFZhbGlkYXRlcyBpZiB0aGUgYmxvY2sgcGF0aCBpcyBjb3JyZWN0bHkgZm9ybWF0dGVkIHRvIGluY2x1ZGUgYXQgbGVhc3Qgb25lIGhlYWRpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBibG9ja19wYXRoIC0gVGhlIGJsb2NrIHBhdGggdG8gdmFsaWRhdGUuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBibG9jayBwYXRoIGlzIHZhbGlkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICB2YWxpZGF0ZV9ibG9ja19wYXRoKGJsb2NrX3BhdGgpIHsgcmV0dXJuIGJsb2NrX3BhdGguaW5kZXhPZihcIiNcIikgPiAtMTsgfSAvLyB2YWxpZGF0ZSBibG9ja19wYXRoIGNvbnRhaW5zIGF0IGxlYXN0IG9uZSBcIiNcIlxuICAvKipcbiAgICogVmFsaWRhdGVzIGEgaGVhZGluZyBhZ2FpbnN0IHRoZSBsaXN0IG9mIGV4Y2x1ZGVkIGhlYWRpbmdzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGVhZGluZ3MgLSBUaGUgaGVhZGluZyB0byB2YWxpZGF0ZS5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIGhlYWRpbmcgaXMgbm90IGV4Y2x1ZGVkLCBmYWxzZSBpZiBpdCBpcy5cbiAgICovICBcbiAgdmFsaWRhdGVfaGVhZGluZyhoZWFkaW5ncykgeyByZXR1cm4gISEhdGhpcy5leGNsdWRlZF9oZWFkaW5ncz8uc29tZShleGNsdXNpb24gPT4gaGVhZGluZ3MuaW5kZXhPZihleGNsdXNpb24pID4gLTEpOyB9IC8vIHZhbGlkYXRlIGhlYWRpbmcgYWdhaW5zdCBleGNsdWRlZCBoZWFkaW5nc1xuXG59XG5leHBvcnRzLlNtYXJ0TWFya2Rvd24gPSBTbWFydE1hcmtkb3duOyIsICIvLyBDb3B5cmlnaHQgKGMpIEJyaWFuIEpvc2VwaCBQZXRyb1xuXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbi8vIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbi8vIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xuLy8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuLy8gaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4vLyBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4vLyBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFXG4vLyBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OXG4vLyBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cbi8vIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5jb25zdCB7IFNtYXJ0TWFya2Rvd24gfSA9IHJlcXVpcmUoJy4vU21hcnRNYXJrZG93bicpO1xuZXhwb3J0cy5TbWFydE1hcmtkb3duID0gU21hcnRNYXJrZG93bjsiLCAiLyoqXG4gKiBDcmVhdGVzIGEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBnaXZlbiBkYXRhIHdpdGhvdXQgdXNpbmcgY3J5cHRvZ3JhcGhpYyBtZXRob2RzLlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgdG8gY3JlYXRlIGEgVUlEIGZvci5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEgdW5pcXVlIGlkZW50aWZpZXIgYmFzZWQgb24gdGhlIGlucHV0IGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZV91aWQoZGF0YSkge1xuICBjb25zdCBzdHIgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgbGV0IGhhc2ggPSAwO1xuICBpZiAoc3RyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGhhc2g7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hhciA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIGNoYXI7XG4gICAgaGFzaCA9IGhhc2ggJiBoYXNoOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgICAvLyByZW1vdmUgbmVnYXRpdmUgc2lnblxuICAgIGlmIChoYXNoIDwgMCkgaGFzaCA9IGhhc2ggKiAtMTtcbiAgfVxuICByZXR1cm4gaGFzaC50b1N0cmluZygpICsgc3RyLmxlbmd0aDtcbn1cbmV4cG9ydHMuY3JlYXRlX3VpZCA9IGNyZWF0ZV91aWQ7XG5cbi8qKlxuICogRGVlcGx5IG1lcmdlcyB0d28gb2JqZWN0cywgZ2l2aW5nIHByZWNlZGVuY2UgdG8gdGhlIHByb3BlcnRpZXMgb2YgdGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IC0gVGhlIHRhcmdldCBvYmplY3QgdG8gbWVyZ2UgcHJvcGVydGllcyBpbnRvLlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSAtIFRoZSBzb3VyY2Ugb2JqZWN0IGZyb20gd2hpY2ggcHJvcGVydGllcyBhcmUgc291cmNlZC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBtZXJnZWQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBkZWVwX21lcmdlKHRhcmdldCwgc291cmNlKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgLy8gYm90aCBleGlzdCBhbmQgYXJlIG9iamVjdHNcbiAgICAgIGlmIChpc19vYmooc291cmNlW2tleV0pICYmIGlzX29iaih0YXJnZXRba2V5XSkpIGRlZXBfbWVyZ2UodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldKTtcbiAgICAgIGVsc2UgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgLy8gcHJlY2VkZW5jZSB0byBzb3VyY2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbiAgZnVuY3Rpb24gaXNfb2JqKGl0ZW0pIHsgcmV0dXJuIChpdGVtICYmIHR5cGVvZiBpdGVtID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShpdGVtKSk7IH1cbn1cbmV4cG9ydHMuZGVlcF9tZXJnZSA9IGRlZXBfbWVyZ2U7XG5cbi8qKlxuICogQ29udmVydHMgYSBjbGFzcyBuYW1lIGZyb20gY2FtZWxDYXNlIHRvIHNuYWtlX2Nhc2UgYW5kIG1ha2VzIHBsdXJhbCBmb3Jtcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc19uYW1lIC0gVGhlIGNsYXNzIG5hbWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBzbmFrZV9jYXNlIGFuZCBwbHVyYWxpemVkIGNsYXNzIG5hbWUuXG4gKi9cbmZ1bmN0aW9uIGNvbGxlY3Rpb25faW5zdGFuY2VfbmFtZV9mcm9tKGNsYXNzX25hbWUpIHtcbiAgcmV0dXJuIGNsYXNzX25hbWVcbiAgICAucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZywgJyQxXyQyJykgLy8gY29udmVydCBjYW1lbENhc2UgdG8gc25ha2VfY2FzZVxuICAgIC50b0xvd2VyQ2FzZSgpIC8vIGNvbnZlcnQgdG8gbG93ZXJjYXNlXG4gICAgLnJlcGxhY2UoL3kkLywgJ2llJykgLy8gZXguIHN1bW1hcmllc1xuICAgICsgJ3MnO1xufVxuZXhwb3J0cy5jb2xsZWN0aW9uX2luc3RhbmNlX25hbWVfZnJvbSA9IGNvbGxlY3Rpb25faW5zdGFuY2VfbmFtZV9mcm9tO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGNvc2luZSBzaW1pbGFyaXR5IGJldHdlZW4gdHdvIHZlY3RvcnMuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHZlY3RvcjEgLSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB2ZWN0b3IyIC0gVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgY29zaW5lIHNpbWlsYXJpdHkgYmV0d2VlbiB0aGUgdHdvIHZlY3RvcnMuXG4gKi9cbmZ1bmN0aW9uIGNvc19zaW0odmVjdG9yMSwgdmVjdG9yMikge1xuICBjb25zdCBkb3RQcm9kdWN0ID0gdmVjdG9yMS5yZWR1Y2UoKGFjYywgdmFsLCBpKSA9PiBhY2MgKyB2YWwgKiB2ZWN0b3IyW2ldLCAwKTtcbiAgY29uc3Qgbm9ybUEgPSBNYXRoLnNxcnQodmVjdG9yMS5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MgKyB2YWwgKiB2YWwsIDApKTtcbiAgY29uc3Qgbm9ybUIgPSBNYXRoLnNxcnQodmVjdG9yMi5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MgKyB2YWwgKiB2YWwsIDApKTtcbiAgcmV0dXJuIG5vcm1BID09PSAwIHx8IG5vcm1CID09PSAwID8gMCA6IGRvdFByb2R1Y3QgLyAobm9ybUEgKiBub3JtQik7XG59XG5leHBvcnRzLmNvc19zaW0gPSBjb3Nfc2ltO1xuXG4vKipcbiAqIE1haW50YWlucyBhIGNvbGxlY3Rpb24gb2YgdG9wIGl0ZW1zIGJhc2VkIG9uIHRoZWlyIHNpbWlsYXJpdHkgbWVhc3VyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBfYWNjIC0gVGhlIGFjY3VtdWxhdG9yIG9iamVjdCB0aGF0IHN0b3JlcyBpdGVtcyBhbmQgdGhlaXIgbWluaW11bSBzaW1pbGFyaXR5LlxuICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gLSBUaGUgbmV3IGl0ZW0gdG8gY29uc2lkZXIgZm9yIGluY2x1c2lvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbY3Q9MTBdIC0gVGhlIGNvdW50IG9mIHRvcCBpdGVtcyB0byBtYWludGFpbi5cbiAqL1xuZnVuY3Rpb24gdG9wX2FjYyhfYWNjLCBpdGVtLCBjdCA9IDEwKSB7XG4gIGlmIChfYWNjLml0ZW1zLnNpemUgPCBjdCkge1xuICAgIF9hY2MuaXRlbXMuYWRkKGl0ZW0pO1xuICB9IGVsc2UgaWYgKGl0ZW0uc2ltID4gX2FjYy5taW4pIHtcbiAgICBfYWNjLml0ZW1zLmFkZChpdGVtKTtcbiAgICBfYWNjLml0ZW1zLmRlbGV0ZShfYWNjLm1pbkl0ZW0pO1xuICAgIF9hY2MubWluSXRlbSA9IEFycmF5LmZyb20oX2FjYy5pdGVtcykucmVkdWNlKChtaW4sIGN1cnIpID0+IChjdXJyLnNpbSA8IG1pbi5zaW0gPyBjdXJyIDogbWluKSk7XG4gICAgX2FjYy5taW4gPSBfYWNjLm1pbkl0ZW0uc2ltO1xuICB9XG59XG5leHBvcnRzLnRvcF9hY2MgPSB0b3BfYWNjO1xuXG4vKipcbiAqIERlbGF5cyB0aGUgZXhlY3V0aW9uIG9mIHRoZSBuZXh0IGxpbmUgaW4gdGhlIGNvZGUgYnkgYSBzcGVjaWZpZWQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtcyAtIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICogQHJldHVybnMge1Byb21pc2V9IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIGFmdGVyIHRoZSBzcGVjaWZpZWQgZGVsYXkuXG4gKi9cbmZ1bmN0aW9uIHNsZWVwKG1zKSB7IHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTsgfVxuZXhwb3J0cy5zbGVlcCA9IHNsZWVwOyIsICJjb25zdCBoZWxwZXJzID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XG5jb25zdCB7XG4gIGNyZWF0ZV91aWQsXG4gIGRlZXBfbWVyZ2UsXG4gIGNvbGxlY3Rpb25faW5zdGFuY2VfbmFtZV9mcm9tLFxufSA9IGhlbHBlcnM7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBpdGVtIHdpdGhpbiBhIGNvbGxlY3Rpb24sIHByb3ZpZGluZyBtZXRob2RzIGZvciBkYXRhIG1hbmlwdWxhdGlvbiwgdmFsaWRhdGlvbiwgYW5kIGludGVyYWN0aW9uIHdpdGggaXRzIGNvbGxlY3Rpb24uXG4gKi9cbmNsYXNzIENvbGxlY3Rpb25JdGVtIHtcbiAgLyoqXG4gICAqIERlZmF1bHQgcHJvcGVydGllcyBmb3IgYW4gaW5zdGFuY2Ugb2YgQ29sbGVjdGlvbkl0ZW0uXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IERlZmF1bHQgZGF0YSBjb25maWd1cmF0aW9uLlxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YToge1xuICAgICAgICBrZXk6IG51bGwsXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBDb2xsZWN0aW9uSXRlbS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGJyYWluIC0gVGhlIGNlbnRyYWwgc3RvcmFnZSBvciBjb250ZXh0LlxuICAgKiBAcGFyYW0ge09iamVjdHxudWxsfSBkYXRhIC0gSW5pdGlhbCBkYXRhIGZvciB0aGUgaXRlbS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVudiwgZGF0YSA9IG51bGwpIHtcbiAgICB0aGlzLmVudiA9IGVudjtcbiAgICB0aGlzLmJyYWluID0gdGhpcy5lbnY7IC8vIERFUFJFQ0FURURcbiAgICB0aGlzLmNvbmZpZyA9IHRoaXMuZW52Py5jb25maWc7XG4gICAgdGhpcy5tZXJnZV9kZWZhdWx0cygpO1xuICAgIGlmIChkYXRhKSB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIGlmKCF0aGlzLmRhdGEuY2xhc3NfbmFtZSkgdGhpcy5kYXRhLmNsYXNzX25hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cblxuICAvKipcbiAgICogTWVyZ2VzIGRlZmF1bHQgcHJvcGVydGllcyBmcm9tIGFsbCBjbGFzc2VzIGluIHRoZSBpbmhlcml0YW5jZSBjaGFpbi5cbiAgICovXG4gIG1lcmdlX2RlZmF1bHRzKCkge1xuICAgIGxldCBjdXJyZW50X2NsYXNzID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICB3aGlsZSAoY3VycmVudF9jbGFzcykgeyAvLyBkZWVwIG1lcmdlIGRlZmF1bHRzXG4gICAgICBmb3IgKGxldCBrZXkgaW4gY3VycmVudF9jbGFzcy5kZWZhdWx0cykge1xuICAgICAgICBpZiAodHlwZW9mIGN1cnJlbnRfY2xhc3MuZGVmYXVsdHNba2V5XSA9PT0gJ29iamVjdCcpIHRoaXNba2V5XSA9IHsgLi4uY3VycmVudF9jbGFzcy5kZWZhdWx0c1trZXldLCAuLi50aGlzW2tleV0gfTtcbiAgICAgICAgZWxzZSB0aGlzW2tleV0gPSBjdXJyZW50X2NsYXNzLmRlZmF1bHRzW2tleV07XG4gICAgICB9XG4gICAgICBjdXJyZW50X2NsYXNzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGN1cnJlbnRfY2xhc3MpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgb3IgcmV0cmlldmVzIGEgdW5pcXVlIGtleSBmb3IgdGhlIGl0ZW0uIENhbiBiZSBvdmVycmlkZGVuIGluIGNoaWxkIGNsYXNzZXMuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSB1bmlxdWUga2V5LlxuICAgKi9cbiAgZ2V0X2tleSgpIHtcbiAgICBjb25zb2xlLmxvZyhcImNhbGxlZCBkZWZhdWx0IGdldF9rZXlcIik7XG4gICAgcmV0dXJuIGNyZWF0ZV91aWQodGhpcy5kYXRhKTtcbiAgfVxuICAvLyB1cGRhdGVfZGF0YSAtIGZvciBkYXRhIGluIHRoaXMuZGF0YVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgZGF0YSBvZiB0aGlzIGl0ZW0gd2l0aCBuZXcgZGF0YS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgbmV3IGRhdGEgZm9yIHRoZSBpdGVtLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBkYXRhIHdhcyBzdWNjZXNzZnVsbHkgdXBkYXRlZC5cbiAgICovXG4gIHVwZGF0ZV9kYXRhKGRhdGEpIHtcbiAgICBkYXRhID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkYXRhLCB0aGlzLnVwZGF0ZV9kYXRhX3JlcGxhY2VyKSk7XG4gICAgZGVlcF9tZXJnZSh0aGlzLmRhdGEsIGRhdGEpOyAvLyBkZWVwIG1lcmdlIGRhdGFcbiAgICByZXR1cm4gdHJ1ZTsgLy8gcmV0dXJuIHRydWUgaWYgZGF0YSBjaGFuZ2VkIChkZWZhdWx0IHRydWUpXG4gIH1cblxuICAvKipcbiAgICogQ3VzdG9tIHJlcGxhY2VyIGZ1bmN0aW9uIGZvciBKU09OLnN0cmluZ2lmeSB1c2VkIGluIHVwZGF0ZV9kYXRhIHRvIGhhbmRsZSBzcGVjaWFsIG9iamVjdCB0eXBlcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IGJlaW5nIHN0cmluZ2lmaWVkLlxuICAgKiBAcGFyYW0ge2FueX0gdmFsdWUgLSBUaGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5IGJlaW5nIHN0cmluZ2lmaWVkLlxuICAgKiBAcmV0dXJucyB7YW55fSBUaGUgdmFsdWUgdG8gYmUgdXNlZCBpbiB0aGUgSlNPTiBzdHJpbmcuXG4gICAqL1xuICB1cGRhdGVfZGF0YV9yZXBsYWNlcihrZXksIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQ29sbGVjdGlvbkl0ZW0pIHJldHVybiB2YWx1ZS5yZWY7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSByZXR1cm4gdmFsdWUubWFwKCh2YWwpID0+ICh2YWwgaW5zdGFuY2VvZiBDb2xsZWN0aW9uSXRlbSkgPyB2YWwucmVmIDogdmFsKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgLy8gaW5pdCAtIGZvciBkYXRhIG5vdCBpbiB0aGlzLmRhdGFcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBpdGVtIHdpdGggaW5wdXRfZGF0YSwgcG90ZW50aWFsbHkgYXN5bmNocm9ub3VzbHkuXG4gICAqIEhhbmRsZXMgaW50ZXJhY3Rpb25zIHdpdGggb3RoZXIgY29sbGVjdGlvbiBpdGVtcy5cbiAgICovXG4gIGluaXQoKSB7IHRoaXMuc2F2ZSgpOyB9IC8vIHNob3VsZCBhbHdheXMgY2FsbCB0aGlzLnNhdmUoKSBpbiBjaGlsZCBjbGFzcyBpbml0KCkgb3ZlcnJpZGVzXG5cbiAgLyoqXG4gICAqIFNhdmVzIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBpdGVtIHRvIGl0cyBjb2xsZWN0aW9uLlxuICAgKi9cbiAgc2F2ZSgpIHtcbiAgICBpZiAoIXRoaXMudmFsaWRhdGVfc2F2ZSgpKSB7XG4gICAgICBpZiAodGhpcy5rZXkpIHRoaXMuY29sbGVjdGlvbi5kZWxldGUodGhpcy5rZXkpO1xuICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIHNhdmU6IFwiLCB7IGRhdGE6IHRoaXMuZGF0YSwgc3RhY2s6IG5ldyBFcnJvcigpLnN0YWNrIH0pO1xuICAgIH1cbiAgICB0aGlzLmNvbGxlY3Rpb24uc2V0KHRoaXMpOyAvLyBzZXQgZW50aXR5IGluIGNvbGxlY3Rpb25cbiAgICB0aGlzLmNvbGxlY3Rpb24uc2F2ZSgpOyAvLyBzYXZlIGNvbGxlY3Rpb25cbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhlIGl0ZW0ncyBkYXRhIGJlZm9yZSBzYXZpbmcuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBkYXRhIGlzIHZhbGlkIGZvciBzYXZpbmcuXG4gICAqL1xuICB2YWxpZGF0ZV9zYXZlKCkge1xuICAgIGlmKCF0aGlzLmtleSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmKHRoaXMua2V5ID09PSAnJykgcmV0dXJuIGZhbHNlO1xuICAgIGlmKHRoaXMua2V5ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgdGhlIGl0ZW0gZnJvbSBpdHMgY29sbGVjdGlvbi5cbiAgICovXG4gIGRlbGV0ZSgpIHsgdGhpcy5jb2xsZWN0aW9uLmRlbGV0ZSh0aGlzLmtleSk7IH1cblxuICAvLyBmdW5jdGlvbmFsIGZpbHRlciAocmV0dXJucyB0cnVlIG9yIGZhbHNlKSBmb3IgZmlsdGVyaW5nIGl0ZW1zIGluIGNvbGxlY3Rpb247IGNhbGxlZCBieSBjb2xsZWN0aW9uIGNsYXNzXG4gIC8qKlxuICAgKiBGaWx0ZXJzIGl0ZW1zIGluIHRoZSBjb2xsZWN0aW9uIGJhc2VkIG9uIHByb3ZpZGVkIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gRmlsdGVyaW5nIG9wdGlvbnMuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBpdGVtIHBhc3NlcyB0aGUgZmlsdGVyLlxuICAgKi9cbiAgZmlsdGVyKG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGV4Y2x1ZGVfa2V5LFxuICAgICAgZXhjbHVkZV9rZXlzID0gZXhjbHVkZV9rZXkgPyBbZXhjbHVkZV9rZXldIDogW10sXG4gICAgICBleGNsdWRlX2tleV9zdGFydHNfd2l0aCxcbiAgICAgIGtleV9lbmRzX3dpdGgsXG4gICAgICBrZXlfc3RhcnRzX3dpdGgsXG4gICAgICBrZXlfc3RhcnRzX3dpdGhfYW55LFxuICAgIH0gPSBvcHRzO1xuICAgIGlmIChleGNsdWRlX2tleXM/LmluY2x1ZGVzKHRoaXMua2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChleGNsdWRlX2tleV9zdGFydHNfd2l0aCAmJiB0aGlzLmtleS5zdGFydHNXaXRoKGV4Y2x1ZGVfa2V5X3N0YXJ0c193aXRoKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChrZXlfZW5kc193aXRoICYmICF0aGlzLmtleS5lbmRzV2l0aChrZXlfZW5kc193aXRoKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChrZXlfc3RhcnRzX3dpdGggJiYgIXRoaXMua2V5LnN0YXJ0c1dpdGgoa2V5X3N0YXJ0c193aXRoKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChrZXlfc3RhcnRzX3dpdGhfYW55ICYmICFrZXlfc3RhcnRzX3dpdGhfYW55LnNvbWUoKHByZWZpeCkgPT4gdGhpcy5rZXkuc3RhcnRzV2l0aChwcmVmaXgpKSkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIE9WRVJSSURFIEZJTFRFUiBMT0dJQyBoZXJlOiBwYXR0ZXJuOiBpZihvcHRzLnBhdHRlcm4gJiYgIXRoaXMuZGF0YVtvcHRzLnBhdHRlcm4ubWF0Y2hlcl0pIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgdGhlIGl0ZW0ncyBkYXRhIGZvciBhbnkgbmVjZXNzYXJ5IHByb2Nlc3Npbmcgb3IgdHJhbnNmb3JtYXRpb24uIFBsYWNlaG9sZGVyIGZvciBvdmVycmlkZSBpbiBjaGlsZCBjbGFzc2VzLlxuICAgKi9cbiAgcGFyc2UoKSB7IH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBjb2xsZWN0aW9uIG5hbWUgZGVyaXZlZCBmcm9tIHRoZSBjbGFzcyBuYW1lLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29sbGVjdGlvbiBuYW1lLlxuICAgKi9cbiAgc3RhdGljIGdldCBjb2xsZWN0aW9uX25hbWUoKSB7IHJldHVybiBjb2xsZWN0aW9uX2luc3RhbmNlX25hbWVfZnJvbSh0aGlzLm5hbWUpOyB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgY29sbGVjdGlvbiBuYW1lIGZvciB0aGUgaW5zdGFuY2UsIGVpdGhlciBmcm9tIGRhdGEgb3IgdGhlIGNsYXNzIG1ldGhvZC5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbGxlY3Rpb24gbmFtZS5cbiAgICovXG4gIGdldCBjb2xsZWN0aW9uX25hbWUoKSB7IHJldHVybiB0aGlzLmRhdGEuY29sbGVjdGlvbl9uYW1lID8gdGhpcy5kYXRhLmNvbGxlY3Rpb25fbmFtZSA6IGNvbGxlY3Rpb25faW5zdGFuY2VfbmFtZV9mcm9tKHRoaXMuZGF0YS5jbGFzc19uYW1lIHx8IHRoaXMuY29uc3RydWN0b3IubmFtZSk7IH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBjb2xsZWN0aW9uIHRoaXMgaXRlbSBiZWxvbmdzIHRvLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgY29sbGVjdGlvbiBvYmplY3QuXG4gICAqL1xuICBnZXQgY29sbGVjdGlvbigpIHsgcmV0dXJuIHRoaXMuZW52W3RoaXMuY29sbGVjdGlvbl9uYW1lXTsgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgb3IgZ2VuZXJhdGVzIHRoZSBrZXkgZm9yIHRoaXMgaXRlbS5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGl0ZW0ncyBrZXkuXG4gICAqL1xuICBnZXQga2V5KCkgeyByZXR1cm4gdGhpcy5kYXRhLmtleSA9IHRoaXMuZGF0YS5rZXkgfHwgdGhpcy5nZXRfa2V5KCk7IH1cblxuICAvKipcbiAgICogUHJvdmlkZXMgYSByZWZlcmVuY2Ugb2JqZWN0IGZvciB0aGlzIGl0ZW0sIGNvbnRhaW5pbmcgdGhlIGNvbGxlY3Rpb24gbmFtZSBhbmQga2V5LlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcmVmZXJlbmNlIG9iamVjdC5cbiAgICovXG4gIGdldCByZWYoKSB7IHJldHVybiB7IGNvbGxlY3Rpb25fbmFtZTogdGhpcy5jb2xsZWN0aW9uX25hbWUsIGtleTogdGhpcy5rZXkgfTsgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIHNlcXVlbmNlIGtleSBmb3IgdGhpcyBpdGVtLCB1c2VkIGZvciBidWlsZGluZyBzZXF1ZW5jZSBrZXlzLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgc2VxdWVuY2Uga2V5LlxuICAgKi9cbiAgZ2V0IHNlcV9rZXkoKSB7IHJldHVybiB0aGlzLmtleTsgfSAvLyB1c2VkIGZvciBidWlsZGluZyBzZXF1ZW5jZSBrZXlzXG59XG5leHBvcnRzLkNvbGxlY3Rpb25JdGVtID0gQ29sbGVjdGlvbkl0ZW07IiwgImNvbnN0IHsgQ29sbGVjdGlvbkl0ZW0gfSA9IHJlcXVpcmUoJy4vQ29sbGVjdGlvbkl0ZW0nKTtcbmNvbnN0IEFzeW5jRnVuY3Rpb24gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYXN5bmMgZnVuY3Rpb24oKXt9KS5jb25zdHJ1Y3RvcjsgLy8gZm9yIGNoZWNraW5nIGlmIGZ1bmN0aW9uIGlzIGFzeW5jXG5jb25zdCBoZWxwZXJzID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XG5jb25zdCB7IGRlZXBfbWVyZ2UsIH0gPSBoZWxwZXJzO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgcmVwcmVzZW50aW5nIGEgY29sbGVjdGlvbiBvZiBpdGVtcyB3aXRoIHZhcmlvdXMgbWV0aG9kcyB0byBtYW5pcHVsYXRlIGFuZCByZXRyaWV2ZSB0aGVzZSBpdGVtcy5cbiAqL1xuY2xhc3MgQ29sbGVjdGlvbiB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IENvbGxlY3Rpb24gaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnYgLSBUaGUgZW52aXJvbm1lbnQgY29udGV4dCBjb250YWluaW5nIGNvbmZpZ3VyYXRpb25zIGFuZCBhZGFwdGVycy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVudikge1xuICAgIHRoaXMuZW52ID0gZW52O1xuICAgIHRoaXMuYnJhaW4gPSB0aGlzLmVudjsgLy8gREVQUkVDQVRFRDogdXNlIGVudiBpbnN0ZWFkIG9mIGJyYWluXG4gICAgdGhpcy5jb25maWcgPSB0aGlzLmVudi5jb25maWc7XG4gICAgdGhpcy5pdGVtcyA9IHt9O1xuICAgIHRoaXMuTFRNID0gdGhpcy5lbnYubHRtX2FkYXB0ZXIud2FrZV91cCh0aGlzLCB0aGlzLmVudi5sdG1fYWRhcHRlcik7XG4gIH1cblxuICAvKipcbiAgICogTG9hZHMgYSBjb2xsZWN0aW9uIGJhc2VkIG9uIHRoZSBlbnZpcm9ubWVudCBhbmQgb3B0aW9uYWwgY29uZmlndXJhdGlvbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IGVudiAtIFRoZSBlbnZpcm9ubWVudCBjb250ZXh0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZz17fV0gLSBPcHRpb25hbCBjb25maWd1cmF0aW9uIGZvciB0aGUgY29sbGVjdGlvbi5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q29sbGVjdGlvbj58Q29sbGVjdGlvbn0gVGhlIGxvYWRlZCBjb2xsZWN0aW9uIGluc3RhbmNlLlxuICAgKi9cbiAgc3RhdGljIGxvYWQoZW52LCBjb25maWcgPSB7fSkge1xuICAgIGNvbnN0IHsgY3VzdG9tX2NvbGxlY3Rpb25fbmFtZSB9ID0gY29uZmlnO1xuICAgIGVudlt0aGlzLmNvbGxlY3Rpb25fbmFtZV0gPSBuZXcgdGhpcyhlbnYpO1xuICAgIGlmIChjdXN0b21fY29sbGVjdGlvbl9uYW1lKSB7XG4gICAgICBlbnZbdGhpcy5jb2xsZWN0aW9uX25hbWVdLmNvbGxlY3Rpb25fbmFtZSA9IGN1c3RvbV9jb2xsZWN0aW9uX25hbWU7XG4gICAgICBlbnYuY29sbGVjdGlvbnNbY3VzdG9tX2NvbGxlY3Rpb25fbmFtZV0gPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgIH1cbiAgICBlbnZbdGhpcy5jb2xsZWN0aW9uX25hbWVdLm1lcmdlX2RlZmF1bHRzKCk7XG4gICAgLy8gcmV0dXJuIHByb21pc2UgaWYgYXN5bmNcbiAgICBpZiAoZW52W3RoaXMuY29sbGVjdGlvbl9uYW1lXS5sb2FkIGluc3RhbmNlb2YgQXN5bmNGdW5jdGlvbikgcmV0dXJuIGVudlt0aGlzLmNvbGxlY3Rpb25fbmFtZV0ubG9hZCgpLnRoZW4oKCkgPT4gZW52W3RoaXMuY29sbGVjdGlvbl9uYW1lXSk7XG4gICAgZWxzZSBlbnZbdGhpcy5jb2xsZWN0aW9uX25hbWVdLmxvYWQoKTtcbiAgICByZXR1cm4gZW52W3RoaXMuY29sbGVjdGlvbl9uYW1lXTtcbiAgfVxuICAvKipcbiAgICogTWVyZ2VzIGRlZmF1bHQgY29uZmlndXJhdGlvbnMgZnJvbSBhbGwgY2xhc3NlcyBpbiB0aGUgaW5oZXJpdGFuY2UgY2hhaW4uXG4gICAqL1xuICBtZXJnZV9kZWZhdWx0cygpIHtcbiAgICBsZXQgY3VycmVudF9jbGFzcyA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgd2hpbGUgKGN1cnJlbnRfY2xhc3MpIHsgLy8gbWVyZ2UgY29sbGVjdGlvbiBjb25maWcgaW50byBpdGVtIGNvbmZpZ1xuICAgICAgY29uc3QgY29sX2NvbmYgPSB0aGlzLmNvbmZpZz8uY29sbGVjdGlvbnM/LltjdXJyZW50X2NsYXNzLmNvbGxlY3Rpb25fbmFtZV07XG4gICAgICBPYmplY3QuZW50cmllcygodHlwZW9mIGNvbF9jb25mID09PSAnb2JqZWN0JykgPyBjb2xfY29uZiA6IHt9KVxuICAgICAgICAuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB0aGlzW2tleV0gPSB2YWx1ZSlcbiAgICAgIDtcbiAgICAgIGN1cnJlbnRfY2xhc3MgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY3VycmVudF9jbGFzcyk7XG4gICAgfVxuICAgIC8vIGNvbnNvbGUubG9nKE9iamVjdC5rZXlzKHRoaXMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTYXZlcyB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICovXG4gIHNhdmUoKSB7IHRoaXMuTFRNLnNhdmUoKTsgfVxuXG4gIC8qKlxuICAgKiBMb2FkcyB0aGUgY29sbGVjdGlvbiBzdGF0ZS5cbiAgICovXG4gIGxvYWQoKSB7IHRoaXMuTFRNLmxvYWQoKTsgfVxuXG4gIC8qKlxuICAgKiBSZXZpdmVzIGl0ZW1zIGZyb20gYSBzZXJpYWxpemVkIHN0YXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSBvZiB0aGUgaXRlbS5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSBzZXJpYWxpemVkIGl0ZW0gdmFsdWUuXG4gICAqIEByZXR1cm5zIHtDb2xsZWN0aW9uSXRlbXwqfSBUaGUgcmV2aXZlZCBpdGVtIG9yIHRoZSBvcmlnaW5hbCB2YWx1ZSBpZiBub3QgYW4gb2JqZWN0LlxuICAgKi9cbiAgcmV2aXZlcihrZXksIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgdmFsdWUgPT09IG51bGwpIHJldHVybiB2YWx1ZTsgLy8gc2tpcCBub24tb2JqZWN0cywgcXVpY2sgcmV0dXJuXG4gICAgaWYgKHZhbHVlLmNsYXNzX25hbWUpIHJldHVybiBuZXcgKHRoaXMuZW52Lml0ZW1fdHlwZXNbdmFsdWUuY2xhc3NfbmFtZV0pKHRoaXMuZW52LCB2YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJlcGxhY2VyKGtleSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiB0aGlzLml0ZW1fdHlwZSkgcmV0dXJuIHZhbHVlLmRhdGE7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQ29sbGVjdGlvbkl0ZW0pIHJldHVybiB2YWx1ZS5yZWY7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgb3IgdXBkYXRlcyBhbiBpdGVtIGluIHRoZSBjb2xsZWN0aW9uIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBkYXRhLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIHRvIGNyZWF0ZSBvciB1cGRhdGUgYW4gaXRlbS5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q29sbGVjdGlvbkl0ZW0+fENvbGxlY3Rpb25JdGVtfSBUaGUgbmV3bHkgY3JlYXRlZCBvciB1cGRhdGVkIGl0ZW0uXG4gICAqL1xuICBjcmVhdGVfb3JfdXBkYXRlKGRhdGEgPSB7fSkge1xuICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5maW5kX2J5KGRhdGEpO1xuICAgIGNvbnN0IGl0ZW0gPSBleGlzdGluZyA/IGV4aXN0aW5nIDogbmV3IHRoaXMuaXRlbV90eXBlKHRoaXMuZW52KTtcbiAgICBpdGVtLmlzX25ldyA9ICEhIWV4aXN0aW5nO1xuICAgIGNvbnN0IGNoYW5nZWQgPSBpdGVtLnVwZGF0ZV9kYXRhKGRhdGEpOyAvLyBoYW5kbGVzIHRoaXMuZGF0YVxuICAgIGlmIChleGlzdGluZyAmJiAhY2hhbmdlZCkgcmV0dXJuIGV4aXN0aW5nOyAvLyBpZiBleGlzdGluZyBpdGVtIGFuZCBubyBjaGFuZ2VzLCByZXR1cm4gZXhpc3RpbmcgaXRlbSAobm8gbmVlZCB0byBzYXZlKVxuICAgIGlmIChpdGVtLnZhbGlkYXRlX3NhdmUoKSkgdGhpcy5zZXQoaXRlbSk7IC8vIG1ha2UgaXQgYXZhaWxhYmxlIGluIGNvbGxlY3Rpb24gKGlmIHZhbGlkKVxuXG4gICAgLy8gZHluYW1pY2FsbHkgaGFuZGxlIGFzeW5jIGluaXQgZnVuY3Rpb25zXG4gICAgaWYgKGl0ZW0uaW5pdCBpbnN0YW5jZW9mIEFzeW5jRnVuY3Rpb24pIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7IGl0ZW0uaW5pdChkYXRhKS50aGVuKCgpID0+IHJlc29sdmUoaXRlbSkpOyB9KTtcbiAgICBpdGVtLmluaXQoZGF0YSk7IC8vIGhhbmRsZXMgZnVuY3Rpb25zIHRoYXQgaW52b2x2ZSBvdGhlciBpdGVtc1xuICAgIHJldHVybiBpdGVtO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIGFuIGl0ZW0gaW4gdGhlIGNvbGxlY3Rpb24gdGhhdCBtYXRjaGVzIHRoZSBnaXZlbiBkYXRhLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIFRoZSBjcml0ZXJpYSB1c2VkIHRvIGZpbmQgdGhlIGl0ZW0uXG4gICAqIEByZXR1cm5zIHtDb2xsZWN0aW9uSXRlbXxudWxsfSBUaGUgZm91bmQgaXRlbSBvciBudWxsIGlmIG5vdCBmb3VuZC5cbiAgICovXG4gIGZpbmRfYnkoZGF0YSkge1xuICAgIGlmKGRhdGEua2V5KSByZXR1cm4gdGhpcy5nZXQoZGF0YS5rZXkpO1xuICAgIGNvbnN0IHRlbXAgPSBuZXcgdGhpcy5pdGVtX3R5cGUodGhpcy5lbnYpO1xuICAgIGNvbnN0IHRlbXBfZGF0YSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGF0YSwgdGVtcC51cGRhdGVfZGF0YV9yZXBsYWNlcikpO1xuICAgIGRlZXBfbWVyZ2UodGVtcC5kYXRhLCB0ZW1wX2RhdGEpOyAvLyBkZWVwIG1lcmdlIGRhdGFcbiAgICByZXR1cm4gdGVtcC5rZXkgPyB0aGlzLmdldCh0ZW1wLmtleSkgOiBudWxsO1xuICB9XG4gIC8vIFJFQURcbiAgLyoqXG4gICAqIEZpbHRlcnMgdGhlIGl0ZW1zIGluIHRoZSBjb2xsZWN0aW9uIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBvcHRpb25zLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIFRoZSBvcHRpb25zIHVzZWQgdG8gZmlsdGVyIHRoZSBpdGVtcy5cbiAgICogQHJldHVybiB7Q29sbGVjdGlvbkl0ZW1bXX0gVGhlIGZpbHRlcmVkIGl0ZW1zLlxuICAgKi9cbiAgZmlsdGVyKG9wdHMpIHsgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHRoaXMuaXRlbXMpLmZpbHRlcigoW2tleSwgaXRlbV0pID0+IGl0ZW0uZmlsdGVyKG9wdHMpKS5tYXAoKFtrZXksIGl0ZW1dKSA9PiBpdGVtKTsgfVxuICAvKipcbiAgICogUmV0cmlldmVzIGl0ZW1zIGZyb20gdGhlIGNvbGxlY3Rpb24gYmFzZWQgb24gdGhlIHByb3ZpZGVkIHN0cmF0ZWd5IGFuZCBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uW119IHN0cmF0ZWd5IC0gVGhlIHN0cmF0ZWd5IHVzZWQgdG8gcmV0cmlldmUgdGhlIGl0ZW1zLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIFRoZSBvcHRpb25zIHVzZWQgdG8gcmV0cmlldmUgdGhlIGl0ZW1zLlxuICAgKiBAcmV0dXJuIHtDb2xsZWN0aW9uSXRlbVtdfSBUaGUgcmV0cmlldmVkIGl0ZW1zLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gVGhyb3dzIGFuIGVycm9yIGlmIGFueSBmdW5jdGlvbiBpbiB0aGUgc3RyYXRlZ3kgYXJyYXkgaXMgbm90IGFjdHVhbGx5IGEgZnVuY3Rpb24gb3IgaWYgYW4gYXN5bmMgZnVuY3Rpb24gdGhyb3dzIGFuIGVycm9yLlxuICAgKi9cbiAgYXN5bmMgcmV0cmlldmUoc3RyYXRlZ3k9W10sIG9wdHM9e30pIHsgcmV0dXJuIGF3YWl0IHNlcXVlbnRpYWxfYXN5bmNfcHJvY2Vzc29yKGZ1bmNzLCB0aGlzLmZpbHRlcihvcHRzKSwgb3B0cyk7IH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhIHNpbmdsZSBpdGVtIGZyb20gdGhlIGNvbGxlY3Rpb24gYmFzZWQgb24gdGhlIHByb3ZpZGVkIHN0cmF0ZWd5IGFuZCBvcHRpb25zLlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IC0gVGhlIGtleSBvZiB0aGUgaXRlbSB0byByZXRyaWV2ZS5cbiAgICogQHJldHVybiB7Q29sbGVjdGlvbkl0ZW19IFRoZSByZXRyaWV2ZWQgaXRlbS5cbiAgICovXG4gIGdldChrZXkpIHsgcmV0dXJuIHRoaXMuaXRlbXNba2V5XTsgfVxuICAvKipcbiAgICogUmV0cmlldmVzIG11bHRpcGxlIGl0ZW1zIGZyb20gdGhlIGNvbGxlY3Rpb24gYmFzZWQgb24gdGhlIHByb3ZpZGVkIGtleXMuXG4gICAqIEBwYXJhbSB7U3RyaW5nW119IGtleXMgLSBUaGUga2V5cyBvZiB0aGUgaXRlbXMgdG8gcmV0cmlldmUuXG4gICAqIEByZXR1cm4ge0NvbGxlY3Rpb25JdGVtW119IFRoZSByZXRyaWV2ZWQgaXRlbXMuXG4gICAqL1xuICBnZXRfbWFueShrZXlzID0gW10pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShrZXlzKSkgcmV0dXJuIGtleXMubWFwKChrZXkpID0+IHRoaXMuZ2V0KGtleSkpO1xuICAgIGNvbnNvbGUuZXJyb3IoXCJnZXRfbWFueSBjYWxsZWQgd2l0aCBub24tYXJyYXkga2V5czogXCIsIGtleXMpO1xuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYSByYW5kb20gaXRlbSBmcm9tIHRoZSBjb2xsZWN0aW9uIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBvcHRpb25zLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIFRoZSBvcHRpb25zIHVzZWQgdG8gcmV0cmlldmUgdGhlIGl0ZW0uXG4gICAqIEByZXR1cm4ge0NvbGxlY3Rpb25JdGVtfSBUaGUgcmV0cmlldmVkIGl0ZW0uXG4gICAqL1xuICBnZXRfcmFuZChvcHRzID0gbnVsbCkge1xuICAgIGlmIChvcHRzKSB7XG4gICAgICBjb25zdCBmaWx0ZXJlZCA9IHRoaXMuZmlsdGVyKG9wdHMpO1xuICAgICAgcmV0dXJuIGZpbHRlcmVkW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGZpbHRlcmVkLmxlbmd0aCldO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pdGVtc1t0aGlzLmtleXNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdGhpcy5rZXlzLmxlbmd0aCldXTtcbiAgfVxuICAvLyBVUERBVEVcbiAgLyoqXG4gICAqIEFkZHMgb3IgdXBkYXRlcyBhbiBpdGVtIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgKiBAcGFyYW0ge0NvbGxlY3Rpb25JdGVtfSBpdGVtIC0gVGhlIGl0ZW0gdG8gYWRkIG9yIHVwZGF0ZS5cbiAgICovXG4gIHNldChpdGVtKSB7XG4gICAgaWYgKCFpdGVtLmtleSkgdGhyb3cgbmV3IEVycm9yKFwiSXRlbSBtdXN0IGhhdmUga2V5IHByb3BlcnR5XCIpO1xuICAgIHRoaXMuaXRlbXNbaXRlbS5rZXldID0gaXRlbTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyBtdWx0aXBsZSBpdGVtcyBpbiB0aGUgY29sbGVjdGlvbiBiYXNlZCBvbiB0aGUgcHJvdmlkZWQga2V5cyBhbmQgZGF0YS5cbiAgICogQHBhcmFtIHtTdHJpbmdbXX0ga2V5cyAtIFRoZSBrZXlzIG9mIHRoZSBpdGVtcyB0byB1cGRhdGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgdG8gdXBkYXRlIHRoZSBpdGVtcyB3aXRoLlxuICAgKi9cbiAgdXBkYXRlX21hbnkoa2V5cyA9IFtdLCBkYXRhID0ge30pIHsgdGhpcy5nZXRfbWFueShrZXlzKS5mb3JFYWNoKChpdGVtKSA9PiBpdGVtLnVwZGF0ZV9kYXRhKGRhdGEpKTsgfVxuICAvLyBERVNUUk9ZXG4gIC8qKlxuICAgKiBDbGVhcnMgYWxsIGl0ZW1zIGZyb20gdGhlIGNvbGxlY3Rpb24uXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICB0aGlzLml0ZW1zID0ge307XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgYW4gaXRlbSBmcm9tIHRoZSBjb2xsZWN0aW9uIGJhc2VkIG9uIGl0cyBrZXkuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSBUaGUga2V5IG9mIHRoZSBpdGVtIHRvIGRlbGV0ZS5cbiAgICovXG4gIGRlbGV0ZShrZXkpIHtcbiAgICBkZWxldGUgdGhpcy5pdGVtc1trZXldO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIG11bHRpcGxlIGl0ZW1zIGZyb20gdGhlIGNvbGxlY3Rpb24gYmFzZWQgb24gdGhlaXIga2V5cy5cbiAgICogQHBhcmFtIHtTdHJpbmdbXX0ga2V5cyAtIFRoZSBrZXlzIG9mIHRoZSBpdGVtcyB0byBkZWxldGUuXG4gICAqL1xuICBkZWxldGVfbWFueShrZXlzID0gW10pIHtcbiAgICBrZXlzLmZvckVhY2goKGtleSkgPT4gZGVsZXRlIHRoaXMuaXRlbXNba2V5XSk7XG4gIH1cbiAgLy8gQ09OVkVOSUVOQ0UgTUVUSE9EUyAobmFtZXNwYWNlIGdldHRlcnMpXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjb2xsZWN0aW9uIG5hbWUgZGVyaXZlZCBmcm9tIHRoZSBjbGFzcyBuYW1lLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBjb2xsZWN0aW9uIG5hbWUuXG4gICAqL1xuICBzdGF0aWMgZ2V0IGNvbGxlY3Rpb25fbmFtZSgpIHsgcmV0dXJuIHRoaXMubmFtZS5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCBcIiQxXyQyXCIpLnRvTG93ZXJDYXNlKCk7IH1cbiAgLyoqXG4gICAqIEdldHMgb3Igc2V0cyB0aGUgY29sbGVjdGlvbiBuYW1lLiBJZiBhIG5hbWUgaXMgc2V0LCBpdCBvdmVycmlkZXMgdGhlIGRlZmF1bHQgbmFtZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBUaGUgbmV3IGNvbGxlY3Rpb24gbmFtZS5cbiAgICovXG4gIGdldCBjb2xsZWN0aW9uX25hbWUoKSB7IHJldHVybiAodGhpcy5fY29sbGVjdGlvbl9uYW1lKSA/IHRoaXMuX2NvbGxlY3Rpb25fbmFtZSA6IHRoaXMuY29uc3RydWN0b3IuY29sbGVjdGlvbl9uYW1lOyB9XG4gIHNldCBjb2xsZWN0aW9uX25hbWUobmFtZSkgeyB0aGlzLl9jb2xsZWN0aW9uX25hbWUgPSBuYW1lOyB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBrZXlzIG9mIHRoZSBpdGVtcyBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICogQHJldHVybiB7U3RyaW5nW119IFRoZSBrZXlzIG9mIHRoZSBpdGVtcy5cbiAgICovXG4gIGdldCBrZXlzKCkgeyByZXR1cm4gT2JqZWN0LmtleXModGhpcy5pdGVtcyk7IH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIGNsYXNzIG5hbWUgb2YgdGhlIGl0ZW0gdHlwZSB0aGUgY29sbGVjdGlvbiBtYW5hZ2VzLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBpdGVtIGNsYXNzIG5hbWUuXG4gICAqL1xuICBnZXQgaXRlbV9jbGFzc19uYW1lKCkgeyByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lLnNsaWNlKDAsIC0xKS5yZXBsYWNlKC8oaWUpJC9nLCAneScpOyB9IC8vIHJlbW92ZSAncycgZnJvbSBlbmQgb2YgbmFtZSAmIGlmIG5hbWUgZW5kcyBpbiAnaWUnLCByZXBsYWNlIHdpdGggJ3knXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBuYW1lIG9mIHRoZSBpdGVtIHR5cGUgdGhlIGNvbGxlY3Rpb24gbWFuYWdlcywgZGVyaXZlZCBmcm9tIHRoZSBjbGFzcyBuYW1lLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBpdGVtIG5hbWUuXG4gICAqL1xuICBnZXQgaXRlbV9uYW1lKCkgeyByZXR1cm4gdGhpcy5pdGVtX2NsYXNzX25hbWUucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZywgXCIkMV8kMlwiKS50b0xvd2VyQ2FzZSgpOyB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgaXRlbSB0eXBlIHRoZSBjb2xsZWN0aW9uIG1hbmFnZXMuXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgaXRlbSB0eXBlIGNvbnN0cnVjdG9yLlxuICAgKi9cbiAgZ2V0IGl0ZW1fdHlwZSgpIHsgcmV0dXJuIHRoaXMuZW52Lml0ZW1fdHlwZXNbdGhpcy5pdGVtX2NsYXNzX25hbWVdOyB9XG59XG5leHBvcnRzLkNvbGxlY3Rpb24gPSBDb2xsZWN0aW9uO1xuXG4vKipcbiAqIFNlcXVlbnRpYWxseSBleGVjdXRlcyBhbiBhcnJheSBvZiBhc3luY2hyb25vdXMgZnVuY3Rpb25zLCBwYXNzaW5nIHRoZSByZXN1bHQgb2YgZWFjaCBmdW5jdGlvblxuICogYXMgdGhlIGlucHV0IHRvIHRoZSBuZXh0LCBhbG9uZyB3aXRoIGFuIG9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0LlxuICogXG4gKiBAcGFyYW0ge0Z1bmN0aW9uW119IGZ1bmNzIC0gQW4gYXJyYXkgb2YgZnVuY3Rpb25zIHRvIGV4ZWN1dGUgc2VxdWVudGlhbGx5IChtYXkgYmUgYXN5bmMgZnVuY3Rpb25zKS5cbiAqIEBwYXJhbSB7Kn0gaW5pdGlhbF92YWx1ZSAtIFRoZSBpbml0aWFsIHZhbHVlIHRvIHBhc3MgdG8gdGhlIGZpcnN0IGZ1bmN0aW9uIGluIHRoZSBhcnJheS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gT3B0aW9uYWwgcGFyYW1ldGVycyB0byBwYXNzIHRvIGVhY2ggZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7Kn0gVGhlIGZpbmFsIHZhbHVlIGFmdGVyIGFsbCBmdW5jdGlvbnMgaGF2ZSBiZWVuIGV4ZWN1dGVkLlxuICogQHRocm93cyB7RXJyb3J9IFRocm93cyBhbiBlcnJvciBpZiBhbnkgZnVuY3Rpb24gaW4gdGhlIGFycmF5IGlzIG5vdCBhY3R1YWxseSBhIGZ1bmN0aW9uIG9yIGlmIGFuIGFzeW5jIGZ1bmN0aW9uIHRocm93cyBhbiBlcnJvci5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2VxdWVudGlhbF9hc3luY19wcm9jZXNzb3IoZnVuY3MsIGluaXRpYWxfdmFsdWUsIG9wdHMgPSB7fSkge1xuICBsZXQgdmFsdWUgPSBpbml0aWFsX3ZhbHVlO1xuICBmb3IgKGNvbnN0IGZ1bmMgb2YgZnVuY3MpIHtcbiAgICAvLyBFbnN1cmUgZWFjaCBlbGVtZW50IGlzIGEgZnVuY3Rpb24gYmVmb3JlIGF0dGVtcHRpbmcgdG8gY2FsbCBpdFxuICAgIGlmICh0eXBlb2YgZnVuYyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQWxsIGVsZW1lbnRzIGluIGFzeW5jX2Z1bmN0aW9ucyBhcnJheSBtdXN0IGJlIGZ1bmN0aW9ucycpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgdmFsdWUgPSBhd2FpdCBmdW5jKHZhbHVlLCBvcHRzKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gY29uc29sZS5lcnJvcihcIkVycm9yIGVuY291bnRlcmVkIGR1cmluZyBzZXF1ZW50aWFsIHByb2Nlc3Npbmc6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yOyAvLyBSZXRocm93IHRvIGhhbHQgZXhlY3V0aW9uLCBvciBoYW5kbGUgZGlmZmVyZW50bHkgaWYgY29udGludWF0aW9uIGlzIGRlc2lyZWRcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnRzLnNlcXVlbnRpYWxfYXN5bmNfcHJvY2Vzc29yID0gc2VxdWVudGlhbF9hc3luY19wcm9jZXNzb3I7XG4iLCAiLyoqXG4gKiBSZXByZXNlbnRzIGEgZ2VuZXJpYyBhZGFwdGVyIGNsYXNzIHRoYXQgaW5pdGlhbGl6ZXMgd2l0aCBhIG1haW4gY29udGV4dCBhbmQgY29waWVzIGl0cyBjb25maWd1cmF0aW9uLlxuICovXG5jbGFzcyBBZGFwdGVyIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYW4gaW5zdGFuY2Ugb2YgQWRhcHRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IG1haW4gLSBUaGUgbWFpbiBjb250ZXh0IG9iamVjdCB3aGljaCBzaG91bGQgY29udGFpbiBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgKi9cbiAgY29uc3RydWN0b3IobWFpbikge1xuICAgIC8qKlxuICAgICAqIFRoZSBtYWluIGNvbnRleHQgb2JqZWN0IGZyb20gd2hpY2ggY29uZmlndXJhdGlvbiBpcyBkZXJpdmVkLlxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5tYWluID0gbWFpbjtcblxuICAgIC8qKlxuICAgICAqIENvcGllcyBwcm9wZXJ0aWVzIGZyb20gdGhlIG1haW4gb2JqZWN0J3MgY29uZmlnIHByb3BlcnR5IHRvIHRoaXMgaW5zdGFuY2UuXG4gICAgICovXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBtYWluLmNvbmZpZyk7IC8vIENvcHkgY29uZmlnIHRvIHRoaXNcbiAgfVxufVxuXG4vLyBFeHBvcnQgdGhlIEFkYXB0ZXIgY2xhc3MgdG8gYmUgYXZhaWxhYmxlIGZvciBvdGhlciBtb2R1bGVzLlxuZXhwb3J0cy5BZGFwdGVyID0gQWRhcHRlcjtcbiIsICJjb25zdCB7IEFkYXB0ZXIgfSA9IHJlcXVpcmUoXCIuL2FkYXB0ZXJcIik7XG5cbi8qKlxuICogQXBpQWRhcHRlciBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgYWxsIEFQSSBhZGFwdGVycy5cbiAqIEl0IHByb3ZpZGVzIHRoZSBiYXNpYyBmdW5jdGlvbmFsaXR5IGZvciBtYWtpbmcgcmVxdWVzdHMgdG8gdGhlIEFQSS5cbiAqIEltcGxlbWVudHMgT3BlbkFJIEFQSS5cbiAqIEBleHRlbmRzIEFkYXB0ZXJcbiAqIFJlcXVpcmVzIG1vZGVsX2NvbmZpZy5yZXF1ZXN0X2FkYXB0ZXIgdG8gYmUgc2V0LlxuICovXG5jbGFzcyBBcGlBZGFwdGVyIGV4dGVuZHMgQWRhcHRlciB7XG4gIC8qKlxuICAgKiBDb3VudHMgdGhlIG51bWJlciBvZiB0b2tlbnMgaW4gdGhlIGlucHV0LlxuICAgKiBPdmVycmlkZSBpbiBjaGlsZCBjbGFzc2VzIHRvIGltcGxlbWVudCB0aGlyZC1wYXJ0eSB0b2tlbiBjb3VudGVycy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0IC0gVGhlIGlucHV0IHRvIGNvdW50IHRva2VucyBmb3IuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlcj59IFRoZSBudW1iZXIgb2YgdG9rZW5zIGluIHRoZSBpbnB1dC5cbiAgICovXG4gIGFzeW5jIGNvdW50X3Rva2VucyhpbnB1dCkgeyByZXR1cm4gdGhpcy5lc3RpbWF0ZV90b2tlbnMoaW5wdXQpOyB9XG5cbiAgLyoqXG4gICAqIEVzdGltYXRlcyB0aGUgbnVtYmVyIG9mIHRva2VucyBpbiB0aGUgaW5wdXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gaW5wdXQgLSBUaGUgaW5wdXQgdG8gZXN0aW1hdGUgdG9rZW5zIGZvci5cbiAgICogQHJldHVybnMge251bWJlcn0gVGhlIGVzdGltYXRlZCBudW1iZXIgb2YgdG9rZW5zLlxuICAgKi9cbiAgZXN0aW1hdGVfdG9rZW5zKGlucHV0KSB7XG4gICAgaWYodHlwZW9mIHRoaXMuYWRhcHRlcj8uZXN0aW1hdGVfdG9rZW5zID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpcy5hZGFwdGVyLmVzdGltYXRlX3Rva2VucyhpbnB1dCk7XG4gICAgaWYodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JykgaW5wdXQgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgcmV0dXJuIGlucHV0Lmxlbmd0aCAvIDMuNztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBtYXhpbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIGFsbG93ZWQgaW4gdGhlIGlucHV0IGJhc2VkIG9uIG1heF90b2tlbnMuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBtYXhpbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzLlxuICAgKi9cbiAgZ2V0IG1heF9jaGFycygpIHsgcmV0dXJuICh0aGlzLm1heF90b2tlbnMgKiA0KSAtIDEwMDsgfVxuXG4gIC8qKlxuICAgKiBFbWJlZHMgdGhlIGlucHV0IGFuZCByZXR1cm5zIHRoZSBmaXJzdCBlbWJlZGRpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCAtIFRoZSBpbnB1dCB0byBlbWJlZC5cbiAgICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gVGhlIGZpcnN0IGVtYmVkZGluZyBvYmplY3QuXG4gICAqL1xuICBhc3luYyBlbWJlZChpbnB1dCkge1xuICAgIGlmKCFpbnB1dD8ubGVuZ3RoKSByZXR1cm4gY29uc29sZS5sb2coXCJpbnB1dCBpcyBlbXB0eVwiKTsgLy8gY2hlY2sgaWYgaW5wdXQgaXMgZW1wdHlcbiAgICBpbnB1dCA9IHRoaXMucHJlcGFyZV9lbWJlZF9pbnB1dChpbnB1dCk7XG4gICAgY29uc3QgZW1iZWRkaW5ncyA9IGF3YWl0IHRoaXMucmVxdWVzdF9lbWJlZGRpbmcoaW5wdXQpO1xuICAgIHJldHVybiBlbWJlZGRpbmdzWzBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEVtYmVkcyBhIGJhdGNoIG9mIGl0ZW1zIGFuZCByZXR1cm5zIHRoZWlyIGVtYmVkZGluZ3MuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGl0ZW1zIC0gVGhlIGl0ZW1zIHRvIGVtYmVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheT59IFRoZSBlbWJlZGRpbmdzIG9mIHRoZSBpdGVtcy5cbiAgICovXG4gIGFzeW5jIGVtYmVkX2JhdGNoKGl0ZW1zKSB7XG4gICAgaXRlbXMgPSBpdGVtcy5maWx0ZXIoaXRlbSA9PiBpdGVtLmVtYmVkX2lucHV0Py5sZW5ndGggPiAwKTsgLy8gcmVtb3ZlIGl0ZW1zIHdpdGggZW1wdHkgZW1iZWRfaW5wdXQgKGNhdXNlcyA0MDAgZXJyb3IpXG4gICAgaWYoaXRlbXMubGVuZ3RoID09PSAwKSByZXR1cm4gY29uc29sZS5sb2coXCJlbXB0eSBiYXRjaCAob3IgYWxsIGl0ZW1zIGhhdmUgZW1wdHkgZW1iZWRfaW5wdXQpXCIpO1xuICAgIGNvbnN0IGVtYmVkX2lucHV0cyA9IHRoaXMucHJlcGFyZV9iYXRjaF9pbnB1dChpdGVtcyk7XG4gICAgbGV0IGVtYmVkZGluZ3MgPSBhd2FpdCB0aGlzLnJlcXVlc3RfZW1iZWRkaW5nKGVtYmVkX2lucHV0cyk7XG4gICAgaWYoIWVtYmVkZGluZ3MpIHJldHVybiBjb25zb2xlLmVycm9yKGl0ZW1zKTtcbiAgICBlbWJlZGRpbmdzID0gZW1iZWRkaW5ncy5tYXAoKGVtYmVkZGluZywgaSkgPT4gdGhpcy5wYXJzZV9lbWJlZGRpbmdfb3V0cHV0KGVtYmVkX2lucHV0cywgZW1iZWRkaW5nLCBpKSk7XG4gICAgcmV0dXJuIGl0ZW1zLm1hcCgoaXRlbSwgaSkgPT4ge1xuICAgICAgaXRlbS52ZWMgPSBlbWJlZGRpbmdzW2ldLnZlYztcbiAgICAgIGl0ZW0udG9rZW5zID0gZW1iZWRkaW5nc1tpXS50b2tlbnM7XG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgdGhlIGVtYmVkZGluZyBvdXRwdXQgZm9yIGVhY2ggaW5wdXQuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGVtYmVkX2lucHV0cyAtIFRoZSBpbnB1dHMgdXNlZCBmb3IgZW1iZWRkaW5nLlxuICAgKiBAcGFyYW0ge29iamVjdH0gZW1iZWRkaW5nIC0gVGhlIGVtYmVkZGluZyByZXN1bHQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpIC0gVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGVtYmVkZGluZy5cbiAgICogQHJldHVybnMge29iamVjdH0gVGhlIHBhcnNlZCBlbWJlZGRpbmcgb3V0cHV0LlxuICAgKi9cbiAgcGFyc2VfZW1iZWRkaW5nX291dHB1dChlbWJlZF9pbnB1dHMsIGVtYmVkZGluZywgaSkge1xuICAgIGNvbnN0IHRvdGFsX2NoYXJzID0gdGhpcy5jb3VudF9lbWJlZF9pbnB1dF9jaGFycyhlbWJlZF9pbnB1dHMpO1xuICAgIHJldHVybiB7XG4gICAgICB2ZWM6IGVtYmVkZGluZy52ZWMsXG4gICAgICB0b2tlbnM6IE1hdGgucm91bmQoKGVtYmVkX2lucHV0c1tpXS5sZW5ndGggLyB0b3RhbF9jaGFycykgKiBlbWJlZGRpbmcudG9rZW5zKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ291bnRzIHRoZSB0b3RhbCBudW1iZXIgb2YgY2hhcmFjdGVycyBpbiBhbGwgZW1iZWQgaW5wdXRzLlxuICAgKiBAcGFyYW0ge0FycmF5fSBlbWJlZF9pbnB1dHMgLSBUaGUgaW5wdXRzIHVzZWQgZm9yIGVtYmVkZGluZy5cbiAgICogQHJldHVybnMge251bWJlcn0gVGhlIHRvdGFsIG51bWJlciBvZiBjaGFyYWN0ZXJzLlxuICAgKi9cbiAgY291bnRfZW1iZWRfaW5wdXRfY2hhcnMoZW1iZWRfaW5wdXRzKSB7IHJldHVybiBlbWJlZF9pbnB1dHMucmVkdWNlKChhY2MsIGN1cnIpID0+IGFjYyArIGN1cnIubGVuZ3RoLCAwKTsgfVxuXG4gIC8qKlxuICAgKiBQcmVwYXJlcyB0aGUgYmF0Y2ggaW5wdXQgYnkgcHJvY2Vzc2luZyBlYWNoIGl0ZW0ncyBlbWJlZCBpbnB1dC5cbiAgICogQHBhcmFtIHtBcnJheX0gaXRlbXMgLSBUaGUgaXRlbXMgdG8gcHJlcGFyZS5cbiAgICogQHJldHVybnMge0FycmF5fSBUaGUgcHJlcGFyZWQgYmF0Y2ggaW5wdXQuXG4gICAqL1xuICBwcmVwYXJlX2JhdGNoX2lucHV0KGl0ZW1zKSB7IHJldHVybiBpdGVtcy5tYXAoaXRlbSA9PiB0aGlzLnByZXBhcmVfZW1iZWRfaW5wdXQoaXRlbS5lbWJlZF9pbnB1dCkpOyB9XG5cbiAgLyoqXG4gICAqIFByZXBhcmVzIHRoZSBlbWJlZCBpbnB1dCBieSB0cnVuY2F0aW5nIGl0IGlmIG5lY2Vzc2FyeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGVtYmVkX2lucHV0IC0gVGhlIGlucHV0IHRvIHByZXBhcmUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBwcmVwYXJlZCBlbWJlZCBpbnB1dC5cbiAgICovXG4gIHByZXBhcmVfZW1iZWRfaW5wdXQoZW1iZWRfaW5wdXQpIHsgcmV0dXJuIChlbWJlZF9pbnB1dC5sZW5ndGggPiB0aGlzLm1heF9jaGFycykgPyBlbWJlZF9pbnB1dC5zbGljZSgwLCB0aGlzLm1heF9jaGFycykgOiBlbWJlZF9pbnB1dDsgfVxuXG4gIC8qKlxuICAgKiBQcmVwYXJlcyB0aGUgcmVxdWVzdCBib2R5IGZvciBlbWJlZGRpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IGVtYmVkX2lucHV0IC0gVGhlIGlucHV0IHRvIGVtYmVkLlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgcHJlcGFyZWQgcmVxdWVzdCBib2R5LlxuICAgKi9cbiAgcHJlcGFyZV9yZXF1ZXN0X2JvZHkoZW1iZWRfaW5wdXQpe1xuICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICBtb2RlbDogdGhpcy5tb2RlbF9uYW1lLFxuICAgICAgaW5wdXQ6IGVtYmVkX2lucHV0LFxuICAgIH07XG4gICAgaWYgKHRoaXMubW9kZWxfbmFtZS5zdGFydHNXaXRoKFwidGV4dC1lbWJlZGRpbmctM1wiKSkge1xuICAgICAgYm9keS5kaW1lbnNpb25zID0gdGhpcy5kaW1zO1xuICAgIH1cbiAgICByZXR1cm4gYm9keTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVwYXJlcyB0aGUgcmVxdWVzdCBoZWFkZXJzIGZvciB0aGUgQVBJIGNhbGwuXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSBwcmVwYXJlZCByZXF1ZXN0IGhlYWRlcnMuXG4gICAqL1xuICBwcmVwYXJlX3JlcXVlc3RfaGVhZGVycygpIHtcbiAgICBsZXQgaGVhZGVycyA9IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgXCJBdXRob3JpemF0aW9uXCI6IGBCZWFyZXIgJHt0aGlzLmFwaV9rZXl9YFxuICAgIH07XG4gICAgaWYgKHRoaXMuaGVhZGVycykgaGVhZGVycyA9IHsgLi4uaGVhZGVycywgLi4udGhpcy5oZWFkZXJzIH07XG4gICAgcmV0dXJuIGhlYWRlcnM7XG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdHMgdGhlIGVtYmVkZGluZyBmcm9tIHRoZSBBUEkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBlbWJlZF9pbnB1dCAtIFRoZSBpbnB1dCB0byBlbWJlZC4gTWF5IGJlIGEgc3RyaW5nIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdFtdPn0gVGhlIGVtYmVkZGluZyBvYmplY3RzIHt2ZWMsIHRva2Vuc30uXG4gICAqL1xuICBhc3luYyByZXF1ZXN0X2VtYmVkZGluZyhlbWJlZF9pbnB1dCkge1xuICAgIC8vIENoZWNrIGlmIGVtYmVkX2lucHV0IGlzIGVtcHR5XG4gICAgaWYgKGVtYmVkX2lucHV0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc29sZS5sb2coXCJlbWJlZF9pbnB1dCBpcyBlbXB0eVwiKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgdXJsOiB0aGlzLmVuZHBvaW50LFxuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHRoaXMucHJlcGFyZV9yZXF1ZXN0X2JvZHkoZW1iZWRfaW5wdXQpKSxcbiAgICAgIGhlYWRlcnM6IHRoaXMucHJlcGFyZV9yZXF1ZXN0X2hlYWRlcnMoKVxuICAgIH07XG4gICAgY29uc3QgcmVzcCA9IGF3YWl0IHRoaXMucmVxdWVzdChyZXF1ZXN0KTtcbiAgICByZXR1cm4gdGhpcy5wYXJzZV9yZXNwb25zZShyZXNwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgdGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSS5cbiAgICogQHBhcmFtIHtvYmplY3R9IHJlc3AgLSBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgQVBJLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBwYXJzZWQgcmVzcG9uc2UgZGF0YS5cbiAgICovXG4gIHBhcnNlX3Jlc3BvbnNlKHJlc3ApIHtcbiAgICByZXR1cm4gcmVzcC5kYXRhLm1hcChpdGVtID0+ICh7XG4gICAgICB2ZWM6IGl0ZW0uZW1iZWRkaW5nLFxuICAgICAgdG9rZW5zOiByZXNwLnVzYWdlLnRvdGFsX3Rva2VucyAvIHJlc3AuZGF0YS5sZW5ndGhcbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSByZXNwb25zZSBKU09OIGluZGljYXRlcyBhbiBlcnJvci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHJlc3BfanNvbiAtIFRoZSByZXNwb25zZSBKU09OIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGVyZSBpcyBhbiBlcnJvciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNfZXJyb3IocmVzcF9qc29uKSB7IHJldHVybiAhcmVzcF9qc29uLmRhdGEgfHwgIXJlc3BfanNvbi51c2FnZTsgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIEpTT04gZnJvbSB0aGUgcmVzcG9uc2UuXG4gICAqIEBwYXJhbSB7UmVzcG9uc2V9IHJlc3AgLSBUaGUgcmVzcG9uc2Ugb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSBUaGUgcmVzcG9uc2UgSlNPTi5cbiAgICovXG4gIGFzeW5jIGdldF9yZXNwX2pzb24ocmVzcCkgeyByZXR1cm4gKHR5cGVvZiByZXNwLmpzb24gPT09ICdmdW5jdGlvbicpID8gYXdhaXQgcmVzcC5qc29uKCkgOiBhd2FpdCByZXNwLmpzb247IH1cblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgcmVxdWVzdCwgaW5jbHVkaW5nIHJldHJpZXMgZm9yIHNwZWNpZmljIGVycm9ycy5cbiAgICogQHBhcmFtIHtvYmplY3R9IHJlcSAtIFRoZSByZXF1ZXN0IG9iamVjdC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJldHJpZXMgLSBUaGUgY3VycmVudCByZXRyeSBjb3VudC5cbiAgICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0fG51bGw+fSBUaGUgcmVzcG9uc2UgSlNPTiBvciBudWxsIGlmIGFuIGVycm9yIG9jY3Vycy5cbiAgICovXG4gIGFzeW5jIHJlcXVlc3QocmVxLCByZXRyaWVzID0gMCl7XG4gICAgdHJ5IHtcbiAgICAgIHJlcS50aHJvdyA9IGZhbHNlO1xuICAgICAgLy8gaGFuZGxlIGZhbGxiYWNrIHRvIGZldGNoIChhbGxvd3MgZm9yIG92ZXJ3cml0aW5nIGluIGNoaWxkIGNsYXNzZXMpXG4gICAgICBjb25zdCByZXNwID0gdGhpcy5yZXF1ZXN0X2FkYXB0ZXIgPyBhd2FpdCB0aGlzLnJlcXVlc3RfYWRhcHRlcih7dXJsOiB0aGlzLmVuZHBvaW50LCAuLi5yZXF9KSA6IGF3YWl0IGZldGNoKHRoaXMuZW5kcG9pbnQsIHJlcSk7XG4gICAgICBjb25zdCByZXNwX2pzb24gPSBhd2FpdCB0aGlzLmdldF9yZXNwX2pzb24ocmVzcCk7XG4gICAgICAvLyBjb25zb2xlLmxvZyhyZXNwX2pzb24pO1xuICAgICAgaWYodGhpcy5pc19lcnJvcihyZXNwX2pzb24pKSByZXR1cm4gYXdhaXQgdGhpcy5oYW5kbGVfcmVxdWVzdF9lcnIocmVzcF9qc29uLCByZXEsIHJldHJpZXMpO1xuICAgICAgcmV0dXJuIHJlc3BfanNvbjtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuaGFuZGxlX3JlcXVlc3RfZXJyKGVycm9yLCByZXEsIHJldHJpZXMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGVycm9ycyBkdXJpbmcgdGhlIHJlcXVlc3QsIGluY2x1ZGluZyByZXRyeWluZyB0aGUgcmVxdWVzdC5cbiAgICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgLSBUaGUgZXJyb3IgZW5jb3VudGVyZWQuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSByZXEgLSBUaGUgcmVxdWVzdCBvYmplY3QuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZXRyaWVzIC0gVGhlIGN1cnJlbnQgcmV0cnkgY291bnQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdHxudWxsPn0gVGhlIHJlc3BvbnNlIEpTT04gb3IgbnVsbCBpZiBhbiBlcnJvciBwZXJzaXN0cy5cbiAgICovXG4gIGFzeW5jIGhhbmRsZV9yZXF1ZXN0X2VycihlcnJvciwgcmVxLCByZXRyaWVzKSB7XG4gICAgLy8gY29uc29sZS5sb2cocmVxKTtcbiAgICAvLyBjb25zb2xlLmxvZyhlcnJvcik7XG4gICAgLy8gcGFyc2Uge21lc3NhZ2U6IFwiVGhpcyBtb2RlbCdzIG1heGltdW0gY29udGV4dCBsZW5ndGggaXMgODE5MiB0b2tlbnMsIGhvd2V2ZXIgeW91IHJlcXVlc3RlZCAxMzc3NiB0b2tlbnMgKDEzNzc2IGluIHlvdXIgcHJvbXB0OyAwIGZvciB0aGUgY29tcGxldGlvbikuIFBsZWFzZSByZWR1Y2UgeW91ciBwcm9tcHQ7IG9yIGNvbXBsZXRpb24gbGVuZ3RoLlwiXG4gICAgZXJyb3IgPSBlcnJvci5lcnJvcjtcbiAgICBpZihlcnJvci5tZXNzYWdlPy5pbmNsdWRlcyhcIm1heGltdW0gY29udGV4dCBsZW5ndGggaXNcIikpIHtcbiAgICAgIGNvbnN0IG1heF9sZW4gPSBwYXJzZUludChlcnJvci5tZXNzYWdlLnNwbGl0KFwibGVuZ3RoIGlzIFwiKVsxXS5zcGxpdChcInRva2Vuc1wiKVswXS50cmltKCkpO1xuICAgICAgY29uc3QgcmVxdWVzdGVkX2xlbiA9IHBhcnNlSW50KGVycm9yLm1lc3NhZ2Uuc3BsaXQoXCJyZXF1ZXN0ZWRcIilbMV0uc3BsaXQoXCJ0b2tlbnNcIilbMF0udHJpbSgpKTtcbiAgICAgIGNvbnNvbGUubG9nKGBtYXggY29udGV4dCBsZW5ndGg6ICR7bWF4X2xlbn0sIHJlcXVlc3RlZDogJHtyZXF1ZXN0ZWRfbGVufWApO1xuICAgICAgY29uc3QgYm9keSA9IEpTT04ucGFyc2UocmVxLmJvZHkpO1xuICAgICAgY29uc3QgbG9uZ2VzdF9sZW4gPSBNYXRoLm1heCguLi5ib2R5LmlucHV0Lm1hcChpdGVtID0+IGl0ZW0ubGVuZ3RoKSk7XG4gICAgICBjb25zdCBsb25nZXN0X2kgPSBib2R5LmlucHV0LmZpbmRJbmRleChpID0+IGkubGVuZ3RoID09PSBsb25nZXN0X2xlbik7XG4gICAgICAvLyByZWR1Y2UgdGhlIGxvbmdlc3QgaW5wdXQgYnkgdGhlIHNhbWUgcmF0aW8gYXMgdGhlIHJlcXVlc3RlZCBsZW5ndGggdG8gdGhlIG1heCBsZW5ndGggKDEwIHJlcXVlc3RlZCwgOCBtYXgsIHJlZHVjZSBsb25nZXN0IGJ5IDIwJSB0byA4KVxuICAgICAgY29uc3QgcmVkdWNlX2ZhY3RvciA9IChyZXF1ZXN0ZWRfbGVuIC0gbWF4X2xlbikgLyByZXF1ZXN0ZWRfbGVuO1xuICAgICAgLy8gY29uc29sZS5sb2coYHJlZHVjZSBmYWN0b3I6ICR7cmVkdWNlX2ZhY3Rvcn1gKTtcbiAgICAgIGJvZHkuaW5wdXRbbG9uZ2VzdF9pXSA9IGJvZHkuaW5wdXRbbG9uZ2VzdF9pXS5zbGljZSgwLCBNYXRoLmZsb29yKHJlZHVjZV9mYWN0b3IgKiBsb25nZXN0X2xlbikgLSAoNTAwICogcmV0cmllcykpO1xuICAgICAgY29uc29sZS5sb2coYHRydW5jYXRlZCBpbnB1dDogJHtib2R5LmlucHV0W2xvbmdlc3RfaV0ubGVuZ3RofWApO1xuICAgICAgcmVxLmJvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5KTtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnJlcXVlc3QocmVxLCByZXRyaWVzICsgMSk7XG4gICAgfVxuICAgIGlmIChlcnJvci5zdGF0dXMgPT09IDQyOSAmJiByZXRyaWVzIDwgMykge1xuICAgICAgY29uc3QgYmFja29mZiA9IE1hdGgucG93KHJldHJpZXMgKyAxLCAyKTsgLy8gZXhwb25lbnRpYWwgYmFja29mZlxuICAgICAgY29uc29sZS5sb2coYFJldHJ5aW5nIHJlcXVlc3QgKDQyOSkgaW4gJHtiYWNrb2ZmfSBzZWNvbmRzLi4uYCk7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyID0+IHNldFRpbWVvdXQociwgMTAwMCAqIGJhY2tvZmYpKTtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnJlcXVlc3QocmVxLCByZXRyaWVzICsgMSk7XG4gICAgfVxuICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5leHBvcnRzLkFwaUFkYXB0ZXIgPSBBcGlBZGFwdGVyOyIsICJjb25zdCB7IEFwaUFkYXB0ZXIgfSA9IHJlcXVpcmUoXCIuL2FwaVwiKTtcbmNsYXNzIExvY2FsQXBpQWRhcHRlciBleHRlbmRzIEFwaUFkYXB0ZXIge1xuICBhc3luYyBlbWJlZChpbnB1dCkge1xuICAgIGNvbnN0IHJlc3AgPSBhd2FpdCB0aGlzLmVtYmVkX2JhdGNoKFt7XG4gICAgICBlbWJlZF9pbnB1dDogaW5wdXQsXG4gICAgfV0pO1xuICAgIHJldHVybiByZXNwPy5bMF07XG4gIH1cbiAgYXN5bmMgaW5pdCgpIHtcbiAgICB0aGlzLmVuZHBvaW50ID0gdGhpcy5sb2NhbF9lbmRwb2ludDtcbiAgfVxuICBwcmVwYXJlX2JhdGNoX2lucHV0KGl0ZW1zKSB7XG4gICAgcmV0dXJuIGl0ZW1zLm1hcChpdGVtID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVtYmVkX2lucHV0OiB0aGlzLnByZXBhcmVfZW1iZWRfaW5wdXQoaXRlbS5lbWJlZF9pbnB1dCksXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcGFyc2VfZW1iZWRkaW5nX291dHB1dChlbWJlZF9pbnB1dHMsIGVtYmVkZGluZywgaSkgeyByZXR1cm4gZW1iZWRkaW5nOyB9XG4gIHByZXBhcmVfcmVxdWVzdF9ib2R5KGlucHV0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vZGVsX2NvbmZpZzogdGhpcy5tYWluLmNvbmZpZyxcbiAgICAgIGlucHV0OiBpbnB1dCxcbiAgICB9O1xuICB9XG4gIHByZXBhcmVfcmVxdWVzdF9oZWFkZXJzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICB9O1xuICB9XG4gIGlzX2Vycm9yKHJlc3ApIHsgcmV0dXJuIHJlc3A/LmVycm9yOyB9XG4gIHBhcnNlX3Jlc3BvbnNlKHJlc3ApIHsgcmV0dXJuIHJlc3A7IH1cbn1cbmV4cG9ydHMuTG9jYWxBcGlBZGFwdGVyID0gTG9jYWxBcGlBZGFwdGVyO1xuXG4iLCAiY29uc3QgeyBBZGFwdGVyIH0gPSByZXF1aXJlKFwiLi9hZGFwdGVyXCIpO1xuXG5jbGFzcyBUcmFuc2Zvcm1lcnNBZGFwdGVyIGV4dGVuZHMgQWRhcHRlciB7XG4gIGFzeW5jIGluaXQoKSB7XG4gICAgY29uc3QgeyBlbnYsIHBpcGVsaW5lLCBBdXRvVG9rZW5pemVyIH0gPSBhd2FpdCBpbXBvcnQoJ0B4ZW5vdmEvdHJhbnNmb3JtZXJzJyk7XG4gICAgZW52LmFsbG93TG9jYWxNb2RlbHMgPSBmYWxzZTtcbiAgICB0aGlzLm1vZGVsID0gYXdhaXQgcGlwZWxpbmUoJ2ZlYXR1cmUtZXh0cmFjdGlvbicsIHRoaXMubW9kZWxfbmFtZSwgeyBxdWFudGl6ZWQ6IHRydWUsIG1heF9sZW5ndGg6IHRoaXMubWF4X3Rva2VucyB9KTtcbiAgICAvLyB0aGlzLm1vZGVsID0gYXdhaXQgcGlwZWxpbmUoJ2ZlYXR1cmUtZXh0cmFjdGlvbicsIHRoaXMubW9kZWxfbmFtZSwgeyBxdWFudGl6ZWQ6IGZhbHNlIH0pO1xuICAgIHRoaXMudG9rZW5pemVyID0gYXdhaXQgQXV0b1Rva2VuaXplci5mcm9tX3ByZXRyYWluZWQodGhpcy5tb2RlbF9uYW1lKTtcbiAgfVxuICBhc3luYyBlbWJlZF9iYXRjaChpdGVtcykge1xuICAgIGl0ZW1zID0gaXRlbXMuZmlsdGVyKGl0ZW0gPT4gaXRlbS5lbWJlZF9pbnB1dD8ubGVuZ3RoID4gMCk7IC8vIHJlbW92ZSBpdGVtcyB3aXRoIGVtcHR5IGVtYmVkX2lucHV0IChjYXVzZXMgLnNwbGl0KCkgZXJyb3IpXG4gICAgaWYoIWl0ZW1zPy5sZW5ndGgpIHJldHVybiBbXTtcbiAgICBjb25zdCB0b2tlbnMgPSBhd2FpdCBQcm9taXNlLmFsbChpdGVtcy5tYXAoaXRlbSA9PiB0aGlzLmNvdW50X3Rva2VucyhpdGVtLmVtYmVkX2lucHV0KSkpO1xuICAgIGNvbnN0IGVtYmVkX2lucHV0ID0gYXdhaXQgUHJvbWlzZS5hbGwoaXRlbXMubWFwKGFzeW5jIChpdGVtLCBpKSA9PiB7XG4gICAgICBpZiAodG9rZW5zW2ldIDwgdGhpcy5tYXhfdG9rZW5zKSByZXR1cm4gaXRlbS5lbWJlZF9pbnB1dDtcbiAgICAgIGxldCB0b2tlbl9jdCA9IHRva2Vuc1tpXTtcbiAgICAgIGxldCB0cnVuY2F0ZWRfaW5wdXQgPSBpdGVtLmVtYmVkX2lucHV0O1xuICAgICAgd2hpbGUgKHRva2VuX2N0ID4gdGhpcy5tYXhfdG9rZW5zKSB7XG4gICAgICAgIGNvbnN0IHBjdCA9IHRoaXMubWF4X3Rva2VucyAvIHRva2VuX2N0OyAvLyBnZXQgcGN0IG9mIGlucHV0IHRvIGtlZXBcbiAgICAgICAgY29uc3QgbWF4X2NoYXJzID0gTWF0aC5mbG9vcih0cnVuY2F0ZWRfaW5wdXQubGVuZ3RoICogcGN0ICogMC45MCk7IC8vIGdldCBudW1iZXIgb2YgY2hhcmFjdGVycyB0byBrZWVwIChtaW51cyAxMCUgZm9yIHNhZmV0eSlcbiAgICAgICAgdHJ1bmNhdGVkX2lucHV0ID0gdHJ1bmNhdGVkX2lucHV0LnN1YnN0cmluZygwLCBtYXhfY2hhcnMpICsgXCIuLi5cIjtcbiAgICAgICAgdG9rZW5fY3QgPSBhd2FpdCB0aGlzLmNvdW50X3Rva2Vucyh0cnVuY2F0ZWRfaW5wdXQpO1xuICAgICAgfVxuICAgICAgLy8gY29uc29sZS5sb2coXCJJbnB1dCB0b28gbG9uZy4gVHJ1bmNhdGluZyB0byBcIiwgdHJ1bmNhdGVkX2lucHV0Lmxlbmd0aCwgXCIgY2hhcmFjdGVycy5cIik7XG4gICAgICAvLyBjb25zb2xlLmxvZyhcIlRva2VuczogXCIsIHRva2Vuc1tpXSwgXCIgLT4gXCIsIHRva2VuX2N0KTtcbiAgICAgIHRva2Vuc1tpXSA9IHRva2VuX2N0O1xuICAgICAgcmV0dXJuIHRydW5jYXRlZF9pbnB1dDtcbiAgICB9KSk7XG5cbiAgICAvLyBjb25zb2xlLmxvZyhlbWJlZF9pbnB1dCk7XG4gICAgdHJ5e1xuICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IHRoaXMubW9kZWwoZW1iZWRfaW5wdXQsIHsgcG9vbGluZzogJ21lYW4nLCBub3JtYWxpemU6IHRydWUgfSk7XG4gICAgICAvLyBjb25zb2xlLmxvZyhyZXNwKTtcbiAgICAgIHJldHVybiBpdGVtcy5tYXAoKGl0ZW0sIGkpID0+IHtcbiAgICAgICAgaXRlbS52ZWMgPSBBcnJheS5mcm9tKHJlc3BbaV0uZGF0YSk7XG4gICAgICAgIGl0ZW0udG9rZW5zID0gdG9rZW5zW2ldO1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH0pO1xuICAgIH1jYXRjaChlcnIpe1xuICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiRXJyb3IgZW1iZWRkaW5nIGJhdGNoLiBUcnlpbmcgb25lIGF0IGEgdGltZS4uLlwiKTtcbiAgICB9XG4gICAgY29uc3QgcmVzcCA9IGF3YWl0IFByb21pc2UuYWxsKGl0ZW1zLm1hcChhc3luYyBpdGVtID0+IHtcbiAgICAgIGNvbnN0IHsgdmVjLCB0b2tlbnMsIGVycm9yIH0gPSBhd2FpdCB0aGlzLmVtYmVkKGl0ZW0uZW1iZWRfaW5wdXQpO1xuICAgICAgaWYoZXJyb3Ipe1xuICAgICAgICBjb25zb2xlLmxvZyhcIkVycm9yIGVtYmVkZGluZyBpdGVtOiBcIiwgaXRlbS5rZXkpO1xuICAgICAgICBjb25zb2xlLmxvZyhlcnJvcik7XG4gICAgICAgIGl0ZW0uZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9XG4gICAgICBpZighdmVjKXtcbiAgICAgICAgY29uc29sZS5sb2coXCJFcnJvciBlbWJlZGRpbmcgaXRlbTogXCIsIGl0ZW0ua2V5KTtcbiAgICAgICAgY29uc29sZS5sb2coXCJWZWM6IFwiLCB2ZWMpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIkVycm9yOiBcIiwgZXJyb3IpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIlRva2VuczogXCIsIHRva2Vucyk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiTm8gdmVjIHJldHVybmVkXCIpO1xuICAgICAgICBpdGVtLmVycm9yID0gXCJObyB2ZWMgcmV0dXJuZWRcIjtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9XG4gICAgICBpdGVtLnZlYyA9IHZlYy5tYXAodmFsID0+IE1hdGgucm91bmQodmFsICogMTAwMDAwMDAwKSAvIDEwMDAwMDAwMCk7IC8vIHJlZHVjZSBwcmVjaXNpb24gdG8gOCBkZWNpbWFsIHBsYWNlcyByZWY6IGh0dHBzOi8vd2ZoYnJpYW4uY29tL3ZlY3Rvci1kaW1lbnNpb24tcHJlY2lzaW9uLWVmZmVjdC1vbi1jb3NpbmUtc2ltaWxhcml0eS9cbiAgICAgIGl0ZW0udG9rZW5zID0gdG9rZW5zO1xuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfSkpO1xuICAgIHJldHVybiByZXNwO1xuICB9XG4gIGFzeW5jIGVtYmVkKGlucHV0KSB7XG4gICAgY29uc3Qgb3V0cHV0ID0geyBlbWJlZF9pbnB1dDogaW5wdXQgfTtcbiAgICBpZiAoIWlucHV0KSByZXR1cm4geyAuLi5vdXRwdXQsIGVycm9yOiBcIk5vIGlucHV0IHRleHQuXCIgfTtcbiAgICBpZiAoIXRoaXMubW9kZWwpIGF3YWl0IHRoaXMuaW5pdCgpO1xuICAgIHRyeSB7XG4gICAgICBvdXRwdXQudG9rZW5zID0gYXdhaXQgdGhpcy5jb3VudF90b2tlbnMoaW5wdXQpO1xuICAgICAgaWYgKG91dHB1dC50b2tlbnMgPCAxKSByZXR1cm4geyAuLi5vdXRwdXQsIGVycm9yOiBcIklucHV0IHRvbyBzaG9ydC5cIiB9O1xuICAgICAgaWYgKG91dHB1dC50b2tlbnMgPCB0aGlzLm1heF90b2tlbnMpIHtcbiAgICAgICAgY29uc3QgZW1iZWRkaW5nID0gYXdhaXQgdGhpcy5tb2RlbChpbnB1dCwgeyBwb29saW5nOiAnbWVhbicsIG5vcm1hbGl6ZTogdHJ1ZSB9KTtcbiAgICAgICAgb3V0cHV0LnZlYyA9IEFycmF5LmZyb20oZW1iZWRkaW5nLmRhdGEpLm1hcCh2YWwgPT4gTWF0aC5yb3VuZCh2YWwgKiAxMDAwMDAwMDApIC8gMTAwMDAwMDAwKTsgLy8gcmVkdWNlIHByZWNpc2lvbiB0byA4IGRlY2ltYWwgcGxhY2VzIHJlZjogaHR0cHM6Ly93Zmhicmlhbi5jb20vdmVjdG9yLWRpbWVuc2lvbi1wcmVjaXNpb24tZWZmZWN0LW9uLWNvc2luZS1zaW1pbGFyaXR5L1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcGN0ID0gdGhpcy5tYXhfdG9rZW5zIC8gb3V0cHV0LnRva2VuczsgLy8gZ2V0IHBjdCBvZiBpbnB1dCB0byBrZWVwXG4gICAgICAgIGNvbnN0IG1heF9jaGFycyA9IE1hdGguZmxvb3IoaW5wdXQubGVuZ3RoICogcGN0ICogMC45NSk7IC8vIGdldCBudW1iZXIgb2YgY2hhcmFjdGVycyB0byBrZWVwIChtaW51cyA1JSBmb3Igc2FmZXR5KVxuICAgICAgICBpbnB1dCA9IGlucHV0LnN1YnN0cmluZygwLCBtYXhfY2hhcnMpICsgXCIuLi5cIjtcbiAgICAgICAgb3V0cHV0LnRydW5jYXRlZCA9IHRydWU7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiSW5wdXQgdG9vIGxvbmcuIFRydW5jYXRpbmcgdG8gXCIsIGlucHV0Lmxlbmd0aCwgXCIgY2hhcmFjdGVycy5cIik7XG4gICAgICAgIGNvbnN0IHsgdmVjLCB0b2tlbnMgfSA9IGF3YWl0IHRoaXMuZW1iZWQoaW5wdXQpO1xuICAgICAgICBvdXRwdXQudmVjID0gdmVjO1xuICAgICAgICBvdXRwdXQudG9rZW5zID0gdG9rZW5zO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICByZXR1cm4geyAuLi5vdXRwdXQsIGVycm9yOiBlcnIubWVzc2FnZSB9O1xuICAgIH1cbiAgfVxuICBhc3luYyBjb3VudF90b2tlbnModGV4dCkge1xuICAgIGlmICghdGhpcy50b2tlbml6ZXIpIGF3YWl0IHRoaXMuaW5pdCgpO1xuICAgIGNvbnN0IHsgaW5wdXRfaWRzIH0gPSBhd2FpdCB0aGlzLnRva2VuaXplcih0ZXh0KTtcbiAgICByZXR1cm4gaW5wdXRfaWRzLmRhdGEubGVuZ3RoOyAvLyBSZXR1cm4gdGhlIG51bWJlciBvZiB0b2tlbnNcbiAgfVxufVxuXG5leHBvcnRzLlRyYW5zZm9ybWVyc0FkYXB0ZXIgPSBUcmFuc2Zvcm1lcnNBZGFwdGVyOyIsICJ7XG4gIFwic2NyaXB0XCI6IFwidmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcXG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcXG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcXG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xcbnZhciBfX2NvbW1vbkpTID0gKGNiLCBtb2QpID0+IGZ1bmN0aW9uIF9fcmVxdWlyZSgpIHtcXG4gIHJldHVybiBtb2QgfHwgKDAsIGNiW19fZ2V0T3duUHJvcE5hbWVzKGNiKVswXV0pKChtb2QgPSB7IGV4cG9ydHM6IHt9IH0pLmV4cG9ydHMsIG1vZCksIG1vZC5leHBvcnRzO1xcbn07XFxudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcXG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcXFwib2JqZWN0XFxcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXFxcImZ1bmN0aW9uXFxcIikge1xcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXFxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcXG4gIH1cXG4gIHJldHVybiB0bztcXG59O1xcbnZhciBfX3RvRVNNID0gKG1vZCwgaXNOb2RlTW9kZSwgdGFyZ2V0KSA9PiAodGFyZ2V0ID0gbW9kICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kKSkgOiB7fSwgX19jb3B5UHJvcHMoXFxuICAvLyBJZiB0aGUgaW1wb3J0ZXIgaXMgaW4gbm9kZSBjb21wYXRpYmlsaXR5IG1vZGUgb3IgdGhpcyBpcyBub3QgYW4gRVNNXFxuICAvLyBmaWxlIHRoYXQgaGFzIGJlZW4gY29udmVydGVkIHRvIGEgQ29tbW9uSlMgZmlsZSB1c2luZyBhIEJhYmVsLVxcbiAgLy8gY29tcGF0aWJsZSB0cmFuc2Zvcm0gKGkuZS4gXFxcIl9fZXNNb2R1bGVcXFwiIGhhcyBub3QgYmVlbiBzZXQpLCB0aGVuIHNldFxcbiAgLy8gXFxcImRlZmF1bHRcXFwiIHRvIHRoZSBDb21tb25KUyBcXFwibW9kdWxlLmV4cG9ydHNcXFwiIGZvciBub2RlIGNvbXBhdGliaWxpdHkuXFxuICBpc05vZGVNb2RlIHx8ICFtb2QgfHwgIW1vZC5fX2VzTW9kdWxlID8gX19kZWZQcm9wKHRhcmdldCwgXFxcImRlZmF1bHRcXFwiLCB7IHZhbHVlOiBtb2QsIGVudW1lcmFibGU6IHRydWUgfSkgOiB0YXJnZXQsXFxuICBtb2RcXG4pKTtcXG5cXG4vLyBhZGFwdGVycy9hZGFwdGVyLmpzXFxudmFyIHJlcXVpcmVfYWRhcHRlciA9IF9fY29tbW9uSlMoe1xcbiAgXFxcImFkYXB0ZXJzL2FkYXB0ZXIuanNcXFwiKGV4cG9ydHMpIHtcXG4gICAgdmFyIEFkYXB0ZXIgPSBjbGFzcyB7XFxuICAgICAgLyoqXFxuICAgICAgICogQ29uc3RydWN0cyBhbiBpbnN0YW5jZSBvZiBBZGFwdGVyLlxcbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBtYWluIC0gVGhlIG1haW4gY29udGV4dCBvYmplY3Qgd2hpY2ggc2hvdWxkIGNvbnRhaW4gYSBjb25maWd1cmF0aW9uIG9iamVjdC5cXG4gICAgICAgKi9cXG4gICAgICBjb25zdHJ1Y3RvcihtYWluKSB7XFxuICAgICAgICB0aGlzLm1haW4gPSBtYWluO1xcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBtYWluLmNvbmZpZyk7XFxuICAgICAgfVxcbiAgICB9O1xcbiAgICBleHBvcnRzLkFkYXB0ZXIgPSBBZGFwdGVyO1xcbiAgfVxcbn0pO1xcblxcbi8vIGFkYXB0ZXJzL3RyYW5zZm9ybWVycy5qc1xcbnZhciByZXF1aXJlX3RyYW5zZm9ybWVycyA9IF9fY29tbW9uSlMoe1xcbiAgXFxcImFkYXB0ZXJzL3RyYW5zZm9ybWVycy5qc1xcXCIoZXhwb3J0cykge1xcbiAgICB2YXIgeyBBZGFwdGVyIH0gPSByZXF1aXJlX2FkYXB0ZXIoKTtcXG4gICAgdmFyIFRyYW5zZm9ybWVyc0FkYXB0ZXIgPSBjbGFzcyBleHRlbmRzIEFkYXB0ZXIge1xcbiAgICAgIGFzeW5jIGluaXQoKSB7XFxuICAgICAgICBjb25zdCB7IGVudiwgcGlwZWxpbmUsIEF1dG9Ub2tlbml6ZXIgfSA9IGF3YWl0IGltcG9ydChcXFwiQHhlbm92YS90cmFuc2Zvcm1lcnNcXFwiKTtcXG4gICAgICAgIGVudi5hbGxvd0xvY2FsTW9kZWxzID0gZmFsc2U7XFxuICAgICAgICB0aGlzLm1vZGVsID0gYXdhaXQgcGlwZWxpbmUoXFxcImZlYXR1cmUtZXh0cmFjdGlvblxcXCIsIHRoaXMubW9kZWxfbmFtZSwgeyBxdWFudGl6ZWQ6IHRydWUsIG1heF9sZW5ndGg6IHRoaXMubWF4X3Rva2VucyB9KTtcXG4gICAgICAgIHRoaXMudG9rZW5pemVyID0gYXdhaXQgQXV0b1Rva2VuaXplci5mcm9tX3ByZXRyYWluZWQodGhpcy5tb2RlbF9uYW1lKTtcXG4gICAgICB9XFxuICAgICAgYXN5bmMgZW1iZWRfYmF0Y2goaXRlbXMpIHtcXG4gICAgICAgIGl0ZW1zID0gaXRlbXMuZmlsdGVyKChpdGVtKSA9PiB7XFxuICAgICAgICAgIHZhciBfYTtcXG4gICAgICAgICAgcmV0dXJuICgoX2EgPSBpdGVtLmVtYmVkX2lucHV0KSA9PSBudWxsID8gdm9pZCAwIDogX2EubGVuZ3RoKSA+IDA7XFxuICAgICAgICB9KTtcXG4gICAgICAgIGlmICghKGl0ZW1zID09IG51bGwgPyB2b2lkIDAgOiBpdGVtcy5sZW5ndGgpKVxcbiAgICAgICAgICByZXR1cm4gW107XFxuICAgICAgICBjb25zdCB0b2tlbnMgPSBhd2FpdCBQcm9taXNlLmFsbChpdGVtcy5tYXAoKGl0ZW0pID0+IHRoaXMuY291bnRfdG9rZW5zKGl0ZW0uZW1iZWRfaW5wdXQpKSk7XFxuICAgICAgICBjb25zdCBlbWJlZF9pbnB1dCA9IGF3YWl0IFByb21pc2UuYWxsKGl0ZW1zLm1hcChhc3luYyAoaXRlbSwgaSkgPT4ge1xcbiAgICAgICAgICBpZiAodG9rZW5zW2ldIDwgdGhpcy5tYXhfdG9rZW5zKVxcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmVtYmVkX2lucHV0O1xcbiAgICAgICAgICBsZXQgdG9rZW5fY3QgPSB0b2tlbnNbaV07XFxuICAgICAgICAgIGxldCB0cnVuY2F0ZWRfaW5wdXQgPSBpdGVtLmVtYmVkX2lucHV0O1xcbiAgICAgICAgICB3aGlsZSAodG9rZW5fY3QgPiB0aGlzLm1heF90b2tlbnMpIHtcXG4gICAgICAgICAgICBjb25zdCBwY3QgPSB0aGlzLm1heF90b2tlbnMgLyB0b2tlbl9jdDtcXG4gICAgICAgICAgICBjb25zdCBtYXhfY2hhcnMgPSBNYXRoLmZsb29yKHRydW5jYXRlZF9pbnB1dC5sZW5ndGggKiBwY3QgKiAwLjkpO1xcbiAgICAgICAgICAgIHRydW5jYXRlZF9pbnB1dCA9IHRydW5jYXRlZF9pbnB1dC5zdWJzdHJpbmcoMCwgbWF4X2NoYXJzKSArIFxcXCIuLi5cXFwiO1xcbiAgICAgICAgICAgIHRva2VuX2N0ID0gYXdhaXQgdGhpcy5jb3VudF90b2tlbnModHJ1bmNhdGVkX2lucHV0KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICB0b2tlbnNbaV0gPSB0b2tlbl9jdDtcXG4gICAgICAgICAgcmV0dXJuIHRydW5jYXRlZF9pbnB1dDtcXG4gICAgICAgIH0pKTtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgIGNvbnN0IHJlc3AyID0gYXdhaXQgdGhpcy5tb2RlbChlbWJlZF9pbnB1dCwgeyBwb29saW5nOiBcXFwibWVhblxcXCIsIG5vcm1hbGl6ZTogdHJ1ZSB9KTtcXG4gICAgICAgICAgcmV0dXJuIGl0ZW1zLm1hcCgoaXRlbSwgaSkgPT4ge1xcbiAgICAgICAgICAgIGl0ZW0udmVjID0gQXJyYXkuZnJvbShyZXNwMltpXS5kYXRhKTtcXG4gICAgICAgICAgICBpdGVtLnRva2VucyA9IHRva2Vuc1tpXTtcXG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcXG4gICAgICAgICAgY29uc29sZS5sb2coXFxcIkVycm9yIGVtYmVkZGluZyBiYXRjaC4gVHJ5aW5nIG9uZSBhdCBhIHRpbWUuLi5cXFwiKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCBQcm9taXNlLmFsbChpdGVtcy5tYXAoYXN5bmMgKGl0ZW0pID0+IHtcXG4gICAgICAgICAgY29uc3QgeyB2ZWMsIHRva2VuczogdG9rZW5zMiwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuZW1iZWQoaXRlbS5lbWJlZF9pbnB1dCk7XFxuICAgICAgICAgIGlmIChlcnJvcikge1xcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxcXCJFcnJvciBlbWJlZGRpbmcgaXRlbTogXFxcIiwgaXRlbS5rZXkpO1xcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcXG4gICAgICAgICAgICBpdGVtLmVycm9yID0gZXJyb3I7XFxuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaWYgKCF2ZWMpIHtcXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcXFwiRXJyb3IgZW1iZWRkaW5nIGl0ZW06IFxcXCIsIGl0ZW0ua2V5KTtcXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcXFwiVmVjOiBcXFwiLCB2ZWMpO1xcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxcXCJFcnJvcjogXFxcIiwgZXJyb3IpO1xcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxcXCJUb2tlbnM6IFxcXCIsIHRva2VuczIpO1xcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxcXCJObyB2ZWMgcmV0dXJuZWRcXFwiKTtcXG4gICAgICAgICAgICBpdGVtLmVycm9yID0gXFxcIk5vIHZlYyByZXR1cm5lZFxcXCI7XFxuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaXRlbS52ZWMgPSB2ZWMubWFwKCh2YWwpID0+IE1hdGgucm91bmQodmFsICogMWU4KSAvIDFlOCk7XFxuICAgICAgICAgIGl0ZW0udG9rZW5zID0gdG9rZW5zMjtcXG4gICAgICAgICAgcmV0dXJuIGl0ZW07XFxuICAgICAgICB9KSk7XFxuICAgICAgICByZXR1cm4gcmVzcDtcXG4gICAgICB9XFxuICAgICAgYXN5bmMgZW1iZWQoaW5wdXQpIHtcXG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHsgZW1iZWRfaW5wdXQ6IGlucHV0IH07XFxuICAgICAgICBpZiAoIWlucHV0KVxcbiAgICAgICAgICByZXR1cm4geyAuLi5vdXRwdXQsIGVycm9yOiBcXFwiTm8gaW5wdXQgdGV4dC5cXFwiIH07XFxuICAgICAgICBpZiAoIXRoaXMubW9kZWwpXFxuICAgICAgICAgIGF3YWl0IHRoaXMuaW5pdCgpO1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgb3V0cHV0LnRva2VucyA9IGF3YWl0IHRoaXMuY291bnRfdG9rZW5zKGlucHV0KTtcXG4gICAgICAgICAgaWYgKG91dHB1dC50b2tlbnMgPCAxKVxcbiAgICAgICAgICAgIHJldHVybiB7IC4uLm91dHB1dCwgZXJyb3I6IFxcXCJJbnB1dCB0b28gc2hvcnQuXFxcIiB9O1xcbiAgICAgICAgICBpZiAob3V0cHV0LnRva2VucyA8IHRoaXMubWF4X3Rva2Vucykge1xcbiAgICAgICAgICAgIGNvbnN0IGVtYmVkZGluZyA9IGF3YWl0IHRoaXMubW9kZWwoaW5wdXQsIHsgcG9vbGluZzogXFxcIm1lYW5cXFwiLCBub3JtYWxpemU6IHRydWUgfSk7XFxuICAgICAgICAgICAgb3V0cHV0LnZlYyA9IEFycmF5LmZyb20oZW1iZWRkaW5nLmRhdGEpLm1hcCgodmFsKSA9PiBNYXRoLnJvdW5kKHZhbCAqIDFlOCkgLyAxZTgpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGNvbnN0IHBjdCA9IHRoaXMubWF4X3Rva2VucyAvIG91dHB1dC50b2tlbnM7XFxuICAgICAgICAgICAgY29uc3QgbWF4X2NoYXJzID0gTWF0aC5mbG9vcihpbnB1dC5sZW5ndGggKiBwY3QgKiAwLjk1KTtcXG4gICAgICAgICAgICBpbnB1dCA9IGlucHV0LnN1YnN0cmluZygwLCBtYXhfY2hhcnMpICsgXFxcIi4uLlxcXCI7XFxuICAgICAgICAgICAgb3V0cHV0LnRydW5jYXRlZCA9IHRydWU7XFxuICAgICAgICAgICAgY29uc29sZS5sb2coXFxcIklucHV0IHRvbyBsb25nLiBUcnVuY2F0aW5nIHRvIFxcXCIsIGlucHV0Lmxlbmd0aCwgXFxcIiBjaGFyYWN0ZXJzLlxcXCIpO1xcbiAgICAgICAgICAgIGNvbnN0IHsgdmVjLCB0b2tlbnMgfSA9IGF3YWl0IHRoaXMuZW1iZWQoaW5wdXQpO1xcbiAgICAgICAgICAgIG91dHB1dC52ZWMgPSB2ZWM7XFxuICAgICAgICAgICAgb3V0cHV0LnRva2VucyA9IHRva2VucztcXG4gICAgICAgICAgfVxcbiAgICAgICAgICByZXR1cm4gb3V0cHV0O1xcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XFxuICAgICAgICAgIHJldHVybiB7IC4uLm91dHB1dCwgZXJyb3I6IGVyci5tZXNzYWdlIH07XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIGFzeW5jIGNvdW50X3Rva2Vucyh0ZXh0KSB7XFxuICAgICAgICBpZiAoIXRoaXMudG9rZW5pemVyKVxcbiAgICAgICAgICBhd2FpdCB0aGlzLmluaXQoKTtcXG4gICAgICAgIGNvbnN0IHsgaW5wdXRfaWRzIH0gPSBhd2FpdCB0aGlzLnRva2VuaXplcih0ZXh0KTtcXG4gICAgICAgIHJldHVybiBpbnB1dF9pZHMuZGF0YS5sZW5ndGg7XFxuICAgICAgfVxcbiAgICB9O1xcbiAgICBleHBvcnRzLlRyYW5zZm9ybWVyc0FkYXB0ZXIgPSBUcmFuc2Zvcm1lcnNBZGFwdGVyO1xcbiAgfVxcbn0pO1xcblxcbi8vIHRyYW5zZm9ybWVyc19pZnJhbWUuanNcXG52YXIgcmVxdWlyZV90cmFuc2Zvcm1lcnNfaWZyYW1lID0gX19jb21tb25KUyh7XFxuICBcXFwidHJhbnNmb3JtZXJzX2lmcmFtZS5qc1xcXCIoZXhwb3J0cykge1xcbiAgICB2YXIgeyBUcmFuc2Zvcm1lcnNBZGFwdGVyIH0gPSByZXF1aXJlX3RyYW5zZm9ybWVycygpO1xcbiAgICB2YXIgVHJhbnNmb3JtZXJzSWZyYW1lQ29ubmVjdG9yID0gY2xhc3MgX1RyYW5zZm9ybWVyc0lmcmFtZUNvbm5lY3RvciBleHRlbmRzIFRyYW5zZm9ybWVyc0FkYXB0ZXIge1xcbiAgICAgIGNvbnN0cnVjdG9yKG1vZGVsX2NvbmZpZywgd2luZG93Mikge1xcbiAgICAgICAgc3VwZXIoeyBjb25maWc6IG1vZGVsX2NvbmZpZyB9KTtcXG4gICAgICAgIHRoaXMubW9kZWwgPSBudWxsO1xcbiAgICAgICAgdGhpcy5ydW5uaW5nX2luaXQgPSBmYWxzZTtcXG4gICAgICAgIHRoaXMud2luZG93ID0gd2luZG93MjtcXG4gICAgICAgIHRoaXMuZW1iZWRfY3QgPSAwO1xcbiAgICAgICAgdGhpcy50aW1lc3RhbXAgPSBudWxsO1xcbiAgICAgICAgdGhpcy50b2tlbnMgPSAwO1xcbiAgICAgIH1cXG4gICAgICBzdGF0aWMgYXN5bmMgY3JlYXRlKG1vZGVsX2NvbmZpZywgd2luZG93Mikge1xcbiAgICAgICAgY29uc3QgY29ubmVjdG9yID0gbmV3IF9UcmFuc2Zvcm1lcnNJZnJhbWVDb25uZWN0b3IobW9kZWxfY29uZmlnLCB3aW5kb3cyKTtcXG4gICAgICAgIGF3YWl0IGNvbm5lY3Rvci5pbml0KCk7XFxuICAgICAgICByZXR1cm4gY29ubmVjdG9yO1xcbiAgICAgIH1cXG4gICAgICBhc3luYyBpbml0KCkge1xcbiAgICAgICAgaWYgKHRoaXMubW9kZWwpXFxuICAgICAgICAgIHJldHVybiBjb25zb2xlLmxvZyhcXFwiU21hcnQgTG9jYWwgTW9kZWwgYWxyZWFkeSBsb2FkZWRcXFwiKTtcXG4gICAgICAgIGlmICh0aGlzLnJ1bm5pbmdfaW5pdClcXG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgM2UzKSk7XFxuICAgICAgICBpZiAoIXRoaXMubW9kZWwgJiYgIXRoaXMucnVubmluZ19pbml0KVxcbiAgICAgICAgICB0aGlzLnJ1bm5pbmdfaW5pdCA9IHRydWU7XFxuICAgICAgICBjb25zb2xlLmxvZyhcXFwiTG9hZGluZyBTbWFydCBMb2NhbCBNb2RlbFxcXCIpO1xcbiAgICAgICAgY29uc3QgeyBwaXBlbGluZSwgZW52LCBBdXRvVG9rZW5pemVyIH0gPSBhd2FpdCBpbXBvcnQoXFxcImh0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHhlbm92YS90cmFuc2Zvcm1lcnNAbGF0ZXN0XFxcIik7XFxuICAgICAgICBlbnYuYWxsb3dMb2NhbE1vZGVscyA9IGZhbHNlO1xcbiAgICAgICAgdGhpcy5tb2RlbCA9IGF3YWl0IHBpcGVsaW5lKFxcXCJmZWF0dXJlLWV4dHJhY3Rpb25cXFwiLCB0aGlzLm1vZGVsX25hbWUsIHsgcXVhbnRpemVkOiB0cnVlIH0pO1xcbiAgICAgICAgdGhpcy50b2tlbml6ZXIgPSBhd2FpdCBBdXRvVG9rZW5pemVyLmZyb21fcHJldHJhaW5lZCh0aGlzLm1vZGVsX25hbWUpO1xcbiAgICAgICAgdGhpcy5ydW5uaW5nX2luaXQgPSBmYWxzZTtcXG4gICAgICAgIHRoaXMud2luZG93LnRva2VuaXplciA9IHRoaXMudG9rZW5pemVyO1xcbiAgICAgICAgY29uc29sZS5sb2coYXdhaXQgdGhpcy5lbWJlZChcXFwidGVzdFxcXCIpKTtcXG4gICAgICAgIHRoaXMud2luZG93LnBhcmVudC5wb3N0TWVzc2FnZSh7IHR5cGU6IFxcXCJtb2RlbF9sb2FkZWRcXFwiLCBkYXRhOiB0cnVlIH0sIFxcXCIqXFxcIik7XFxuICAgICAgICB0aGlzLndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFxcXCJtZXNzYWdlXFxcIiwgdGhpcy5oYW5kbGVfaXBjLmJpbmQodGhpcyksIGZhbHNlKTtcXG4gICAgICB9XFxuICAgICAgYXN5bmMgaGFuZGxlX2lwYyhldmVudCkge1xcbiAgICAgICAgaWYgKGV2ZW50LmRhdGEudHlwZSA9PSBcXFwic21hcnRfZW1iZWRcXFwiKVxcbiAgICAgICAgICB0aGlzLmVtYmVkX2hhbmRsZXIoZXZlbnQuZGF0YSk7XFxuICAgICAgICBpZiAoZXZlbnQuZGF0YS50eXBlID09IFxcXCJzbWFydF9lbWJlZF90b2tlbl9jdFxcXCIpXFxuICAgICAgICAgIHRoaXMuY291bnRfdG9rZW5zX2hhbmRsZXIoZXZlbnQuZGF0YS5lbWJlZF9pbnB1dCk7XFxuICAgICAgfVxcbiAgICAgIGFzeW5jIGVtYmVkX2hhbmRsZXIoZXZlbnRfZGF0YSkge1xcbiAgICAgICAgY29uc3QgeyBlbWJlZF9pbnB1dCwgaGFuZGxlcl9pZCB9ID0gZXZlbnRfZGF0YTtcXG4gICAgICAgIGlmICghdGhpcy50aW1lc3RhbXApXFxuICAgICAgICAgIHRoaXMudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGVtYmVkX2lucHV0KSkge1xcbiAgICAgICAgICBjb25zdCByZXNwID0gYXdhaXQgdGhpcy5lbWJlZF9iYXRjaChlbWJlZF9pbnB1dCk7XFxuICAgICAgICAgIGNvbnN0IHNlbmRfZGF0YSA9IHtcXG4gICAgICAgICAgICB0eXBlOiBcXFwic21hcnRfZW1iZWRfcmVzcFxcXCIsXFxuICAgICAgICAgICAgaGFuZGxlcl9pZCxcXG4gICAgICAgICAgICBkYXRhOiByZXNwXFxuICAgICAgICAgIH07XFxuICAgICAgICAgIHRoaXMud2luZG93LnBvc3RNZXNzYWdlKHNlbmRfZGF0YSwgXFxcIipcXFwiKTtcXG4gICAgICAgICAgdGhpcy50b2tlbnMgKz0gcmVzcC5yZWR1Y2UoKGFjYywgaXRlbSkgPT4gYWNjICsgaXRlbS50b2tlbnMsIDApO1xcbiAgICAgICAgICB0aGlzLmVtYmVkX2N0ICs9IHJlc3AubGVuZ3RoO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgaWYgKCF0aGlzLnRpbWVzdGFtcClcXG4gICAgICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IERhdGUubm93KCk7XFxuICAgICAgICAgIGNvbnN0IHNlbmRfZGF0YSA9IGF3YWl0IHRoaXMuZW1iZWQoZW1iZWRfaW5wdXQpO1xcbiAgICAgICAgICBzZW5kX2RhdGEudHlwZSA9IFxcXCJzbWFydF9lbWJlZF9yZXNwXFxcIjtcXG4gICAgICAgICAgaWYgKGhhbmRsZXJfaWQpXFxuICAgICAgICAgICAgc2VuZF9kYXRhLmhhbmRsZXJfaWQgPSBoYW5kbGVyX2lkO1xcbiAgICAgICAgICB0aGlzLndpbmRvdy5wb3N0TWVzc2FnZShzZW5kX2RhdGEsIFxcXCIqXFxcIik7XFxuICAgICAgICAgIHRoaXMudG9rZW5zICs9IHNlbmRfZGF0YS50b2tlbnM7XFxuICAgICAgICAgIHRoaXMuZW1iZWRfY3QrKztcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChEYXRlLm5vdygpIC0gdGhpcy50aW1lc3RhbXAgPiAxZTQpIHtcXG4gICAgICAgICAgY29uc29sZS5sb2coYEVtYmVkZGVkOiAke3RoaXMuZW1iZWRfY3R9IGlucHV0cyAoJHt0aGlzLnRva2Vuc30gdG9rZW5zLCAkeyh0aGlzLnRva2VucyAvICgoRGF0ZS5ub3coKSAtIHRoaXMudGltZXN0YW1wKSAvIDFlMykpLnRvRml4ZWQoMCl9IHRva2Vucy9zZWMpYCk7XFxuICAgICAgICAgIHRoaXMudGltZXN0YW1wID0gbnVsbDtcXG4gICAgICAgICAgdGhpcy50b2tlbnMgPSAwO1xcbiAgICAgICAgICB0aGlzLmVtYmVkX2N0ID0gMDtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgYXN5bmMgY291bnRfdG9rZW5zX2hhbmRsZXIoaW5wdXQpIHtcXG4gICAgICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IHRoaXMuY291bnRfdG9rZW5zKGlucHV0KTtcXG4gICAgICAgIGNvbnN0IHNlbmRfZGF0YSA9IHtcXG4gICAgICAgICAgdHlwZTogXFxcInNtYXJ0X2VtYmVkX3Rva2VuX2N0XFxcIixcXG4gICAgICAgICAgdGV4dDogXFxcImNvdW50OlxcXCIgKyBpbnB1dCxcXG4gICAgICAgICAgY291bnQ6IG91dHB1dFxcbiAgICAgICAgfTtcXG4gICAgICAgIHRoaXMud2luZG93LnBvc3RNZXNzYWdlKHNlbmRfZGF0YSwgXFxcIipcXFwiKTtcXG4gICAgICB9XFxuICAgIH07XFxuICAgIGV4cG9ydHMuVHJhbnNmb3JtZXJzSWZyYW1lQ29ubmVjdG9yID0gVHJhbnNmb3JtZXJzSWZyYW1lQ29ubmVjdG9yO1xcbiAgfVxcbn0pO1xcblxcbi8vIHNtYXJ0X2VtYmVkX3dlYi5qc1xcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFxcXCJtZXNzYWdlXFxcIiwgaW5pdCk7XFxuYXN5bmMgZnVuY3Rpb24gaW5pdChldmVudCkge1xcbiAgaWYgKGV2ZW50LmRhdGEudHlwZSA9PT0gXFxcImluaXRcXFwiKSB7XFxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFxcXCJtZXNzYWdlXFxcIiwgaW5pdCk7XFxuICAgIGNvbnN0IG1vZGVsX2NvbmZpZyA9IGV2ZW50LmRhdGEubW9kZWxfY29uZmlnO1xcbiAgICBjb25zb2xlLmxvZyhtb2RlbF9jb25maWcpO1xcbiAgICBjb25zdCB7IFRyYW5zZm9ybWVyc0lmcmFtZUNvbm5lY3RvciB9ID0gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiBfX3RvRVNNKHJlcXVpcmVfdHJhbnNmb3JtZXJzX2lmcmFtZSgpKSk7XFxuICAgIGNvbnN0IG1vZGVsID0gYXdhaXQgVHJhbnNmb3JtZXJzSWZyYW1lQ29ubmVjdG9yLmNyZWF0ZShtb2RlbF9jb25maWcsIHdpbmRvdyk7XFxuICAgIHdpbmRvdy5tb2RlbCA9IG1vZGVsO1xcbiAgfVxcbn1cXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV3b2dJQ0oyWlhKemFXOXVJam9nTXl3S0lDQWljMjkxY21ObGN5STZJRnNpWVdSaGNIUmxjbk12WVdSaGNIUmxjaTVxY3lJc0lDSmhaR0Z3ZEdWeWN5OTBjbUZ1YzJadmNtMWxjbk11YW5NaUxDQWlkSEpoYm5ObWIzSnRaWEp6WDJsbWNtRnRaUzVxY3lJc0lDSnpiV0Z5ZEY5bGJXSmxaRjkzWldJdWFuTWlYU3dLSUNBaWMyOTFjbU5sYzBOdmJuUmxiblFpT2lCYklpOHFLbHh1SUNvZ1VtVndjbVZ6Wlc1MGN5QmhJR2RsYm1WeWFXTWdZV1JoY0hSbGNpQmpiR0Z6Y3lCMGFHRjBJR2x1YVhScFlXeHBlbVZ6SUhkcGRHZ2dZU0J0WVdsdUlHTnZiblJsZUhRZ1lXNWtJR052Y0dsbGN5QnBkSE1nWTI5dVptbG5kWEpoZEdsdmJpNWNiaUFxTDF4dVkyeGhjM01nUVdSaGNIUmxjaUI3WEc0Z0lDOHFLbHh1SUNBZ0tpQkRiMjV6ZEhKMVkzUnpJR0Z1SUdsdWMzUmhibU5sSUc5bUlFRmtZWEIwWlhJdVhHNGdJQ0FxSUVCd1lYSmhiU0I3YjJKcVpXTjBmU0J0WVdsdUlDMGdWR2hsSUcxaGFXNGdZMjl1ZEdWNGRDQnZZbXBsWTNRZ2QyaHBZMmdnYzJodmRXeGtJR052Ym5SaGFXNGdZU0JqYjI1bWFXZDFjbUYwYVc5dUlHOWlhbVZqZEM1Y2JpQWdJQ292WEc0Z0lHTnZibk4wY25WamRHOXlLRzFoYVc0cElIdGNiaUFnSUNBdktpcGNiaUFnSUNBZ0tpQlVhR1VnYldGcGJpQmpiMjUwWlhoMElHOWlhbVZqZENCbWNtOXRJSGRvYVdOb0lHTnZibVpwWjNWeVlYUnBiMjRnYVhNZ1pHVnlhWFpsWkM1Y2JpQWdJQ0FnS2lCQWRIbHdaU0I3YjJKcVpXTjBmVnh1SUNBZ0lDQXFMMXh1SUNBZ0lIUm9hWE11YldGcGJpQTlJRzFoYVc0N1hHNWNiaUFnSUNBdktpcGNiaUFnSUNBZ0tpQkRiM0JwWlhNZ2NISnZjR1Z5ZEdsbGN5Qm1jbTl0SUhSb1pTQnRZV2x1SUc5aWFtVmpkQ2R6SUdOdmJtWnBaeUJ3Y205d1pYSjBlU0IwYnlCMGFHbHpJR2x1YzNSaGJtTmxMbHh1SUNBZ0lDQXFMMXh1SUNBZ0lFOWlhbVZqZEM1aGMzTnBaMjRvZEdocGN5d2diV0ZwYmk1amIyNW1hV2NwT3lBdkx5QkRiM0I1SUdOdmJtWnBaeUIwYnlCMGFHbHpYRzRnSUgxY2JuMWNibHh1THk4Z1JYaHdiM0owSUhSb1pTQkJaR0Z3ZEdWeUlHTnNZWE56SUhSdklHSmxJR0YyWVdsc1lXSnNaU0JtYjNJZ2IzUm9aWElnYlc5a2RXeGxjeTVjYm1WNGNHOXlkSE11UVdSaGNIUmxjaUE5SUVGa1lYQjBaWEk3WEc0aUxDQWlZMjl1YzNRZ2V5QkJaR0Z3ZEdWeUlIMGdQU0J5WlhGMWFYSmxLRndpTGk5aFpHRndkR1Z5WENJcE8xeHVYRzVqYkdGemN5QlVjbUZ1YzJadmNtMWxjbk5CWkdGd2RHVnlJR1Y0ZEdWdVpITWdRV1JoY0hSbGNpQjdYRzRnSUdGemVXNWpJR2x1YVhRb0tTQjdYRzRnSUNBZ1kyOXVjM1FnZXlCbGJuWXNJSEJwY0dWc2FXNWxMQ0JCZFhSdlZHOXJaVzVwZW1WeUlIMGdQU0JoZDJGcGRDQnBiWEJ2Y25Rb0owQjRaVzV2ZG1FdmRISmhibk5tYjNKdFpYSnpKeWs3WEc0Z0lDQWdaVzUyTG1Gc2JHOTNURzlqWVd4TmIyUmxiSE1nUFNCbVlXeHpaVHRjYmlBZ0lDQjBhR2x6TG0xdlpHVnNJRDBnWVhkaGFYUWdjR2x3Wld4cGJtVW9KMlpsWVhSMWNtVXRaWGgwY21GamRHbHZiaWNzSUhSb2FYTXViVzlrWld4ZmJtRnRaU3dnZXlCeGRXRnVkR2w2WldRNklIUnlkV1VzSUcxaGVGOXNaVzVuZEdnNklIUm9hWE11YldGNFgzUnZhMlZ1Y3lCOUtUdGNiaUFnSUNBdkx5QjBhR2x6TG0xdlpHVnNJRDBnWVhkaGFYUWdjR2x3Wld4cGJtVW9KMlpsWVhSMWNtVXRaWGgwY21GamRHbHZiaWNzSUhSb2FYTXViVzlrWld4ZmJtRnRaU3dnZXlCeGRXRnVkR2w2WldRNklHWmhiSE5sSUgwcE8xeHVJQ0FnSUhSb2FYTXVkRzlyWlc1cGVtVnlJRDBnWVhkaGFYUWdRWFYwYjFSdmEyVnVhWHBsY2k1bWNtOXRYM0J5WlhSeVlXbHVaV1FvZEdocGN5NXRiMlJsYkY5dVlXMWxLVHRjYmlBZ2ZWeHVJQ0JoYzNsdVl5QmxiV0psWkY5aVlYUmphQ2hwZEdWdGN5a2dlMXh1SUNBZ0lHbDBaVzF6SUQwZ2FYUmxiWE11Wm1sc2RHVnlLR2wwWlcwZ1BUNGdhWFJsYlM1bGJXSmxaRjlwYm5CMWREOHViR1Z1WjNSb0lENGdNQ2s3SUM4dklISmxiVzkyWlNCcGRHVnRjeUIzYVhSb0lHVnRjSFI1SUdWdFltVmtYMmx1Y0hWMElDaGpZWFZ6WlhNZ0xuTndiR2wwS0NrZ1pYSnliM0lwWEc0Z0lDQWdhV1lvSVdsMFpXMXpQeTVzWlc1bmRHZ3BJSEpsZEhWeWJpQmJYVHRjYmlBZ0lDQmpiMjV6ZENCMGIydGxibk1nUFNCaGQyRnBkQ0JRY205dGFYTmxMbUZzYkNocGRHVnRjeTV0WVhBb2FYUmxiU0E5UGlCMGFHbHpMbU52ZFc1MFgzUnZhMlZ1Y3locGRHVnRMbVZ0WW1Wa1gybHVjSFYwS1NrcE8xeHVJQ0FnSUdOdmJuTjBJR1Z0WW1Wa1gybHVjSFYwSUQwZ1lYZGhhWFFnVUhKdmJXbHpaUzVoYkd3b2FYUmxiWE11YldGd0tHRnplVzVqSUNocGRHVnRMQ0JwS1NBOVBpQjdYRzRnSUNBZ0lDQnBaaUFvZEc5clpXNXpXMmxkSUR3Z2RHaHBjeTV0WVhoZmRHOXJaVzV6S1NCeVpYUjFjbTRnYVhSbGJTNWxiV0psWkY5cGJuQjFkRHRjYmlBZ0lDQWdJR3hsZENCMGIydGxibDlqZENBOUlIUnZhMlZ1YzF0cFhUdGNiaUFnSUNBZ0lHeGxkQ0IwY25WdVkyRjBaV1JmYVc1d2RYUWdQU0JwZEdWdExtVnRZbVZrWDJsdWNIVjBPMXh1SUNBZ0lDQWdkMmhwYkdVZ0tIUnZhMlZ1WDJOMElENGdkR2hwY3k1dFlYaGZkRzlyWlc1ektTQjdYRzRnSUNBZ0lDQWdJR052Ym5OMElIQmpkQ0E5SUhSb2FYTXViV0Y0WDNSdmEyVnVjeUF2SUhSdmEyVnVYMk4wT3lBdkx5Qm5aWFFnY0dOMElHOW1JR2x1Y0hWMElIUnZJR3RsWlhCY2JpQWdJQ0FnSUNBZ1kyOXVjM1FnYldGNFgyTm9ZWEp6SUQwZ1RXRjBhQzVtYkc5dmNpaDBjblZ1WTJGMFpXUmZhVzV3ZFhRdWJHVnVaM1JvSUNvZ2NHTjBJQ29nTUM0NU1DazdJQzh2SUdkbGRDQnVkVzFpWlhJZ2IyWWdZMmhoY21GamRHVnljeUIwYnlCclpXVndJQ2h0YVc1MWN5QXhNQ1VnWm05eUlITmhabVYwZVNsY2JpQWdJQ0FnSUNBZ2RISjFibU5oZEdWa1gybHVjSFYwSUQwZ2RISjFibU5oZEdWa1gybHVjSFYwTG5OMVluTjBjbWx1Wnlnd0xDQnRZWGhmWTJoaGNuTXBJQ3NnWENJdUxpNWNJanRjYmlBZ0lDQWdJQ0FnZEc5clpXNWZZM1FnUFNCaGQyRnBkQ0IwYUdsekxtTnZkVzUwWDNSdmEyVnVjeWgwY25WdVkyRjBaV1JmYVc1d2RYUXBPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lDQWdMeThnWTI5dWMyOXNaUzVzYjJjb1hDSkpibkIxZENCMGIyOGdiRzl1Wnk0Z1ZISjFibU5oZEdsdVp5QjBieUJjSWl3Z2RISjFibU5oZEdWa1gybHVjSFYwTG14bGJtZDBhQ3dnWENJZ1kyaGhjbUZqZEdWeWN5NWNJaWs3WEc0Z0lDQWdJQ0F2THlCamIyNXpiMnhsTG14dlp5aGNJbFJ2YTJWdWN6b2dYQ0lzSUhSdmEyVnVjMXRwWFN3Z1hDSWdMVDRnWENJc0lIUnZhMlZ1WDJOMEtUdGNiaUFnSUNBZ0lIUnZhMlZ1YzF0cFhTQTlJSFJ2YTJWdVgyTjBPMXh1SUNBZ0lDQWdjbVYwZFhKdUlIUnlkVzVqWVhSbFpGOXBibkIxZER0Y2JpQWdJQ0I5S1NrN1hHNWNiaUFnSUNBdkx5QmpiMjV6YjJ4bExteHZaeWhsYldKbFpGOXBibkIxZENrN1hHNGdJQ0FnZEhKNWUxeHVJQ0FnSUNBZ1kyOXVjM1FnY21WemNDQTlJR0YzWVdsMElIUm9hWE11Ylc5a1pXd29aVzFpWldSZmFXNXdkWFFzSUhzZ2NHOXZiR2x1WnpvZ0oyMWxZVzRuTENCdWIzSnRZV3hwZW1VNklIUnlkV1VnZlNrN1hHNGdJQ0FnSUNBdkx5QmpiMjV6YjJ4bExteHZaeWh5WlhOd0tUdGNiaUFnSUNBZ0lISmxkSFZ5YmlCcGRHVnRjeTV0WVhBb0tHbDBaVzBzSUdrcElEMCtJSHRjYmlBZ0lDQWdJQ0FnYVhSbGJTNTJaV01nUFNCQmNuSmhlUzVtY205dEtISmxjM0JiYVYwdVpHRjBZU2s3WEc0Z0lDQWdJQ0FnSUdsMFpXMHVkRzlyWlc1eklEMGdkRzlyWlc1elcybGRPMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdhWFJsYlR0Y2JpQWdJQ0FnSUgwcE8xeHVJQ0FnSUgxallYUmphQ2hsY25JcGUxeHVJQ0FnSUNBZ1kyOXVjMjlzWlM1c2IyY29aWEp5S1R0Y2JpQWdJQ0FnSUdOdmJuTnZiR1V1Ykc5bktGd2lSWEp5YjNJZ1pXMWlaV1JrYVc1bklHSmhkR05vTGlCVWNubHBibWNnYjI1bElHRjBJR0VnZEdsdFpTNHVMbHdpS1R0Y2JpQWdJQ0I5WEc0Z0lDQWdZMjl1YzNRZ2NtVnpjQ0E5SUdGM1lXbDBJRkJ5YjIxcGMyVXVZV3hzS0dsMFpXMXpMbTFoY0NoaGMzbHVZeUJwZEdWdElEMCtJSHRjYmlBZ0lDQWdJR052Ym5OMElIc2dkbVZqTENCMGIydGxibk1zSUdWeWNtOXlJSDBnUFNCaGQyRnBkQ0IwYUdsekxtVnRZbVZrS0dsMFpXMHVaVzFpWldSZmFXNXdkWFFwTzF4dUlDQWdJQ0FnYVdZb1pYSnliM0lwZTF4dUlDQWdJQ0FnSUNCamIyNXpiMnhsTG14dlp5aGNJa1Z5Y205eUlHVnRZbVZrWkdsdVp5QnBkR1Z0T2lCY0lpd2dhWFJsYlM1clpYa3BPMXh1SUNBZ0lDQWdJQ0JqYjI1emIyeGxMbXh2WnlobGNuSnZjaWs3WEc0Z0lDQWdJQ0FnSUdsMFpXMHVaWEp5YjNJZ1BTQmxjbkp2Y2p0Y2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUdsMFpXMDdYRzRnSUNBZ0lDQjlYRzRnSUNBZ0lDQnBaaWdoZG1WaktYdGNiaUFnSUNBZ0lDQWdZMjl1YzI5c1pTNXNiMmNvWENKRmNuSnZjaUJsYldKbFpHUnBibWNnYVhSbGJUb2dYQ0lzSUdsMFpXMHVhMlY1S1R0Y2JpQWdJQ0FnSUNBZ1kyOXVjMjlzWlM1c2IyY29YQ0pXWldNNklGd2lMQ0IyWldNcE8xeHVJQ0FnSUNBZ0lDQmpiMjV6YjJ4bExteHZaeWhjSWtWeWNtOXlPaUJjSWl3Z1pYSnliM0lwTzF4dUlDQWdJQ0FnSUNCamIyNXpiMnhsTG14dlp5aGNJbFJ2YTJWdWN6b2dYQ0lzSUhSdmEyVnVjeWs3WEc0Z0lDQWdJQ0FnSUdOdmJuTnZiR1V1Ykc5bktGd2lUbThnZG1WaklISmxkSFZ5Ym1Wa1hDSXBPMXh1SUNBZ0lDQWdJQ0JwZEdWdExtVnljbTl5SUQwZ1hDSk9ieUIyWldNZ2NtVjBkWEp1WldSY0lqdGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlHbDBaVzA3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdJQ0JwZEdWdExuWmxZeUE5SUhabFl5NXRZWEFvZG1Gc0lEMCtJRTFoZEdndWNtOTFibVFvZG1Gc0lDb2dNVEF3TURBd01EQXdLU0F2SURFd01EQXdNREF3TUNrN0lDOHZJSEpsWkhWalpTQndjbVZqYVhOcGIyNGdkRzhnT0NCa1pXTnBiV0ZzSUhCc1lXTmxjeUJ5WldZNklHaDBkSEJ6T2k4dmQyWm9ZbkpwWVc0dVkyOXRMM1psWTNSdmNpMWthVzFsYm5OcGIyNHRjSEpsWTJsemFXOXVMV1ZtWm1WamRDMXZiaTFqYjNOcGJtVXRjMmx0YVd4aGNtbDBlUzljYmlBZ0lDQWdJR2wwWlcwdWRHOXJaVzV6SUQwZ2RHOXJaVzV6TzF4dUlDQWdJQ0FnY21WMGRYSnVJR2wwWlcwN1hHNGdJQ0FnZlNrcE8xeHVJQ0FnSUhKbGRIVnliaUJ5WlhOd08xeHVJQ0I5WEc0Z0lHRnplVzVqSUdWdFltVmtLR2x1Y0hWMEtTQjdYRzRnSUNBZ1kyOXVjM1FnYjNWMGNIVjBJRDBnZXlCbGJXSmxaRjlwYm5CMWREb2dhVzV3ZFhRZ2ZUdGNiaUFnSUNCcFppQW9JV2x1Y0hWMEtTQnlaWFIxY200Z2V5QXVMaTV2ZFhSd2RYUXNJR1Z5Y205eU9pQmNJazV2SUdsdWNIVjBJSFJsZUhRdVhDSWdmVHRjYmlBZ0lDQnBaaUFvSVhSb2FYTXViVzlrWld3cElHRjNZV2wwSUhSb2FYTXVhVzVwZENncE8xeHVJQ0FnSUhSeWVTQjdYRzRnSUNBZ0lDQnZkWFJ3ZFhRdWRHOXJaVzV6SUQwZ1lYZGhhWFFnZEdocGN5NWpiM1Z1ZEY5MGIydGxibk1vYVc1d2RYUXBPMXh1SUNBZ0lDQWdhV1lnS0c5MWRIQjFkQzUwYjJ0bGJuTWdQQ0F4S1NCeVpYUjFjbTRnZXlBdUxpNXZkWFJ3ZFhRc0lHVnljbTl5T2lCY0lrbHVjSFYwSUhSdmJ5QnphRzl5ZEM1Y0lpQjlPMXh1SUNBZ0lDQWdhV1lnS0c5MWRIQjFkQzUwYjJ0bGJuTWdQQ0IwYUdsekxtMWhlRjkwYjJ0bGJuTXBJSHRjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdaVzFpWldSa2FXNW5JRDBnWVhkaGFYUWdkR2hwY3k1dGIyUmxiQ2hwYm5CMWRDd2dleUJ3YjI5c2FXNW5PaUFuYldWaGJpY3NJRzV2Y20xaGJHbDZaVG9nZEhKMVpTQjlLVHRjYmlBZ0lDQWdJQ0FnYjNWMGNIVjBMblpsWXlBOUlFRnljbUY1TG1aeWIyMG9aVzFpWldSa2FXNW5MbVJoZEdFcExtMWhjQ2gyWVd3Z1BUNGdUV0YwYUM1eWIzVnVaQ2gyWVd3Z0tpQXhNREF3TURBd01EQXBJQzhnTVRBd01EQXdNREF3S1RzZ0x5OGdjbVZrZFdObElIQnlaV05wYzJsdmJpQjBieUE0SUdSbFkybHRZV3dnY0d4aFkyVnpJSEpsWmpvZ2FIUjBjSE02THk5M1ptaGljbWxoYmk1amIyMHZkbVZqZEc5eUxXUnBiV1Z1YzJsdmJpMXdjbVZqYVhOcGIyNHRaV1ptWldOMExXOXVMV052YzJsdVpTMXphVzFwYkdGeWFYUjVMMXh1SUNBZ0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lDQWdZMjl1YzNRZ2NHTjBJRDBnZEdocGN5NXRZWGhmZEc5clpXNXpJQzhnYjNWMGNIVjBMblJ2YTJWdWN6c2dMeThnWjJWMElIQmpkQ0J2WmlCcGJuQjFkQ0IwYnlCclpXVndYRzRnSUNBZ0lDQWdJR052Ym5OMElHMWhlRjlqYUdGeWN5QTlJRTFoZEdndVpteHZiM0lvYVc1d2RYUXViR1Z1WjNSb0lDb2djR04wSUNvZ01DNDVOU2s3SUM4dklHZGxkQ0J1ZFcxaVpYSWdiMllnWTJoaGNtRmpkR1Z5Y3lCMGJ5QnJaV1Z3SUNodGFXNTFjeUExSlNCbWIzSWdjMkZtWlhSNUtWeHVJQ0FnSUNBZ0lDQnBibkIxZENBOUlHbHVjSFYwTG5OMVluTjBjbWx1Wnlnd0xDQnRZWGhmWTJoaGNuTXBJQ3NnWENJdUxpNWNJanRjYmlBZ0lDQWdJQ0FnYjNWMGNIVjBMblJ5ZFc1allYUmxaQ0E5SUhSeWRXVTdYRzRnSUNBZ0lDQWdJR052Ym5OdmJHVXViRzluS0Z3aVNXNXdkWFFnZEc5dklHeHZibWN1SUZSeWRXNWpZWFJwYm1jZ2RHOGdYQ0lzSUdsdWNIVjBMbXhsYm1kMGFDd2dYQ0lnWTJoaGNtRmpkR1Z5Y3k1Y0lpazdYRzRnSUNBZ0lDQWdJR052Ym5OMElIc2dkbVZqTENCMGIydGxibk1nZlNBOUlHRjNZV2wwSUhSb2FYTXVaVzFpWldRb2FXNXdkWFFwTzF4dUlDQWdJQ0FnSUNCdmRYUndkWFF1ZG1WaklEMGdkbVZqTzF4dUlDQWdJQ0FnSUNCdmRYUndkWFF1ZEc5clpXNXpJRDBnZEc5clpXNXpPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lDQWdjbVYwZFhKdUlHOTFkSEIxZER0Y2JpQWdJQ0I5SUdOaGRHTm9JQ2hsY25JcElIdGNiaUFnSUNBZ0lHTnZibk52YkdVdWJHOW5LR1Z5Y2lrN1hHNGdJQ0FnSUNCeVpYUjFjbTRnZXlBdUxpNXZkWFJ3ZFhRc0lHVnljbTl5T2lCbGNuSXViV1Z6YzJGblpTQjlPMXh1SUNBZ0lIMWNiaUFnZlZ4dUlDQmhjM2x1WXlCamIzVnVkRjkwYjJ0bGJuTW9kR1Y0ZENrZ2UxeHVJQ0FnSUdsbUlDZ2hkR2hwY3k1MGIydGxibWw2WlhJcElHRjNZV2wwSUhSb2FYTXVhVzVwZENncE8xeHVJQ0FnSUdOdmJuTjBJSHNnYVc1d2RYUmZhV1J6SUgwZ1BTQmhkMkZwZENCMGFHbHpMblJ2YTJWdWFYcGxjaWgwWlhoMEtUdGNiaUFnSUNCeVpYUjFjbTRnYVc1d2RYUmZhV1J6TG1SaGRHRXViR1Z1WjNSb095QXZMeUJTWlhSMWNtNGdkR2hsSUc1MWJXSmxjaUJ2WmlCMGIydGxibk5jYmlBZ2ZWeHVmVnh1WEc1bGVIQnZjblJ6TGxSeVlXNXpabTl5YldWeWMwRmtZWEIwWlhJZ1BTQlVjbUZ1YzJadmNtMWxjbk5CWkdGd2RHVnlPeUlzSUNKamIyNXpkQ0I3SUZSeVlXNXpabTl5YldWeWMwRmtZWEIwWlhJZ2ZTQTlJSEpsY1hWcGNtVW9KeTR2WVdSaGNIUmxjbk12ZEhKaGJuTm1iM0p0WlhKekp5azdYRzVjYmk4dklFTlBUazVGUTFSUFVpQkdUMUlnVDBKVFNVUkpRVTVjYm1Oc1lYTnpJRlJ5WVc1elptOXliV1Z5YzBsbWNtRnRaVU52Ym01bFkzUnZjaUJsZUhSbGJtUnpJRlJ5WVc1elptOXliV1Z5YzBGa1lYQjBaWElnZTF4dUlDQmpiMjV6ZEhKMVkzUnZjaWh0YjJSbGJGOWpiMjVtYVdjc0lIZHBibVJ2ZHlrZ2UxeHVJQ0FnSUhOMWNHVnlLSHRqYjI1bWFXYzZJRzF2WkdWc1gyTnZibVpwWjMwcE95QXZMeUJoYzNOcFoyNXpJR052Ym1acFp5QjBieUIwYUdseklHbHVJRUZrWVhCMFpYSmNiaUFnSUNCMGFHbHpMbTF2WkdWc0lEMGdiblZzYkR0Y2JpQWdJQ0IwYUdsekxuSjFibTVwYm1kZmFXNXBkQ0E5SUdaaGJITmxPMXh1SUNBZ0lIUm9hWE11ZDJsdVpHOTNJRDBnZDJsdVpHOTNPMXh1SUNBZ0lDOHZJSE4wWVhSelhHNGdJQ0FnZEdocGN5NWxiV0psWkY5amRDQTlJREE3WEc0Z0lDQWdkR2hwY3k1MGFXMWxjM1JoYlhBZ1BTQnVkV3hzTzF4dUlDQWdJSFJvYVhNdWRHOXJaVzV6SUQwZ01EdGNiaUFnZlZ4dUlDQnpkR0YwYVdNZ1lYTjVibU1nWTNKbFlYUmxLRzF2WkdWc1gyTnZibVpwWnl3Z2QybHVaRzkzS1NCN1hHNGdJQ0FnWTI5dWMzUWdZMjl1Ym1WamRHOXlJRDBnYm1WM0lGUnlZVzV6Wm05eWJXVnljMGxtY21GdFpVTnZibTVsWTNSdmNpaHRiMlJsYkY5amIyNW1hV2NzSUhkcGJtUnZkeWs3WEc0Z0lDQWdZWGRoYVhRZ1kyOXVibVZqZEc5eUxtbHVhWFFvS1R0Y2JpQWdJQ0J5WlhSMWNtNGdZMjl1Ym1WamRHOXlPMXh1SUNCOVhHNGdJR0Z6ZVc1aklHbHVhWFFvS1NCN1hHNGdJQ0FnYVdZZ0tIUm9hWE11Ylc5a1pXd3BJSEpsZEhWeWJpQmpiMjV6YjJ4bExteHZaeWhjSWxOdFlYSjBJRXh2WTJGc0lFMXZaR1ZzSUdGc2NtVmhaSGtnYkc5aFpHVmtYQ0lwTzF4dUlDQWdJR2xtSUNoMGFHbHpMbkoxYm01cGJtZGZhVzVwZENrZ1lYZGhhWFFnYm1WM0lGQnliMjFwYzJVb2NtVnpiMngyWlNBOVBpQnpaWFJVYVcxbGIzVjBLSEpsYzI5c2RtVXNJRE13TURBcEtUdGNiaUFnSUNCcFppQW9JWFJvYVhNdWJXOWtaV3dnSmlZZ0lYUm9hWE11Y25WdWJtbHVaMTlwYm1sMEtTQjBhR2x6TG5KMWJtNXBibWRmYVc1cGRDQTlJSFJ5ZFdVN1hHNGdJQ0FnWTI5dWMyOXNaUzVzYjJjb1hDSk1iMkZrYVc1bklGTnRZWEowSUV4dlkyRnNJRTF2WkdWc1hDSXBPMXh1SUNBZ0lDOHZJR052Ym5OMElIc2djR2x3Wld4cGJtVXNJR1Z1ZGl3Z1FYVjBiMVJ2YTJWdWFYcGxjaUI5SUQwZ1lYZGhhWFFnYVcxd2IzSjBLQ2RvZEhSd2N6b3ZMMk5rYmk1cWMyUmxiR2wyY2k1dVpYUXZibkJ0TDBCNFpXNXZkbUV2ZEhKaGJuTm1iM0p0WlhKelFESXVNVE11TUNjcE8xeHVJQ0FnSUdOdmJuTjBJSHNnY0dsd1pXeHBibVVzSUdWdWRpd2dRWFYwYjFSdmEyVnVhWHBsY2lCOUlEMGdZWGRoYVhRZ2FXMXdiM0owS0Nkb2RIUndjem92TDJOa2JpNXFjMlJsYkdsMmNpNXVaWFF2Ym5CdEwwQjRaVzV2ZG1FdmRISmhibk5tYjNKdFpYSnpRR3hoZEdWemRDY3BPMXh1SUNBZ0lHVnVkaTVoYkd4dmQweHZZMkZzVFc5a1pXeHpJRDBnWm1Gc2MyVTdYRzRnSUNBZ2RHaHBjeTV0YjJSbGJDQTlJR0YzWVdsMElIQnBjR1ZzYVc1bEtDZG1aV0YwZFhKbExXVjRkSEpoWTNScGIyNG5MQ0IwYUdsekxtMXZaR1ZzWDI1aGJXVXNJSHNnY1hWaGJuUnBlbVZrT2lCMGNuVmxJSDBwTzF4dUlDQWdJSFJvYVhNdWRHOXJaVzVwZW1WeUlEMGdZWGRoYVhRZ1FYVjBiMVJ2YTJWdWFYcGxjaTVtY205dFgzQnlaWFJ5WVdsdVpXUW9kR2hwY3k1dGIyUmxiRjl1WVcxbEtUdGNiaUFnSUNCMGFHbHpMbkoxYm01cGJtZGZhVzVwZENBOUlHWmhiSE5sTzF4dUlDQWdJSFJvYVhNdWQybHVaRzkzTG5SdmEyVnVhWHBsY2lBOUlIUm9hWE11ZEc5clpXNXBlbVZ5TzF4dUlDQWdJR052Ym5OdmJHVXViRzluS0dGM1lXbDBJSFJvYVhNdVpXMWlaV1FvWENKMFpYTjBYQ0lwS1R0Y2JpQWdJQ0IwYUdsekxuZHBibVJ2ZHk1d1lYSmxiblF1Y0c5emRFMWxjM05oWjJVb2V5QjBlWEJsT2lCY0ltMXZaR1ZzWDJ4dllXUmxaRndpTENCa1lYUmhPaUIwY25WbElIMHNJRndpS2x3aUtUc2dMeThnY0c5emRDQnRaWE56WVdkbElIUnZJSEJoY21WdWRDQjBhR0YwSUcxdlpHVnNJR2x6SUd4dllXUmxaRnh1SUNBZ0lIUm9hWE11ZDJsdVpHOTNMbUZrWkVWMlpXNTBUR2x6ZEdWdVpYSW9YQ0p0WlhOellXZGxYQ0lzSUhSb2FYTXVhR0Z1Wkd4bFgybHdZeTVpYVc1a0tIUm9hWE1wTENCbVlXeHpaU2s3WEc0Z0lIMWNiaUFnWVhONWJtTWdhR0Z1Wkd4bFgybHdZeWhsZG1WdWRDa2dlMXh1SUNBZ0lHbG1JQ2hsZG1WdWRDNWtZWFJoTG5SNWNHVWdQVDBnWENKemJXRnlkRjlsYldKbFpGd2lLU0IwYUdsekxtVnRZbVZrWDJoaGJtUnNaWElvWlhabGJuUXVaR0YwWVNrN1hHNGdJQ0FnTHk4Z2FXWWdLR1YyWlc1MExtUmhkR0V1ZEhsd1pTQTlQU0JjSW5OdFlYSjBYMlZ0WW1Wa1gySmhkR05vWENJcElIUm9hWE11WlcxaVpXUmZZbUYwWTJoZmFHRnVaR3hsY2lobGRtVnVkQzVrWVhSaExtVnRZbVZrWDJsdWNIVjBLVHRjYmlBZ0lDQnBaaUFvWlhabGJuUXVaR0YwWVM1MGVYQmxJRDA5SUZ3aWMyMWhjblJmWlcxaVpXUmZkRzlyWlc1ZlkzUmNJaWtnZEdocGN5NWpiM1Z1ZEY5MGIydGxibk5mYUdGdVpHeGxjaWhsZG1WdWRDNWtZWFJoTG1WdFltVmtYMmx1Y0hWMEtUdGNiaUFnZlZ4dUlDQmhjM2x1WXlCbGJXSmxaRjlvWVc1a2JHVnlLR1YyWlc1MFgyUmhkR0VwSUh0Y2JpQWdJQ0JqYjI1emRDQjdJR1Z0WW1Wa1gybHVjSFYwTENCb1lXNWtiR1Z5WDJsa0lIMGdQU0JsZG1WdWRGOWtZWFJoTzF4dUlDQWdJQzh2SUdOdmJuTnZiR1V1Ykc5bktHVnRZbVZrWDJsdWNIVjBLVHRjYmlBZ0lDQnBaaWdoZEdocGN5NTBhVzFsYzNSaGJYQXBJSFJvYVhNdWRHbHRaWE4wWVcxd0lEMGdSR0YwWlM1dWIzY29LVHRjYmlBZ0lDQnBaaWhCY25KaGVTNXBjMEZ5Y21GNUtHVnRZbVZrWDJsdWNIVjBLU2tnZTF4dUlDQWdJQ0FnWTI5dWMzUWdjbVZ6Y0NBOUlHRjNZV2wwSUhSb2FYTXVaVzFpWldSZlltRjBZMmdvWlcxaVpXUmZhVzV3ZFhRcE8xeHVJQ0FnSUNBZ1kyOXVjM1FnYzJWdVpGOWtZWFJoSUQwZ2UxeHVJQ0FnSUNBZ0lDQjBlWEJsT2lCY0luTnRZWEowWDJWdFltVmtYM0psYzNCY0lpeGNiaUFnSUNBZ0lDQWdhR0Z1Wkd4bGNsOXBaQ3hjYmlBZ0lDQWdJQ0FnWkdGMFlUb2djbVZ6Y0N4Y2JpQWdJQ0FnSUgwN1hHNGdJQ0FnSUNCMGFHbHpMbmRwYm1SdmR5NXdiM04wVFdWemMyRm5aU2h6Wlc1a1gyUmhkR0VzSUZ3aUtsd2lLVHRjYmlBZ0lDQWdJSFJvYVhNdWRHOXJaVzV6SUNzOUlISmxjM0F1Y21Wa2RXTmxLQ2hoWTJNc0lHbDBaVzBwSUQwK0lHRmpZeUFySUdsMFpXMHVkRzlyWlc1ekxDQXdLVHRjYmlBZ0lDQWdJSFJvYVhNdVpXMWlaV1JmWTNRZ0t6MGdjbVZ6Y0M1c1pXNW5kR2c3WEc0Z0lDQWdmV1ZzYzJWN1hHNGdJQ0FnSUNCcFppQW9JWFJvYVhNdWRHbHRaWE4wWVcxd0tTQjBhR2x6TG5ScGJXVnpkR0Z0Y0NBOUlFUmhkR1V1Ym05M0tDazdYRzRnSUNBZ0lDQmpiMjV6ZENCelpXNWtYMlJoZEdFZ1BTQmhkMkZwZENCMGFHbHpMbVZ0WW1Wa0tHVnRZbVZrWDJsdWNIVjBLVHRjYmlBZ0lDQWdJSE5sYm1SZlpHRjBZUzUwZVhCbElEMGdYQ0p6YldGeWRGOWxiV0psWkY5eVpYTndYQ0k3WEc0Z0lDQWdJQ0JwWmlBb2FHRnVaR3hsY2w5cFpDa2djMlZ1WkY5a1lYUmhMbWhoYm1Sc1pYSmZhV1FnUFNCb1lXNWtiR1Z5WDJsa08xeHVJQ0FnSUNBZ2RHaHBjeTUzYVc1a2IzY3VjRzl6ZEUxbGMzTmhaMlVvYzJWdVpGOWtZWFJoTENCY0lpcGNJaWs3WEc0Z0lDQWdJQ0IwYUdsekxuUnZhMlZ1Y3lBclBTQnpaVzVrWDJSaGRHRXVkRzlyWlc1ek8xeHVJQ0FnSUNBZ2RHaHBjeTVsYldKbFpGOWpkQ3NyTzF4dUlDQWdJSDFjYmlBZ0lDQnBaaUFvUkdGMFpTNXViM2NvS1NBdElIUm9hWE11ZEdsdFpYTjBZVzF3SUQ0Z01UQXdNREFwSUh0Y2JpQWdJQ0FnSUdOdmJuTnZiR1V1Ykc5bktHQkZiV0psWkdSbFpEb2dKSHQwYUdsekxtVnRZbVZrWDJOMGZTQnBibkIxZEhNZ0tDUjdkR2hwY3k1MGIydGxibk45SUhSdmEyVnVjeXdnSkhzb2RHaHBjeTUwYjJ0bGJuTWdMeUFvS0VSaGRHVXVibTkzS0NrZ0xTQjBhR2x6TG5ScGJXVnpkR0Z0Y0NrZ0x5QXhNREF3S1NrdWRHOUdhWGhsWkNnd0tYMGdkRzlyWlc1ekwzTmxZeWxnS1R0Y2JpQWdJQ0FnSUhSb2FYTXVkR2x0WlhOMFlXMXdJRDBnYm5Wc2JEdGNiaUFnSUNBZ0lIUm9hWE11ZEc5clpXNXpJRDBnTUR0Y2JpQWdJQ0FnSUhSb2FYTXVaVzFpWldSZlkzUWdQU0F3TzF4dUlDQWdJSDFjYmlBZ2ZWeHVJQ0JoYzNsdVl5QmpiM1Z1ZEY5MGIydGxibk5mYUdGdVpHeGxjaWhwYm5CMWRDa2dlMXh1SUNBZ0lHTnZibk4wSUc5MWRIQjFkQ0E5SUdGM1lXbDBJSFJvYVhNdVkyOTFiblJmZEc5clpXNXpLR2x1Y0hWMEtUdGNiaUFnSUNCamIyNXpkQ0J6Wlc1a1gyUmhkR0VnUFNCN1hHNGdJQ0FnSUNCMGVYQmxPaUJjSW5OdFlYSjBYMlZ0WW1Wa1gzUnZhMlZ1WDJOMFhDSXNYRzRnSUNBZ0lDQjBaWGgwT2lCY0ltTnZkVzUwT2x3aUlDc2dhVzV3ZFhRc1hHNGdJQ0FnSUNCamIzVnVkRG9nYjNWMGNIVjBYRzRnSUNBZ2ZUdGNiaUFnSUNCMGFHbHpMbmRwYm1SdmR5NXdiM04wVFdWemMyRm5aU2h6Wlc1a1gyUmhkR0VzSUZ3aUtsd2lLVHRjYmlBZ2ZWeHVmVnh1Wlhod2IzSjBjeTVVY21GdWMyWnZjbTFsY25OSlpuSmhiV1ZEYjI1dVpXTjBiM0lnUFNCVWNtRnVjMlp2Y20xbGNuTkpabkpoYldWRGIyNXVaV04wYjNJN1hHNWNiaUlzSUNKM2FXNWtiM2N1WVdSa1JYWmxiblJNYVhOMFpXNWxjaWduYldWemMyRm5aU2NzSUdsdWFYUXBPeUF2THlCc2FYTjBaVzRnWm05eUlHbHVhWFFnYldWemMyRm5aVnh1WVhONWJtTWdablZ1WTNScGIyNGdhVzVwZENobGRtVnVkQ2tnZTF4dUlDQnBaaUFvWlhabGJuUXVaR0YwWVM1MGVYQmxJRDA5UFNBbmFXNXBkQ2NwSUh0Y2JpQWdJQ0IzYVc1a2IzY3VjbVZ0YjNabFJYWmxiblJNYVhOMFpXNWxjaWduYldWemMyRm5aU2NzSUdsdWFYUXBPeUF2THlCeVpXMXZkbVVnZEdocGN5QmxkbVZ1ZENCc2FYTjBaVzVsY2x4dUlDQWdJR052Ym5OMElHMXZaR1ZzWDJOdmJtWnBaeUE5SUdWMlpXNTBMbVJoZEdFdWJXOWtaV3hmWTI5dVptbG5PMXh1SUNBZ0lHTnZibk52YkdVdWJHOW5LRzF2WkdWc1gyTnZibVpwWnlrN1hHNGdJQ0FnWTI5dWMzUWdleUJVY21GdWMyWnZjbTFsY25OSlpuSmhiV1ZEYjI1dVpXTjBiM0lnZlNBOUlHRjNZV2wwSUdsdGNHOXlkQ2duTGk5MGNtRnVjMlp2Y20xbGNuTmZhV1p5WVcxbExtcHpKeWs3WEc0Z0lDQWdZMjl1YzNRZ2JXOWtaV3dnUFNCaGQyRnBkQ0JVY21GdWMyWnZjbTFsY25OSlpuSmhiV1ZEYjI1dVpXTjBiM0l1WTNKbFlYUmxLRzF2WkdWc1gyTnZibVpwWnl3Z2QybHVaRzkzS1R0Y2JpQWdJQ0IzYVc1a2IzY3ViVzlrWld3Z1BTQnRiMlJsYkR0Y2JpQWdmVnh1ZlNKZExBb2dJQ0p0WVhCd2FXNW5jeUk2SUNJN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3p0QlFVRkJPMEZCUVVFN1FVRkhRU3hSUVVGTkxGVkJRVTRzVFVGQll6dEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFc1RVRkxXaXhaUVVGWkxFMUJRVTA3UVVGTGFFSXNZVUZCU3l4UFFVRlBPMEZCUzFvc1pVRkJUeXhQUVVGUExFMUJRVTBzUzBGQlN5eE5RVUZOTzBGQlFVRXNUVUZEYWtNN1FVRkJRU3hKUVVOR08wRkJSMEVzV1VGQlVTeFZRVUZWTzBGQlFVRTdRVUZCUVRzN08wRkRka0pzUWp0QlFVRkJPMEZCUVVFc1VVRkJUU3hGUVVGRkxGRkJRVkVzU1VGQlNUdEJRVVZ3UWl4UlFVRk5MSE5DUVVGT0xHTkJRV3RETEZGQlFWRTdRVUZCUVN4TlFVTjRReXhOUVVGTkxFOUJRVTg3UVVGRFdDeGpRVUZOTEVWQlFVVXNTMEZCU3l4VlFVRlZMR05CUVdNc1NVRkJTU3hOUVVGTkxFOUJRVThzYzBKQlFYTkNPMEZCUXpWRkxGbEJRVWtzYlVKQlFXMUNPMEZCUTNaQ0xHRkJRVXNzVVVGQlVTeE5RVUZOTEZOQlFWTXNjMEpCUVhOQ0xFdEJRVXNzV1VGQldTeEZRVUZGTEZkQlFWY3NUVUZCVFN4WlFVRlpMRXRCUVVzc1YwRkJWeXhEUVVGRE8wRkJSVzVJTEdGQlFVc3NXVUZCV1N4TlFVRk5MR05CUVdNc1owSkJRV2RDTEV0QlFVc3NWVUZCVlR0QlFVRkJMRTFCUTNSRk8wRkJRVUVzVFVGRFFTeE5RVUZOTEZsQlFWa3NUMEZCVHp0QlFVTjJRaXhuUWtGQlVTeE5RVUZOTEU5QlFVOHNWVUZCU3p0QlFWZzVRanRCUVZkcFF5dzJRa0ZCU3l4blFrRkJUQ3h0UWtGQmEwSXNWVUZCVXp0QlFVRkJMRk5CUVVNN1FVRkRla1FzV1VGQlJ5eEZRVUZETEN0Q1FVRlBPMEZCUVZFc2FVSkJRVThzUTBGQlF6dEJRVU16UWl4alFVRk5MRk5CUVZNc1RVRkJUU3hSUVVGUkxFbEJRVWtzVFVGQlRTeEpRVUZKTEZWQlFWRXNTMEZCU3l4aFFVRmhMRXRCUVVzc1YwRkJWeXhEUVVGRExFTkJRVU03UVVGRGRrWXNZMEZCVFN4alFVRmpMRTFCUVUwc1VVRkJVU3hKUVVGSkxFMUJRVTBzU1VGQlNTeFBRVUZQTEUxQlFVMHNUVUZCVFR0QlFVTnFSU3hqUVVGSkxFOUJRVThzUTBGQlF5eEpRVUZKTEV0QlFVczdRVUZCV1N4dFFrRkJUeXhMUVVGTE8wRkJRemRETEdOQlFVa3NWMEZCVnl4UFFVRlBMRU5CUVVNN1FVRkRka0lzWTBGQlNTeHJRa0ZCYTBJc1MwRkJTenRCUVVNelFpeHBRa0ZCVHl4WFFVRlhMRXRCUVVzc1dVRkJXVHRCUVVOcVF5eHJRa0ZCVFN4TlFVRk5MRXRCUVVzc1lVRkJZVHRCUVVNNVFpeHJRa0ZCVFN4WlFVRlpMRXRCUVVzc1RVRkJUU3huUWtGQlowSXNVMEZCVXl4TlFVRk5MRWRCUVVrN1FVRkRhRVVzT0VKQlFXdENMR2RDUVVGblFpeFZRVUZWTEVkQlFVY3NVMEZCVXl4SlFVRkpPMEZCUXpWRUxIVkNRVUZYTEUxQlFVMHNTMEZCU3l4aFFVRmhMR1ZCUVdVN1FVRkJRU3hWUVVOd1JEdEJRVWRCTEdsQ1FVRlBMRU5CUVVNc1NVRkJTVHRCUVVOYUxHbENRVUZQTzBGQlFVRXNVVUZEVkN4RFFVRkRMRU5CUVVNN1FVRkhSaXhaUVVGSE8wRkJRMFFzWjBKQlFVMUJMRkZCUVU4c1RVRkJUU3hMUVVGTExFMUJRVTBzWVVGQllTeEZRVUZGTEZOQlFWTXNVVUZCVVN4WFFVRlhMRXRCUVVzc1EwRkJRenRCUVVVdlJTeHBRa0ZCVHl4TlFVRk5MRWxCUVVrc1EwRkJReXhOUVVGTkxFMUJRVTA3UVVGRE5VSXNhVUpCUVVzc1RVRkJUU3hOUVVGTkxFdEJRVXRCTEUxQlFVc3NRMEZCUXl4RlFVRkZMRWxCUVVrN1FVRkRiRU1zYVVKQlFVc3NVMEZCVXl4UFFVRlBMRU5CUVVNN1FVRkRkRUlzYlVKQlFVODdRVUZCUVN4VlFVTlVMRU5CUVVNN1FVRkJRU3hSUVVOSUxGTkJRVThzUzBGQlNUdEJRVU5VTEd0Q1FVRlJMRWxCUVVrc1IwRkJSenRCUVVObUxHdENRVUZSTEVsQlFVa3NaMFJCUVdkRU8wRkJRVUVzVVVGRE9VUTdRVUZEUVN4alFVRk5MRTlCUVU4c1RVRkJUU3hSUVVGUkxFbEJRVWtzVFVGQlRTeEpRVUZKTEU5QlFVMHNVMEZCVVR0QlFVTnlSQ3huUWtGQlRTeEZRVUZGTEV0QlFVc3NVVUZCUVVNc1UwRkJVU3hOUVVGTkxFbEJRVWtzVFVGQlRTeExRVUZMTEUxQlFVMHNTMEZCU3l4WFFVRlhPMEZCUTJoRkxHTkJRVWNzVDBGQlRUdEJRVU5RTEc5Q1FVRlJMRWxCUVVrc01FSkJRVEJDTEV0QlFVc3NSMEZCUnp0QlFVTTVReXh2UWtGQlVTeEpRVUZKTEV0QlFVczdRVUZEYWtJc2FVSkJRVXNzVVVGQlVUdEJRVU5pTEcxQ1FVRlBPMEZCUVVFc1ZVRkRWRHRCUVVOQkxHTkJRVWNzUTBGQlF5eExRVUZKTzBGQlEwNHNiMEpCUVZFc1NVRkJTU3d3UWtGQk1FSXNTMEZCU3l4SFFVRkhPMEZCUXpsRExHOUNRVUZSTEVsQlFVa3NVMEZCVXl4SFFVRkhPMEZCUTNoQ0xHOUNRVUZSTEVsQlFVa3NWMEZCVnl4TFFVRkxPMEZCUXpWQ0xHOUNRVUZSTEVsQlFVa3NXVUZCV1VFc1QwRkJUVHRCUVVNNVFpeHZRa0ZCVVN4SlFVRkpMR2xDUVVGcFFqdEJRVU0zUWl4cFFrRkJTeXhSUVVGUk8wRkJRMklzYlVKQlFVODdRVUZCUVN4VlFVTlVPMEZCUTBFc1pVRkJTeXhOUVVGTkxFbEJRVWtzU1VGQlNTeFRRVUZQTEV0QlFVc3NUVUZCVFN4TlFVRk5MRWRCUVZNc1NVRkJTU3hIUVVGVE8wRkJRMnBGTEdWQlFVc3NVMEZCVTBFN1FVRkRaQ3hwUWtGQlR6dEJRVUZCTEZGQlExUXNRMEZCUXl4RFFVRkRPMEZCUTBZc1pVRkJUenRCUVVGQkxFMUJRMVE3UVVGQlFTeE5RVU5CTEUxQlFVMHNUVUZCVFN4UFFVRlBPMEZCUTJwQ0xHTkJRVTBzVTBGQlV5eEZRVUZGTEdGQlFXRXNUVUZCVFR0QlFVTndReXhaUVVGSkxFTkJRVU03UVVGQlR5eHBRa0ZCVHl4RlFVRkZMRWRCUVVjc1VVRkJVU3hQUVVGUExHbENRVUZwUWp0QlFVTjRSQ3haUVVGSkxFTkJRVU1zUzBGQlN6dEJRVUZQTEdkQ1FVRk5MRXRCUVVzc1MwRkJTenRCUVVOcVF5eFpRVUZKTzBGQlEwWXNhVUpCUVU4c1UwRkJVeXhOUVVGTkxFdEJRVXNzWVVGQllTeExRVUZMTzBGQlF6ZERMR05CUVVrc1QwRkJUeXhUUVVGVE8wRkJRVWNzYlVKQlFVOHNSVUZCUlN4SFFVRkhMRkZCUVZFc1QwRkJUeXh0UWtGQmJVSTdRVUZEY2tVc1kwRkJTU3hQUVVGUExGTkJRVk1zUzBGQlN5eFpRVUZaTzBGQlEyNURMR3RDUVVGTkxGbEJRVmtzVFVGQlRTeExRVUZMTEUxQlFVMHNUMEZCVHl4RlFVRkZMRk5CUVZNc1VVRkJVU3hYUVVGWExFdEJRVXNzUTBGQlF6dEJRVU01UlN4dFFrRkJUeXhOUVVGTkxFMUJRVTBzUzBGQlN5eFZRVUZWTEVsQlFVa3NSVUZCUlN4SlFVRkpMRk5CUVU4c1MwRkJTeXhOUVVGTkxFMUJRVTBzUjBGQlV5eEpRVUZKTEVkQlFWTTdRVUZCUVN4VlFVTTFSaXhQUVVGUE8wRkJRMHdzYTBKQlFVMHNUVUZCVFN4TFFVRkxMR0ZCUVdFc1QwRkJUenRCUVVOeVF5eHJRa0ZCVFN4WlFVRlpMRXRCUVVzc1RVRkJUU3hOUVVGTkxGTkJRVk1zVFVGQlRTeEpRVUZKTzBGQlEzUkVMRzlDUVVGUkxFMUJRVTBzVlVGQlZTeEhRVUZITEZOQlFWTXNTVUZCU1R0QlFVTjRReXh0UWtGQlR5eFpRVUZaTzBGQlEyNUNMRzlDUVVGUkxFbEJRVWtzYTBOQlFXdERMRTFCUVUwc1VVRkJVU3hqUVVGak8wRkJRekZGTEd0Q1FVRk5MRVZCUVVVc1MwRkJTeXhQUVVGUExFbEJRVWtzVFVGQlRTeExRVUZMTEUxQlFVMHNTMEZCU3p0QlFVTTVReXh0UWtGQlR5eE5RVUZOTzBGQlEySXNiVUpCUVU4c1UwRkJVenRCUVVGQkxGVkJRMnhDTzBGQlEwRXNhVUpCUVU4N1FVRkJRU3hSUVVOVUxGTkJRVk1zUzBGQlN6dEJRVU5hTEd0Q1FVRlJMRWxCUVVrc1IwRkJSenRCUVVObUxHbENRVUZQTEVWQlFVVXNSMEZCUnl4UlFVRlJMRTlCUVU4c1NVRkJTU3hSUVVGUk8wRkJRVUVzVVVGRGVrTTdRVUZCUVN4TlFVTkdPMEZCUVVFc1RVRkRRU3hOUVVGTkxHRkJRV0VzVFVGQlRUdEJRVU4yUWl4WlFVRkpMRU5CUVVNc1MwRkJTenRCUVVGWExHZENRVUZOTEV0QlFVc3NTMEZCU3p0QlFVTnlReXhqUVVGTkxFVkJRVVVzVlVGQlZTeEpRVUZKTEUxQlFVMHNTMEZCU3l4VlFVRlZMRWxCUVVrN1FVRkRMME1zWlVGQlR5eFZRVUZWTEV0QlFVczdRVUZCUVN4TlFVTjRRanRCUVVGQkxFbEJRMFk3UVVGRlFTeFpRVUZSTEhOQ1FVRnpRanRCUVVGQk8wRkJRVUU3T3p0QlEyNUhPVUk3UVVGQlFUdEJRVUZCTEZGQlFVMHNSVUZCUlN4dlFrRkJiMElzU1VGQlNUdEJRVWRvUXl4UlFVRk5MRGhDUVVGT0xFMUJRVTBzY1VOQlFXOURMRzlDUVVGdlFqdEJRVUZCTEUxQlF6VkVMRmxCUVZrc1kwRkJZME1zVTBGQlVUdEJRVU5vUXl4alFVRk5MRVZCUVVNc1VVRkJVU3hoUVVGWkxFTkJRVU03UVVGRE5VSXNZVUZCU3l4UlFVRlJPMEZCUTJJc1lVRkJTeXhsUVVGbE8wRkJRM0JDTEdGQlFVc3NVMEZCVTBFN1FVRkZaQ3hoUVVGTExGZEJRVmM3UVVGRGFFSXNZVUZCU3l4WlFVRlpPMEZCUTJwQ0xHRkJRVXNzVTBGQlV6dEJRVUZCTEUxQlEyaENPMEZCUVVFc1RVRkRRU3hoUVVGaExFOUJRVThzWTBGQlkwRXNVMEZCVVR0QlFVTjRReXhqUVVGTkxGbEJRVmtzU1VGQlNTdzJRa0ZCTkVJc1kwRkJZMEVzVDBGQlRUdEJRVU4wUlN4alFVRk5MRlZCUVZVc1MwRkJTenRCUVVOeVFpeGxRVUZQTzBGQlFVRXNUVUZEVkR0QlFVRkJMRTFCUTBFc1RVRkJUU3hQUVVGUE8wRkJRMWdzV1VGQlNTeExRVUZMTzBGQlFVOHNhVUpCUVU4c1VVRkJVU3hKUVVGSkxHdERRVUZyUXp0QlFVTnlSU3haUVVGSkxFdEJRVXM3UVVGQll5eG5Ra0ZCVFN4SlFVRkpMRkZCUVZFc1lVRkJWeXhYUVVGWExGTkJRVk1zUjBGQlNTeERRVUZETzBGQlF6ZEZMRmxCUVVrc1EwRkJReXhMUVVGTExGTkJRVk1zUTBGQlF5eExRVUZMTzBGQlFXTXNaVUZCU3l4bFFVRmxPMEZCUXpORUxHZENRVUZSTEVsQlFVa3NNa0pCUVRKQ08wRkJSWFpETEdOQlFVMHNSVUZCUlN4VlFVRlZMRXRCUVVzc1kwRkJZeXhKUVVGSkxFMUJRVTBzVDBGQlR5d3dSRUZCTUVRN1FVRkRhRWdzV1VGQlNTeHRRa0ZCYlVJN1FVRkRka0lzWVVGQlN5eFJRVUZSTEUxQlFVMHNVMEZCVXl4elFrRkJjMElzUzBGQlN5eFpRVUZaTEVWQlFVVXNWMEZCVnl4TFFVRkxMRU5CUVVNN1FVRkRkRVlzWVVGQlN5eFpRVUZaTEUxQlFVMHNZMEZCWXl4blFrRkJaMElzUzBGQlN5eFZRVUZWTzBGQlEzQkZMR0ZCUVVzc1pVRkJaVHRCUVVOd1FpeGhRVUZMTEU5QlFVOHNXVUZCV1N4TFFVRkxPMEZCUXpkQ0xHZENRVUZSTEVsQlFVa3NUVUZCVFN4TFFVRkxMRTFCUVUwc1RVRkJUU3hEUVVGRE8wRkJRM0JETEdGQlFVc3NUMEZCVHl4UFFVRlBMRmxCUVZrc1JVRkJSU3hOUVVGTkxHZENRVUZuUWl4TlFVRk5MRXRCUVVzc1IwRkJSeXhIUVVGSE8wRkJRM2hGTEdGQlFVc3NUMEZCVHl4cFFrRkJhVUlzVjBGQlZ5eExRVUZMTEZkQlFWY3NTMEZCU3l4SlFVRkpMRWRCUVVjc1MwRkJTenRCUVVGQkxFMUJRek5GTzBGQlFVRXNUVUZEUVN4TlFVRk5MRmRCUVZjc1QwRkJUenRCUVVOMFFpeFpRVUZKTEUxQlFVMHNTMEZCU3l4UlFVRlJPMEZCUVdVc1pVRkJTeXhqUVVGakxFMUJRVTBzU1VGQlNUdEJRVVZ1UlN4WlFVRkpMRTFCUVUwc1MwRkJTeXhSUVVGUk8wRkJRWGRDTEdWQlFVc3NjVUpCUVhGQ0xFMUJRVTBzUzBGQlN5eFhRVUZYTzBGQlFVRXNUVUZEYWtjN1FVRkJRU3hOUVVOQkxFMUJRVTBzWTBGQll5eFpRVUZaTzBGQlF6bENMR05CUVUwc1JVRkJSU3hoUVVGaExGZEJRVmNzU1VGQlNUdEJRVVZ3UXl4WlFVRkhMRU5CUVVNc1MwRkJTenRCUVVGWExHVkJRVXNzV1VGQldTeExRVUZMTEVsQlFVazdRVUZET1VNc1dVRkJSeXhOUVVGTkxGRkJRVkVzVjBGQlZ5eEhRVUZITzBGQlF6ZENMR2RDUVVGTkxFOUJRVThzVFVGQlRTeExRVUZMTEZsQlFWa3NWMEZCVnp0QlFVTXZReXhuUWtGQlRTeFpRVUZaTzBGQlFVRXNXVUZEYUVJc1RVRkJUVHRCUVVGQkxGbEJRMDQ3UVVGQlFTeFpRVU5CTEUxQlFVMDdRVUZCUVN4VlFVTlNPMEZCUTBFc1pVRkJTeXhQUVVGUExGbEJRVmtzVjBGQlZ5eEhRVUZITzBGQlEzUkRMR1ZCUVVzc1ZVRkJWU3hMUVVGTExFOUJRVThzUTBGQlF5eExRVUZMTEZOQlFWTXNUVUZCVFN4TFFVRkxMRkZCUVZFc1EwRkJRenRCUVVNNVJDeGxRVUZMTEZsQlFWa3NTMEZCU3p0QlFVRkJMRkZCUTNoQ0xFOUJRVXM3UVVGRFNDeGpRVUZKTEVOQlFVTXNTMEZCU3p0QlFVRlhMR2xDUVVGTExGbEJRVmtzUzBGQlN5eEpRVUZKTzBGQlF5OURMR2RDUVVGTkxGbEJRVmtzVFVGQlRTeExRVUZMTEUxQlFVMHNWMEZCVnp0QlFVTTVReXh2UWtGQlZTeFBRVUZQTzBGQlEycENMR05CUVVrN1FVRkJXU3h6UWtGQlZTeGhRVUZoTzBGQlEzWkRMR1ZCUVVzc1QwRkJUeXhaUVVGWkxGZEJRVmNzUjBGQlJ6dEJRVU4wUXl4bFFVRkxMRlZCUVZVc1ZVRkJWVHRCUVVONlFpeGxRVUZMTzBGQlFVRXNVVUZEVUR0QlFVTkJMRmxCUVVrc1MwRkJTeXhKUVVGSkxFbEJRVWtzUzBGQlN5eFpRVUZaTEV0QlFVODdRVUZEZGtNc2EwSkJRVkVzU1VGQlNTeGhRVUZoTEV0QlFVc3NVVUZCVVN4WlFVRlpMRXRCUVVzc1RVRkJUU3hoUVVGaExFdEJRVXNzVjBGQlZ5eExRVUZMTEVsQlFVa3NTVUZCU1N4TFFVRkxMR0ZCUVdFc1RVRkJUeXhSUVVGUkxFTkJRVU1zUTBGQlF5eGpRVUZqTzBGQlEzaEtMR1ZCUVVzc1dVRkJXVHRCUVVOcVFpeGxRVUZMTEZOQlFWTTdRVUZEWkN4bFFVRkxMRmRCUVZjN1FVRkJRU3hSUVVOc1FqdEJRVUZCTEUxQlEwWTdRVUZCUVN4TlFVTkJMRTFCUVUwc2NVSkJRWEZDTEU5QlFVODdRVUZEYUVNc1kwRkJUU3hUUVVGVExFMUJRVTBzUzBGQlN5eGhRVUZoTEV0QlFVczdRVUZETlVNc1kwRkJUU3haUVVGWk8wRkJRVUVzVlVGRGFFSXNUVUZCVFR0QlFVRkJMRlZCUTA0c1RVRkJUU3hYUVVGWE8wRkJRVUVzVlVGRGFrSXNUMEZCVHp0QlFVRkJMRkZCUTFRN1FVRkRRU3hoUVVGTExFOUJRVThzV1VGQldTeFhRVUZYTEVkQlFVYzdRVUZCUVN4TlFVTjRRenRCUVVGQkxFbEJRMFk3UVVGRFFTeFpRVUZSTERoQ1FVRTRRanRCUVVGQk8wRkJRVUU3T3p0QlEyaEdkRU1zVDBGQlR5eHBRa0ZCYVVJc1YwRkJWeXhKUVVGSk8wRkJRM1pETEdWQlFXVXNTMEZCU3l4UFFVRlBPMEZCUTNwQ0xFMUJRVWtzVFVGQlRTeExRVUZMTEZOQlFWTXNVVUZCVVR0QlFVTTVRaXhYUVVGUExHOUNRVUZ2UWl4WFFVRlhMRWxCUVVrN1FVRkRNVU1zVlVGQlRTeGxRVUZsTEUxQlFVMHNTMEZCU3p0QlFVTm9ReXhaUVVGUkxFbEJRVWtzV1VGQldUdEJRVU40UWl4VlFVRk5MRVZCUVVVc05FSkJRVFJDTEVsQlFVa3NUVUZCVFR0QlFVTTVReXhWUVVGTkxGRkJRVkVzVFVGQlRTdzBRa0ZCTkVJc1QwRkJUeXhqUVVGakxFMUJRVTA3UVVGRE0wVXNWMEZCVHl4UlFVRlJPMEZCUVVFc1JVRkRha0k3UVVGRFJqc2lMQW9nSUNKdVlXMWxjeUk2SUZzaWNtVnpjQ0lzSUNKMGIydGxibk1pTENBaWQybHVaRzkzSWwwS2ZRbz1cXG5cIlxufSIsICJjb25zdCB7IEFkYXB0ZXIgfSA9IHJlcXVpcmUoJy4vYWRhcHRlcicpO1xuY29uc3Qgd2ViX2Nvbm5lY3RvciA9IHJlcXVpcmUoJy4uL3dlYl9jb25uZWN0b3InKTtcblxuY2xhc3MgSWZyYW1lQWRhcHRlciBleHRlbmRzIEFkYXB0ZXIge1xuICBjb25zdHJ1Y3RvcihtYWluKSB7XG4gICAgc3VwZXIobWFpbik7XG4gICAgdGhpcy5mcmFtZSA9IG51bGw7XG4gICAgdGhpcy5vdXRwdXQgPSB7fTtcbiAgICB0aGlzLnJlc3BvbnNlX2hhbmRsZXJzID0ge307XG4gICAgdGhpcy53ZWJfc2NyaXB0ID0gd2ViX2Nvbm5lY3Rvci5zY3JpcHQ7IC8vIHdlYiBzY3JpcHQgdG8gbG9hZCBpbiBpZnJhbWVcbiAgfVxuICB1bmxvYWQoKSB7XG4gICAgY29uc29sZS5sb2coXCJTbWFydEVtYmVkVHJhbnNmb3JtZXJzV2ViQWRhcHRlciBVbmxvYWRpbmdcIik7XG4gICAgdGhpcy5yZW1vdmVfZnJhbWUoKTtcbiAgICB0aGlzLmZyYW1lID0gbnVsbDtcbiAgICB0aGlzLm91dHB1dCA9IHt9O1xuICAgIHRoaXMucmVzcG9uc2VfaGFuZGxlcnMgPSB7fTtcbiAgfVxuICBhc3luYyBpbml0KCkge1xuICAgIC8vIHRoaXMuZnJhbWUgPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiI1wiICsgdGhpcy5jb250YWluZXJfaWQpO1xuICAgIGlmKCF0aGlzLmZyYW1lKSB7XG4gICAgICB0aGlzLmZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtcbiAgICAgIHRoaXMuZnJhbWUuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgdGhpcy5mcmFtZS5zdHlsZS53aWR0aCA9IFwiMFwiO1xuICAgICAgdGhpcy5mcmFtZS5zdHlsZS5oZWlnaHQgPSBcIjBcIjtcbiAgICAgIC8vIHRoaXMuZnJhbWUuaWQgPSB0aGlzLmNvbnRhaW5lcl9pZDtcbiAgICAgIHRoaXMuZnJhbWVfbG9hZGVkID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB0aGlzLmZyYW1lLm9ubG9hZCA9IHJlc29sdmUpOyAvLyB3YWl0IGZvciBpZnJhbWUgdG8gbG9hZFxuICAgICAgY29uc3QgbW9kZWxfbG9hZGVkID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBldmVudCA9PiB7XG4gICAgICAgICAgaWYgKGV2ZW50LmRhdGEudHlwZSA9PT0gXCJtb2RlbF9sb2FkZWRcIil7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIk1vZGVsIExvYWRlZDogXCIgKyB0aGlzLm1vZGVsX25hbWUpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgeyBvbmNlOiB0cnVlLCBjYXB0dXJlOiBmYWxzZSB9KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5mcmFtZS5zcmNkb2MgPSB0aGlzLmlmcmFtZV9zY3JpcHQ7XG4gICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmZyYW1lKTtcbiAgICAgIGF3YWl0IHRoaXMuZnJhbWVfbG9hZGVkOyAvLyB3YWl0IGZvciBpZnJhbWUgdG8gbG9hZFxuICAgICAgdGhpcy5mcmFtZS5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKHsgdHlwZTogXCJpbml0XCIsIG1vZGVsX2NvbmZpZzogey4uLnRoaXMubWFpbi5jb25maWcsIGNvbnRhaW5lcjogbnVsbH0gfSwgXCIqXCIpOyAvLyBzZW5kIGluaXQgbWVzc2FnZSB0byBpZnJhbWVcbiAgICAgIGF3YWl0IG1vZGVsX2xvYWRlZDsgLy8gd2FpdCBmb3IgbW9kZWwgdG8gbG9hZFxuICAgICAgdGhpcy5mcmFtZS5jb250ZW50V2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMuaGFuZGxlX2lmcmFtZV9tZXNzYWdlcy5iaW5kKHRoaXMpLCBmYWxzZSk7XG4gICAgfVxuICAgIC8vIGNvbnNvbGUubG9nKGF3YWl0IHRoaXMucmVxdWVzdF9lbWJlZGRpbmcoXCJ0ZXN0XCIpKTtcbiAgICBjb25zb2xlLmxvZyhcIlNtYXJ0RW1iZWRUcmFuc2Zvcm1lcnNXZWJBZGFwdGVyIENvbm5lY3RlZFwiKTtcbiAgfVxuICByZXF1ZXN0X2VtYmVkZGluZyhlbWJlZF9pbnB1dCwgcmV0cmllcyA9IDApIHtcbiAgICBpZiAoIWVtYmVkX2lucHV0Py5sZW5ndGgpIHJldHVybiBjb25zb2xlLmxvZyhcImVtYmVkX2lucHV0IGlzIGVtcHR5XCIpOyAvLyBjaGVjayBpZiBlbWJlZF9pbnB1dCBpcyBlbXB0eVxuICAgIGNvbnN0IGhhbmRsZXJfaWQgPSAodHlwZW9mIGVtYmVkX2lucHV0ID09PSBcInN0cmluZ1wiKSA/IGVtYmVkX2lucHV0IDogY3JlYXRlX3VpZChlbWJlZF9pbnB1dCk7XG4gICAgdGhpcy5mcmFtZS5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKHsgdHlwZTogXCJzbWFydF9lbWJlZFwiLCBlbWJlZF9pbnB1dCwgaGFuZGxlcl9pZCB9LCBcIipcIik7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucmVzcG9uc2VfaGFuZGxlcnNbaGFuZGxlcl9pZF0gPSAoeyBlcnJvciwgZGF0YSB9KSA9PiB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMucmVzcG9uc2VfaGFuZGxlcnNbaGFuZGxlcl9pZF0pIHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiVGltZW91dCB3YWl0aW5nIGZvciByZXNwb25zZVwiKSk7XG4gICAgICAgICAgZGVsZXRlIHRoaXMucmVzcG9uc2VfaGFuZGxlcnNbaGFuZGxlcl9pZF07XG4gICAgICAgIH1cbiAgICAgIH0sIDYwMDAwKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBlbWJlZF9iYXRjaChpdGVtcykge1xuICAgIGl0ZW1zID0gaXRlbXMuZmlsdGVyKGl0ZW0gPT4gaXRlbS5lbWJlZF9pbnB1dD8ubGVuZ3RoID4gMCk7XG4gICAgaWYoIWl0ZW1zPy5sZW5ndGgpIHJldHVybiBbXTtcbiAgICBjb25zdCByZXNwID0gYXdhaXQgdGhpcy5yZXF1ZXN0X2VtYmVkZGluZyhpdGVtcy5tYXAoaXRlbSA9PiAoeyBlbWJlZF9pbnB1dDogaXRlbS5lbWJlZF9pbnB1dCB9KSkpO1xuICAgIHJldHVybiBpdGVtcy5tYXAoKGl0ZW0sIGkpID0+IHtcbiAgICAgIGNvbnN0IHJlc3BfaXRlbSA9IHJlc3AuZGF0YVtpXTtcbiAgICAgIGl0ZW0udmVjID0gcmVzcF9pdGVtLnZlYztcbiAgICAgIGl0ZW0udG9rZW5zID0gcmVzcF9pdGVtLnRva2VucztcbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH0pO1xuICB9XG4gIGVtYmVkKGlucHV0KSB7IHJldHVybiB0aGlzLnJlcXVlc3RfZW1iZWRkaW5nKGlucHV0KTsgfVxuICBjb3VudF90b2tlbnMoaW5wdXQsIHRpbWVvdXQgPSA2MDAwMCkge1xuICAgIHRoaXMuZnJhbWUuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZSh7IHR5cGU6IFwic21hcnRfZW1iZWRfdG9rZW5fY3RcIiwgZW1iZWRfaW5wdXQ6IGlucHV0IH0sIFwiKlwiKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5yZXNwb25zZV9oYW5kbGVyc1tcImNvdW50OlwiICsgaW5wdXRdID0gKHsgZXJyb3IsIGRhdGEgfSkgPT4ge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhlcnJvcik7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnJlc3BvbnNlX2hhbmRsZXJzW1wiY291bnQ6XCIgKyBpbnB1dF0pIHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiVGltZW91dCB3YWl0aW5nIGZvciByZXNwb25zZVwiKSk7XG4gICAgICAgICAgZGVsZXRlIHRoaXMucmVzcG9uc2VfaGFuZGxlcnNbXCJjb3VudDpcIiArIGlucHV0XTtcbiAgICAgICAgfVxuICAgICAgfSwgdGltZW91dCk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0IGlmcmFtZV9zY3JpcHQoKSB7IHJldHVybiBgPHNjcmlwdCB0eXBlPVwibW9kdWxlXCI+JHt0aGlzLndlYl9zY3JpcHR9PC9zY3JpcHQ+YDsgfVxuICBnZXQgaXNfZW1iZWRkaW5nKCkgeyByZXR1cm4gT2JqZWN0LmtleXModGhpcy5yZXNwb25zZV9oYW5kbGVycykubGVuZ3RoID4gMDsgfVxuICBnZXQgcXVldWVfbGVuZ3RoKCkgeyByZXR1cm4gT2JqZWN0LmtleXModGhpcy5yZXNwb25zZV9oYW5kbGVycykubGVuZ3RoOyB9XG4gIGdldCBjb250YWluZXJfaWQoKSB7IHJldHVybiB0aGlzLm1vZGVsX25hbWUucmVwbGFjZSgvW15hLXowLTldL2dpLCAnXycpLnRvTG93ZXJDYXNlKCk7IH1cbiAgcmVtb3ZlX2ZyYW1lKCkge1xuICAgIGlmICh0aGlzLmZyYW1lKSB0aGlzLmZyYW1lLnJlbW92ZSgpO1xuICAgIGNvbnN0IGZyYW1lX2NoZWNrID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcihcIiNcIiArIHRoaXMuY29udGFpbmVyX2lkKTtcbiAgICBpZiAoZnJhbWVfY2hlY2spIGZyYW1lX2NoZWNrLnJlbW92ZSgpO1xuICAgIGNvbnNvbGUubG9nKFwiU21hcnRFbWJlZFRyYW5zZm9ybWVyc1dlYkFkYXB0ZXIgRGlzY29ubmVjdGVkXCIpO1xuICB9XG4gIGhhbmRsZV9pZnJhbWVfbWVzc2FnZXMoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuZGF0YS50eXBlID09PSBcInNtYXJ0X2VtYmVkX3Jlc3BcIiB8fCBldmVudC5kYXRhLnR5cGUgPT09IFwic21hcnRfZW1iZWRfdG9rZW5fY3RcIikge1xuICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMucmVzcG9uc2VfaGFuZGxlcnNbZXZlbnQuZGF0YS5oYW5kbGVyX2lkIHx8IGV2ZW50LmRhdGEudGV4dF07XG4gICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICBoYW5kbGVyKHsgZXJyb3I6IG51bGwsIGRhdGE6IGV2ZW50LmRhdGEgfSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnJlc3BvbnNlX2hhbmRsZXJzW2V2ZW50LmRhdGEuaGFuZGxlcl9pZCB8fCBldmVudC5kYXRhLnRleHRdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZXhwb3J0cy5JZnJhbWVBZGFwdGVyID0gSWZyYW1lQWRhcHRlcjtcblxuZnVuY3Rpb24gY3JlYXRlX3VpZChkYXRhKSB7XG4gIGNvbnN0IHN0ciA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICBsZXQgaGFzaCA9IDA7XG4gIGlmIChzdHIubGVuZ3RoID09PSAwKSByZXR1cm4gaGFzaDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGFyID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgY2hhcjtcbiAgICBoYXNoID0gaGFzaCAmIGhhc2g7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICAgIC8vIHJlbW92ZSBuZWdhdGl2ZSBzaWduXG4gICAgaWYgKGhhc2ggPCAwKSBoYXNoID0gaGFzaCAqIC0xO1xuICB9XG4gIHJldHVybiBoYXNoLnRvU3RyaW5nKCkgKyBzdHIubGVuZ3RoO1xufSIsICJjb25zdCB7IEFwaUFkYXB0ZXIgfSA9IHJlcXVpcmUoJy4vYWRhcHRlcnMvYXBpJyk7XG5leHBvcnRzLmFwaSA9IEFwaUFkYXB0ZXI7XG5jb25zdCB7IExvY2FsQXBpQWRhcHRlciB9ID0gcmVxdWlyZSgnLi9hZGFwdGVycy9sb2NhbF9hcGknKTtcbmV4cG9ydHMubG9jYWxfYXBpID0gTG9jYWxBcGlBZGFwdGVyO1xuY29uc3QgeyBUcmFuc2Zvcm1lcnNBZGFwdGVyIH0gPSByZXF1aXJlKCcuL2FkYXB0ZXJzL3RyYW5zZm9ybWVycycpO1xuZXhwb3J0cy50cmFuc2Zvcm1lcnMgPSBUcmFuc2Zvcm1lcnNBZGFwdGVyO1xuY29uc3QgeyBJZnJhbWVBZGFwdGVyIH0gPSByZXF1aXJlKCcuL2FkYXB0ZXJzL2lmcmFtZScpO1xuZXhwb3J0cy5pZnJhbWUgPSBJZnJhbWVBZGFwdGVyOyIsICJ7XG4gIFwiVGF5bG9yQUkvYmdlLW1pY3JvLXYyXCI6IHtcbiAgICBcIm1vZGVsX25hbWVcIjogXCJUYXlsb3JBSS9iZ2UtbWljcm8tdjJcIixcbiAgICBcImJhdGNoX3NpemVcIjogMSxcbiAgICBcImRpbXNcIjogMzg0LFxuICAgIFwibWF4X3Rva2Vuc1wiOiA1MTIsXG4gICAgXCJuYW1lXCI6IFwiQkdFLW1pY3JvLXYyXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkxvY2FsLCA1MTIgdG9rZW5zLCAzODQgZGltXCIsXG4gICAgXCJ0eXBlXCI6IFwiaHVnZ2luZ2ZhY2UtdHJhbnNmb3JtZXJzXCJcbiAgfSxcbiAgXCJhbmRlcnNvbmJjZGVmZy9iZ2Utc21hbGwtNDA5NlwiOiB7XG4gICAgXCJtb2RlbF9uYW1lXCI6IFwiYW5kZXJzb25iY2RlZmcvYmdlLXNtYWxsLTQwOTZcIixcbiAgICBcImJhdGNoX3NpemVcIjogMSxcbiAgICBcImRpbXNcIjogMzg0LFxuICAgIFwibWF4X3Rva2Vuc1wiOiA0MDk2LFxuICAgIFwibmFtZVwiOiBcIkJHRS1zbWFsbC00S1wiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJMb2NhbCwgNCwwOTYgdG9rZW5zLCAzODQgZGltXCIsXG4gICAgXCJ0eXBlXCI6IFwiaHVnZ2luZ2ZhY2UtdHJhbnNmb3JtZXJzXCJcbiAgfSxcbiAgXCJYZW5vdmEvamluYS1lbWJlZGRpbmdzLXYyLWJhc2UtemgtODE5MlwiOiB7XG4gICAgXCJtb2RlbF9uYW1lXCI6IFwiWGVub3ZhL2ppbmEtZW1iZWRkaW5ncy12Mi1iYXNlLXpoXCIsXG4gICAgXCJiYXRjaF9zaXplXCI6IDEsXG4gICAgXCJkaW1zXCI6IDUxMixcbiAgICBcIm1heF90b2tlbnNcIjogODE5MixcbiAgICBcIm5hbWVcIjogXCJKaW5hLXYyLWJhc2UtemgtOEtcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiTG9jYWwsIDgsMTkyIHRva2VucywgNTEyIGRpbSwgQ2hpbmVzZS9FbmdsaXNoIGJpbGluZ3VhbFwiLFxuICAgIFwidHlwZVwiOiBcImh1Z2dpbmdmYWNlLXRyYW5zZm9ybWVyc1wiXG4gIH0sXG4gIFwidGV4dC1lbWJlZGRpbmctMy1zbWFsbFwiOiB7XG4gICAgXCJtb2RlbF9uYW1lXCI6IFwidGV4dC1lbWJlZGRpbmctMy1zbWFsbFwiLFxuICAgIFwiYmF0Y2hfc2l6ZVwiOiA1MCxcbiAgICBcImRpbXNcIjogMTUzNixcbiAgICBcIm1heF90b2tlbnNcIjogODE5MSxcbiAgICBcIm5hbWVcIjogXCJPcGVuQUkgVGV4dC0zIFNtYWxsXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkFQSSwgOCwxOTEgdG9rZW5zLCAxLDUzNiBkaW1cIixcbiAgICBcImVuZHBvaW50XCI6IFwiaHR0cHM6Ly9hcGkub3BlbmFpLmNvbS92MS9lbWJlZGRpbmdzXCIsXG4gICAgXCJ0eXBlXCI6IFwib3BlbmFpXCJcbiAgfSxcbiAgXCJ0ZXh0LWVtYmVkZGluZy0zLWxhcmdlXCI6IHtcbiAgICBcIm1vZGVsX25hbWVcIjogXCJ0ZXh0LWVtYmVkZGluZy0zLWxhcmdlXCIsXG4gICAgXCJiYXRjaF9zaXplXCI6IDUwLFxuICAgIFwiZGltc1wiOiAzMDcyLFxuICAgIFwibWF4X3Rva2Vuc1wiOiA4MTkxLFxuICAgIFwibmFtZVwiOiBcIk9wZW5BSSBUZXh0LTMgTGFyZ2VcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQVBJLCA4LDE5MSB0b2tlbnMsIDMsMDcyIGRpbVwiLFxuICAgIFwiZW5kcG9pbnRcIjogXCJodHRwczovL2FwaS5vcGVuYWkuY29tL3YxL2VtYmVkZGluZ3NcIixcbiAgICBcInR5cGVcIjogXCJvcGVuYWlcIlxuICB9LFxuICBcInRleHQtZW1iZWRkaW5nLTMtc21hbGwtNTEyXCI6IHtcbiAgICBcIm1vZGVsX25hbWVcIjogXCJ0ZXh0LWVtYmVkZGluZy0zLXNtYWxsXCIsXG4gICAgXCJiYXRjaF9zaXplXCI6IDUwLFxuICAgIFwiZGltc1wiOiA1MTIsXG4gICAgXCJtYXhfdG9rZW5zXCI6IDgxOTEsXG4gICAgXCJuYW1lXCI6IFwiT3BlbkFJIFRleHQtMyBTbWFsbCAtIDUxMlwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJBUEksIDgsMTkxIHRva2VucywgNTEyIGRpbVwiLFxuICAgIFwiZW5kcG9pbnRcIjogXCJodHRwczovL2FwaS5vcGVuYWkuY29tL3YxL2VtYmVkZGluZ3NcIixcbiAgICBcInR5cGVcIjogXCJvcGVuYWlcIlxuICB9LFxuICBcInRleHQtZW1iZWRkaW5nLTMtbGFyZ2UtMjU2XCI6IHtcbiAgICBcIm1vZGVsX25hbWVcIjogXCJ0ZXh0LWVtYmVkZGluZy0zLWxhcmdlXCIsXG4gICAgXCJiYXRjaF9zaXplXCI6IDUwLFxuICAgIFwiZGltc1wiOiAyNTYsXG4gICAgXCJtYXhfdG9rZW5zXCI6IDgxOTEsXG4gICAgXCJuYW1lXCI6IFwiT3BlbkFJIFRleHQtMyBMYXJnZSAtIDI1NlwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJBUEksIDgsMTkxIHRva2VucywgMjU2IGRpbVwiLFxuICAgIFwiZW5kcG9pbnRcIjogXCJodHRwczovL2FwaS5vcGVuYWkuY29tL3YxL2VtYmVkZGluZ3NcIixcbiAgICBcInR5cGVcIjogXCJvcGVuYWlcIlxuICB9LFxuICBcInRleHQtZW1iZWRkaW5nLWFkYS0wMDJcIjoge1xuICAgIFwibW9kZWxfbmFtZVwiOiBcInRleHQtZW1iZWRkaW5nLWFkYS0wMDJcIixcbiAgICBcImJhdGNoX3NpemVcIjogNTAsXG4gICAgXCJkaW1zXCI6IDE1MzYsXG4gICAgXCJtYXhfdG9rZW5zXCI6IDgxOTEsXG4gICAgXCJuYW1lXCI6IFwiT3BlbkFJIEFkYVwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJBUEksIDgsMTkxIHRva2VucywgMSw1MzYgZGltXCIsXG4gICAgXCJlbmRwb2ludFwiOiBcImh0dHBzOi8vYXBpLm9wZW5haS5jb20vdjEvZW1iZWRkaW5nc1wiLFxuICAgIFwidHlwZVwiOiBcIm9wZW5haVwiXG4gIH0sXG4gIFwiWGVub3ZhL2ppbmEtZW1iZWRkaW5ncy12Mi1zbWFsbC1lblwiOiB7XG4gICAgXCJtb2RlbF9uYW1lXCI6IFwiWGVub3ZhL2ppbmEtZW1iZWRkaW5ncy12Mi1zbWFsbC1lblwiLFxuICAgIFwiYmF0Y2hfc2l6ZVwiOiAxLFxuICAgIFwiZGltc1wiOiA1MTIsXG4gICAgXCJtYXhfdG9rZW5zXCI6IDgxOTIsXG4gICAgXCJuYW1lXCI6IFwiSmluYS12Mi1zbWFsbC1lblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJMb2NhbCwgOCwxOTIgdG9rZW5zLCA1MTIgZGltXCIsXG4gICAgXCJ0eXBlXCI6IFwiaHVnZ2luZ2ZhY2UtdHJhbnNmb3JtZXJzXCJcbiAgfSxcbiAgXCJub21pYy1haS9ub21pYy1lbWJlZC10ZXh0LXYxLjUtMjU2XCI6IHtcbiAgICBcIm1vZGVsX25hbWVcIjogXCJub21pYy1haS9ub21pYy1lbWJlZC10ZXh0LXYxLjVcIixcbiAgICBcImJhdGNoX3NpemVcIjogMSxcbiAgICBcImRpbXNcIjogMjU2LFxuICAgIFwibWF4X3Rva2Vuc1wiOiA4MTkyLFxuICAgIFwibmFtZVwiOiBcIk5vbWljLWVtYmVkLXRleHQtdjEuNVwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJMb2NhbCwgOCwxOTIgdG9rZW5zLCAyNTYgZGltXCIsXG4gICAgXCJ0eXBlXCI6IFwiaHVnZ2luZ2ZhY2UtdHJhbnNmb3JtZXJzXCJcbiAgfSxcbiAgXCJYZW5vdmEvYmdlLXNtYWxsLWVuLXYxLjVcIjoge1xuICAgIFwibW9kZWxfbmFtZVwiOiBcIlhlbm92YS9iZ2Utc21hbGwtZW4tdjEuNVwiLFxuICAgIFwiYmF0Y2hfc2l6ZVwiOiAxLFxuICAgIFwiZGltc1wiOiAzODQsXG4gICAgXCJtYXhfdG9rZW5zXCI6IDUxMixcbiAgICBcIm5hbWVcIjogXCJCR0Utc21hbGxcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiTG9jYWwsIDUxMiB0b2tlbnMsIDM4NCBkaW1cIixcbiAgICBcInR5cGVcIjogXCJodWdnaW5nZmFjZS10cmFuc2Zvcm1lcnNcIlxuICB9LFxuICBcIm5vbWljLWFpL25vbWljLWVtYmVkLXRleHQtdjFcIjoge1xuICAgIFwibW9kZWxfbmFtZVwiOiBcIm5vbWljLWFpL25vbWljLWVtYmVkLXRleHQtdjFcIixcbiAgICBcImJhdGNoX3NpemVcIjogMSxcbiAgICBcImRpbXNcIjogNzY4LFxuICAgIFwibWF4X3Rva2Vuc1wiOiAyMDQ4LFxuICAgIFwibmFtZVwiOiBcIk5vbWljLWVtYmVkLXRleHRcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiTG9jYWwsIDIsMDQ4IHRva2VucywgNzY4IGRpbVwiLFxuICAgIFwidHlwZVwiOiBcImh1Z2dpbmdmYWNlLXRyYW5zZm9ybWVyc1wiXG4gIH1cbn0iLCAiLy8gQ29weXJpZ2h0IChjKSBCcmlhbiBKb3NlcGggUGV0cm9cblxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXG4vLyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4vLyBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbi8vIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbi8vIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuLy8gRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuLy8gTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRVxuLy8gTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTlxuLy8gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4vLyBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuY29uc3QgYWRhcHRlcnMgPSByZXF1aXJlKCcuL2FkYXB0ZXJzJyk7XG5jb25zdCBlbWJlZF9tb2RlbHMgPSByZXF1aXJlKCcuL21vZGVscycpO1xuXG4vKipcbiAqIEFuIHVuaXZlcnNhbCBpbnRlcmZhY2UgZm9yIGVtYmVkZGluZyBtb2RlbHMuXG4gKi9cbmNsYXNzIFNtYXJ0RW1iZWRNb2RlbCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBTbWFydEVtYmVkIGluc3RhbmNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZW52IC0gVGhlIGVudmlyb25tZW50IHRvIHVzZS5cbiAgICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBjb25maWcgLSBUaGUgbW9kZWwgY29uZmlndXJhdGlvbiBrZXkgb3IgdGhlIG1vZGVsIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgKiBleHBlY3RzIG1vZGVsIHRvIGNvbnRhaW4gYXQgbGVhc3QgYSBtb2RlbF9rZXlcbiAgICovXG4gIGNvbnN0cnVjdG9yKGVudiwgY29uZmlnKSB7XG4gICAgdGhpcy5lbnYgPSBlbnY7XG4gICAgaWYoY29uZmlnLm1vZGVsX2tleSkgdGhpcy5jb25maWcgPSB7Li4uZW1iZWRfbW9kZWxzW2NvbmZpZy5tb2RlbF9rZXldLCAuLi5jb25maWd9O1xuICAgIGVsc2UgdGhpcy5jb25maWcgPSB7IC4uLmNvbmZpZyB9O1xuICAgIC8vIEluaXRpYWxpemUgc3RhdGlzdGljc1xuICAgIHRoaXMuZW1iZWRfY3QgPSAwOyAvLyBDb3VudCBvZiBlbWJlZGRpbmdzIHByb2Nlc3NlZFxuICAgIHRoaXMudGltZXN0YW1wID0gbnVsbDsgLy8gTGFzdCBvcGVyYXRpb24gdGltZXN0YW1wXG4gICAgdGhpcy50b2tlbnMgPSAwOyAvLyBDb3VudCBvZiB0b2tlbnMgcHJvY2Vzc2VkXG4gICAgLy8gSW5pdGlhbGl6ZSBhZGFwdGVyIGlmIHNwZWNpZmllZCBpbiB0aGUgY29uZmlndXJhdGlvbiAoZWxzZSB1c2UgYXBpIGFkYXB0ZXIpXG4gICAgaWYodGhpcy5jb25maWcuYWRhcHRlcikgdGhpcy5hZGFwdGVyID0gbmV3IGFkYXB0ZXJzW3RoaXMuY29uZmlnLmFkYXB0ZXJdKHRoaXMpO1xuICAgIGVsc2UgdGhpcy5hZGFwdGVyID0gbmV3IGFkYXB0ZXJzWydhcGknXSh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgU21hcnRFbWJlZCBpbnN0YW5jZSBhbmQgaW5pdGlhbGl6ZSBpdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGVudiAtIFRoZSBlbnZpcm9ubWVudCB0byB1c2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlbF9jb25maWcgLSBGdWxsIG1vZGVsIGNvbmZpZ3VyYXRpb24gb2JqZWN0IG9yIGF0IGxlYXN0IGEgbW9kZWxfa2V5LCBhcGlfa2V5LCBhbmQgYWRhcHRlclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTbWFydEVtYmVkPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBhbiBpbml0aWFsaXplZCBTbWFydEVtYmVkIGluc3RhbmNlLlxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGNyZWF0ZShlbnYsIG1vZGVsX2NvbmZpZykge1xuICAgIGNvbnN0IG1vZGVsID0gbmV3IHRoaXMoZW52LCBtb2RlbF9jb25maWcpO1xuICAgIC8vIEluaXRpYWxpemUgYWRhcHRlci1zcGVjaWZpYyBsb2dpYyBpZiBhZGFwdGVyIGlzIHByZXNlbnRcbiAgICBpZiAobW9kZWwuYWRhcHRlciAmJiB0eXBlb2YgbW9kZWwuYWRhcHRlci5pbml0ID09PSAnZnVuY3Rpb24nKSBhd2FpdCBtb2RlbC5hZGFwdGVyLmluaXQoKTtcbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cblxuICAvKipcbiAgICogQ291bnQgdGhlIG51bWJlciBvZiB0b2tlbnMgaW4gdGhlIGlucHV0IHN0cmluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0IC0gVGhlIGlucHV0IHN0cmluZyB0byBwcm9jZXNzLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxudW1iZXI+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBudW1iZXIgb2YgdG9rZW5zLlxuICAgKi9cbiAgYXN5bmMgY291bnRfdG9rZW5zKGlucHV0KSB7XG4gICAgaWYgKHRoaXMuYWRhcHRlciAmJiB0eXBlb2YgdGhpcy5hZGFwdGVyLmNvdW50X3Rva2VucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuYWRhcHRlci5jb3VudF90b2tlbnMoaW5wdXQpO1xuICAgIH1cbiAgICAvLyBEZWZhdWx0IHRva2VuIGNvdW50aW5nIGxvZ2ljIGhlcmUgaWYgbm8gYWRhcHRlciBvciBhZGFwdGVyIGxhY2tzIHRoZSBtZXRob2RcbiAgfVxuXG4gIC8qKlxuICAgKiBFbWJlZCB0aGUgaW5wdXQgc3RyaW5nIGludG8gYSBudW1lcmljYWwgYXJyYXkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCAtIFRoZSBpbnB1dCBzdHJpbmcgdG8gZW1iZWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlcltdPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgZW1iZWRkaW5nIGFycmF5LlxuICAgKi9cbiAgYXN5bmMgZW1iZWQoaW5wdXQpIHtcbiAgICBpZiAodGhpcy5hZGFwdGVyICYmIHR5cGVvZiB0aGlzLmFkYXB0ZXIuZW1iZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmFkYXB0ZXIuZW1iZWQoaW5wdXQpO1xuICAgIH1cbiAgICAvLyBEZWZhdWx0IGVtYmVkZGluZyBsb2dpYyBoZXJlIGlmIG5vIGFkYXB0ZXIgb3IgYWRhcHRlciBsYWNrcyB0aGUgbWV0aG9kXG4gIH1cblxuICAvKipcbiAgICogRW1iZWQgYSBiYXRjaCBvZiBpbnB1dCBzdHJpbmdzIGludG8gYXJyYXlzIG9mIG51bWVyaWNhbCBhcnJheXMuXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IGlucHV0IC0gVGhlIGFycmF5IG9mIHN0cmluZ3MgdG8gZW1iZWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlcltdW10+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBhcnJheSBvZiBlbWJlZGRpbmcgYXJyYXlzLlxuICAgKi9cbiAgYXN5bmMgZW1iZWRfYmF0Y2goaW5wdXQpIHtcbiAgICBpZiAodGhpcy5hZGFwdGVyICYmIHR5cGVvZiB0aGlzLmFkYXB0ZXIuZW1iZWRfYmF0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmFkYXB0ZXIuZW1iZWRfYmF0Y2goaW5wdXQpO1xuICAgIH1cbiAgICAvLyBEZWZhdWx0IGJhdGNoIGVtYmVkZGluZyBsb2dpYyBoZXJlIGlmIG5vIGFkYXB0ZXIgb3IgYWRhcHRlciBsYWNrcyB0aGUgbWV0aG9kXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjb25maWd1cmVkIGJhdGNoIHNpemUgZm9yIGVtYmVkZGluZy5cbiAgICogQHJldHVybnMge251bWJlcn0gVGhlIGJhdGNoIHNpemUuXG4gICAqL1xuICBnZXQgYmF0Y2hfc2l6ZSgpIHsgcmV0dXJuIHRoaXMuY29uZmlnLmJhdGNoX3NpemU7IH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkaW1lbnNpb25zIG9mIHRoZSBlbWJlZGRpbmcuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBkaW1lbnNpb25zIG9mIHRoZSBlbWJlZGRpbmcuXG4gICAqL1xuICBnZXQgZGltcygpIHsgcmV0dXJuIHRoaXMuY29uZmlnLmRpbXM7IH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtYXhpbXVtIG51bWJlciBvZiB0b2tlbnMgdGhhdCBjYW4gYmUgcHJvY2Vzc2VkLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbWF4aW11bSBudW1iZXIgb2YgdG9rZW5zLlxuICAgKi9cbiAgZ2V0IG1heF90b2tlbnMoKSB7IHJldHVybiB0aGlzLmNvbmZpZy5tYXhfdG9rZW5zOyB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmFtZSBvZiB0aGUgbW9kZWwgdXNlZCBmb3IgZW1iZWRkaW5nLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgbW9kZWwgbmFtZS5cbiAgICovXG4gIGdldCBtb2RlbF9uYW1lKCkgeyByZXR1cm4gdGhpcy5jb25maWcubW9kZWxfbmFtZTsgfVxufVxuXG5leHBvcnRzLlNtYXJ0RW1iZWRNb2RlbCA9IFNtYXJ0RW1iZWRNb2RlbDsiLCAiLy8gQ29weXJpZ2h0IChjKSBCcmlhbiBKb3NlcGggUGV0cm9cblxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXG4vLyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4vLyBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbi8vIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbi8vIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuLy8gRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuLy8gTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRVxuLy8gTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTlxuLy8gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4vLyBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuY29uc3QgeyBDb2xsZWN0aW9uIH0gPSByZXF1aXJlKFwic21hcnQtY29sbGVjdGlvbnMvQ29sbGVjdGlvblwiKTsgLy8gbnBtXG5jb25zdCB7IENvbGxlY3Rpb25JdGVtIH0gPSByZXF1aXJlKFwic21hcnQtY29sbGVjdGlvbnMvQ29sbGVjdGlvbkl0ZW1cIik7IC8vIG5wbVxuY29uc3QgeyBTbWFydEVtYmVkTW9kZWwgfSA9IHJlcXVpcmUoJ3NtYXJ0LWVtYmVkLW1vZGVsJyk7XG5jbGFzcyBTbWFydEVudGl0aWVzIGV4dGVuZHMgQ29sbGVjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKGVudikge1xuICAgIHN1cGVyKGVudik7XG4gICAgdGhpcy5lbnYgPSBlbnY7IC8vIGVudiBpcyB0aGUgYnJhaW4gKGJyYWluIGlzIERlcHJlY2F0ZWQpXG4gICAgdGhpcy5fcGF1c2VfZW1iZWRkaW5ncyA9IGZhbHNlOyAvLyB1c2VkIHRvIHBhdXNlIGVuc3VyZV9lbWJlZGRpbmdzXG4gIH1cbiAgYXN5bmMgX3NhdmUoKSB7IGF3YWl0IHRoaXMuTFRNLl9zYXZlKCk7IH0gLy8gYXN5bmMgYi9jIE9ic2lkaWFuIEFQSSBpcyBhc3luY1xuICByZXBsYWNlcihrZXksIHZhbHVlKSB7IC8vIEpTT04uc3RyaW5naWZ5IHJlcGxhY2VyXG4gICAgaWYodmFsdWUgaW5zdGFuY2VvZiB0aGlzLml0ZW1fdHlwZSl7XG4gICAgICBpZighdmFsdWUudmFsaWRhdGVfc2F2ZSgpKXtcbiAgICAgICAgY29uc29sZS5sb2coXCJJbnZhbGlkIGJsb2NrLCBza2lwcGluZyBzYXZlOiBcIiwgdmFsdWUuZGF0YSk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIHNraXAgaWYgaW52YWxpZFxuICAgICAgfVxuICAgICAgaWYodmFsdWUuZGF0YS5lbWJlZGRpbmcudmVjICYmIHZhbHVlLmRhdGEudGV4dCkgdmFsdWUuZGF0YS50ZXh0ID0gdW5kZWZpbmVkOyAvLyBjbGVhciB0ZXh0IGlmIGVtYmVkZGluZyBleGlzdHNcbiAgICAgIHJldHVybiB2YWx1ZS5kYXRhO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucmVwbGFjZXIoa2V5LCB2YWx1ZSk7XG4gIH1cbiAgdW5sb2FkKCl7XG4gICAgaWYodHlwZW9mIHRoaXMuc21hcnRfZW1iZWQ/LnVubG9hZCA9PT0gJ2Z1bmN0aW9uJyl7XG4gICAgICB0aGlzLnNtYXJ0X2VtYmVkLnVubG9hZCgpO1xuICAgICAgZGVsZXRlIHRoaXMuc21hcnRfZW1iZWQ7XG4gICAgfVxuICAgIGlmKHRoaXMuc21hcnRfZW1iZWRfY29udGFpbmVyKXtcbiAgICAgIGNvbnN0IGlmcmFtZSA9IHRoaXMuc21hcnRfZW1iZWRfY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJ2lmcmFtZScpO1xuICAgICAgaWYgKCFpZnJhbWUpIHJldHVybjtcbiAgICAgIC8vIERPOiBpbXByb3ZlIHJlbW92ZSBvZiBldmVudCBsaXN0ZW5lcnNcbiAgICAgIGlmcmFtZS5zcmNkb2MgPSAnJztcbiAgICAgIGlmcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgICB0aGlzLnNtYXJ0X2VtYmVkX2NvbnRhaW5lci5yZW1vdmUoKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgbG9hZCgpIHtcbiAgICBhd2FpdCB0aGlzLkxUTS5sb2FkKCk7IC8vIE1VU1QgUlVOIEJFRk9SRSBTTUFSVCBFTUJFRCBhc3luYyBiL2MgT2JzaWRpYW4gQVBJIGlzIGFzeW5jXG4gICAgY29uc29sZS5sb2codGhpcyk7XG4gICAgY29uc29sZS5sb2codGhpcy5lbnYpO1xuICAgIGF3YWl0IHRoaXMubG9hZF9zbWFydF9lbWJlZCgpO1xuICB9XG4gIGFzeW5jIGxvYWRfc21hcnRfZW1iZWQoKSB7XG4gICAgLy8gY29uc29sZS5sb2coXCJMb2FkaW5nIFNtYXJ0RW1iZWQgZm9yIFwiICsgdGhpcy5jb2xsZWN0aW9uX25hbWUgKyBcIiBNb2RlbDogXCIgKyB0aGlzLnNtYXJ0X2VtYmVkX21vZGVsKTtcbiAgICBpZih0aGlzLnNtYXJ0X2VtYmVkX21vZGVsID09PSBcIk5vbmVcIikgcmV0dXJuOyAvLyBjb25zb2xlLmxvZyhcIlNtYXJ0RW1iZWQgZGlzYWJsZWQgZm9yIFwiLCB0aGlzLmNvbGxlY3Rpb25fbmFtZSk7XG4gICAgaWYodGhpcy5lbnYuc21hcnRfZW1iZWRfYWN0aXZlX21vZGVsc1t0aGlzLnNtYXJ0X2VtYmVkX21vZGVsXSBpbnN0YW5jZW9mIFNtYXJ0RW1iZWRNb2RlbCl7XG4gICAgICB0aGlzLnNtYXJ0X2VtYmVkID0gdGhpcy5lbnYuc21hcnRfZW1iZWRfYWN0aXZlX21vZGVsc1t0aGlzLnNtYXJ0X2VtYmVkX21vZGVsXTtcbiAgICAgIGNvbnNvbGUubG9nKFwiU21hcnRFbWJlZCBhbHJlYWR5IGxvYWRlZCBmb3IgXCIgKyB0aGlzLmNvbGxlY3Rpb25fbmFtZSArIFwiOiBNb2RlbDogXCIgKyB0aGlzLnNtYXJ0X2VtYmVkX21vZGVsKTtcbiAgICB9ZWxzZXtcbiAgICAgIGNvbnN0IG1vZGVsID0ge21vZGVsX2tleTogdGhpcy5zbWFydF9lbWJlZF9tb2RlbH07XG4gICAgICBpZih0aGlzLnNtYXJ0X2VtYmVkX21vZGVsLmluY2x1ZGVzKFwiL1wiKSkgeyAvLyBUT0RPOiBiZXR0ZXIgd2F5IHRvIGRldGVjdCBsb2NhbCBtb2RlbFxuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmVudi5sb2NhbF9tb2RlbF90eXBlKTtcbiAgICAgICAgdGhpcy5tb2RlbF9rZXkgPSB0aGlzLnNtYXJ0X2VtYmVkX21vZGVsO1xuICAgICAgICBjb25zdCBsb2NhbF9tYXggPSB0aGlzLmVudi5jb25maWcubG9jYWxfZW1iZWRkaW5nX21heF90b2tlbnM7XG4gICAgICAgIGlmKGxvY2FsX21heCA8IG1vZGVsLm1heF90b2tlbnMpIG1vZGVsLm1heF90b2tlbnMgPSBsb2NhbF9tYXg7XG4gICAgICAgIC8vIGNoZWNrIGlmIGh0dHA6Ly9sb2NhbGhvc3Q6Mzc0MjAvZW1iZWQgaXMgYXZhaWxhYmxlXG4gICAgICAgIGNvbnNvbGUubG9nKCdDaGVja2luZyBmb3IgbG9jYWwgU21hcnQgQ29ubmVjdCBzZXJ2ZXIuLi4nKTtcbiAgICAgICAgdHJ5e1xuICAgICAgICAgIGNvbnN0IHJlcXVlc3RfYWRhcHRlciA9IHRoaXMuZW52Lm1haW4ub2JzaWRpYW4/LnJlcXVlc3RVcmwgfHwgbnVsbDtcbiAgICAgICAgICBjb25zdCBzY19sb2NhbCA9ICFyZXF1ZXN0X2FkYXB0ZXIgPyBhd2FpdCBmZXRjaCgnaHR0cDovL2xvY2FsaG9zdDozNzQyMS8nKSA6IGF3YWl0IHJlcXVlc3RfYWRhcHRlcih7dXJsOiAnaHR0cDovL2xvY2FsaG9zdDozNzQyMS8nLCBtZXRob2Q6ICdHRVQnfSk7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coc2NfbG9jYWwpO1xuICAgICAgICAgIGlmKHNjX2xvY2FsLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnTG9jYWwgU21hcnQgQ29ubmVjdCBzZXJ2ZXIgZm91bmQnKTtcbiAgICAgICAgICAgIHRoaXMuc21hcnRfZW1iZWQgPSBhd2FpdCBTbWFydEVtYmVkTW9kZWwuY3JlYXRlKHRoaXMuZW52LCB7Li4ubW9kZWwsIHJlcXVlc3RfYWRhcHRlcjogcmVxdWVzdF9hZGFwdGVyLCBhZGFwdGVyOiAnbG9jYWxfYXBpJywgbG9jYWxfZW5kcG9pbnQ6ICdodHRwOi8vbG9jYWxob3N0OjM3NDIxL2VtYmVkX2JhdGNoJ30pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfWNhdGNoKGVycil7XG4gICAgICAgICAgY29uc29sZS5sb2coJ0NvdWxkIG5vdCBjb25uZWN0IHRvIGxvY2FsIFNtYXJ0IENvbm5lY3Qgc2VydmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy5lbnYubG9jYWxfbW9kZWxfdHlwZSA9PT0gJ1dlYicpe1xuICAgICAgICAgIHRoaXMubW9kZWxfa2V5ICs9ICdfd2ViJzsgLy8gbW9kZWwgcmVnaXN0cnkgbmFtZVxuICAgICAgICAgIGlmKHRoaXMuc21hcnRfZW1iZWQpIGNvbnNvbGUubG9nKGBFeGlzdGluZyBXZWJBZGFwdGVyIGZvciAke3RoaXMuY29sbGVjdGlvbl9uYW1lfSBtb2RlbDogJHt0aGlzLnNtYXJ0X2VtYmVkX21vZGVsfWApO1xuICAgICAgICAgIGVsc2UgdGhpcy5zbWFydF9lbWJlZCA9IGF3YWl0IFNtYXJ0RW1iZWRNb2RlbC5jcmVhdGUodGhpcy5lbnYsIHsuLi5tb2RlbCwgYWRhcHRlcjogJ2lmcmFtZScsIGNvbnRhaW5lcjogdGhpcy5zbWFydF9lbWJlZF9jb250YWluZXJ9KTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgdGhpcy5tb2RlbF9rZXkgKz0gJ19ub2RlJzsgLy8gbW9kZWwgcmVnaXN0cnkgbmFtZVxuICAgICAgICAgIGlmKHRoaXMuc21hcnRfZW1iZWQpIGNvbnNvbGUubG9nKGBFeGlzdGluZyBOb2RlQWRhcHRlciBmb3IgJHt0aGlzLmNvbGxlY3Rpb25fbmFtZX0gbW9kZWw6ICR7dGhpcy5zbWFydF9lbWJlZF9tb2RlbH1gKTsgLy8gQ2hlY2sgaWYgYSBjb25uZWN0aW9uIGZvciB0aGlzIG1vZGVsIGFscmVhZHkgZXhpc3RzXG4gICAgICAgICAgZWxzZSB0aGlzLnNtYXJ0X2VtYmVkID0gYXdhaXQgU21hcnRFbWJlZE1vZGVsLmNyZWF0ZSh0aGlzLmVudiwgey4uLm1vZGVsLCBhZGFwdGVyOiAndHJhbnNmb3JtZXJzJ30pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgeyAvLyBpcyBBUEkgbW9kZWxcbiAgICAgICAgdGhpcy5tb2RlbF9rZXkgKz0gJ19hcGknOyAvLyBtb2RlbCByZWdpc3RyeSBuYW1lXG4gICAgICAgIGlmKHRoaXMuc21hcnRfZW1iZWQpIGNvbnNvbGUubG9nKGBFeGlzdGluZyBBcGlBZGFwdGVyIGZvciAke3RoaXMuY29sbGVjdGlvbl9uYW1lfSBtb2RlbDogJHt0aGlzLnNtYXJ0X2VtYmVkX21vZGVsfWApOyAvLyBDaGVjayBpZiBhIGNvbm5lY3Rpb24gZm9yIHRoaXMgbW9kZWwgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgZWxzZSB0aGlzLnNtYXJ0X2VtYmVkID0gYXdhaXQgU21hcnRFbWJlZE1vZGVsLmNyZWF0ZSh0aGlzLmVudiwgey4uLm1vZGVsLCByZXF1ZXN0X2FkYXB0ZXI6IHRoaXMuZW52Lm1haW4ub2JzaWRpYW4/LnJlcXVlc3RVcmwsIGFwaV9rZXk6IHRoaXMuY29uZmlnLmFwaV9rZXl9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0IHNtYXJ0X2VtYmVkX2NvbnRhaW5lcigpIHtcbiAgICBpZighdGhpcy5tb2RlbF9rZXkpIHJldHVybiBjb25zb2xlLmxvZygnbW9kZWxfa2V5IG5vdCBzZXQnKTtcbiAgICBjb25zdCBpZCA9IHRoaXMubW9kZWxfa2V5LnJlcGxhY2UoL1teYS16QS1aMC05XS9nLCAnXycpO1xuICAgIGlmKCF3aW5kb3cuZG9jdW1lbnQpIHJldHVybiBjb25zb2xlLmxvZygnd2luZG93LmRvY3VtZW50IG5vdCBhdmFpbGFibGUnKTtcbiAgICBpZih3aW5kb3cuZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgIyR7aWR9YCkpIHJldHVybiB3aW5kb3cuZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgIyR7aWR9YCk7XG4gICAgY29uc3QgY29udGFpbmVyID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRhaW5lci5pZCA9IGlkO1xuICAgIHdpbmRvdy5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxuICBnZXQgc21hcnRfZW1iZWQoKSB7IHJldHVybiB0aGlzLmVudi5hY3RpdmVfZW1iZWRfbW9kZWxzPy5bdGhpcy5tb2RlbF9rZXldOyB9XG4gIHNldCBzbWFydF9lbWJlZCh2YWwpIHtcbiAgICBpZighdGhpcy5tb2RlbF9rZXkpIHRoaXMubW9kZWxfa2V5ID0gdmFsLm1vZGVsX25hbWUgKyBcIl9cIiArIHZhbC5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIGlmKCF0aGlzLmVudi5hY3RpdmVfZW1iZWRfbW9kZWxzKSB0aGlzLmVudi5hY3RpdmVfZW1iZWRfbW9kZWxzID0ge307XG4gICAgdGhpcy5lbnYuYWN0aXZlX2VtYmVkX21vZGVsc1t0aGlzLm1vZGVsX2tleV0gPSB2YWw7XG4gIH1cbiAgcGF1c2VfZW1iZWRkaW5nKCkge1xuICAgIHRoaXMuX3BhdXNlX2VtYmVkZGluZ3MgPSB0cnVlO1xuICAgIHRoaXMuZW52Lm1haW4ubm90aWNlcy5yZW1vdmUoJ2VtYmVkZGluZyBwcm9ncmVzcycpO1xuICB9XG4gIGFzeW5jIGVuc3VyZV9lbWJlZGRpbmdzKHNob3dfbm90aWNlID0gbnVsbCkge1xuICAgIGNvbnNvbGUubG9nKFwiZW5zdXJlX2VtYmVkZGluZ3NcIik7XG4gICAgaWYoIXRoaXMuc21hcnRfZW1iZWQpIHJldHVybiBjb25zb2xlLmxvZyhcIlNtYXJ0RW1iZWQgbm90IGxvYWRlZCBmb3IgXCIgKyB0aGlzLmNvbGxlY3Rpb25fbmFtZSk7XG4gICAgY29uc3QgdW5lbWJlZGRlZF9pdGVtcyA9IHRoaXMudW5lbWJlZGRlZF9pdGVtczsgLy8gZ2V0cyBhbGwgd2l0aG91dCB2ZWNcbiAgICBpZih1bmVtYmVkZGVkX2l0ZW1zLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRydWU7IC8vIHNraXAgaWYgbm8gdW5lbWJlZGRlZCBpdGVtc1xuICAgIGNvbnNvbGUubG9nKFwidW5lbWJlZGRlZF9pdGVtczogXCIsIHVuZW1iZWRkZWRfaXRlbXMpO1xuICAgIGNvbnN0IHBlcmZvcm1hbmNlX25vdGljZV9tc2cgPSBcIihUaGlzIGlzIGEgcmVzb3VyY2UgaW50ZW5zaXZlIG9wZXJhdGlvbilcIjtcbiAgICBpZigoc2hvd19ub3RpY2UgIT09IGZhbHNlKSAmJiAodW5lbWJlZGRlZF9pdGVtcy5sZW5ndGggPiAzMCkpIHtcbiAgICAgIGNvbnN0IHN0YXJ0X2J0biA9IHt0ZXh0OiBcIlN0YXJ0IGVtYmVkZGluZ1wiLCBjYWxsYmFjazogKCkgPT4gdGhpcy5lbnN1cmVfZW1iZWRkaW5ncyhmYWxzZSkgfTtcbiAgICAgIHRoaXMuZW52Lm1haW4ubm90aWNlcy5zaG93KCdzdGFydCBlbWJlZGRpbmcnLCBbYEFyZSB5b3UgcmVhZHkgdG8gYmVnaW4gZW1iZWRkaW5nICR7dW5lbWJlZGRlZF9pdGVtcy5sZW5ndGh9ICR7dGhpcy5jb2xsZWN0aW9uX25hbWV9P2AsIHBlcmZvcm1hbmNlX25vdGljZV9tc2ddLCB7IHRpbWVvdXQ6IDAsIGNvbmZpcm06IHN0YXJ0X2J0bn0pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZih0aGlzLmlzX2VtYmVkZGluZykgcmV0dXJuIGNvbnNvbGUubG9nKCdhbHJlYWR5IGVtYmVkZGluZycpO1xuICAgIHRoaXMuaXNfZW1iZWRkaW5nID0gdHJ1ZTtcbiAgICBjb25zdCBiYXRjaF9zaXplID0gdGhpcy5zbWFydF9lbWJlZC5iYXRjaF9zaXplO1xuICAgIHRoaXMuZW52Lm1haW4ubm90aWNlcy5yZW1vdmUoJ3N0YXJ0IGVtYmVkZGluZycpO1xuICAgIGxldCB0b3RhbF90b2tlbnMgPSAwO1xuICAgIGxldCB0aW1lX3N0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgdGltZV9lbGFwc2VkID0gMDtcbiAgICBsZXQgdG9rZW5zX3Blcl9zZWMgPSAwO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCB1bmVtYmVkZGVkX2l0ZW1zLmxlbmd0aDsgaSArPSBiYXRjaF9zaXplKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyhcImk6IFwiLCBpKTtcbiAgICAgIGlmKHRoaXMuX3BhdXNlX2VtYmVkZGluZ3MpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJwYXVzZV9lbWJlZGRpbmdzXCIpO1xuICAgICAgICB0aGlzLl9wYXVzZV9lbWJlZGRpbmdzID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHJlc3RhcnRfYnRuID0ge3RleHQ6IFwiUmVzdGFydFwiLCBjYWxsYmFjazogKCkgPT4gdGhpcy5lbnN1cmVfZW1iZWRkaW5ncygpIH07XG4gICAgICAgIHRoaXMuZW52Lm1haW4ubm90aWNlcy5zaG93KCdyZXN0YXJ0IGVtYmVkZGluZycsIFtgRW1iZWRkaW5nICR7dGhpcy5jb2xsZWN0aW9uX25hbWV9Li4uYCwgYFBhdXNlZCBhdCAke2l9IC8gJHt1bmVtYmVkZGVkX2l0ZW1zLmxlbmd0aH0gJHt0aGlzLmNvbGxlY3Rpb25fbmFtZX1gLCBwZXJmb3JtYW5jZV9ub3RpY2VfbXNnXSwgeyB0aW1lb3V0OiAwLCBidXR0b246IHJlc3RhcnRfYnRufSk7XG4gICAgICAgIHRoaXMuTFRNLl9zYXZlKHRydWUpOyAvLyBzYXZlIGltbWVkaWF0ZWx5LCBvdmVyd3JpdGVzIGV4aXN0aW5nIGZpbGVcbiAgICAgICAgdGhpcy5pc19lbWJlZGRpbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYoaSAlIDEwID09PSAwKXtcbiAgICAgICAgY29uc3QgcGF1c2VfYnRuID0ge3RleHQ6IFwiUGF1c2VcIiwgY2FsbGJhY2s6ICgpID0+IHRoaXMucGF1c2VfZW1iZWRkaW5nKCksIHN0YXlfb3BlbjogdHJ1ZX07XG4gICAgICAgIHRoaXMuZW52Lm1haW4ubm90aWNlcy5zaG93KCdlbWJlZGRpbmcgcHJvZ3Jlc3MnLCBbYEVtYmVkZGluZyAke3RoaXMuY29sbGVjdGlvbl9uYW1lfS4uLmAsIGBQcm9ncmVzczogJHtpfSAvICR7dW5lbWJlZGRlZF9pdGVtcy5sZW5ndGh9ICR7dGhpcy5jb2xsZWN0aW9uX25hbWV9YCwgYCR7dG9rZW5zX3Blcl9zZWN9IHRva2Vucy9zZWNgLCBwZXJmb3JtYW5jZV9ub3RpY2VfbXNnXSwgeyB0aW1lb3V0OiAwLCBidXR0b246IHBhdXNlX2J0biwgaW1tdXRhYmxlOiB0cnVlfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBpdGVtcyA9IHVuZW1iZWRkZWRfaXRlbXMuc2xpY2UoaSwgaSArIGJhdGNoX3NpemUpO1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoaXRlbXMubWFwKGFzeW5jIGl0ZW0gPT4gYXdhaXQgaXRlbS5nZXRfZW1iZWRfaW5wdXQoKSkpOyAvLyBtYWtlIHN1cmUgYWxsIGl0ZW1zIGhhdmUgZW1iZWRfaW5wdXQgKGluIGNhY2hlIGZvciBjYWxsIGJ5IGVtYmVkX2JhdGNoKVxuICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IHRoaXMuc21hcnRfZW1iZWQuZW1iZWRfYmF0Y2goaXRlbXMpO1xuICAgICAgLy8gY29uc29sZS5sb2coXCJyZXNwOiBcIiwgcmVzcCk7XG4gICAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICBpdGVtLl9lbWJlZF9pbnB1dCA9IG51bGw7IC8vIGNsZWFyIF9lbWJlZF9pbnB1dCBjYWNoZSBhZnRlciBlbWJlZGRpbmdcbiAgICAgICAgaXRlbS5jaGFuZ2VkID0gdHJ1ZTsgLy8gbWFyayBhcyBjaGFuZ2VkXG4gICAgICB9KTtcbiAgICAgIHRvdGFsX3Rva2VucyArPSByZXNwLnJlZHVjZSgoYWNjLCBpdGVtKSA9PiBhY2MgKyBpdGVtLnRva2VucywgMCk7XG4gICAgICB0aW1lX2VsYXBzZWQgPSBEYXRlLm5vdygpIC0gdGltZV9zdGFydDtcbiAgICAgIHRva2Vuc19wZXJfc2VjID0gTWF0aC5yb3VuZCh0b3RhbF90b2tlbnMgLyAodGltZV9lbGFwc2VkIC8gMTAwMCkpO1xuICAgICAgLy8gY29uc29sZS5sb2coaXRlbXMuZmlsdGVyKGkgPT4gIWkudmVjKS5tYXAoaXRlbSA9PiBpdGVtKSk7XG4gICAgICBpZihpICYmIChpICUgNTAwID09PSAwKSl7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHVuZW1iZWRkZWRfaXRlbXNbaV0pO1xuICAgICAgICBhd2FpdCB0aGlzLkxUTS5fc2F2ZSgpO1xuICAgICAgfVxuICAgICAgLy8gY29uc29sZS5sb2coXCJkb25lIGk6IFwiLCBpKTtcbiAgICB9XG4gICAgaWYodGhpcy5lbnYubWFpbi5fbm90aWNlPy5ub3RpY2VFbD8ucGFyZW50RWxlbWVudCkgdGhpcy5lbnYubWFpbi5fbm90aWNlLmhpZGUoKTtcbiAgICBjb25zdCBlbWJlZGRlZF9jdCA9IHVuZW1iZWRkZWRfaXRlbXMuZmlsdGVyKGkgPT4gaS52ZWMpLmxlbmd0aDtcbiAgICAvLyBjb25zb2xlLmxvZyh1bmVtYmVkZGVkX2l0ZW1zLm1hcChpID0+IGkua2V5KSk7XG4gICAgdGhpcy5lbnYubWFpbi5ub3RpY2VzLnJlbW92ZSgnZW1iZWRkaW5nIHByb2dyZXNzJyk7XG4gICAgdGhpcy5lbnYubWFpbi5ub3RpY2VzLnNob3coJ2RvbmUgZW1iZWRkaW5nJywgW2BFbWJlZGRpbmcgJHt0aGlzLmNvbGxlY3Rpb25fbmFtZX0uLi5gLCBgRG9uZSBjcmVhdGluZyAke2VtYmVkZGVkX2N0fSBlbWJlZGRpbmdzLmBdLCB7IHRpbWVvdXQ6IDEwMDAwIH0pO1xuICAgIGlmKHVuZW1iZWRkZWRfaXRlbXMubGVuZ3RoKSB0aGlzLkxUTS5fc2F2ZSgpO1xuICAgIHRoaXMuaXNfZW1iZWRkaW5nID0gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZ2V0IGVtYmVkZGVkX2l0ZW1zKCkgeyByZXR1cm4gdGhpcy5zbWFydF9lbWJlZCA/IE9iamVjdC52YWx1ZXModGhpcy5pdGVtcykuZmlsdGVyKGkgPT4gaS52ZWMpIDogT2JqZWN0LnZhbHVlcyh0aGlzLml0ZW1zKTsgfVxuICBnZXQgdW5lbWJlZGRlZF9pdGVtcygpIHsgcmV0dXJuIHRoaXMuc21hcnRfZW1iZWQgPyBPYmplY3QudmFsdWVzKHRoaXMuaXRlbXMpLmZpbHRlcihpdGVtID0+ICFpdGVtLnZlYykgOiBbXTsgfVxuXG4gIG5lYXJlc3QodmVjLCBmaWx0ZXI9e30pIHtcbiAgICBpZighdmVjKSByZXR1cm4gY29uc29sZS5sb2coXCJubyB2ZWNcIik7XG4gICAgY29uc3Qge1xuICAgICAgLy8gcmVzdWx0c19jb3VudCA9IDIwLFxuICAgICAgcmVzdWx0c19jb3VudCA9IDUwLFxuICAgIH0gPSBmaWx0ZXI7XG4gICAgY29uc3QgbmVhcmVzdCA9IHRoaXMuZmlsdGVyKGZpbHRlcilcbiAgICAgIC5yZWR1Y2UoKGFjYywgaXRlbSkgPT4ge1xuICAgICAgICBpZighaXRlbS5kYXRhLmVtYmVkZGluZz8udmVjKSByZXR1cm4gYWNjOyAvLyBza2lwIGlmIG5vIHZlY1xuICAgICAgICBpdGVtLnNpbSA9IGNvc19zaW0odmVjLCBpdGVtLmRhdGEuZW1iZWRkaW5nLnZlYyk7XG4gICAgICAgIHRvcF9hY2MoYWNjLCBpdGVtLCByZXN1bHRzX2NvdW50KTsgLy8gdXBkYXRlIGFjY1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSwgeyBtaW46IDAsIGl0ZW1zOiBuZXcgU2V0KCkgfSlcbiAgICA7XG4gICAgcmV0dXJuIEFycmF5LmZyb20obmVhcmVzdC5pdGVtcyk7XG4gIH1cbiAgZ2V0IGZpbGVfbmFtZSgpIHsgcmV0dXJuIHRoaXMuY29sbGVjdGlvbl9uYW1lICsgJy0nICsgdGhpcy5zbWFydF9lbWJlZF9tb2RlbC5zcGxpdChcIi9cIikucG9wKCk7IH1cbiAgZ2V0IHNtYXJ0X2VtYmVkX21vZGVsKCkgeyByZXR1cm4gdGhpcy5jb25maWdbdGhpcy5jb2xsZWN0aW9uX25hbWUgKyBcIl9lbWJlZF9tb2RlbFwiXTsgfVxufVxuY2xhc3MgU21hcnRFbnRpdHkgZXh0ZW5kcyBDb2xsZWN0aW9uSXRlbSB7XG4gIHN0YXRpYyBnZXQgZGVmYXVsdHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgcGF0aDogbnVsbCxcbiAgICAgICAgZW1iZWRkaW5nOiB7fSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuICBnZXRfa2V5KCkgeyByZXR1cm4gdGhpcy5kYXRhLnBhdGg7IH1cbiAgLy8gRE86IGNsYXJpZmllZC9pbXByb3ZlZCBsb2dpY1xuICBzYXZlKCkge1xuICAgIHRoaXMuY29sbGVjdGlvbi5zZXQodGhpcyk7XG4gICAgdGhpcy5lbnYuc2F2ZSgpO1xuICB9XG4gIGdldF9uZWFyZXN0KGZpbHRlcj17fSkgeyAvKiBUT0RPICovIH1cbiAgYXN5bmMgZ2V0X2FzX2NvbnRleHQocGFyYW1zID0ge30pIHtcbiAgICByZXR1cm4gYC0tLUJFR0lOIE5PVEUke3BhcmFtcy5pID8gXCIgXCIgKyBwYXJhbXMuaSA6IFwiXCJ9IFtbJHt0aGlzLnBhdGh9XV0tLS1cXG4ke2F3YWl0IHRoaXMuZ2V0X2NvbnRlbnQoKX1cXG4tLS1FTkQgTk9URSR7cGFyYW1zLmkgPyBcIiBcIiArIHBhcmFtcy5pIDogXCJcIn0tLS1gO1xuICB9XG4gIGFzeW5jIGdldF9jb250ZW50KCkge30gLy8gb3ZlcnJpZGUgaW4gY2hpbGQgY2xhc3NcbiAgYXN5bmMgZ2V0X2VtYmVkX2lucHV0KCkge30gLy8gb3ZlcnJpZGUgaW4gY2hpbGQgY2xhc3NcbiAgLy8gZ2V0dGVyc1xuICBnZXQgYWpzb24oKSB7IHJldHVybiBgJHtKU09OLnN0cmluZ2lmeSh0aGlzLmtleSl9OiAke0pTT04uc3RyaW5naWZ5KHRoaXMuZGF0YSl9YDsgfVxuICBnZXQgZW1iZWRfbGluaygpIHsgcmV0dXJuIGAhW1ske3RoaXMuZGF0YS5wYXRofV1dYDsgfVxuICBnZXQgbXVsdGlfYWpzb25fZmlsZV9uYW1lKCkgeyByZXR1cm4gKHRoaXMucGF0aC5zcGxpdChcIiNcIikuc2hpZnQoKSkucmVwbGFjZSgvW15hLXpBLVowLTldL2csICdfJykucmVwbGFjZShcIi5tZFwiLCBcIlwiKTsgfVxuICBnZXQgbmFtZSgpIHsgcmV0dXJuICghdGhpcy5lbnYubWFpbi5zZXR0aW5ncy5zaG93X2Z1bGxfcGF0aCA/IHRoaXMucGF0aC5zcGxpdChcIi9cIikucG9wKCkgOiB0aGlzLnBhdGguc3BsaXQoXCIvXCIpLmpvaW4oXCIgPiBcIikpLnNwbGl0KFwiI1wiKS5qb2luKFwiID4gXCIpLnJlcGxhY2UoXCIubWRcIiwgXCJcIik7IH1cbiAgZ2V0IHBhdGgoKSB7IHJldHVybiB0aGlzLmRhdGEucGF0aDsgfVxuICBnZXQgdG9rZW5zKCkgeyByZXR1cm4gdGhpcy5kYXRhLmVtYmVkZGluZy50b2tlbnM7IH1cbiAgZ2V0IHZlYygpIHsgcmV0dXJuIHRoaXMuZGF0YS5lbWJlZGRpbmcudmVjOyB9XG4gIC8vIHNldHRlcnNcbiAgc2V0IGVycm9yKGVycm9yKSB7IHRoaXMuZGF0YS5lbWJlZGRpbmcuZXJyb3IgPSBlcnJvcjsgfVxuICBzZXQgdG9rZW5zKHRva2VucykgeyB0aGlzLmRhdGEuZW1iZWRkaW5nLnRva2VucyA9IHRva2VuczsgfVxuICBzZXQgdmVjKHZlYykgeyB0aGlzLmRhdGEuZW1iZWRkaW5nLnZlYyA9IHZlYzsgfVxufVxuLy8gQ09TSU5FIFNJTUlMQVJJVFlcbmZ1bmN0aW9uIGNvc19zaW0odmVjdG9yMSwgdmVjdG9yMikge1xuICBjb25zdCBkb3RQcm9kdWN0ID0gdmVjdG9yMS5yZWR1Y2UoKGFjYywgdmFsLCBpKSA9PiBhY2MgKyB2YWwgKiB2ZWN0b3IyW2ldLCAwKTtcbiAgY29uc3Qgbm9ybUEgPSBNYXRoLnNxcnQodmVjdG9yMS5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MgKyB2YWwgKiB2YWwsIDApKTtcbiAgY29uc3Qgbm9ybUIgPSBNYXRoLnNxcnQodmVjdG9yMi5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MgKyB2YWwgKiB2YWwsIDApKTtcbiAgcmV0dXJuIG5vcm1BID09PSAwIHx8IG5vcm1CID09PSAwID8gMCA6IGRvdFByb2R1Y3QgLyAobm9ybUEgKiBub3JtQik7XG59XG5mdW5jdGlvbiB0b3BfYWNjKF9hY2MsIGl0ZW0sIGN0ID0gMTApIHtcbiAgaWYgKF9hY2MuaXRlbXMuc2l6ZSA8IGN0KSB7XG4gICAgX2FjYy5pdGVtcy5hZGQoaXRlbSk7XG4gIH0gZWxzZSBpZiAoaXRlbS5zaW0gPiBfYWNjLm1pbikge1xuICAgIF9hY2MuaXRlbXMuYWRkKGl0ZW0pO1xuICAgIF9hY2MuaXRlbXMuZGVsZXRlKF9hY2MubWluSXRlbSk7XG4gICAgX2FjYy5taW5JdGVtID0gQXJyYXkuZnJvbShfYWNjLml0ZW1zKS5yZWR1Y2UoKG1pbiwgY3VycikgPT4gKGN1cnIuc2ltIDwgbWluLnNpbSA/IGN1cnIgOiBtaW4pKTtcbiAgICBfYWNjLm1pbiA9IF9hY2MubWluSXRlbS5zaW07XG4gIH1cbn1cblxuZXhwb3J0cy5TbWFydEVudGl0eSA9IFNtYXJ0RW50aXR5O1xuZXhwb3J0cy5TbWFydEVudGl0aWVzID0gU21hcnRFbnRpdGllcztcbmV4cG9ydHMuY29zX3NpbSA9IGNvc19zaW07XG5cbi8vIERPOiBFeHRyYWN0IHRvIHNlcGFyYXRlIGZpbGVzXG5jbGFzcyBTbWFydE5vdGVzIGV4dGVuZHMgU21hcnRFbnRpdGllcyB7XG4gIGFzeW5jIGltcG9ydChmaWxlcywgb3B0cz0ge30pIHtcbiAgICB0cnl7XG4gICAgICBsZXQgYmF0Y2ggPSBbXTtcbiAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGlmKGJhdGNoLmxlbmd0aCAlIDEwID09PSAwKXtcbiAgICAgICAgICB0aGlzLmVudi5tYWluLm5vdGljZXMuc2hvdygnaW5pdGlhbCBzY2FuIHByb2dyZXNzJywgW2BNYWtpbmcgU21hcnQgQ29ubmVjdGlvbnMuLi5gLCBgUHJvZ3Jlc3M6ICR7aX0gLyAke2ZpbGVzLmxlbmd0aH0gZmlsZXNgXSwgeyB0aW1lb3V0OiAwIH0pO1xuICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGJhdGNoKTtcbiAgICAgICAgICBiYXRjaCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vdGUgPSB0aGlzLmdldChmaWxlc1tpXS5wYXRoKTtcbiAgICAgICAgaWYoIW5vdGUpIGJhdGNoLnB1c2godGhpcy5jcmVhdGVfb3JfdXBkYXRlKHsgcGF0aDogZmlsZXNbaV0ucGF0aCB9KSk7XG4gICAgICAgIGlmKG5vdGUgJiYgbm90ZS5tZXRhX2NoYW5nZWQpe1xuICAgICAgICAgIG5vdGUuZGF0YS5lbWJlZGRpbmcgPSB7fTtcbiAgICAgICAgICBiYXRjaC5wdXNoKHRoaXMuY3JlYXRlX29yX3VwZGF0ZSh7IHBhdGg6IGZpbGVzW2ldLnBhdGggfSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChiYXRjaCk7XG4gICAgICB0aGlzLmVudi5tYWluLm5vdGljZXMucmVtb3ZlKCdpbml0aWFsIHNjYW4gcHJvZ3Jlc3MnKTtcbiAgICAgIHRoaXMuZW52Lm1haW4ubm90aWNlcy5zaG93KCdkb25lIGluaXRpYWwgc2NhbicsIFtgTWFraW5nIFNtYXJ0IENvbm5lY3Rpb25zLi4uYCwgYERvbmUgaW1wb3J0aW5nIFNtYXJ0IE5vdGVzLmBdLCB7IHRpbWVvdXQ6IDMwMDAgfSk7XG4gICAgICB0aGlzLmVuc3VyZV9lbWJlZGRpbmdzKCk7XG4gICAgfWNhdGNoKGUpe1xuICAgICAgY29uc29sZS5sb2coXCJlcnJvciBpbXBvcnRpbmcgYmxvY2tzXCIpO1xuICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGVuc3VyZV9lbWJlZGRpbmdzKHNob3dfbm90aWNlID0gZmFsc2UpIHtcbiAgICBhd2FpdCBzdXBlci5lbnN1cmVfZW1iZWRkaW5ncyhzaG93X25vdGljZSk7XG4gICAgYXdhaXQgdGhpcy5wcnVuZSh0cnVlKTtcbiAgICBpZih0aGlzLmVudi5zbWFydF9ibG9ja3M/LnNtYXJ0X2VtYmVkKXtcbiAgICAgIGF3YWl0IHRoaXMuZW52LnNtYXJ0X2Jsb2Nrcy5lbnN1cmVfZW1iZWRkaW5ncyh7c2hvd19ub3RpY2V9KTsgLy8gdHJpZ2dlciBibG9jay1sZXZlbCBpbXBvcnRcbiAgICAgIGF3YWl0IHRoaXMuZW52LnNtYXJ0X2Jsb2Nrcy5wcnVuZSh0cnVlKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcHJ1bmUob3ZlcnJpZGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IHJlbW92ZSA9IFtdO1xuICAgIGNvbnN0IGl0ZW1zX3dfdmVjID0gT2JqZWN0LmVudHJpZXModGhpcy5pdGVtcykuZmlsdGVyKChba2V5LCBub3RlXSkgPT4gbm90ZS52ZWMpO1xuICAgIGNvbnN0IHRvdGFsX2l0ZW1zX3dfdmVjID0gaXRlbXNfd192ZWMubGVuZ3RoO1xuICAgIGNvbnN0IGF2YWlsYWJsZV9ub3RlcyA9IHRoaXMuZW52LmZpbGVzLnJlZHVjZSgoYWNjLCBmaWxlKSA9PiB7XG4gICAgICBhY2NbZmlsZS5wYXRoXSA9IHRydWU7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgICBpZighdG90YWxfaXRlbXNfd192ZWMpe1xuICAgICAgdGhpcy5jbGVhcigpOyAvLyBjbGVhciBpZiBubyBpdGVtcyB3aXRoIHZlYyAocmVidWlsZHMgaW4gaW1wb3J0KVxuICAgICAgcmV0dXJuOyAvLyBza2lwIHJlc3QgaWYgbm8gaXRlbXMgd2l0aCB2ZWNcbiAgICB9XG4gICAgZm9yKGNvbnN0IFtrZXksIG5vdGVdIG9mIGl0ZW1zX3dfdmVjKXtcbiAgICAgIGlmKCFhdmFpbGFibGVfbm90ZXNbbm90ZS5kYXRhLnBhdGhdKXtcbiAgICAgICAgcmVtb3ZlLnB1c2goa2V5KTsgLy8gcmVtb3ZlIGlmIG5vdCBhdmFpbGFibGVcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZihub3RlLmlzX2dvbmUpe1xuICAgICAgICByZW1vdmUucHVzaChrZXkpOyAvLyByZW1vdmUgaWYgZXhwaXJlZFxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmKG5vdGUubWV0YV9jaGFuZ2VkKXtcbiAgICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IG5vdGUuZ2V0X2NvbnRlbnQoKTtcbiAgICAgICAgY29uc3QgaGFzaCA9IGF3YWl0IGNyZWF0ZV9oYXNoKGNvbnRlbnQpO1xuICAgICAgICBpZihoYXNoICE9PSBub3RlLmxhc3RfaGlzdG9yeT8uaGFzaCl7XG4gICAgICAgICAgcmVtb3ZlLnB1c2goa2V5KTsgLy8gcmVtb3ZlIGlmIGNoYW5nZWRcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zb2xlLmxvZyhyZW1vdmUpO1xuICAgIGNvbnN0IHJlbW92ZV9yYXRpbyA9IHJlbW92ZS5sZW5ndGggLyB0b3RhbF9pdGVtc193X3ZlYztcbiAgICBpZigob3ZlcnJpZGUgJiYgKHJlbW92ZV9yYXRpbyA8IDAuNSkpIHx8IGNvbmZpcm0oYEFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBkZWxldGUgJHtyZW1vdmUubGVuZ3RofSAoJHtNYXRoLmZsb29yKHJlbW92ZV9yYXRpbyoxMDApfSUpIE5vdGUtbGV2ZWwgRW1iZWRkaW5ncz9gKSl7XG4gICAgICB0aGlzLmRlbGV0ZV9tYW55KHJlbW92ZSk7XG4gICAgICB0aGlzLkxUTS5fc2F2ZSh0cnVlKTsgLy8gc2F2ZSBpZiBub3Qgb3ZlcnJpZGVcbiAgICAgIGNvbnNvbGUubG9nKGBQcnVuZWQgJHtyZW1vdmUubGVuZ3RofSBTbWFydCBOb3Rlc2ApO1xuICAgIH1cbiAgfVxuICBnZXQgY3VycmVudF9ub3RlKCkgeyByZXR1cm4gdGhpcy5nZXQodGhpcy5lbnYubWFpbi5hcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKS5wYXRoKTsgfVxuICBnZXQgYmxvY2tzKCkgeyB0aGlzLmVudi5zbWFydF9ibG9ja3MuZ2V0X21hbnkodGhpcy5sYXN0X2hpc3RvcnkuYmxvY2tzKTsgfVxufVxuY2xhc3MgU21hcnROb3RlIGV4dGVuZHMgU21hcnRFbnRpdHkge1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIGhpc3Rvcnk6IFtdLCAvLyBhcnJheSBvZiB7IG10aW1lLCBoYXNoLCBsZW5ndGgsIGJsb2Nrc1tdIH1cbiAgICAgIH0sXG4gICAgICBfZW1iZWRfaW5wdXQ6IG51bGwsIC8vIHN0b3JlZCB0ZW1wb3JhcmlseVxuICAgIH07XG4gIH1cbiAgYXN5bmMgaW5pdCgpIHtcbiAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy5nZXRfY29udGVudCgpO1xuICAgIGNvbnN0IGhhc2ggPSBhd2FpdCBjcmVhdGVfaGFzaChjb250ZW50KTsgLy8gdXBkYXRlIGhhc2hcbiAgICBpZihoYXNoICE9PSB0aGlzLmxhc3RfaGlzdG9yeT8uaGFzaCl7XG4gICAgICB0aGlzLmRhdGEuaGlzdG9yeS5wdXNoKHsgYmxvY2tzOiB7fSwgbXRpbWU6IHRoaXMudF9maWxlLnN0YXQubXRpbWUsIHNpemU6IHRoaXMudF9maWxlLnN0YXQuc2l6ZSwgaGFzaCB9KTsgLy8gYWRkIGhpc3RvcnkgZW50cnlcbiAgICAgIHRoaXMuZGF0YS5lbWJlZGRpbmcgPSB7fTsgLy8gY2xlYXIgZW1iZWRkaW5nXG4gICAgfWVsc2V7XG4gICAgICB0aGlzLmxhc3RfaGlzdG9yeS5tdGltZSA9IHRoaXMudF9maWxlLnN0YXQubXRpbWU7IC8vIHVwZGF0ZSBtdGltZVxuICAgICAgdGhpcy5sYXN0X2hpc3Rvcnkuc2l6ZSA9IHRoaXMudF9maWxlLnN0YXQuc2l6ZTsgLy8gdXBkYXRlIHNpemVcbiAgICB9XG4gICAgdGhpcy5lbnYuc21hcnRfYmxvY2tzLmltcG9ydCh0aGlzLCB7IHNob3dfbm90aWNlOiBmYWxzZSB9KTtcbiAgfVxuICBhc3luYyBnZXRfZW1iZWRfaW5wdXQoKSB7XG4gICAgaWYodHlwZW9mIHRoaXMuX2VtYmVkX2lucHV0ID09PSAnc3RyaW5nJyAmJiB0aGlzLl9lbWJlZF9pbnB1dC5sZW5ndGgpIHJldHVybiB0aGlzLl9lbWJlZF9pbnB1dDsgLy8gcmV0dXJuIGNhY2hlZCAodGVtcG9yYXJ5KSBpbnB1dFxuICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLmdldF9jb250ZW50KCk7IC8vIGdldCBjb250ZW50IGZyb20gZmlsZVxuICAgIGNvbnN0IGJyZWFkY3J1bWJzID0gdGhpcy5kYXRhLnBhdGguc3BsaXQoXCIvXCIpLmpvaW4oXCIgPiBcIikucmVwbGFjZShcIi5tZFwiLCBcIlwiKTtcbiAgICB0aGlzLl9lbWJlZF9pbnB1dCA9IGAke2JyZWFkY3J1bWJzfTpcXG4ke2NvbnRlbnR9YDtcbiAgICByZXR1cm4gdGhpcy5fZW1iZWRfaW5wdXQ7XG4gIH1cbiAgZmluZF9jb25uZWN0aW9ucygpIHtcbiAgICBsZXQgcmVzdWx0cyA9IFtdO1xuICAgIGlmKCF0aGlzLnZlYyAmJiAhdGhpcy5tZWRpYW5fYmxvY2tfdmVjKXtcbiAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMpO1xuICAgICAgY29uc3Qgc3RhcnRfZW1iZWRkaW5nX2J0biA9IHtcbiAgICAgICAgdGV4dDogXCJTdGFydCBlbWJlZGRpbmdcIixcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmNvbGxlY3Rpb24uaW1wb3J0KCkudGhlbigoKSA9PiB0aGlzLmVudi5tYWluLnZpZXcucmVuZGVyX25lYXJlc3QodGhpcykpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5lbnYubWFpbi5ub3RpY2VzLnNob3coJ25vIGVtYmVkZGluZyBmb3VuZCcsIGBObyBlbWJlZGRpbmdzIGZvdW5kIGZvciAke3RoaXMubmFtZX0uYCwgeyBjb25maXJtOiBzdGFydF9lbWJlZGRpbmdfYnRuIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIGlmKHRoaXMudmVjICYmIHRoaXMubWVkaWFuX2Jsb2NrX3ZlYyAmJiB0aGlzLmVudi5zbWFydF9ibG9ja3Muc21hcnRfZW1iZWQgJiYgdGhpcy5jb2xsZWN0aW9uLnNtYXJ0X2VtYmVkKXtcbiAgICAgIGNvbnN0IG5lYXJlc3RfYmxvY2tzID0gdGhpcy5lbnYuc21hcnRfYmxvY2tzLm5lYXJlc3QodGhpcy5tZWRpYW5fYmxvY2tfdmVjLCB7IGV4Y2x1ZGVfa2V5X3N0YXJ0c193aXRoOiB0aGlzLmtleSB9KTtcbiAgICAgIGNvbnN0IG5lYXJlc3Rfbm90ZXMgPSB0aGlzLmVudi5zbWFydF9ub3Rlcy5uZWFyZXN0KHRoaXMudmVjLCB7IGV4Y2x1ZGVfa2V5X3N0YXJ0c193aXRoOiB0aGlzLmtleSB9KTtcbiAgICAgIHJlc3VsdHMgPSBuZWFyZXN0X2Jsb2Nrc1xuICAgICAgICAubWFwKGJsb2NrID0+IHtcbiAgICAgICAgICBjb25zdCBub3RlID0gbmVhcmVzdF9ub3Rlcy5maW5kKG5vdGUgPT4gbm90ZS5rZXkgPT09IGJsb2NrLm5vdGVfa2V5KTtcbiAgICAgICAgICBpZighbm90ZSkgYmxvY2suc2NvcmUgPSBibG9jay5zaW07XG4gICAgICAgICAgZWxzZSBibG9jay5zY29yZSA9IChibG9jay5zaW0gKyBub3RlLnNpbSkgLyAyO1xuICAgICAgICAgIHJldHVybiBibG9jaztcbiAgICAgICAgfSlcbiAgICAgICAgLy8gc29ydCBieSBpdGVtLnNjb3JlIGRlc2NlbmRpbmdcbiAgICAgICAgLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICBpZihhLnNjb3JlID09PSBiLnNjb3JlKSByZXR1cm4gMDtcbiAgICAgICAgICByZXR1cm4gKGEuc2NvcmUgPiBiLnNjb3JlKSA/IC0xIDogMTtcbiAgICAgICAgfSlcbiAgICAgIDtcbiAgICB9ZWxzZSBpZih0aGlzLm1lZGlhbl9ibG9ja192ZWMgJiYgdGhpcy5lbnYuc21hcnRfYmxvY2tzLnNtYXJ0X2VtYmVkKXtcbiAgICAgIGNvbnN0IG5lYXJlc3RfYmxvY2tzID0gdGhpcy5lbnYuc21hcnRfYmxvY2tzLm5lYXJlc3QodGhpcy5tZWRpYW5fYmxvY2tfdmVjLCB7IGV4Y2x1ZGVfa2V5X3N0YXJ0c193aXRoOiB0aGlzLmtleSB9KTtcbiAgICAgIC8vIHJlLXJhbms6IHNvcnQgYnkgYmxvY2sgbm90ZSBtZWRpYW4gYmxvY2sgdmVjIHNpbVxuICAgICAgcmVzdWx0cyA9IG5lYXJlc3RfYmxvY2tzXG4gICAgICAgIC5tYXAoYmxvY2sgPT4ge1xuICAgICAgICAgIGlmKCFibG9jay5ub3RlPy5tZWRpYW5fYmxvY2tfdmVjLmxlbmd0aCl7XG4gICAgICAgICAgICBibG9jay5zY29yZSA9IGJsb2NrLnNpbTtcbiAgICAgICAgICAgIHJldHVybiBibG9jaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYmxvY2suc2NvcmUgPSAoYmxvY2suc2ltICsgY29zX3NpbSh0aGlzLm1lZGlhbl9ibG9ja192ZWMsIGJsb2NrLm5vdGUubWVkaWFuX2Jsb2NrX3ZlYykpIC8gMjtcbiAgICAgICAgICByZXR1cm4gYmxvY2s7XG4gICAgICAgIH0pXG4gICAgICAgIC8vIHNvcnQgYnkgaXRlbS5zY29yZSBkZXNjZW5kaW5nXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgaWYoYS5zY29yZSA9PT0gYi5zY29yZSkgcmV0dXJuIDA7XG4gICAgICAgICAgcmV0dXJuIChhLnNjb3JlID4gYi5zY29yZSkgPyAtMSA6IDE7XG4gICAgICAgIH0pXG4gICAgICA7XG4gICAgfWVsc2UgaWYodGhpcy52ZWMgJiYgdGhpcy5jb2xsZWN0aW9uLnNtYXJ0X2VtYmVkKXtcbiAgICAgIGNvbnN0IG5lYXJlc3Rfbm90ZXMgPSB0aGlzLmVudi5zbWFydF9ub3Rlcy5uZWFyZXN0KHRoaXMudmVjLCB7IGV4Y2x1ZGVfa2V5X3N0YXJ0c193aXRoOiB0aGlzLmtleSB9KTtcbiAgICAgIHJlc3VsdHMgPSBuZWFyZXN0X25vdGVzXG4gICAgICAgIC5tYXAobm90ZSA9PiB7XG4gICAgICAgICAgbm90ZS5zY29yZSA9IG5vdGUuc2ltO1xuICAgICAgICAgIHJldHVybiBub3RlO1xuICAgICAgICB9KVxuICAgICAgICAvLyBzb3J0IGJ5IGl0ZW0uc2NvcmUgZGVzY2VuZGluZ1xuICAgICAgICAuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgIGlmKGEuc2NvcmUgPT09IGIuc2NvcmUpIHJldHVybiAwO1xuICAgICAgICAgIHJldHVybiAoYS5zY29yZSA+IGIuc2NvcmUpID8gLTEgOiAxO1xuICAgICAgICB9KVxuICAgICAgO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuICBvcGVuKCkgeyB0aGlzLmVudi5tYWluLm9wZW5fbm90ZSh0aGlzLmRhdGEucGF0aCk7IH1cbiAgZ2V0X2Jsb2NrX2J5X2xpbmUobGluZSkgeyByZXR1cm4gdGhpcy5ibG9ja3MuZmluZChibG9jayA9PiBibG9jay5kYXRhLmxpbmVzWzBdIDw9IGxpbmUgJiYgYmxvY2suZGF0YS5saW5lc1sxXSA+PSBsaW5lKTsgfVxuICBnZXQgYmxvY2tfdmVjcygpIHsgcmV0dXJuIHRoaXMuYmxvY2tzLm1hcChibG9jayA9PiBibG9jay5kYXRhLmVtYmVkZGluZy52ZWMpLmZpbHRlcih2ZWMgPT4gdmVjKTsgfSAvLyBmaWx0ZXIgb3V0IGJsb2NrcyB3aXRob3V0IHZlY1xuICBnZXQgYmxvY2tzKCkgeyByZXR1cm4gT2JqZWN0LmtleXModGhpcy5sYXN0X2hpc3RvcnkuYmxvY2tzKS5tYXAoYmxvY2tfa2V5ID0+IHRoaXMuZW52LnNtYXJ0X2Jsb2Nrcy5nZXQoYmxvY2tfa2V5KSkuZmlsdGVyKGJsb2NrID0+IGJsb2NrKTsgfSAvLyBmaWx0ZXIgb3V0IGJsb2NrcyB0aGF0IGRvbid0IGV4aXN0XG4gIGdldCBlbWJlZF9pbnB1dCgpIHsgcmV0dXJuIHRoaXMuX2VtYmVkX2lucHV0ID8gdGhpcy5fZW1iZWRfaW5wdXQgOiB0aGlzLmdldF9lbWJlZF9pbnB1dCgpOyB9XG4gIGdldCBtZXRhX2NoYW5nZWQoKSB7XG4gICAgaWYoIXRoaXMubGFzdF9oaXN0b3J5KSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gKHRoaXMubGFzdF9oaXN0b3J5Lm10aW1lICE9PSB0aGlzLnRfZmlsZS5zdGF0Lm10aW1lKSAmJiAodGhpcy5sYXN0X2hpc3Rvcnkuc2l6ZSAhPT0gdGhpcy50X2ZpbGUuc3RhdC5zaXplKTtcbiAgfVxuICBnZXQgaXNfY2FudmFzKCkgeyByZXR1cm4gdGhpcy5kYXRhLnBhdGguZW5kc1dpdGgoXCJjYW52YXNcIik7IH1cbiAgZ2V0IGlzX2V4Y2FsaWRyYXcoKSB7IHJldHVybiB0aGlzLmRhdGEucGF0aC5lbmRzV2l0aChcImV4Y2FsaWRyYXcubWRcIik7IH1cbiAgZ2V0IGlzX2dvbmUoKSB7IHJldHVybiB0aGlzLnRfZmlsZSA9PT0gbnVsbDsgfVxuICBnZXQgbGFzdF9oaXN0b3J5KCkgeyByZXR1cm4gdGhpcy5kYXRhLmhpc3RvcnkubGVuZ3RoID8gdGhpcy5kYXRhLmhpc3RvcnlbdGhpcy5kYXRhLmhpc3RvcnkubGVuZ3RoIC0gMV0gOiBudWxsOyB9XG4gIGdldCBtZWFuX2Jsb2NrX3ZlYygpIHsgcmV0dXJuIHRoaXMuX21lYW5fYmxvY2tfdmVjID8gdGhpcy5fbWVhbl9ibG9ja192ZWMgOiB0aGlzLl9tZWFuX2Jsb2NrX3ZlYyA9IHRoaXMuYmxvY2tfdmVjcy5yZWR1Y2UoKGFjYywgdmVjKSA9PiBhY2MubWFwKCh2YWwsIGkpID0+IHZhbCArIHZlY1tpXSksIEFycmF5KDM4NCkuZmlsbCgwKSkubWFwKHZhbCA9PiB2YWwgLyB0aGlzLmJsb2NrX3ZlY3MubGVuZ3RoKTsgfVxuICBnZXQgbWVkaWFuX2Jsb2NrX3ZlYygpIHsgcmV0dXJuIHRoaXMuX21lZGlhbl9ibG9ja192ZWMgPyB0aGlzLl9tZWRpYW5fYmxvY2tfdmVjIDogdGhpcy5fbWVkaWFuX2Jsb2NrX3ZlYyA9IHRoaXMuYmxvY2tfdmVjc1swXT8ubWFwKCh2YWwsIGkpID0+IHRoaXMuYmxvY2tfdmVjcy5tYXAodmVjID0+IHZlY1tpXSkuc29ydCgpW01hdGguZmxvb3IodGhpcy5ibG9ja192ZWNzLmxlbmd0aCAvIDIpXSk7IH1cbiAgZ2V0IG5vdGVfbmFtZSgpIHsgcmV0dXJuIHRoaXMucGF0aC5zcGxpdChcIi9cIikucG9wKCkucmVwbGFjZShcIi5tZFwiLCBcIlwiKTsgfVxuICBnZXQgdF9maWxlKCkgeyByZXR1cm4gdGhpcy5lbnYuZ2V0X3RmaWxlKHRoaXMuZGF0YS5wYXRoKTsgfVxufVxuY2xhc3MgU21hcnRCbG9ja3MgZXh0ZW5kcyBTbWFydEVudGl0aWVzIHtcbiAgYXN5bmMgaW1wb3J0KG5vdGUpIHtcbiAgICB0cnl7XG4gICAgICBjb25zdCBub3RlX3BhdGggPSBub3RlLmRhdGEucGF0aDtcbiAgICAgIGNvbnN0IG5vdGVfY29udGVudCA9IGF3YWl0IG5vdGUuZ2V0X2NvbnRlbnQoKTtcbiAgICAgIGNvbnN0IHsgYmxvY2tzIH0gPSB0aGlzLmVudi5zbWFydF9tYXJrZG93bi5wYXJzZSh7IGNvbnRlbnQ6IG5vdGVfY29udGVudCwgZmlsZV9wYXRoOiBub3RlX3BhdGggfSk7XG4gICAgICBibG9ja3MuZm9yRWFjaChibG9jayA9PiB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLmNyZWF0ZV9vcl91cGRhdGUoYmxvY2spO1xuICAgICAgICBub3RlLmxhc3RfaGlzdG9yeS5ibG9ja3NbaXRlbS5rZXldID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH1jYXRjaChlKXtcbiAgICAgIGNvbnNvbGUubG9nKFwiZXJyb3IgcGFyc2luZyBibG9ja3MgZm9yIG5vdGU6IFwiLCBub3RlLmtleSk7XG4gICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcHJ1bmUob3ZlcnJpZGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IHJlbW92ZSA9IFtdO1xuICAgIGNvbnN0IHRvdGFsX2l0ZW1zX3dfdmVjID0gdGhpcy5lbWJlZGRlZF9pdGVtcy5sZW5ndGg7XG4gICAgLy8gY29uc29sZS5sb2coXCJ0b3RhbF9pdGVtc193X3ZlYzogXCIsIHRvdGFsX2l0ZW1zX3dfdmVjKTtcbiAgICBpZighdG90YWxfaXRlbXNfd192ZWMpe1xuICAgICAgLy8gRE9FUyBOT1QgY2xlYXIgbGlrZSBpbiBub3Rlc1xuICAgICAgcmV0dXJuOyAvLyBza2lwIHJlc3QgaWYgbm8gaXRlbXMgd2l0aCB2ZWNcbiAgICB9XG4gICAgZm9yKGNvbnN0IFtrZXksIGJsb2NrXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLml0ZW1zKSkge1xuICAgICAgaWYoYmxvY2suaXNfZ29uZSkgcmVtb3ZlLnB1c2goa2V5KTsgLy8gcmVtb3ZlIGlmIGV4cGlyZWRcbiAgICB9XG4gICAgY29uc3QgcmVtb3ZlX3JhdGlvID0gcmVtb3ZlLmxlbmd0aCAvIHRvdGFsX2l0ZW1zX3dfdmVjO1xuICAgIGlmKChvdmVycmlkZSAmJiAocmVtb3ZlX3JhdGlvIDwgMC41KSkgfHwgY29uZmlybShgQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIGRlbGV0ZSAke3JlbW92ZS5sZW5ndGh9ICgke01hdGguZmxvb3IocmVtb3ZlX3JhdGlvKjEwMCl9JSkgQmxvY2stbGV2ZWwgZW1iZWRkaW5ncz9gKSl7XG4gICAgICB0aGlzLmRlbGV0ZV9tYW55KHJlbW92ZSk7XG4gICAgICBpZighb3ZlcnJpZGUpIHRoaXMuTFRNLl9zYXZlKHRydWUpOyAvLyBzYXZlIGlmIG5vdCBvdmVycmlkZVxuICAgIH1cbiAgICBjb25zb2xlLmxvZyhgUHJ1bmVkICR7cmVtb3ZlLmxlbmd0aH0gU21hcnRCbG9ja3MuYCk7XG4gIH1cbn1cbmNsYXNzIFNtYXJ0QmxvY2sgZXh0ZW5kcyBTbWFydEVudGl0eSB7XG4gIHN0YXRpYyBnZXQgZGVmYXVsdHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgdGV4dDogbnVsbCxcbiAgICAgICAgLy8gaGFzaDogbnVsbCxcbiAgICAgICAgbGVuZ3RoOiAwLFxuICAgICAgfSxcbiAgICAgIF9lbWJlZF9pbnB1dDogJycsIC8vIHN0b3JlZCB0ZW1wb3JhcmlseVxuICAgIH07XG4gIH1cbiAgLy8gU21hcnRDaHVuazogdGV4dCwgbGVuZ3RoLCBwYXRoXG4gIHVwZGF0ZV9kYXRhKGRhdGEpIHtcbiAgICBpZighdGhpcy5pc19uZXcpe1xuICAgICAgLy8gbGVuZ3RoIHJldHVybmVkIGJ5IFNtYXJ0TWFya2Rvd25cbiAgICAgIGlmKHRoaXMuZGF0YS5sZW5ndGggIT09IGRhdGEubGVuZ3RoKSB0aGlzLmRhdGEuZW1iZWRkaW5nID0ge307IC8vIGNsZWFyIGVtYmVkZGluZ1xuICAgIH1cbiAgICBpZighdGhpcy5kYXRhLmVtYmVkZGluZz8udmVjKSB0aGlzLl9lbWJlZF9pbnB1dCArPSBkYXRhLnRleHQ7IC8vIHN0b3JlIHRleHQgZm9yIGVtYmVkZGluZ1xuICAgIGRlbGV0ZSBkYXRhLnRleHQ7IC8vIGNsZWFyIGRhdGEudGV4dCB0byBwcmV2ZW50IHNhdmluZyB0ZXh0XG4gICAgc3VwZXIudXBkYXRlX2RhdGEoZGF0YSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaW5pdCgpIHtcbiAgICBpZighdGhpcy5ub3RlKSByZXR1cm4gY29uc29sZS5sb2coe1wibm8gbm90ZSBmb3IgYmxvY2tcIjogdGhpcy5kYXRhfSk7XG4gICAgaWYoQXJyYXkuaXNBcnJheSh0aGlzLm5vdGUubGFzdF9oaXN0b3J5LmJsb2NrcykpIHRoaXMubm90ZS5sYXN0X2hpc3RvcnkuYmxvY2tzID0ge307IC8vIGNvbnZlcnQgdG8gb2JqZWN0XG4gICAgdGhpcy5ub3RlLmxhc3RfaGlzdG9yeS5ibG9ja3NbdGhpcy5rZXldID0gdHJ1ZTsgLy8gYWRkIGJsb2NrIGtleSB0byBub3RlIGhpc3RvcnkgZW50cnlcbiAgfVxuICBhc3luYyBnZXRfY29udGVudCgpIHtcbiAgICBjb25zdCBub3RlX2NvbnRlbnQgPSBhd2FpdCB0aGlzLm5vdGU/LmdldF9jb250ZW50KCk7XG4gICAgaWYoIW5vdGVfY29udGVudCkgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgYmxvY2tfY29udGVudCA9IHRoaXMuZW52LnNtYXJ0X21hcmtkb3duLmdldF9ibG9ja19mcm9tX3BhdGgodGhpcy5kYXRhLnBhdGgsIG5vdGVfY29udGVudCk7XG4gICAgcmV0dXJuIGJsb2NrX2NvbnRlbnQ7XG4gIH1cbiAgYXN5bmMgZ2V0X2VtYmVkX2lucHV0KCkge1xuICAgIGlmKHR5cGVvZiB0aGlzLl9lbWJlZF9pbnB1dCA9PT0gJ3N0cmluZycgJiYgdGhpcy5fZW1iZWRfaW5wdXQubGVuZ3RoKSByZXR1cm4gdGhpcy5fZW1iZWRfaW5wdXQ7IC8vIHJldHVybiBjYWNoZWQgKHRlbXBvcmFyeSkgaW5wdXRcbiAgICB0aGlzLl9lbWJlZF9pbnB1dCA9IHRoaXMuYnJlYWRjcnVtYnMgKyBcIlxcblwiICsgKGF3YWl0IHRoaXMuZ2V0X2NvbnRlbnQoKSk7XG4gICAgcmV0dXJuIHRoaXMuX2VtYmVkX2lucHV0O1xuICB9XG4gIGFzeW5jIGdldF9uZXh0X2tfc2hvdChpKSB7XG4gICAgaWYoIXRoaXMubmV4dF9ibG9jaykgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgY3VycmVudCA9IGF3YWl0IHRoaXMuZ2V0X2NvbnRlbnQoKTtcbiAgICBjb25zdCBuZXh0ID0gYXdhaXQgdGhpcy5uZXh0X2Jsb2NrLmdldF9jb250ZW50KCk7XG4gICAgcmV0dXJuIGAtLS1CRUdJTiBDVVJSRU5UICR7aX0tLS1cXG4ke2N1cnJlbnR9XFxuLS0tRU5EIENVUlJFTlQgJHtpfS0tLVxcbi0tLUJFR0lOIE5FWFQgJHtpfS0tLVxcbiR7bmV4dH1cXG4tLS1FTkQgTkVYVCAke2l9LS0tXFxuYDtcbiAgfVxuICBmaW5kX2Nvbm5lY3Rpb25zKCkge1xuICAgIGlmKCF0aGlzLnZlYykgcmV0dXJuIFtdO1xuICAgIHJldHVybiB0aGlzLmVudi5zbWFydF9ibG9ja3MubmVhcmVzdCh0aGlzLnZlYywgeyBleGNsdWRlX2tleV9zdGFydHNfd2l0aDogdGhpcy5ub3RlLmtleSB9KTtcbiAgfVxuICBnZXQgYnJlYWRjcnVtYnMoKSB7IHJldHVybiB0aGlzLmRhdGEucGF0aC5zcGxpdChcIi9cIikuam9pbihcIiA+IFwiKS5zcGxpdChcIiNcIikuam9pbihcIiA+IFwiKS5yZXBsYWNlKFwiLm1kXCIsIFwiXCIpOyB9XG4gIGdldCBlbWJlZF9pbnB1dCgpIHsgcmV0dXJuIHRoaXMuX2VtYmVkX2lucHV0ID8gdGhpcy5fZW1iZWRfaW5wdXQgOiB0aGlzLmdldF9lbWJlZF9pbnB1dCgpOyB9XG4gIGdldCBsaW5lcygpIHsgcmV0dXJuIHsgc3RhcnQ6IHRoaXMuZGF0YS5saW5lc1swXSwgZW5kOiB0aGlzLmRhdGEubGluZXNbMV0gfSB9O1xuICBnZXQgZm9sZGVyKCkgeyByZXR1cm4gdGhpcy5kYXRhLnBhdGguc3BsaXQoXCIvXCIpLnNsaWNlKDAsIC0xKS5qb2luKFwiL1wiKTsgfVxuICBnZXQgaXNfYmxvY2soKSB7IHRoaXMuZGF0YS5wYXRoLmluY2x1ZGVzKFwiI1wiKTsgfVxuICBnZXQgaXNfZ29uZSgpIHtcbiAgICBpZih0aGlzLmVudi5zbWFydF9ub3Rlcy51bmVtYmVkZGVkX2l0ZW1zLmxlbmd0aCkgcmV0dXJuIGZhbHNlOyAvLyBub3RlIG5vdCBnb25lIGlmIGFueSBub3RlcyBhcmUgdW5lbWJlZGRlZCAocHJldmVudCBlcnJvbmVvdXMgZGVsZXRlKVxuICAgIGlmKCF0aGlzLm5vdGUpIHJldHVybiB0cnVlO1xuICAgIGlmKHRoaXMubm90ZS5pc19nb25lKSByZXR1cm4gdHJ1ZTtcbiAgICBpZighdGhpcy5ub3RlLmxhc3RfaGlzdG9yeS5ibG9ja3NbdGhpcy5rZXldKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gdXNlIHRleHQgbGVuZ3RoIHRvIGRldGVjdCBjaGFuZ2VzXG4gIGdldCBuYW1lKCkgeyByZXR1cm4gKCF0aGlzLmVudi5tYWluLnNldHRpbmdzLnNob3dfZnVsbF9wYXRoID8gdGhpcy5kYXRhLnBhdGguc3BsaXQoXCIvXCIpLnBvcCgpIDogdGhpcy5kYXRhLnBhdGguc3BsaXQoXCIvXCIpLmpvaW4oXCIgPiBcIikpLnNwbGl0KFwiI1wiKS5qb2luKFwiID4gXCIpLnJlcGxhY2UoXCIubWRcIiwgXCJcIik7IH1cbiAgLy8gdXNlcyBkYXRhLmxpbmVzIHRvIGdldCBuZXh0IGJsb2NrXG4gIGdldCBuZXh0X2Jsb2NrKCkge1xuICAgIGlmKCF0aGlzLmRhdGEubGluZXMpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IG5leHRfbGluZSA9IHRoaXMuZGF0YS5saW5lc1sxXSArIDE7XG4gICAgcmV0dXJuIHRoaXMubm90ZS5ibG9ja3M/LmZpbmQoYmxvY2sgPT4gbmV4dF9saW5lID09PSBibG9jay5kYXRhPy5saW5lcz8uWzBdKTsgXG4gIH1cbiAgZ2V0IG5vdGUoKSB7IHJldHVybiB0aGlzLmVudi5zbWFydF9ub3Rlcy5nZXQodGhpcy5ub3RlX2tleSk7IH1cbiAgZ2V0IG5vdGVfa2V5KCkgeyByZXR1cm4gdGhpcy5kYXRhLnBhdGguc3BsaXQoXCIjXCIpWzBdOyB9XG4gIGdldCBub3RlX25hbWUoKSB7IHJldHVybiB0aGlzLm5vdGVfa2V5LnNwbGl0KFwiL1wiKS5wb3AoKS5yZXBsYWNlKFwiLm1kXCIsIFwiXCIpOyB9XG4gIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IChERVBSRUNBVEVEKVxuICBnZXQgbGluaygpIHsgcmV0dXJuIHRoaXMuZGF0YS5wYXRoOyB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZV9oYXNoKHRleHQpIHtcbiAgY29uc3QgbXNnVWludDggPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodGV4dC50cmltKCkpOyAvLyBlbmNvZGUgYXMgKHV0Zi04KSBVaW50OEFycmF5XG4gIGNvbnN0IGhhc2hCdWZmZXIgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmRpZ2VzdCgnU0hBLTI1NicsIG1zZ1VpbnQ4KTsgLy8gaGFzaCB0aGUgbWVzc2FnZVxuICBjb25zdCBoYXNoQXJyYXkgPSBBcnJheS5mcm9tKG5ldyBVaW50OEFycmF5KGhhc2hCdWZmZXIpKTsgLy8gY29udmVydCBidWZmZXIgdG8gYnl0ZSBhcnJheVxuICBjb25zdCBoYXNoSGV4ID0gaGFzaEFycmF5Lm1hcChiID0+IGIudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpLmpvaW4oJycpOyAvLyBjb252ZXJ0IGJ5dGVzIHRvIGhleCBzdHJpbmdcbiAgcmV0dXJuIGhhc2hIZXg7XG59XG5cbmV4cG9ydHMuU21hcnRCbG9jayA9IFNtYXJ0QmxvY2s7XG5leHBvcnRzLlNtYXJ0QmxvY2tzID0gU21hcnRCbG9ja3M7XG5leHBvcnRzLlNtYXJ0Tm90ZSA9IFNtYXJ0Tm90ZTtcbmV4cG9ydHMuU21hcnROb3RlcyA9IFNtYXJ0Tm90ZXM7IiwgImFzeW5jIGZ1bmN0aW9uIHJlbmRlcl9kYXRhdmlld19jb2RlYmxvY2tzKGZpbGVfY29udGVudCwgbm90ZV9wYXRoLCBvcHRzID0ge30pIHtcbiAgb3B0cyA9IHtcbiAgICBjaGFyX2xpbWl0OiBudWxsLFxuICAgIC4uLm9wdHNcbiAgfTtcbiAgY29uc3QgZGF0YXZpZXdfYXBpID0gd2luZG93Py5bXCJEYXRhdmlld0FQSVwiXTsgLy8gdXNlIHdpbmRvdyB0byBnZXQgZGF0YXZpZXcgYXBpXG4gIGlmICghZGF0YXZpZXdfYXBpKSByZXR1cm4gZmlsZV9jb250ZW50OyAvLyBza2lwIGlmIGRhdGF2aWV3IGFwaSBub3QgZm91bmRcbiAgY29uc3QgZGF0YXZpZXdfY29kZV9ibG9ja3MgPSBmaWxlX2NvbnRlbnQubWF0Y2goL2BgYGRhdGF2aWV3KC4qPylgYGAvZ3MpO1xuICBpZighZGF0YXZpZXdfY29kZV9ibG9ja3MpIHJldHVybiBmaWxlX2NvbnRlbnQ7IC8vIHNraXAgaWYgbm8gZGF0YXZpZXcgY29kZSBibG9ja3MgZm91bmRcbiAgLy8gZm9yIGVhY2ggZGF0YXZpZXcgY29kZSBibG9ja1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGF2aWV3X2NvZGVfYmxvY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gaWYgb3B0cyBjaGFyX2xpbWl0IGlzIGxlc3MgdGhhbiBpbmRleE9mIGRhdGF2aWV3IGNvZGUgYmxvY2ssIGJyZWFrXG4gICAgaWYgKG9wdHMuY2hhcl9saW1pdCAmJiBvcHRzLmNoYXJfbGltaXQgPCBmaWxlX2NvbnRlbnQuaW5kZXhPZihkYXRhdmlld19jb2RlX2Jsb2Nrc1tpXSkpIGJyZWFrO1xuICAgIC8vIGdldCBkYXRhdmlldyBjb2RlIGJsb2NrXG4gICAgY29uc3QgZGF0YXZpZXdfY29kZV9ibG9jayA9IGRhdGF2aWV3X2NvZGVfYmxvY2tzW2ldO1xuICAgIC8vIGdldCBjb250ZW50IG9mIGRhdGF2aWV3IGNvZGUgYmxvY2tcbiAgICBjb25zdCBkYXRhdmlld19jb2RlX2Jsb2NrX2NvbnRlbnQgPSBkYXRhdmlld19jb2RlX2Jsb2NrLnJlcGxhY2UoXCJgYGBkYXRhdmlld1wiLCBcIlwiKS5yZXBsYWNlKFwiYGBgXCIsIFwiXCIpO1xuICAgIC8vIGdldCBkYXRhdmlldyBxdWVyeSByZXN1bHRcbiAgICBjb25zdCBkYXRhdmlld19xdWVyeV9yZXN1bHQgPSBhd2FpdCBkYXRhdmlld19hcGkucXVlcnlNYXJrZG93bihkYXRhdmlld19jb2RlX2Jsb2NrX2NvbnRlbnQsIG5vdGVfcGF0aCwgbnVsbCk7XG4gICAgLy8gaWYgcXVlcnkgcmVzdWx0IGlzIHN1Y2Nlc3NmdWwsIHJlcGxhY2UgZGF0YXZpZXcgY29kZSBibG9jayB3aXRoIHF1ZXJ5IHJlc3VsdFxuICAgIGlmIChkYXRhdmlld19xdWVyeV9yZXN1bHQuc3VjY2Vzc2Z1bCkge1xuICAgICAgZmlsZV9jb250ZW50ID0gZmlsZV9jb250ZW50LnJlcGxhY2UoZGF0YXZpZXdfY29kZV9ibG9jaywgZGF0YXZpZXdfcXVlcnlfcmVzdWx0LnZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZpbGVfY29udGVudDtcbn1cbmV4cG9ydHMucmVuZGVyX2RhdGF2aWV3X2NvZGVibG9ja3MgPSByZW5kZXJfZGF0YXZpZXdfY29kZWJsb2NrczsiLCAiY29uc3Qge1xuICBTbWFydEJsb2NrOiBCYXNlU21hcnRCbG9jayxcbiAgU21hcnRCbG9ja3MsXG4gIFNtYXJ0Tm90ZTogQmFzZVNtYXJ0Tm90ZSxcbiAgU21hcnROb3Rlcyxcbn0gPSByZXF1aXJlKCdzbWFydC1lbnRpdGllcycpO1xuY29uc3QgeyByZW5kZXJfZGF0YXZpZXdfY29kZWJsb2NrcyB9ID0gcmVxdWlyZSgnLi9yZW5kZXJfZGF0YXZpZXdfY29kZWJsb2NrcycpO1xuY2xhc3MgU21hcnROb3RlIGV4dGVuZHMgQmFzZVNtYXJ0Tm90ZSB7XG4gIGFzeW5jIGdldF9jb250ZW50KCkgeyByZXR1cm4gYXdhaXQgdGhpcy5icmFpbi5jYWNoZWRfcmVhZCh0aGlzLmRhdGEucGF0aCk7IH1cbiAgYXN5bmMgZ2V0X2FzX2NvbnRleHQocGFyYW1zID0ge30pIHtcbiAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgcmVuZGVyX2RhdGF2aWV3X2NvZGVibG9ja3MoYXdhaXQgdGhpcy5nZXRfY29udGVudCgpLCB0aGlzLmRhdGEucGF0aCk7XG4gICAgcmV0dXJuIGAtLS1CRUdJTiBOT1RFJHtwYXJhbXMuaSA/IFwiIFwiICsgcGFyYW1zLmkgOiBcIlwifSBbWyR7dGhpcy5wYXRofV1dLS0tXFxuJHtjb250ZW50fVxcbi0tLUVORCBOT1RFJHtwYXJhbXMuaSA/IFwiIFwiICsgcGFyYW1zLmkgOiBcIlwifS0tLWA7XG4gIH1cbn1cbmNsYXNzIFNtYXJ0QmxvY2sgZXh0ZW5kcyBCYXNlU21hcnRCbG9jayB7XG4gIGFzeW5jIGdldF9hc19jb250ZXh0KHBhcmFtcyA9IHt9KSB7XG4gICAgY29uc3QgY29udGVudCA9IGF3YWl0IHJlbmRlcl9kYXRhdmlld19jb2RlYmxvY2tzKGF3YWl0IHRoaXMuZ2V0X2NvbnRlbnQoKSwgdGhpcy5kYXRhLnBhdGgpO1xuICAgIHJldHVybiBgLS0tQkVHSU4gTk9URSR7cGFyYW1zLmkgPyBcIiBcIiArIHBhcmFtcy5pIDogXCJcIn0gW1ske3RoaXMucGF0aH1dXS0tLVxcbiR7Y29udGVudH1cXG4tLS1FTkQgTk9URSR7cGFyYW1zLmkgPyBcIiBcIiArIHBhcmFtcy5pIDogXCJcIn0tLS1gO1xuICB9XG59XG5leHBvcnRzLlNtYXJ0Tm90ZXMgPSBTbWFydE5vdGVzO1xuZXhwb3J0cy5TbWFydE5vdGUgPSBTbWFydE5vdGU7XG5leHBvcnRzLlNtYXJ0QmxvY2tzID0gU21hcnRCbG9ja3M7XG5leHBvcnRzLlNtYXJ0QmxvY2sgPSBTbWFydEJsb2NrO1xuXG4iLCAiY2xhc3MgU21hcnRTb2NrZXQge1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBTbWFydFNvY2tldC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBvcnQgVGhlIHBvcnQgbnVtYmVyIHRvIGNvbm5lY3QgdG8uXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihwb3J0KSB7XG4gICAgdGhpcy5wb3J0ID0gcG9ydDtcbiAgICB0aGlzLndzX3JldHJpZXMgPSAwO1xuICAgIC8vIEluaXRpYWxpemUgd3MgYXMgbnVsbCB0byBpbmRpY2F0ZSBubyBhY3RpdmUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaW5pdGlhbGx5XG4gICAgdGhpcy53cyA9IG51bGw7XG4gICAgdGhpcy5yZXRyeSA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYXRlcyB0aGUgY29ubmVjdGlvbiBwcm9jZXNzLCB3aXRoIG9wdGlvbmFsIHJldHJ5IGxvZ2ljLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXRyeT1mYWxzZV0gV2hldGhlciB0byBhdHRlbXB0IGEgcmVjb25uZWN0aW9uLlxuICAgKi9cbiAgYXN5bmMgY29ubmVjdChyZXRyeSA9IGZhbHNlKSB7XG4gICAgdGhpcy5yZXRyeSA9IHJldHJ5O1xuICAgIGlmICghdGhpcy5jYW5fYXR0ZW1wdF9jb25uZWN0aW9uKHJldHJ5KSkgcmV0dXJuO1xuXG4gICAgaWYocmV0cnkpIGF3YWl0IHRoaXMuY2FsY3VsYXRlX2JhY2tvZmYocmV0cnkpO1xuICAgIGlmKHR5cGVvZiB0aGlzLmlzX3NlcnZlcl9ydW5uaW5nID09PSAnZnVuY3Rpb24nKXtcbiAgICAgIGNvbnN0IGlzX3J1bm5pbmcgPSBhd2FpdCB0aGlzLmlzX3NlcnZlcl9ydW5uaW5nKCk7XG4gICAgICBpZighaXNfcnVubmluZyl7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiU21hcnQgQ29ubmVjdCBpcyBub3QgcnVubmluZywgd2lsbCB0cnkgdG8gY29ubmVjdCBhZ2FpbiBsYXRlclwiKTtcbiAgICAgICAgdGhpcy5jb25uZWN0KHRydWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVfd2Vic29ja2V0KCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBjb25zb2xlLmVycm9yKGBXZWJTb2NrZXQgY29ubmVjdGlvbiBlcnJvciBvbiByZXRyeSAke3RoaXMud3NfcmV0cmllc306ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICBpZiAocmV0cnkgJiYgKCh0aGlzLndzX3JldHJpZXMgPCAxMCkgfHwgKHR5cGVvZiB0aGlzLmlzX3NlcnZlcl9ydW5uaW5nID09PSAnZnVuY3Rpb24nKSkpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5oYW5kbGVfY29ubmVjdGlvbl9lcnJvcih0cnVlLCBlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vbl9mYWlsX3RvX3JlY29ubmVjdCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBuZXcgY29ubmVjdGlvbiBhdHRlbXB0IGNhbiBiZSBtYWRlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJldHJ5IEluZGljYXRlcyBpZiB0aGlzIGlzIGEgcmV0cnkgYXR0ZW1wdC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgYSBjb25uZWN0aW9uIGF0dGVtcHQgY2FuIGJlIG1hZGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGNhbl9hdHRlbXB0X2Nvbm5lY3Rpb24ocmV0cnkpIHtcbiAgICByZXRyeSA9IHJldHJ5IHx8IHRoaXMucmV0cnk7XG4gICAgaWYgKHRoaXMud3MgJiYgdGhpcy53cy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgY29uc29sZS5sb2coXCJXZWJTb2NrZXQgaXMgYWxyZWFkeSBjb25uZWN0ZWQuIEFib3J0aW5nIG5ldyBjb25uZWN0aW9uIGF0dGVtcHQuXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAocmV0cnkgJiYgdGhpcy53c19yZXRyaWVzID49IDEwKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHJlY29ubmVjdCBhZnRlciAxMCBhdHRlbXB0c1wiKTtcbiAgICAgIHRoaXMub25fZmFpbF90b19yZWNvbm5lY3QoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyBhbmQgYXBwbGllcyBhIGJhY2tvZmYgZGVsYXkgZm9yIHJlY29ubmVjdGlvbiBhdHRlbXB0cy5cbiAgICogQHBhcmFtIHtib29sZWFufSByZXRyeSBJbmRpY2F0ZXMgaWYgdGhpcyBpcyBhIHJldHJ5IGF0dGVtcHQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyBhZnRlciB0aGUgYmFja29mZiBkZWxheS5cbiAgICovXG4gIGNhbGN1bGF0ZV9iYWNrb2ZmKHJldHJ5KSB7XG4gICAgaWYgKHJldHJ5IHx8IHRoaXMucmV0cnkpIHtcbiAgICAgIHRoaXMud3NfcmV0cmllcyArPSAxO1xuICAgICAgY29uc3QgYmFja29mZl90aW1lID0gTWF0aC5taW4oMTAwMCAqIE1hdGgucG93KDIsIHRoaXMud3NfcmV0cmllcyksIDYwMDAwKTtcbiAgICAgIGNvbnNvbGUubG9nKGBBdHRlbXB0aW5nIHRvIHJlY29ubmVjdCBpbiAke2JhY2tvZmZfdGltZSAvIDEwMDB9IHNlY29uZHMuLi5gKTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgYmFja29mZl90aW1lKSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBXZWJTb2NrZXQgaXMgc3VjY2Vzc2Z1bGx5IG9wZW5lZC5cbiAgICovXG4gIGFzeW5jIGluaXRpYWxpemVfd2Vic29ja2V0KCkge1xuICAgIC8vIENsZWFuIHVwIGFueSBleGlzdGluZyBXZWJTb2NrZXQgY29ubmVjdGlvbiBiZWZvcmUgaW5pdGlhbGl6aW5nIGEgbmV3IG9uZVxuICAgIHRoaXMuY2xlYW51cF93ZWJzb2NrZXQoKTtcblxuICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHRpbWVvdXRfaWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLndzIHx8IHRoaXMud3MucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgICAgICB0aGlzLndzPy5jbG9zZSgpO1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1dlYlNvY2tldCBmYWlsZWQgdG8gY29ubmVjdCcpKTtcbiAgICAgICAgfVxuICAgICAgfSwgMTAwMDApO1xuICBcbiAgICAgIHRoaXMud3MgPSBuZXcgV2ViU29ja2V0KGB3czovL2xvY2FsaG9zdDoke3RoaXMucG9ydH1gKTtcbiAgICAgIHRoaXMud3Mub25vcGVuID0gKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dF9pZCk7XG4gICAgICAgIHRoaXMub25fb3BlbigpO1xuICAgICAgICB0aGlzLndzX3JldHJpZXMgPSAwOyAvLyBSZXNldCByZXRyaWVzIG9uIHN1Y2Nlc3NmdWwgY29ubmVjdGlvblxuICAgICAgICB0aGlzLnJldHJ5ID0gdHJ1ZTsgLy8gc2V0IHJldHJ5IHNpbmNlIHdlIGtub3cgY29ubmVjdGlvbiBpcyBhdmFpbGFibGVcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfTtcbiAgICAgIHRoaXMud3Mub25jbG9zZSA9IChldmVudCkgPT4ge1xuICAgICAgICB0aGlzLmNsZWFudXBfd2Vic29ja2V0KCk7IC8vIEVuc3VyZSBjbGVhbnVwIHdoZW4gdGhlIFdlYlNvY2tldCBpcyBjbG9zZWRcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignV2ViU29ja2V0IGNsb3NlZCcpKTtcbiAgICAgICAgdGhpcy5vbl9jbG9zZSgpO1xuICAgICAgfTtcbiAgICAgIHRoaXMud3Mub25lcnJvciA9IChlcnIpID0+IHtcbiAgICAgICAgdGhpcy5jbGVhbnVwX3dlYnNvY2tldCgpOyAvLyBFbnN1cmUgY2xlYW51cCBvbiBlcnJvclxuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgdGhpcy5vbl9lcnJvcihlcnIpO1xuICAgICAgfTtcbiAgICAgIHRoaXMud3Mub25tZXNzYWdlID0gdGhpcy5oYW5kbGVfbWVzc2FnZS5iaW5kKHRoaXMpO1xuICAgIH0pO1xuICB9XG5cbiAgY2xlYW51cF93ZWJzb2NrZXQoKSB7XG4gICAgaWYgKHRoaXMud3MpIHtcbiAgICAgIC8vIFJlbW92ZSBhbGwgZXZlbnQgbGlzdGVuZXJzIHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzXG4gICAgICB0aGlzLndzLm9ub3BlbiA9IG51bGw7XG4gICAgICB0aGlzLndzLm9uY2xvc2UgPSBudWxsO1xuICAgICAgdGhpcy53cy5vbmVycm9yID0gbnVsbDtcbiAgICAgIHRoaXMud3Mub25tZXNzYWdlID0gbnVsbDtcbiAgICAgIC8vIENsb3NlIHRoZSBXZWJTb2NrZXQgaWYgaXQncyBub3QgYWxyZWFkeSBjbG9zZWRcbiAgICAgIGlmICh0aGlzLndzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOIHx8IHRoaXMud3MucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgICAgdGhpcy53cy5jbG9zZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy53cyA9IG51bGw7IC8vIENsZWFyIHRoZSByZWZlcmVuY2UgdG8gZmFjaWxpdGF0ZSBnYXJiYWdlIGNvbGxlY3Rpb25cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBjb25uZWN0aW9uIGVycm9ycyBhbmQgZGVjaWRlcyB3aGV0aGVyIHRvIHJldHJ5LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJldHJ5IEluZGljYXRlcyBpZiB0aGlzIGlzIGEgcmV0cnkgYXR0ZW1wdC5cbiAgICogQHBhcmFtIHtFcnJvcn0gZXJyIFRoZSBlcnJvciB0aGF0IG9jY3VycmVkIGR1cmluZyBjb25uZWN0aW9uLlxuICAgKi9cbiAgYXN5bmMgaGFuZGxlX2Nvbm5lY3Rpb25fZXJyb3IocmV0cnksIGVycikge1xuICAgIGNvbnNvbGUubG9nKFwiSGFuZGxpbmcgV2ViU29ja2V0IGNvbm5lY3Rpb24gZXJyb3Igb24gcG9ydCBcIiArIHRoaXMucG9ydCk7XG4gICAgaWYgKHJldHJ5ICYmIHRoaXMud3NfcmV0cmllcyA8IDEwKSB7XG4gICAgICBhd2FpdCB0aGlzLmNvbm5lY3QodHJ1ZSk7IC8vIFJldHJ5IHdpdGggYmFja29mZlxuICAgIH0gZWxzZSBpZiAoIXJldHJ5IHx8IHRoaXMud3NfcmV0cmllcyA+PSAxMCkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBjb25uZWN0IHRvIFdlYlNvY2tldCBhZnRlciByZXRyaWVzOlwiKTtcbiAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICB0aGlzLm9uX2ZhaWxfdG9fcmVjb25uZWN0KCk7XG4gICAgfVxuICB9XG4gIFxuXG4gIC8qKlxuICAgKiBQbGFjZWhvbGRlciBmb3IgZXJyb3IgaGFuZGxpbmcgbG9naWMuXG4gICAqIEBwYXJhbSB7RXJyb3J9IGVyciBUaGUgZXJyb3IgZW5jb3VudGVyZWQuXG4gICAqL1xuICBvbl9lcnJvcihlcnIpIHtcbiAgICAvLyBjb25zb2xlLmVycm9yKFwiV2ViU29ja2V0IGVycm9yXCIsIGVycik7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBXZWJTb2NrZXQgY2xvc3VyZSBhbmQgYXR0ZW1wdHMgcmVjb25uZWN0aW9uLlxuICAgKi9cbiAgb25fY2xvc2UoKSB7XG4gICAgY29uc29sZS5sb2coXCJEaXNjb25uZWN0ZWQgZnJvbSBXZWJTb2NrZXRcIik7XG4gIFxuICAgIC8vIE5vdywgdXNlIHRoZSBgc2hvdWxkX2F0dGVtcHRfcmVjb25uZWN0YCB0byBkZWNpZGUgd2hldGhlciB0byBpbml0aWF0ZSBhIHJlY29ubmVjdGlvbi5cbiAgICBpZih0aGlzLnJldHJ5ICYmIHRoaXMuc2hvdWxkX2F0dGVtcHRfcmVjb25uZWN0KSB7XG4gICAgICB0aGlzLmNvbm5lY3QodHJ1ZSk7IC8vIEF0dGVtcHQgdG8gcmVjb25uZWN0IHdpdGggYmFja29mZlxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlJlY29ubmVjdGlvbiBub3QgYXR0ZW1wdGVkIGR1ZSB0byBwb2xpY3kgKGludGVudGlvbmFsIGRpc2Nvbm5lY3Rpb24gb3IgcmV0cnkgbGltaXQgcmVhY2hlZCkuXCIpO1xuICAgICAgLy8gSGFuZGxlIHRoZSBjYXNlIHdoZXJlIG5vIHJlY29ubmVjdGlvbiB3aWxsIGJlIGF0dGVtcHRlZCwgc3VjaCBhcyBieSBpbmZvcm1pbmcgdGhlIHVzZXIuXG4gICAgfVxuICB9XG4gIFxuICBnZXQgc2hvdWxkX2F0dGVtcHRfcmVjb25uZWN0KCkge1xuICAgIHJldHVybiB0aGlzLndzX3JldHJpZXMgPCAxMDtcbiAgfVxuICBcblxuICAvKipcbiAgICogTG9ncyBzdWNjZXNzZnVsIFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICAgKi9cbiAgb25fb3BlbigpIHtcbiAgICBjb25zb2xlLmxvZyhgQ29ubmVjdGVkIHRvIFdlYlNvY2tldCBvbiBwb3J0ICR7dGhpcy5wb3J0fWApO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgaW5jb21pbmcgV2ViU29ja2V0IG1lc3NhZ2VzLlxuICAgKiBAcGFyYW0ge01lc3NhZ2VFdmVudH0gZXZlbnQgVGhlIG1lc3NhZ2UgZXZlbnQuXG4gICAqL1xuICBoYW5kbGVfbWVzc2FnZShldmVudCkge1xuICAgIGNvbnNvbGUubG9nKFwiTWVzc2FnZSBmcm9tIHNlcnZlclwiLCBldmVudC5kYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGZhaWx1cmUgdG8gcmVjb25uZWN0IGFmdGVyIG11bHRpcGxlIGF0dGVtcHRzLlxuICAgKi9cbiAgb25fZmFpbF90b19yZWNvbm5lY3QoKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byByZWNvbm5lY3QsIHdpbGwgbm90IHJldHJ5Li4uXCIpO1xuICB9XG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICAgKi9cbiAgdW5sb2FkKCkge1xuICAgIHRoaXMuY2xlYW51cF93ZWJzb2NrZXQoKTtcbiAgfVxufVxuZXhwb3J0cy5TbWFydFNvY2tldCA9IFNtYXJ0U29ja2V0OyIsICJjb25zdCB7IFNtYXJ0U29ja2V0IH0gPSByZXF1aXJlKFwiLi9zbWFydF9zb2NrZXRcIik7XG5cbmNsYXNzIERhdGF2aWV3U29ja2V0IGV4dGVuZHMgU21hcnRTb2NrZXQge1xuICBjb25zdHJ1Y3RvcihlbnYsIHBvcnQpIHtcbiAgICBzdXBlcihwb3J0KTtcbiAgICB0aGlzLmVudiA9IGVudjtcbiAgICB0aGlzLmJyYWluID0gdGhpcy5lbnY7IC8vIERFUFJFQ0FURURcbiAgICB0aGlzLmRhdGF2aWV3X2FwaSA9IG51bGw7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGNyZWF0ZShlbnYsIHBvcnQpIHtcbiAgICBjb25zdCBzbWFydF9zb2NrZXQgPSBuZXcgRGF0YXZpZXdTb2NrZXQoZW52LCBwb3J0KTtcbiAgICBlbnYuZHZfd3MgPSBzbWFydF9zb2NrZXQ7XG4gICAgYXdhaXQgc21hcnRfc29ja2V0LmluaXQoKTtcbiAgICByZXR1cm4gc21hcnRfc29ja2V0O1xuICB9XG4gIGFzeW5jIGluaXQoKSB7XG4gICAgYXdhaXQgdGhpcy5nZXRfZGF0YXZpZXdfYXBpKCk7XG4gICAgYXdhaXQgdGhpcy5jb25uZWN0KCk7XG4gICAgLy8gY29uc29sZS5sb2coXCJEYXRhdmlld1NvY2tldCBpbml0aWFsaXplZFwiKTtcbiAgfVxuICBhc3luYyBpc19zZXJ2ZXJfcnVubmluZygpe1xuICAgIHRyeXtcbiAgICAgIGNvbnN0IHNjX2xvY2FsID0gYXdhaXQgdGhpcy5lbnYubWFpbi5vYnNpZGlhbj8ucmVxdWVzdFVybCh7dXJsOiAnaHR0cDovL2xvY2FsaG9zdDozNzQyMS8nLCBtZXRob2Q6ICdHRVQnfSk7XG4gICAgICBjb25zb2xlLmxvZyhzY19sb2NhbCk7XG4gICAgICByZXR1cm4gc2NfbG9jYWw/LnN0YXR1cyA9PT0gMjAwO1xuICAgIH1jYXRjaChlcnIpe1xuICAgICAgLy8gY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXRfZGF0YXZpZXdfYXBpKHJldHJpZXMgPSAwKSB7XG4gICAgdGhpcy5kYXRhdmlld19hcGkgPSB3aW5kb3dbXCJEYXRhdmlld0FQSVwiXTtcbiAgICBpZiAoIXRoaXMuZGF0YXZpZXdfYXBpKSB7XG4gICAgICBpZiAocmV0cmllcyA8IDEwKSB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCByZXRyaWVzICogMTAwMCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRfZGF0YXZpZXdfYXBpKHJldHJpZXMgKyAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYnJhaW4ubWFpbi5zaG93X25vdGljZShcIkRhdGF2aWV3IEFQSSBub3QgZm91bmRcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFzeW5jIGhhbmRsZV9tZXNzYWdlKGV2ZW50KSB7XG4gICAgY29uc29sZS5sb2coXCJNZXNzYWdlIGZyb20gc2VydmVyIFwiLCBldmVudC5kYXRhKTtcbiAgICBjb25zb2xlLmxvZyh0eXBlb2YgZXZlbnQuZGF0YSk7XG4gICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCB0aGlzLmRhdGF2aWV3X2FwaS5xdWVyeU1hcmtkb3duKGRhdGEucXVlcnksIGRhdGEucmVsX3BhdGgsIG51bGwpO1xuICAgICAgY29uc29sZS5sb2cocmVzcCk7XG4gICAgICB0aGlzLndzLnNlbmQoSlNPTi5zdHJpbmdpZnkocmVzcCkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgdGhpcy53cy5zZW5kKEpTT04uc3RyaW5naWZ5KHsgc3RhdHVzOiBcImVycm9yXCIsIG1lc3NhZ2U6IGVyciB9KSk7XG4gICAgfVxuICB9XG59XG5leHBvcnRzLkRhdGF2aWV3U29ja2V0ID0gRGF0YXZpZXdTb2NrZXQ7XG4iLCAie1xuICBcImF0dHJpYnV0aW9uXCI6IFwiPGRpdiBjbGFzcz1cXFwic2MtYnJhbmRcXFwiPlxcbiAgPHN2ZyB2aWV3Qm94PVxcXCIwIDAgMTAwIDEwMFxcXCIgY2xhc3M9XFxcInN2Zy1pY29uIHNtYXJ0LWNvbm5lY3Rpb25zXFxcIj5cXG4gICAgPHBhdGggZD1cXFwiTTUwLDIwIEw4MCw0MCBMODAsNjAgTDUwLDEwMFxcXCIgc3Ryb2tlPVxcXCJjdXJyZW50Q29sb3JcXFwiIHN0cm9rZS13aWR0aD1cXFwiNFxcXCIgZmlsbD1cXFwibm9uZVxcXCI+PC9wYXRoPlxcbiAgICA8cGF0aCBkPVxcXCJNMzAsNTAgTDU1LDcwXFxcIiBzdHJva2U9XFxcImN1cnJlbnRDb2xvclxcXCIgc3Ryb2tlLXdpZHRoPVxcXCI1XFxcIiBmaWxsPVxcXCJub25lXFxcIj48L3BhdGg+XFxuICAgIDxjaXJjbGUgY3g9XFxcIjUwXFxcIiBjeT1cXFwiMjBcXFwiIHI9XFxcIjlcXFwiIGZpbGw9XFxcImN1cnJlbnRDb2xvclxcXCI+PC9jaXJjbGU+XFxuICAgIDxjaXJjbGUgY3g9XFxcIjgwXFxcIiBjeT1cXFwiNDBcXFwiIHI9XFxcIjlcXFwiIGZpbGw9XFxcImN1cnJlbnRDb2xvclxcXCI+PC9jaXJjbGU+XFxuICAgIDxjaXJjbGUgY3g9XFxcIjgwXFxcIiBjeT1cXFwiNzBcXFwiIHI9XFxcIjlcXFwiIGZpbGw9XFxcImN1cnJlbnRDb2xvclxcXCI+PC9jaXJjbGU+XFxuICAgIDxjaXJjbGUgY3g9XFxcIjUwXFxcIiBjeT1cXFwiMTAwXFxcIiByPVxcXCI5XFxcIiBmaWxsPVxcXCJjdXJyZW50Q29sb3JcXFwiPjwvY2lyY2xlPlxcbiAgICA8Y2lyY2xlIGN4PVxcXCIzMFxcXCIgY3k9XFxcIjUwXFxcIiByPVxcXCI5XFxcIiBmaWxsPVxcXCJjdXJyZW50Q29sb3JcXFwiPjwvY2lyY2xlPlxcbiAgPC9zdmc+XFxuICA8cD48YSBzdHlsZT1cXFwiZm9udC13ZWlnaHQ6IDcwMDtcXFwiIGhyZWY9XFxcImh0dHBzOi8vc21hcnRjb25uZWN0aW9ucy5hcHAvXFxcIj5TbWFydCBDb25uZWN0aW9uczwvYT48L3A+XFxuPC9kaXY+XCIsXG4gIFwic2NfY2hhbmdlXCI6IFwiPGRpdiBjbGFzcz1cXFwic2MtY2hhbmdlXFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcImFjdGlvbnNcXFwiPlxcbiAgICA8YnV0dG9uPkFjY2VwdDwvYnV0dG9uPlxcbiAgICA8YnV0dG9uPlJlamVjdDwvYnV0dG9uPlxcbiAgICA8YnV0dG9uPlNob3cgT2xkPC9idXR0b24+XFxuICAgIDxidXR0b24gc3R5bGU9XFxcImRpc3BsYXk6IG5vbmU7XFxcIj5IaWRlIE9sZDwvYnV0dG9uPlxcbiAgICA8ZGl2PlRpbWUgc2F2ZWQ6IDwlPSB0aW1lX3NhdmVkICU+PC9kaXY+XFxuICAgIDwlLSB0aGlzLmF0dHJpYnV0aW9uICU+XFxuICA8L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFxcIm9sZC1jb250ZW50XFxcIiBzdHlsZT1cXFwiZGlzcGxheTogbm9uZTtcXFwiPjwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwibmV3LWNvbnRlbnRcXFwiPjwvZGl2PlxcbjwvZGl2PlxcblxcblwiLFxuICBcInNtYXJ0X2NoYXRcIjogXCI8ZGl2IGNsYXNzPVxcXCJ3b3Jrc3BhY2UtbGVhZi1jb250ZW50XFxcIiBkYXRhLXR5cGU9XFxcInNtYXJ0LWNvbm5lY3Rpb25zLWNoYXQtdmlld1xcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJzYy1jaGF0LWNvbnRhaW5lclxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcInNjLXRvcC1iYXItY29udGFpbmVyXFxcIj5cXG4gICAgICA8aW5wdXQgY2xhc3M9XFxcInNjLWNoYXQtbmFtZS1pbnB1dFxcXCIgdHlwZT1cXFwidGV4dFxcXCIgdmFsdWU9XFxcIjwlPSBuYW1lICU+XFxcIiBwbGFjZWhvbGRlcj1cXFwiQ2hhdCBOYW1lXFxcIj5cXG4gICAgICA8YnV0dG9uIHRpdGxlPVxcXCJPcGVuIENvbnZlcnNhdGlvbiBOb3RlXFxcIj48JS0gdGhpcy5nZXRfaWNvbignZXh0ZXJuYWwtbGluaycpICU+PC9idXR0b24+XFxuICAgICAgPGJ1dHRvbiB0aXRsZT1cXFwiQ2hhdCBIaXN0b3J5XFxcIj48JS0gdGhpcy5nZXRfaWNvbignaGlzdG9yeScpICU+PC9idXR0b24+XFxuICAgICAgPGJ1dHRvbiB0aXRsZT1cXFwiU2V0dGluZ3NcXFwiPjwlLSB0aGlzLmdldF9pY29uKCdnZWFyJykgJT48L2J1dHRvbj5cXG4gICAgICA8YnV0dG9uIHRpdGxlPVxcXCJOZXcgQ2hhdFxcXCI+PCUtIHRoaXMuZ2V0X2ljb24oJ3BsdXMnKSAlPjwvYnV0dG9uPlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwic2MtY2hhdC1ib3hcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcInNjLW1lc3NhZ2UtY29udGFpbmVyXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInNjLW1lc3NhZ2UgYXNzaXN0YW50XFxcIj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwic2MtbWVzc2FnZS1jb250ZW50XFxcIj5cXG4gICAgICAgICAgICA8c3Bhbj5cXG4gICAgICAgICAgICAgIEhpIHRoZXJlLCB3ZWxjb21lIHRvIHRoZSBTbWFydCBDaGF0LiZuYnNwO0FzayBtZSBhIHF1ZXN0aW9uIGFib3V0IHlvdXIgbm90ZXMgYW5kIEknbGwgdHJ5IHRvIGFuc3dlciBpdC5cXG4gICAgICAgICAgICA8L3NwYW4+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8JS0gbWVzc2FnZXMgJT5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcInNjLWNoYXQtZm9ybVxcXCI+PHRleHRhcmVhIGNsYXNzPVxcXCJzYy1jaGF0LWlucHV0XFxcIlxcbiAgICAgICAgcGxhY2Vob2xkZXI9XFxcIlRyeSAmcXVvdDtCYXNlZCBvbiBteSBub3RlcyZxdW90OyBvciAmcXVvdDtTdW1tYXJpemUgW1t0aGlzIG5vdGVdXSZxdW90OyBvciAmcXVvdDtJbXBvcnRhbnQgdGFza3MgaW4gL2ZvbGRlci8mcXVvdDtcXFwiPjwvdGV4dGFyZWE+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwic2MtYnV0dG9uLWNvbnRhaW5lclxcXCI+XFxuICAgICAgICA8c3BhbiBpZD1cXFwic2MtYWJvcnQtYnV0dG9uXFxcIiBzdHlsZT1cXFwiZGlzcGxheTogbm9uZTtcXFwiPjwlLSB0aGlzLmdldF9pY29uKCdzcXVhcmUnKSAlPjwvc3Bhbj5cXG4gICAgICAgIDxidXR0b24gY2xhc3M9XFxcInNlbmQtYnV0dG9uXFxcIiBpZD1cXFwic2Mtc2VuZC1idXR0b25cXFwiPlNlbmQ8L2J1dHRvbj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgaWQ9XFxcInNldHRpbmdzXFxcIj48L2Rpdj5cXG4gIDwvZGl2PlxcbiAgPCUtIHRoaXMuYXR0cmlidXRpb24gJT5cXG48L2Rpdj5cIixcbiAgXCJzbWFydF9jaGF0X21zZ1wiOiBcIjxkaXYgY2xhc3M9XFxcInNjLW1lc3NhZ2UgPCU9IHJvbGUgJT5cXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwic2MtbWVzc2FnZS1jb250ZW50XFxcIiBkYXRhLWNvbnRlbnQ9XFxcIjwlPSBjb250ZW50ICU+XFxcIj5cXG4gICAgPHNwYW4+PCU9IGNvbnRlbnQgJT48L3NwYW4+XFxuICAgIDxzcGFuIGNsYXNzPVxcXCJzYy1tc2ctYnV0dG9uXFxcIiB0aXRsZT1cXFwiQ29weSBtZXNzYWdlIHRvIGNsaXBib2FyZFxcXCI+PCUtIHRoaXMuZ2V0X2ljb24oJ2NvcHknKSAlPjwvc3Bhbj5cXG4gICAgPCEtLSBUT0RPOiBDb3B5IGNvbnRleHQgdG8gY2xpcGJvYXJkIChpY29uOiBleWUpIC0tPlxcbiAgICA8IS0tIFRPRE86IENvcHkgcHJvbXB0IHRvIGNsaXBib2FyZCAoaWNvbjogZmlsZXMpIC0tPlxcbiAgPC9kaXY+XFxuPC9kaXY+XCIsXG4gIFwic21hcnRfY2hhdF9zZXR0aW5nc1wiOiBcIjxkaXYgY2xhc3M9XFxcInNldHRpbmctY29tcG9uZW50XFxcIlxcbiAgZGF0YS1uYW1lPVxcXCJNb2RlbCBQbGF0Zm9ybVxcXCJcXG4gIGRhdGEtc2V0dGluZz1cXFwiY2hhdF9tb2RlbF9wbGF0Zm9ybV9rZXlcXFwiXFxuICBkYXRhLXR5cGU9XFxcImRyb3Bkb3duXFxcIlxcbiAgZGF0YS1kZXNjcmlwdGlvbj1cXFwiU2VsZWN0IGEgbW9kZWwgcGxhdGZvcm0gdG8gdXNlIHdpdGggU21hcnQgQ2hhdC5cXFwiXFxuICA8JS0gY2hhdF9wbGF0Zm9ybXMubWFwKChwbGF0Zm9ybSwgaSkgPT4gYGRhdGEtb3B0aW9uLSR7aSArIDF9PVxcXCIke3BsYXRmb3JtLmtleX18JHtwbGF0Zm9ybS5kZXNjcmlwdGlvbn1cXFwiYCkuam9pbignXFxcXG4nKSAlPlxcbiAgZGF0YS1jYWxsYmFjaz1cXFwiY2hhbmdlZF9zbWFydF9jaGF0X21vZGVsXFxcIlxcbj48L2Rpdj5cXG48JSBpZihjaGF0X3BsYXRmb3JtLmZldGNoX21vZGVscykgeyAlPlxcbiAgPCUgaWYoc2V0dGluZ3Nbc2V0dGluZ3MuY2hhdF9tb2RlbF9wbGF0Zm9ybV9rZXldPy5hcGlfa2V5KSB7ICU+XFxuICAgIDxkaXYgY2xhc3M9XFxcInNldHRpbmctY29tcG9uZW50XFxcIlxcbiAgICAgIGRhdGEtbmFtZT1cXFwiTW9kZWwgTmFtZVxcXCJcXG4gICAgICBkYXRhLXR5cGU9XFxcImRyb3Bkb3duXFxcIlxcbiAgICAgIGRhdGEtc2V0dGluZz1cXFwiPCU9IHNldHRpbmdzLmNoYXRfbW9kZWxfcGxhdGZvcm1fa2V5ICU+Lm1vZGVsX25hbWVcXFwiXFxuICAgICAgZGF0YS1jYWxsYmFjaz1cXFwiY2hhbmdlZF9zbWFydF9jaGF0X21vZGVsXFxcIlxcbiAgICAgIDwlLSBwbGF0Zm9ybV9jaGF0X21vZGVscy5tYXAoKG1vZGVsLCBpKSA9PiBgZGF0YS1vcHRpb24tJHtpfT1cXFwiJHttb2RlbC5rZXl9fCR7bW9kZWwubW9kZWxfbmFtZX0gKCR7bW9kZWwuZGVzY3JpcHRpb259KVxcXCJgKS5qb2luKCdcXFxcbicpICU+XFxuICAgID48L2Rpdj5cXG4gIDwlIH0gJT5cXG4gIDwlIGlmKCFwbGF0Zm9ybV9jaGF0X21vZGVscy5sZW5ndGgpIHsgJT5cXG4gICAgPGRpdiBjbGFzcz1cXFwic2V0dGluZy1jb21wb25lbnRcXFwiXFxuICAgICAgZGF0YS1uYW1lPVxcXCJSZWZyZXNoIE1vZGVscyBMaXN0XFxcIlxcbiAgICAgIGRhdGEtdHlwZT1cXFwiYnV0dG9uXFxcIlxcbiAgICAgIGRhdGEtY2FsbGJhY2s9XFxcImNoYW5nZWRfc21hcnRfY2hhdF9tb2RlbFxcXCJcXG4gICAgPjwvZGl2PlxcbiAgPCUgfSAlPlxcbiAgPGRpdiBjbGFzcz1cXFwic2V0dGluZy1jb21wb25lbnRcXFwiXFxuICAgIGRhdGEtbmFtZT1cXFwiPCU9IGNoYXRfcGxhdGZvcm0uZGVzY3JpcHRpb24gJT4gQVBJIEtleVxcXCJcXG4gICAgZGF0YS10eXBlPVxcXCJ0ZXh0XFxcIlxcbiAgICBkYXRhLXNldHRpbmc9XFxcIjwlPSBzZXR0aW5ncy5jaGF0X21vZGVsX3BsYXRmb3JtX2tleSAlPi5hcGlfa2V5XFxcIlxcbiAgICA8JSBpZihjaGF0X3BsYXRmb3JtLnNpZ251cF91cmwpIHsgJT5cXG4gICAgICBkYXRhLWRlc2NyaXB0aW9uPVxcXCI8YSBocmVmPSc8JT0gY2hhdF9wbGF0Zm9ybS5zaWdudXBfdXJsICU+Jz5HZXQgQVBJIEtleTwvYT4gZm9yIDwlPSBjaGF0X3BsYXRmb3JtLmRlc2NyaXB0aW9uICU+LlxcXCJcXG4gICAgPCUgfSBlbHNlIHsgJT5cXG4gICAgICBkYXRhLWRlc2NyaXB0aW9uPVxcXCJBUEkgS2V5IGZvciA8JT0gY2hhdF9wbGF0Zm9ybS5kZXNjcmlwdGlvbiAlPi5cXFwiXFxuICAgIDwlIH0gJT5cXG4gICAgZGF0YS1wbGFjZWhvbGRlcj1cXFwiRW50ZXIgYW4gQVBJIEtleVxcXCJcXG4gICAgZGF0YS1idXR0b249XFxcIlNhdmVcXFwiXFxuICAgIGRhdGEtY2FsbGJhY2s9XFxcInRlc3RfY2hhdF9hcGlfa2V5XFxcIlxcbiAgPjwvZGl2PlxcbjwlIH0gJT5cXG48JSBpZiAoc2V0dGluZ3MuY2hhdF9tb2RlbF9wbGF0Zm9ybV9rZXkuc3RhcnRzV2l0aCgnY3VzdG9tX2xvY2FsJykpIHsgJT5cXG4gIDxoMz5DdXN0b20gTG9jYWwgTW9kZWw8L2gzPlxcbiAgPGRpdiBjbGFzcz1cXFwic2V0dGluZy1jb21wb25lbnRcXFwiXFxuICAgIGRhdGEtbmFtZT1cXFwiTW9kZWwgTmFtZVxcXCJcXG4gICAgZGF0YS10eXBlPVxcXCJ0ZXh0XFxcIlxcbiAgICBkYXRhLXNldHRpbmc9XFxcImN1c3RvbV9sb2NhbC5tb2RlbF9uYW1lXFxcIlxcbiAgICBkYXRhLWRlc2NyaXB0aW9uPVxcXCJOYW1lIG9mIHRoZSBjdXN0b20gbW9kZWwuXFxcIlxcbiAgICBkYXRhLXBsYWNlaG9sZGVyPVxcXCJFbnRlciBhIG1vZGVsIG5hbWVcXFwiXFxuICAgIGRhdGEtY2FsbGJhY2s9XFxcImNoYW5nZWRfc21hcnRfY2hhdF9tb2RlbFxcXCJcXG4gID48L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFxcInNldHRpbmctY29tcG9uZW50XFxcIlxcbiAgICBkYXRhLW5hbWU9XFxcInByb3RvY29sXFxcIlxcbiAgICBkYXRhLXR5cGU9XFxcInRleHRcXFwiXFxuICAgIGRhdGEtc2V0dGluZz1cXFwiY3VzdG9tX2xvY2FsLnByb3RvY29sXFxcIlxcbiAgICBkYXRhLWRlc2NyaXB0aW9uPVxcXCJQcm90b2NvbCBmb3IgY2hhdCBzZXJ2ZXIgKGh0dHAgb3IgaHR0cHMpLlxcXCJcXG4gICAgZGF0YS1wbGFjZWhvbGRlcj1cXFwiRW50ZXIgYSBwcm90b2NvbFxcXCJcXG4gICAgZGF0YS1jYWxsYmFjaz1cXFwiY2hhbmdlZF9zbWFydF9jaGF0X21vZGVsXFxcIlxcbiAgPjwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwic2V0dGluZy1jb21wb25lbnRcXFwiXFxuICAgIGRhdGEtbmFtZT1cXFwiaG9zdG5hbWVcXFwiXFxuICAgIGRhdGEtdHlwZT1cXFwidGV4dFxcXCJcXG4gICAgZGF0YS1zZXR0aW5nPVxcXCJjdXN0b21fbG9jYWwuaG9zdG5hbWVcXFwiXFxuICAgIGRhdGEtZGVzY3JpcHRpb249XFxcIkhvc3QgZm9yIGxvY2FsIGNoYXQgc2VydmVyLlxcXCJcXG4gICAgZGF0YS1wbGFjZWhvbGRlcj1cXFwiRW50ZXIgYSBob3N0XFxcIlxcbiAgICBkYXRhLWNhbGxiYWNrPVxcXCJjaGFuZ2VkX3NtYXJ0X2NoYXRfbW9kZWxcXFwiXFxuICA+PC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJzZXR0aW5nLWNvbXBvbmVudFxcXCJcXG4gICAgZGF0YS1uYW1lPVxcXCJwb3J0XFxcIlxcbiAgICBkYXRhLXR5cGU9XFxcIm51bWJlclxcXCJcXG4gICAgZGF0YS1zZXR0aW5nPVxcXCJjdXN0b21fbG9jYWwucG9ydFxcXCJcXG4gICAgZGF0YS1kZXNjcmlwdGlvbj1cXFwiUG9ydCBmb3IgbG9jYWwgY2hhdCBzZXJ2ZXIuXFxcIlxcbiAgICBkYXRhLXBsYWNlaG9sZGVyPVxcXCJFbnRlciBhIHBvcnQgbnVtYmVyXFxcIlxcbiAgICBkYXRhLWNhbGxiYWNrPVxcXCJjaGFuZ2VkX3NtYXJ0X2NoYXRfbW9kZWxcXFwiXFxuICA+PC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJzZXR0aW5nLWNvbXBvbmVudFxcXCJcXG4gICAgZGF0YS1uYW1lPVxcXCJwYXRoXFxcIlxcbiAgICBkYXRhLXR5cGU9XFxcInRleHRcXFwiXFxuICAgIGRhdGEtc2V0dGluZz1cXFwiY3VzdG9tX2xvY2FsLnBhdGhcXFwiXFxuICAgIGRhdGEtZGVzY3JpcHRpb249XFxcIlBhdGggZm9yIGxvY2FsIGNoYXQgc2VydmVyLlxcXCJcXG4gICAgZGF0YS1wbGFjZWhvbGRlcj1cXFwiRW50ZXIgYSBwYXRoXFxcIlxcbiAgICBkYXRhLWNhbGxiYWNrPVxcXCJjaGFuZ2VkX3NtYXJ0X2NoYXRfbW9kZWxcXFwiXFxuICA+PC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJzZXR0aW5nLWNvbXBvbmVudFxcXCJcXG4gICAgZGF0YS1uYW1lPVxcXCJzdHJlYW1pbmdcXFwiXFxuICAgIGRhdGEtdHlwZT1cXFwidG9nZ2xlXFxcIlxcbiAgICBkYXRhLXNldHRpbmc9XFxcImN1c3RvbV9sb2NhbC5zdHJlYW1pbmdcXFwiXFxuICAgIGRhdGEtZGVzY3JpcHRpb249XFxcIkVuYWJsZSBzdHJlYW1pbmcgZm9yIGxvY2FsIGNoYXQgc2VydmVyLiBEaXNhYmxlIGlmIHlvdSBhcmUgZ2V0dGluZyBDT1JTIGVycm9ycy5cXFwiXFxuICAgIGRhdGEtY2FsbGJhY2s9XFxcImNoYW5nZWRfc21hcnRfY2hhdF9tb2RlbFxcXCJcXG4gID48L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFxcInNldHRpbmctY29tcG9uZW50XFxcIlxcbiAgICBkYXRhLW5hbWU9XFxcIk1heCBpbnB1dCB0b2tlbnNcXFwiXFxuICAgIGRhdGEtZGVzY3JpcHRpb249XFxcIk1heGltdW0gbnVtYmVyIG9mIHRva2VucyBmb3IgaW5wdXQgdG8gdGhlIG1vZGVsLlxcXCJcXG4gICAgZGF0YS10eXBlPVxcXCJudW1iZXJcXFwiXFxuICAgIGRhdGEtc2V0dGluZz1cXFwiY3VzdG9tX2xvY2FsLm1heF9pbnB1dF90b2tlbnNcXFwiXFxuICAgIGRhdGEtcGxhY2Vob2xkZXI9XFxcIkVudGVyIGEgbnVtYmVyXFxcIlxcbiAgICBkYXRhLWNhbGxiYWNrPVxcXCJjaGFuZ2VkX3NtYXJ0X2NoYXRfbW9kZWxcXFwiXFxuICA+PC9kaXY+XFxuPCUgfSBlbHNlIGlmKHNldHRpbmdzLmNoYXRfbW9kZWxfcGxhdGZvcm1fa2V5LnN0YXJ0c1dpdGgoJ2N1c3RvbV9hcGknKSkgeyAlPlxcbiAgPGgzPkN1c3RvbSBTZXJ2ZXI8L2gzPlxcbiAgPGRpdiBjbGFzcz1cXFwic2V0dGluZy1jb21wb25lbnRcXFwiXFxuICAgIGRhdGEtbmFtZT1cXFwiTW9kZWwgTmFtZVxcXCJcXG4gICAgZGF0YS10eXBlPVxcXCJ0ZXh0XFxcIlxcbiAgICBkYXRhLXNldHRpbmc9XFxcImN1c3RvbV9hcGkubW9kZWxfbmFtZVxcXCJcXG4gICAgZGF0YS1kZXNjcmlwdGlvbj1cXFwiTmFtZSBvZiB0aGUgY3VzdG9tIG1vZGVsLlxcXCJcXG4gICAgZGF0YS1wbGFjZWhvbGRlcj1cXFwiRW50ZXIgYSBtb2RlbCBuYW1lXFxcIlxcbiAgICBkYXRhLWNhbGxiYWNrPVxcXCJjaGFuZ2VkX3NtYXJ0X2NoYXRfbW9kZWxcXFwiXFxuICA+PC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJzZXR0aW5nLWNvbXBvbmVudFxcXCJcXG4gICAgZGF0YS1uYW1lPVxcXCJwcm90b2NvbFxcXCJcXG4gICAgZGF0YS10eXBlPVxcXCJ0ZXh0XFxcIlxcbiAgICBkYXRhLXNldHRpbmc9XFxcImN1c3RvbV9hcGkucHJvdG9jb2xcXFwiXFxuICAgIGRhdGEtZGVzY3JpcHRpb249XFxcIlByb3RvY29sIGZvciBjaGF0IHNlcnZlciAoaHR0cCBvciBodHRwcykuXFxcIlxcbiAgICBkYXRhLXBsYWNlaG9sZGVyPVxcXCJFbnRlciBhIHByb3RvY29sXFxcIlxcbiAgICBkYXRhLWNhbGxiYWNrPVxcXCJjaGFuZ2VkX3NtYXJ0X2NoYXRfbW9kZWxcXFwiXFxuICA+PC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJzZXR0aW5nLWNvbXBvbmVudFxcXCJcXG4gICAgZGF0YS1uYW1lPVxcXCJob3N0bmFtZVxcXCJcXG4gICAgZGF0YS10eXBlPVxcXCJ0ZXh0XFxcIlxcbiAgICBkYXRhLXNldHRpbmc9XFxcImN1c3RvbV9hcGkuaG9zdG5hbWVcXFwiXFxuICAgIGRhdGEtZGVzY3JpcHRpb249XFxcIkhvc3QgZm9yIGNoYXQgc2VydmVyLlxcXCJcXG4gICAgZGF0YS1wbGFjZWhvbGRlcj1cXFwiRW50ZXIgYSBob3N0XFxcIlxcbiAgICBkYXRhLWNhbGxiYWNrPVxcXCJjaGFuZ2VkX3NtYXJ0X2NoYXRfbW9kZWxcXFwiXFxuICA+PC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJzZXR0aW5nLWNvbXBvbmVudFxcXCJcXG4gICAgZGF0YS1uYW1lPVxcXCJwYXRoXFxcIlxcbiAgICBkYXRhLXR5cGU9XFxcInRleHRcXFwiXFxuICAgIGRhdGEtc2V0dGluZz1cXFwiY3VzdG9tX2FwaS5wYXRoXFxcIlxcbiAgICBkYXRhLWRlc2NyaXB0aW9uPVxcXCJQYXRoIGZvciBjaGF0IHNlcnZlci5cXFwiXFxuICAgIGRhdGEtcGxhY2Vob2xkZXI9XFxcIkVudGVyIGEgcGF0aFxcXCJcXG4gICAgZGF0YS1jYWxsYmFjaz1cXFwiY2hhbmdlZF9zbWFydF9jaGF0X21vZGVsXFxcIlxcbiAgPjwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwic2V0dGluZy1jb21wb25lbnRcXFwiXFxuICAgIGRhdGEtbmFtZT1cXFwic3RyZWFtaW5nXFxcIlxcbiAgICBkYXRhLXR5cGU9XFxcInRvZ2dsZVxcXCJcXG4gICAgZGF0YS1zZXR0aW5nPVxcXCJjdXN0b21fYXBpLnN0cmVhbWluZ1xcXCJcXG4gICAgZGF0YS1kZXNjcmlwdGlvbj1cXFwiRW5hYmxlIHN0cmVhbWluZyBmb3IgY2hhdCBzZXJ2ZXIuIERpc2FibGUgaWYgeW91IGFyZSBnZXR0aW5nIENPUlMgZXJyb3JzLlxcXCJcXG4gICAgZGF0YS1jYWxsYmFjaz1cXFwiY2hhbmdlZF9zbWFydF9jaGF0X21vZGVsXFxcIlxcbiAgPjwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwic2V0dGluZy1jb21wb25lbnRcXFwiXFxuICAgIGRhdGEtbmFtZT1cXFwiTWF4IGlucHV0IHRva2Vuc1xcXCJcXG4gICAgZGF0YS1kZXNjcmlwdGlvbj1cXFwiTWF4aW11bSBudW1iZXIgb2YgdG9rZW5zIGZvciBpbnB1dCB0byB0aGUgbW9kZWwuXFxcIlxcbiAgICBkYXRhLXR5cGU9XFxcIm51bWJlclxcXCJcXG4gICAgZGF0YS1zZXR0aW5nPVxcXCJjdXN0b21fYXBpLm1heF9pbnB1dF90b2tlbnNcXFwiXFxuICAgIGRhdGEtcGxhY2Vob2xkZXI9XFxcIkVudGVyIGEgbnVtYmVyXFxcIlxcbiAgICBkYXRhLWNhbGxiYWNrPVxcXCJjaGFuZ2VkX3NtYXJ0X2NoYXRfbW9kZWxcXFwiXFxuICA+PC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJzZXR0aW5nLWNvbXBvbmVudFxcXCJcXG4gICAgZGF0YS1uYW1lPVxcXCJBUEkgS2V5XFxcIlxcbiAgICBkYXRhLXR5cGU9XFxcInRleHRcXFwiXFxuICAgIGRhdGEtc2V0dGluZz1cXFwiY3VzdG9tX2FwaS5hcGlfa2V5XFxcIlxcbiAgICBkYXRhLWRlc2NyaXB0aW9uPVxcXCJBUEkgS2V5IGZvciB0aGUgY3VzdG9tIHNlcnZlciBzZW50IGFzIGEgaGVhZGVyIChiZWFyZXIgdG9rZW4pLlxcXCJcXG4gICAgZGF0YS1wbGFjZWhvbGRlcj1cXFwiRW50ZXIgYW4gQVBJIEtleVxcXCJcXG4gICAgZGF0YS1idXR0b249XFxcIlNhdmVcXFwiXFxuICAgIGRhdGEtY2FsbGJhY2s9XFxcInRlc3RfY2hhdF9hcGlfa2V5XFxcIlxcbiAgPjwvZGl2PlxcbjwlIH0gJT5cIixcbiAgXCJzbWFydF9jaGF0X3N5c3RlbV9tc2dcIjogXCI8ZGl2IGNsYXNzPVxcXCJzYy08JT0gcm9sZSAlPlxcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJcXFwiIGRhdGEtY29udGVudD1cXFwiPCU9IGNvbnRlbnQgJT5cXFwiPlxcbiAgICA8c3Bhbj48JT0gY29udGVudCAlPjwvc3Bhbj5cXG4gIDwvZGl2PlxcbjwvZGl2PlwiLFxuICBcInNtYXJ0X2Nvbm5lY3Rpb25zXCI6IFwiPGRpdiBjbGFzcz1cXFwic2MtdG9wLWJhclxcXCI+XFxuICA8cCBjbGFzcz1cXFwic2MtY29udGV4dFxcXCI+XFxuICAgIDwlLSBjdXJyZW50X3BhdGggJT5cXG4gICAgPCUtIHRoaXMubm90ZXMgJT4gKDwlLSB0aGlzLmJsb2NrcyAlPilcXG4gIDwvcD5cXG4gIDxidXR0b24gY2xhc3M9XFxcInNjLWZvbGQtYWxsXFxcIj48JS0gdGhpcy5nZXRfaWNvbignZm9sZC12ZXJ0aWNhbCcpICU+PC9idXR0b24+XFxuICA8YnV0dG9uIGNsYXNzPVxcXCJzYy11bmZvbGQtYWxsXFxcIj48JS0gdGhpcy5nZXRfaWNvbigndW5mb2xkLXZlcnRpY2FsJykgJT48L2J1dHRvbj5cXG4gIDxidXR0b24gY2xhc3M9XFxcInNjLXNlYXJjaC1idXR0b25cXFwiPjwlLSB0aGlzLmdldF9pY29uKCdzZWFyY2gnKSAlPjwvYnV0dG9uPlxcbiAgPGJ1dHRvbiB0aXRsZT1cXFwiU2V0dGluZ3NcXFwiPjwlLSB0aGlzLmdldF9pY29uKCdnZWFyJykgJT48L2J1dHRvbj5cXG48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJzYy1saXN0XFxcIj5cXG4gIDwlIGZvciAobGV0IHJlc3VsdCBvZiByZXN1bHRzKSB7ICU+XFxuICA8ZGl2IGNsYXNzPVxcXCJzZWFyY2gtcmVzdWx0PCUtICF0aGlzLnNldHRpbmdzLmV4cGFuZGVkX3ZpZXcgPyAnIHNjLWNvbGxhcHNlZCcgOiAnJyAlPlxcXCIgZGF0YS1wYXRoPVxcXCI8JS0gcmVzdWx0LnBhdGggJT5cXFwiPlxcbiAgICA8c3BhbiBjbGFzcz1cXFwiaGVhZGVyXFxcIj5cXG4gICAgICA8JS0gdGhpcy5nZXRfaWNvbigncmlnaHQtdHJpYW5nbGUnKSAlPlxcbiAgICAgIDxhIGNsYXNzPVxcXCJzZWFyY2gtcmVzdWx0LWZpbGUtdGl0bGVcXFwiIHRpdGxlPVxcXCI8JS0gcmVzdWx0LnBhdGggJT5cXFwiIGRyYWdnYWJsZT1cXFwidHJ1ZVxcXCI+XFxuICAgICAgICA8c21hbGw+PCUtIFtyZXN1bHQuc2NvcmU/LnRvRml4ZWQoMiksIHJlc3VsdC5uYW1lXS5qb2luKCcgfCAnKSAlPjwvc21hbGw+XFxuICAgICAgPC9hPlxcbiAgICA8L3NwYW4+XFxuICAgIDx1bCBkcmFnZ2FibGU9XFxcInRydWVcXFwiPlxcbiAgICAgIDxsaSBjbGFzcz1cXFwic2VhcmNoLXJlc3VsdC1maWxlLXRpdGxlXFxcIiB0aXRsZT1cXFwiPCUtIHJlc3VsdC5wYXRoICU+XFxcIiBkYXRhLWNvbGxlY3Rpb249XFxcIjwlPSByZXN1bHQuY29sbGVjdGlvbl9uYW1lICU+XFxcIj48L2xpPlxcbiAgICA8L3VsPlxcbiAgPC9kaXY+XFxuICA8JSB9ICU+XFxuPC9kaXY+XFxuPGRpdiBpZD1cXFwic2V0dGluZ3NcXFwiPjwvZGl2PlxcbjwlLSB0aGlzLmF0dHJpYnV0aW9uICU+XCIsXG4gIFwic21hcnRfZW1iZWRfc2V0dGluZ3NcIjogXCI8ZGl2IGNsYXNzPVxcXCJzZXR0aW5nLWNvbXBvbmVudFxcXCJcXG4gIGRhdGEtbmFtZT1cXFwiTm90ZXMgRW1iZWRkaW5nIE1vZGVsXFxcIlxcbiAgZGF0YS1zZXR0aW5nPVxcXCJzbWFydF9ub3Rlc19lbWJlZF9tb2RlbFxcXCJcXG4gIGRhdGEtdHlwZT1cXFwiZHJvcGRvd25cXFwiXFxuICBkYXRhLWRlc2NyaXB0aW9uPVxcXCJTZWxlY3QgYSBtb2RlbCB0byB1c2UgZm9yIGVtYmVkZGluZyB5b3VyIG5vdGVzLlxcXCJcXG4gIDwlLSBlbWJlZGRpbmdfbW9kZWxzLm1hcCgobW9kZWwsIGkpID0+IGBkYXRhLW9wdGlvbi0ke2kgKyAxfT1cXFwiJHttb2RlbC5rZXl9fCR7bW9kZWwubmFtZX0gKCR7bW9kZWwuZGVzY3JpcHRpb259KVxcXCJgKS5qb2luKCdcXFxcbicpICU+XFxuICBkYXRhLWNhbGxiYWNrPVxcXCJyZXN0YXJ0X3BsdWdpblxcXCJcXG4+PC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwic2V0dGluZy1jb21wb25lbnRcXFwiXFxuICBkYXRhLW5hbWU9XFxcIkJsb2NrcyBFbWJlZGRpbmcgTW9kZWxcXFwiXFxuICBkYXRhLXNldHRpbmc9XFxcInNtYXJ0X2Jsb2Nrc19lbWJlZF9tb2RlbFxcXCJcXG4gIGRhdGEtdHlwZT1cXFwiZHJvcGRvd25cXFwiXFxuICBkYXRhLWRlc2NyaXB0aW9uPVxcXCJTZWxlY3QgYSBtb2RlbCB0byB1c2UgZm9yIGVtYmVkZGluZyB5b3VyIGJsb2Nrcy5cXFwiXFxuICBkYXRhLW9wdGlvbi0wPVxcXCJOb25lfE5vbmVcXFwiXFxuICA8JS0gZW1iZWRkaW5nX21vZGVscy5tYXAoKG1vZGVsLCBpKSA9PiBgZGF0YS1vcHRpb24tJHtpICsgMX09XFxcIiR7bW9kZWwua2V5fXwke21vZGVsLm5hbWV9ICgke21vZGVsLmRlc2NyaXB0aW9ufSlcXFwiYCkuam9pbignXFxcXG4nKSAlPlxcbiAgZGF0YS1jYWxsYmFjaz1cXFwicmVzdGFydF9wbHVnaW5cXFwiXFxuPjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcInNldHRpbmctY29tcG9uZW50XFxcIlxcbiAgZGF0YS1uYW1lPVxcXCJNaW5pbXVtIEVtYmVkZGluZyBMZW5ndGhcXFwiXFxuICBkYXRhLWRlc2NyaXB0aW9uPVxcXCJNaW5pbXVtIGxlbmd0aCBvZiBub3RlIHRvIGVtYmVkLlxcXCJcXG4gIGRhdGEtdHlwZT1cXFwibnVtYmVyXFxcIlxcbiAgZGF0YS1zZXR0aW5nPVxcXCJlbWJlZF9pbnB1dF9taW5fY2hhcnNcXFwiXFxuICBkYXRhLXBsYWNlaG9sZGVyPVxcXCJFbnRlciBhIG51bWJlclxcXCJcXG4gIGRhdGEtY2FsbGJhY2s9XFxcInJlbG9hZF9lbnZcXFwiXFxuPjwvZGl2PlxcbjwlIGlmKCFzZXR0aW5ncy5zbWFydF9ub3Rlc19lbWJlZF9tb2RlbC5pbmNsdWRlcygnLycpIHx8ICFzZXR0aW5ncy5zbWFydF9ibG9ja3NfZW1iZWRfbW9kZWwuaW5jbHVkZXMoJy8nKSkgeyAlPlxcbjxkaXYgY2xhc3M9XFxcInNldHRpbmctY29tcG9uZW50XFxcIlxcbiAgZGF0YS1uYW1lPVxcXCJPcGVuQUkgQVBJIEtleSBmb3IgZW1iZWRkaW5nc1xcXCJcXG4gIGRhdGEtdHlwZT1cXFwidGV4dFxcXCJcXG4gIGRhdGEtc2V0dGluZz1cXFwiYXBpX2tleVxcXCJcXG4gIGRhdGEtcGxhY2Vob2xkZXI9XFxcIkVudGVyIHlvdXIgT3BlbkFJIEFQSSBLZXlcXFwiXFxuICBkYXRhLWJ1dHRvbj1cXFwiU2F2ZVxcXCJcXG4gIGRhdGEtY2FsbGJhY2s9XFxcInRlc3RfYXBpX2tleV9vcGVuYWlfZW1iZWRkaW5nc1xcXCJcXG4+PC9kaXY+XFxuPCUgfSAlPlxcbjwlIGlmKHNldHRpbmdzLnNtYXJ0X25vdGVzX2VtYmVkX21vZGVsLmluY2x1ZGVzKCcvJykgfHwgc2V0dGluZ3Muc21hcnRfYmxvY2tzX2VtYmVkX21vZGVsLmluY2x1ZGVzKCcvJykpIHsgJT5cXG48ZGl2IGNsYXNzPVxcXCJzZXR0aW5nLWNvbXBvbmVudFxcXCJcXG4gIGRhdGEtbmFtZT1cXFwiTG9jYWwgRW1iZWRkaW5nIE1heCBUb2tlbnNcXFwiXFxuICBkYXRhLWRlc2NyaXB0aW9uPVxcXCJSZWR1Y2UgbWF4IHRva2VucyBkZXBlbmRpbmcgb24gYXZhaWxhYmxlIHJlc291cmNlcyAoQ1BVLCBSQU0pLlxcXCIgXFxuICBkYXRhLXR5cGU9XFxcImRyb3Bkb3duXFxcIlxcbiAgZGF0YS1zZXR0aW5nPVxcXCJsb2NhbF9lbWJlZGRpbmdfbWF4X3Rva2Vuc1xcXCJcXG4gIGRhdGEtb3B0aW9uLTE9XFxcIjUxMlxcXCJcXG4gIGRhdGEtb3B0aW9uLTI9XFxcIjEwMjRcXFwiXFxuICBkYXRhLW9wdGlvbi0zPVxcXCIyMDQ4fDIwNDggKGRlZmF1bHQpXFxcIlxcbiAgZGF0YS1vcHRpb24tND1cXFwiNDA5NlxcXCJcXG4gIGRhdGEtb3B0aW9uLTU9XFxcIjgxOTJcXFwiXFxuICBkYXRhLWNhbGxiYWNrPVxcXCJyZWxvYWRfZW52XFxcIlxcbj48L2Rpdj5cXG5cXG48ZGl2IGNsYXNzPVxcXCJzZXR0aW5nLWNvbXBvbmVudFxcXCJcXG4gIGRhdGEtbmFtZT1cXFwiQ29ubmVjdCB0byBTbWFydCBDb25uZWN0XFxcIlxcbiAgZGF0YS1kZXNjcmlwdGlvbj1cXFwiPGEgaHJlZj0naHR0cHM6Ly9naXRodWIuY29tL2JyaWFucGV0cm8vc21hcnQtY29ubmVjdCc+U21hcnQgQ29ubmVjdDwvYT4gaXMgZnJlZSB0byB1c2UgZm9yIGZhc3RlciBsb2NhbCBlbWJlZGRpbmdzLlxcXCJcXG4gIGRhdGEtdHlwZT1cXFwiYnV0dG9uXFxcIlxcbiAgZGF0YS1jYWxsYmFjaz1cXFwiY29ubmVjdF90b19zbWFydF9jb25uZWN0XFxcIlxcbj48L2Rpdj5cXG48JSB9ICU+XFxuPGRpdiBjbGFzcz1cXFwic2V0dGluZy1jb21wb25lbnRcXFwiXFxuICBkYXRhLW5hbWU9XFxcIlNob3cgRnVsbCBQYXRoXFxcIlxcbiAgZGF0YS1kZXNjcmlwdGlvbj1cXFwiU2hvdyBmdWxsIHBhdGggaW4gdmlldy5cXFwiXFxuICBkYXRhLXR5cGU9XFxcInRvZ2dsZVxcXCJcXG4gIGRhdGEtc2V0dGluZz1cXFwic2hvd19mdWxsX3BhdGhcXFwiXFxuICBkYXRhLWNhbGxiYWNrPVxcXCJyZWZyZXNoX3NtYXJ0X3ZpZXdcXFwiXFxuPjwvZGl2PlwiLFxuICBcInNtYXJ0X3NldHRpbmdzXCI6IFwiPGRpdiBkYXRhLWNhbGxvdXQtbWV0YWRhdGE9XFxcIlxcXCIgZGF0YS1jYWxsb3V0LWZvbGQ9XFxcIlxcXCIgZGF0YS1jYWxsb3V0PVxcXCJpbmZvXFxcIiBjbGFzcz1cXFwiY2FsbG91dFxcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJjYWxsb3V0LXRpdGxlXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiY2FsbG91dC1pY29uXFxcIj48c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgd2lkdGg9XFxcIjI0XFxcIiBoZWlnaHQ9XFxcIjI0XFxcIiB2aWV3Qm94PVxcXCIwIDAgMjQgMjRcXFwiXFxuICAgICAgICBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcImN1cnJlbnRDb2xvclxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIyXFxcIiBzdHJva2UtbGluZWNhcD1cXFwicm91bmRcXFwiIHN0cm9rZS1saW5lam9pbj1cXFwicm91bmRcXFwiXFxuICAgICAgICBjbGFzcz1cXFwic3ZnLWljb24gbHVjaWRlLWluZm9cXFwiPlxcbiAgICAgICAgPGNpcmNsZSBjeD1cXFwiMTJcXFwiIGN5PVxcXCIxMlxcXCIgcj1cXFwiMTBcXFwiPjwvY2lyY2xlPlxcbiAgICAgICAgPHBhdGggZD1cXFwiTTEyIDE2di00XFxcIj48L3BhdGg+XFxuICAgICAgICA8cGF0aCBkPVxcXCJNMTIgOGguMDFcXFwiPjwvcGF0aD5cXG4gICAgICA8L3N2Zz48L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiY2FsbG91dC10aXRsZS1pbm5lclxcXCI+XFxuICAgICAgPGJsb2NrcXVvdGU+XFxuICAgICAgICA8cD48Yj5Vc2VyIEFncmVlbWVudDo8L2I+IEJ5IHVzaW5nIFNtYXJ0IENvbm5lY3Rpb25zIHlvdSBhZ3JlZSB0byBzaGFyZSBob3cgaXQgaGVscHMgeW91IHdpdGggYXQgbGVhc3Qgb25lIG90aGVyIHBlcnNvblxcbiAgICAgICAgICBcdUQ4M0RcdURFMEFcdUQ4M0NcdURGMzQ8L3A+XFxuICAgICAgPC9ibG9ja3F1b3RlPlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcbjxoMT5TdXBwb3J0ZXIgRmVhdHVyZXM8L2gxPlxcbjxwPkFzIGEgU21hcnQgQ29ubmVjdGlvbnMgXFxcIlN1cHBvcnRlclxcXCIsIGZhc3QtdHJhY2sgeW91ciBQS00gam91cm5leSB3aXRoIHByaW9yaXR5IHBlcmtzIGFuZCBwaW9uZWVyaW5nIGlubm92YXRpb25zLjwvcD5cXG48dWw+XFxuICA8bGk+QWNjZXNzIHRvIHRoZSBzdXBwb3J0ZXItb25seSA8YSBocmVmPVxcXCJodHRwczovL2NoYXQuc21hcnRjb25uZWN0aW9ucy5hcHBcXFwiPnByaXZhdGUgY2hhdDwvYT46XFxuICAgIDx1bD5cXG4gICAgICA8bGk+U3dpZnQsIHRvcC1wcmlvcml0eSBzdXBwb3J0LjwvbGk+XFxuICAgICAgPGxpPkxlYXJuIGFib3V0IHRoZSBsYXRlc3QgZmVhdHVyZXMgYW5kIGltcHJvdmVtZW50cyBiZWZvcmUgdGhleSBhcmUgcmVsZWFzZWQuPC9saT5cXG4gICAgICA8bGk+T3Bwb3J0dW5pdHkgdG8gaW5mbHVlbmNlIHRoZSBmdXR1cmUgb2YgU21hcnQgQ29ubmVjdGlvbnMuPC9saT5cXG4gICAgICA8bGk+QXNrIHF1ZXN0aW9ucyBhbmQgc2hhcmUgeW91ciBpbnNpZ2h0cyB3aXRoIG90aGVyIHN1cHBvcnRlcnMuPC9saT5cXG4gICAgPC91bD5cXG4gIDwvbGk+XFxuICA8bGk+RWFybHkgYWNjZXNzIHRvIG5ldyAmYW1wOyBleHBlcmltZW50YWwgZmVhdHVyZXM6XFxuICAgIDx1bD5cXG4gICAgICA8bGk+Q29taW5nIHNvb24gaW4gdjIuMjogTXVsdGktbW9kYWwgU21hcnQgQ2hhdDwvbGk+XFxuICAgICAgPGxpPkNvbWluZyBzb29uIGluIHYyLjI6IFJlLXJhbmtpbmcgaW4gdGhlIFNtYXJ0IFZpZXc8L2xpPlxcbiAgICAgIDxsaT5Db21pbmcgc29vbiBpbiB2Mi4yOiBBY3Rpb25zIGluIHRoZSBTbWFydCBDaGF0PC9saT5cXG4gICAgICA8bGk+Q29taW5nIHNvb24gaW4gdjIuMjogQWR2YW5jZWQgZmlsdGVycyBpbiB0aGUgU21hcnQgVmlldzwvbGk+XFxuICAgIDwvdWw+XFxuICA8L2xpPlxcbiAgPGxpPjxpPkZvciBhIGxpbWl0ZWQgdGltZTwvaT46IEVhcmx5IGFjY2VzcyB0byBTbWFydCBDb25uZWN0OiBVc2UgQ2hhdEdQVCB3aXRoIHlvdXIgbm90ZXMgPGk+d2l0aG91dDwvaT4gdXBsb2FkaW5nIHlvdXIgbm90ZXMgdG8gdGhlIGNsb3VkIHVzaW5nIDxhIGhyZWY9XFxcImh0dHBzOi8vY2hhdC5vcGVuYWkuY29tL2cvZy05WGIxbVJKWWwtc21hcnQtY29ubmVjdC1vYnNpZGlhblxcXCI+U21hcnQgQ29ubmVjdCAtIE9ic2lkaWFuPC9hPiBHUFQuPC9saT5cXG48L3VsPlxcbjxkaXYgY2xhc3M9XFxcInNldHRpbmctY29tcG9uZW50XFxcIlxcbiAgZGF0YS1uYW1lPVxcXCJTdXBwb3J0ZXIgTGljZW5zZSBLZXlcXFwiXFxuICBkYXRhLXR5cGU9XFxcInRleHRcXFwiXFxuICBkYXRhLXNldHRpbmc9XFxcImxpY2Vuc2Vfa2V5XFxcIlxcbiAgZGF0YS1kZXNjcmlwdGlvbj1cXFwiTm90ZTogdGhpcyBpcyBub3QgcmVxdWlyZWQgdG8gdXNlIFNtYXJ0IENvbm5lY3Rpb25zLlxcXCJcXG4gIGRhdGEtcGxhY2Vob2xkZXI9XFxcIkVudGVyIHlvdXIgbGljZW5zZV9rZXlcXFwiXFxuPjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcInNldHRpbmctY29tcG9uZW50XFxcIlxcbiAgZGF0YS1uYW1lPVxcXCJTbWFydCBDb25uZWN0IC0gT2JzaWRpYW4gR1BUXFxcIlxcbiAgZGF0YS1idG4tdGV4dD1cXFwiT3BlbiBHUFRcXFwiXFxuICBkYXRhLWRlc2NyaXB0aW9uPSdDaGF0IHdpdGggeW91ciBub3RlcyBpbiBDaGF0R1BUIHdpdGhvdXQgdXBsb2FkaW5nIHlvdXIgbm90ZXMgdG8gdGhlIGNsb3VkISdcXG4gIGRhdGEtdHlwZT1cXFwiYnV0dG9uXFxcIlxcbiAgZGF0YS1ocmVmPVxcXCJodHRwczovL2NoYXQub3BlbmFpLmNvbS9nL2ctOVhiMW1SSllsLXNtYXJ0LWNvbm5lY3Rpb25zLTJcXFwiXFxuPjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcInNldHRpbmctY29tcG9uZW50XFxcIlxcbiAgZGF0YS1uYW1lPVxcXCJCZWNvbWUgYSBTdXBwb3J0ZXJcXFwiXFxuICBkYXRhLWRlc2NyaXB0aW9uPVxcXCJCZWNvbWUgYSBTdXBwb3J0ZXJcXFwiXFxuICBkYXRhLXR5cGU9XFxcImJ1dHRvblxcXCJcXG4gIGRhdGEtaHJlZj1cXFwiaHR0cHM6Ly9idXkuc3RyaXBlLmNvbS85QVE3c1dlbVQ0OHUxTEdjTjRcXFwiXFxuPjwvZGl2PlxcbjxoMT5TbWFydCBWaWV3ICYgRW1iZWRkaW5nczwvaDE+XFxuPHA+Tm90ZXMgYWJvdXQgZW1iZWRkaW5nIG1vZGVsczo8L3A+XFxuPHVsPlxcbiAgPGxpPkxvY2FsIG1vZGVsIGNvbXBhdGliaWxpdHkgZGVwZW5kcyBvbiBhdmFpbGFibGUgQ1BVIGFuZCBSQU0uIFRyeSByZWR1Y2luZyB0aGUgbWF4IHRva2VucyAoY29udGV4dCkgaWYgYSBsb2NhbCBtb2RlbCBpZiBmYWlsaW5nLjwvbGk+XFxuICA8bGk+QVBJIG1vZGVscyBhcmUgbm90IGRlcGVuZGVudCBvbiBsb2NhbCBjb21wdXRlLCBidXQgdGhleSByZXF1aXJlIGFuIEFQSSBrZXkgYW5kIHNlbmQgeW91ciBub3RlcyB0byB0aGlyZC1wYXJ0eSBzZXJ2ZXJzIGZvciBwcm9jZXNzaW5nLjwvbGk+XFxuPC91bD5cXG48JS0gc21hcnRfZW1iZWRfc2V0dGluZ3MgJT5cXG48aDE+U21hcnQgQ2hhdDwvaDE+XFxuPCUtIHNtYXJ0X2NoYXRfc2V0dGluZ3MgJT5cXG48aDM+U3lzdGVtIFByb21wdHM8L2gzPlxcbjxkaXYgY2xhc3M9XFxcInNldHRpbmctY29tcG9uZW50XFxcIlxcbiAgZGF0YS1uYW1lPVxcXCJTeXN0ZW0gUHJvbXB0cyBGb2xkZXJcXFwiXFxuICBkYXRhLWRlc2NyaXB0aW9uPVxcXCJGb2xkZXIgdG8gc3RvcmUgc3lzdGVtIHByb21wdHMuIEF2YWlsYWJsZSBpbiBjaGF0IGJ5IHR5cGluZyAnQCdcXFwiXFxuICBkYXRhLXR5cGU9XFxcInRleHRcXFwiXFxuICBkYXRhLXNldHRpbmc9XFxcInN5c3RlbV9wcm9tcHRzX2ZvbGRlclxcXCJcXG4gIGRhdGEtcGxhY2Vob2xkZXI9XFxcIkVudGVyIGEgZm9sZGVyIG5hbWVcXFwiXFxuICBkYXRhLWNhbGxiYWNrPVxcXCJ1cGRhdGVfc3lzdGVtX3Byb21wdHNfZm9sZGVyXFxcIlxcbiAgZGF0YS1idXR0b249XFxcIlNhdmVcXFwiXFxuPjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcInNldHRpbmctY29tcG9uZW50XFxcIlxcbiAgZGF0YS1uYW1lPVxcXCJEZWZhdWx0IExhbmd1YWdlXFxcIlxcbiAgZGF0YS1zZXR0aW5nPVxcXCJsYW5ndWFnZVxcXCJcXG4gIGRhdGEtdHlwZT1cXFwiZHJvcGRvd25cXFwiXFxuICBkYXRhLWRlc2NyaXB0aW9uPVxcXCJEZWZhdWx0IGxhbmd1YWdlIHRvIHVzZSBmb3IgU21hcnQgQ2hhdC4gQ2hhbmdlcyB3aGljaCBzZWxmLXJlZmVyZW50aWFsIHByb25vdW5zIHdpbGwgdHJpZ2dlciBsb29rdXAgb2YgeW91ciBub3Rlcy5cXFwiXFxuICBkYXRhLW9wdGlvbi0xPVxcXCJlbnxFbmdsaXNoXFxcIlxcbiAgZGF0YS1vcHRpb24tMj1cXFwiZXN8U3BhbmlzaFxcXCJcXG4gIGRhdGEtb3B0aW9uLTM9XFxcImZyfEZyZW5jaFxcXCJcXG4gIGRhdGEtb3B0aW9uLTQ9XFxcImRlfEdlcm1hblxcXCJcXG4gIGRhdGEtb3B0aW9uLTU9XFxcIml0fEl0YWxpYW5cXFwiXFxuICBkYXRhLWNhbGxiYWNrPVxcXCJ1cGRhdGVfbGFuZ3VhZ2VcXFwiXFxuPjwvZGl2PlxcbjxzcGFuIGlkPVxcXCJzZWxmLXJlZmVyZW50aWFsLXByb25vdW5zXFxcIj5DdXJyZW50OiBteSwgSSwgbWUsIG1pbmUsIG91ciwgb3VycywgdXMsIHdlPC9zcGFuPlxcbjxoMT5FeGNsdXNpb25zPC9oMT5cXG48cCBpZD1cXFwiZmlsZS1jb3VudHNcXFwiPkluY2x1ZGVkIGZpbGVzOiA8JT0gaW5jbHVkZWRfZmlsZXMgJT4gLyBUb3RhbCBmaWxlczogPCU9IHRvdGFsX2ZpbGVzICU+PC9wPlxcbjxkaXYgY2xhc3M9XFxcInNldHRpbmctY29tcG9uZW50XFxcIlxcbiAgZGF0YS1uYW1lPVxcXCJGaWxlIEV4Y2x1c2lvbnNcXFwiXFxuICBkYXRhLWRlc2NyaXB0aW9uPVxcXCInRXhjbHVkZWQgZmlsZScgbWF0Y2hlcnMgc2VwYXJhdGVkIGJ5IGEgY29tbWEuXFxcIlxcbiAgZGF0YS10eXBlPVxcXCJ0ZXh0XFxcIlxcbiAgZGF0YS1zZXR0aW5nPVxcXCJmaWxlX2V4Y2x1c2lvbnNcXFwiXFxuICBkYXRhLXBsYWNlaG9sZGVyPVxcXCJkcmF3aW5ncyxwcm9tcHRzL2xvZ3NcXFwiXFxuICBkYXRhLWNhbGxiYWNrPVxcXCJ1cGRhdGVfZXhjbHVzaW9uc1xcXCJcXG4+PC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwic2V0dGluZy1jb21wb25lbnRcXFwiXFxuICBkYXRhLW5hbWU9XFxcIkZvbGRlciBFeGNsdXNpb25zXFxcIlxcbiAgZGF0YS1kZXNjcmlwdGlvbj1cXFwiJ0V4Y2x1ZGVkIGZvbGRlcicgbWF0Y2hlcnMgc2VwYXJhdGVkIGJ5IGEgY29tbWEuXFxcIlxcbiAgZGF0YS10eXBlPVxcXCJ0ZXh0XFxcIlxcbiAgZGF0YS1zZXR0aW5nPVxcXCJmb2xkZXJfZXhjbHVzaW9uc1xcXCJcXG4gIGRhdGEtcGxhY2Vob2xkZXI9XFxcImRyYXdpbmdzLHByb21wdHMvbG9nc1xcXCJcXG4gIGRhdGEtY2FsbGJhY2s9XFxcInVwZGF0ZV9leGNsdXNpb25zXFxcIlxcbj48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJzZXR0aW5nLWNvbXBvbmVudFxcXCJcXG4gIGRhdGEtbmFtZT1cXFwiRXhjbHVkZSBhbGwgdG9wLWxldmVsIGZvbGRlcnNcXFwiXFxuICBkYXRhLWRlc2NyaXB0aW9uPVxcXCJTZXQgZm9sZGVyIGV4Y2x1c2lvbnMgdG8gZXhjbHVkZSBhbGwgdG9wLWxldmVsIGZvbGRlcnMuXFxcIlxcbiAgZGF0YS10eXBlPVxcXCJidXR0b25cXFwiXFxuICBkYXRhLWNhbGxiYWNrPVxcXCJleGNsdWRlX2FsbF90b3BfbGV2ZWxfZm9sZGVyc1xcXCJcXG4+PC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwic2V0dGluZy1jb21wb25lbnRcXFwiXFxuICBkYXRhLW5hbWU9XFxcIkhlYWRpbmcgRXhjbHVzaW9uc1xcXCJcXG4gIGRhdGEtZGVzY3JpcHRpb249XFxcIidFeGNsdWRlZCBoZWFkZXInIG1hdGNoZXJzIHNlcGFyYXRlZCBieSBhIGNvbW1hLiBXb3JrcyBmb3IgJ2Jsb2Nrcycgb25seS5cXFwiXFxuICBkYXRhLXR5cGU9XFxcInRleHRcXFwiXFxuICBkYXRhLXNldHRpbmc9XFxcImV4Y2x1ZGVkX2hlYWRpbmdzXFxcIlxcbiAgZGF0YS1wbGFjZWhvbGRlcj1cXFwiZHJhd2luZ3MscHJvbXB0cy9sb2dzXFxcIlxcbj48L2Rpdj5cXG48aDM+RGF0YSBNYW5hZ2VtZW50PC9oMz5cXG48ZGl2IGNsYXNzPVxcXCJzZXR0aW5nLWNvbXBvbmVudFxcXCJcXG4gIGRhdGEtbmFtZT1cXFwiUmVmcmVzaCBOb3Rlc1xcXCJcXG4gIGRhdGEtZGVzY3JpcHRpb249XFxcIkNsZWFyIG5vdGVzIGRhdGEgYW5kIHJlcHJvY2Vzcy5cXFwiXFxuICBkYXRhLXR5cGU9XFxcImJ1dHRvblxcXCJcXG4gIGRhdGEtY2FsbGJhY2s9XFxcInJlZnJlc2hfbm90ZXNcXFwiXFxuPjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcInNldHRpbmctY29tcG9uZW50XFxcIlxcbiAgZGF0YS1uYW1lPVxcXCJTbWFydCBDb25uZWN0aW9ucyBGb2xkZXJcXFwiXFxuICBkYXRhLWRlc2NyaXB0aW9uPVxcXCJGb2xkZXIgdG8gc3RvcmUgU21hcnQgQ29ubmVjdGlvbnMgZGF0YS5cXFwiXFxuICBkYXRhLXR5cGU9XFxcInRleHRcXFwiXFxuICBkYXRhLXNldHRpbmc9XFxcInNtYXJ0X2Nvbm5lY3Rpb25zX2ZvbGRlclxcXCJcXG4gIGRhdGEtcGxhY2Vob2xkZXI9XFxcIkVudGVyIGEgZm9sZGVyIG5hbWVcXFwiXFxuICBkYXRhLWNhbGxiYWNrPVxcXCJ1cGRhdGVfc21hcnRfY29ubmVjdGlvbnNfZm9sZGVyXFxcIlxcbiAgZGF0YS1idXR0b249XFxcInJlbmFtZVxcXCJcXG4+PC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwic2V0dGluZy1jb21wb25lbnRcXFwiXFxuICBkYXRhLW5hbWU9XFxcIlNtYXJ0IENoYXQgSGlzdG9yeSBGb2xkZXJcXFwiXFxuICBkYXRhLWRlc2NyaXB0aW9uPVxcXCJGb2xkZXIgdG8gc3RvcmUgU21hcnQgQ2hhdCBoaXN0b3J5LlxcXCJcXG4gIGRhdGEtdHlwZT1cXFwidGV4dFxcXCJcXG4gIGRhdGEtc2V0dGluZz1cXFwic21hcnRfY2hhdF9mb2xkZXJcXFwiXFxuICBkYXRhLXBsYWNlaG9sZGVyPVxcXCJFbnRlciBhIGZvbGRlciBuYW1lXFxcIlxcbiAgZGF0YS1jYWxsYmFjaz1cXFwidXBkYXRlX3NtYXJ0X2NoYXRfZm9sZGVyXFxcIlxcbiAgZGF0YS1idXR0b249XFxcInJlbmFtZVxcXCJcXG4+PC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwic2V0dGluZy1jb21wb25lbnRcXFwiXFxuICBkYXRhLW5hbWU9XFxcIkVtYmVkZGluZyBmaWxlIHBlciBub3RlIChFWFBFUklNRU5UQUwpXFxcIlxcbiAgZGF0YS1kZXNjcmlwdGlvbj1cXFwiU2F2ZSBlbWJlZGRpbmcgZGF0YSBpbiBhIHNlcGFyYXRlIGZpbGUgcGVyIG5vdGUuXFxcIlxcbiAgZGF0YS10eXBlPVxcXCJ0b2dnbGVcXFwiXFxuICBkYXRhLXNldHRpbmc9XFxcImVtYmVkZGluZ19maWxlX3Blcl9ub3RlXFxcIlxcbiAgZGF0YS1jYWxsYmFjaz1cXFwicmVzdGFydF9wbHVnaW5cXFwiXFxuPjwvZGl2PlxcbjxoMT5Gb3JjZSBSZWZyZXNoPC9oMT5cXG48ZGl2IGNsYXNzPVxcXCJzZXR0aW5nLWNvbXBvbmVudFxcXCJcXG4gIGRhdGEtbmFtZT1cXFwiZm9yY2VfcmVmcmVzaFxcXCJcXG4gIGRhdGEtZGVzY3JpcHRpb249XFxcIldBUk5JTkc6IERPIE5PVCB1c2UgdW5sZXNzIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZyEgVGhpcyB3aWxsIGRlbGV0ZSBhbGwgb2YgeW91ciBjdXJyZW50IGVtYmVkZGluZ3MgZnJvbSBPcGVuQUkgYW5kIHRyaWdnZXIgcmVwcm9jZXNzaW5nIG9mIHlvdXIgZW50aXJlIHZhdWx0IVxcXCJcXG4gIGRhdGEtY29uZmlybT1cXFwiQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIEZvcmNlIFJlZnJlc2g/IEJ5IGNsaWNraW5nIHllcyB5b3UgY29uZmlybSB0aGF0IHlvdSB1bmRlcnN0YW5kIHRoZSBjb25zZXF1ZW5jZXMgb2YgdGhpcyBhY3Rpb24uXFxcIlxcbiAgZGF0YS10eXBlPVxcXCJidXR0b25cXFwiXFxuICBkYXRhLWNhbGxiYWNrPVxcXCJmb3JjZV9yZWZyZXNoXFxcIlxcbj48L2Rpdj5cXG48IS0tIE5hdGl2ZSBKUyBjb25maXJtIGZvY3Vzc2luZyBidWcgLS0+XFxuPCEtLSAgXFxuPGgzPkZvcmNlIFJlZnJlc2g8L2gzPlxcbjxkaXYgY2xhc3M9XFxcInNldHRpbmctY29tcG9uZW50XFxcIlxcbiAgZGF0YS1uYW1lPVxcXCJmb3JjZV9yZWZyZXNoXFxcIlxcbiAgZGF0YS1kZXNjcmlwdGlvbj1cXFwiV0FSTklORzogRE8gTk9UIHVzZSB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UgYXJlIGRvaW5nISBUaGlzIHdpbGwgZGVsZXRlIGFsbCBvZiB5b3VyIGN1cnJlbnQgZW1iZWRkaW5ncyBmcm9tIE9wZW5BSSBhbmQgdHJpZ2dlciByZXByb2Nlc3Npbmcgb2YgeW91ciBlbnRpcmUgdmF1bHQhXFxcIlxcbiAgZGF0YS1jb25maXJtPVxcXCJBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gRm9yY2UgUmVmcmVzaD8gQnkgY2xpY2tpbmcgeWVzIHlvdSBjb25maXJtIHRoYXQgeW91IHVuZGVyc3RhbmQgdGhlIGNvbnNlcXVlbmNlcyBvZiB0aGlzIGFjdGlvbi5cXFwiXFxuICBkYXRhLXR5cGU9XFxcImJ1dHRvblxcXCJcXG4gIGRhdGEtY2FsbGJhY2s9XFxcImZvcmNlX3JlZnJlc2hcXFwiXFxuPjwvZGl2PiAtLT5cXG48aDE+TXV0ZWQgTm90aWNlczwvaDE+XFxuPCUgaWYobXV0ZWRfbm90aWNlcyAmJiBPYmplY3Qua2V5cyhtdXRlZF9ub3RpY2VzKS5sZW5ndGgpIHsgJT5cXG4gIDwlIGZvcihjb25zdCBub3RpY2UgaW4gbXV0ZWRfbm90aWNlcykgeyAlPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJzZXR0aW5nLWNvbXBvbmVudFxcXCJcXG4gICAgICBkYXRhLW5hbWU9XFxcIjwlPSBub3RpY2UgJT5cXFwiXFxuICAgICAgZGF0YS1zZXR0aW5nPVxcXCJtdXRlZF9ub3RpY2VzLjwlPSBub3RpY2UgJT5cXFwiXFxuICAgICAgZGF0YS10eXBlPVxcXCJidXR0b25cXFwiXFxuICAgICAgZGF0YS1idG4tdGV4dD1cXFwiVW5tdXRlXFxcIlxcbiAgICAgIGRhdGEtY2FsbGJhY2s9XFxcInVubXV0ZV9ub3RpY2VcXFwiXFxuICAgID48L2Rpdj5cXG4gIDwlIH0gJT5cXG48JSB9IGVsc2UgeyAlPlxcbiAgPHA+Tm8gbXV0ZWQgbm90aWNlcy48L3A+XFxuPCUgfSAlPlxcbjxocj5cXG48aDUgbmFtZT1cXFwib2ctZ3B0XFxcIiBpZD1cXFwib2ctZ3B0XFxcIj5UaGUgT3JpZ2luYWwgU21hcnQgQ29ubmVjdGlvbnMgR1BUPC9oNT5cXG48ZGl2IGRhdGEtY2FsbG91dC1tZXRhZGF0YT1cXFwiXFxcIiBkYXRhLWNhbGxvdXQtZm9sZD1cXFwiXFxcIiBkYXRhLWNhbGxvdXQ9XFxcIndhcm5pbmdcXFwiIGNsYXNzPVxcXCJjYWxsb3V0XFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcImNhbGxvdXQtdGl0bGVcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjYWxsb3V0LWljb25cXFwiPjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB3aWR0aD1cXFwiMjRcXFwiIGhlaWdodD1cXFwiMjRcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNCAyNFxcXCJcXG4gICAgICAgIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiY3VycmVudENvbG9yXFxcIiBzdHJva2Utd2lkdGg9XFxcIjJcXFwiIHN0cm9rZS1saW5lY2FwPVxcXCJyb3VuZFxcXCIgc3Ryb2tlLWxpbmVqb2luPVxcXCJyb3VuZFxcXCJcXG4gICAgICAgIGNsYXNzPVxcXCJzdmctaWNvbiBsdWNpZGUtYWxlcnQtdHJpYW5nbGVcXFwiPlxcbiAgICAgICAgPHBhdGggZD1cXFwibTIxLjczIDE4LTgtMTRhMiAyIDAgMCAwLTMuNDggMGwtOCAxNEEyIDIgMCAwIDAgNCAyMWgxNmEyIDIgMCAwIDAgMS43My0zWlxcXCI+PC9wYXRoPlxcbiAgICAgICAgPHBhdGggZD1cXFwiTTEyIDl2NFxcXCI+PC9wYXRoPlxcbiAgICAgICAgPHBhdGggZD1cXFwiTTEyIDE3aC4wMVxcXCI+PC9wYXRoPlxcbiAgICAgIDwvc3ZnPjwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjYWxsb3V0LXRpdGxlLWlubmVyXFxcIj48cD48aT5UaGlzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLjwvaT4gUGxlYXNlIHVzZSB0aGUgPGEgaHJlZj1cXFwiaHR0cHM6Ly9jaGF0Lm9wZW5haS5jb20vZy9nLTlYYjFtUkpZbC1zbWFydC1jb25uZWN0LW9ic2lkaWFuXFxcIj5TbWFydCBDb25uZWN0IC0gT2JzaWRpYW48L2E+IEdQVCBmb3IgbW9yZSBhZHZhbmNlZCBmZWF0dXJlcyBsaWtlIGNyZWF0aW5nIG5vdGVzIGFuZCBlbWJlZGRpbmcgc2VhcmNoLjwvcD48L2Rpdj5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcbjxwPlRoaXMgR1BUIGNhbiBicm93c2VyIGZvbGRlcnMgYW5kIHJlYWQgbm90ZXMuIEl0IHJlcXVpcmVzIG1hbnVhbGx5IHN5bmNocm9uaXphdGlvbiBmb3IgeW91ciBub3RlcyB0byBiZSBhY2Nlc3NpYmxlIGJ5IENoYXRHUFQuPC9wPlxcbjxkaXYgY2xhc3M9XFxcInNldHRpbmctY29tcG9uZW50XFxcIlxcbiAgZGF0YS1uYW1lPVxcXCJDaGF0R1BUIEludGVncmF0aW9uIChzdXBwb3J0ZXItb25seSlcXFwiXFxuICBkYXRhLWJ0bi10ZXh0PVxcXCJTeW5jIE5vdGVzXFxcIlxcbiAgZGF0YS1kZXNjcmlwdGlvbj1cXFwiU3luYyB5b3VyIG5vdGVzIGZvciB1c2Ugd2l0aCB0aGUgU21hcnQgQ29ubmVjdGlvbnMgR1BUIGFuZCBDaGF0R1BUIFBsdWdpbi4gUmVzcGVjdHMgeW91ciBmaWxlIGFuZCBmb2xkZXIgZXhjbHVzaW9uIHNldHRpbmdzLiBSZXF1aXJlZCB0byB1c2UgdGhlIFNtYXJ0IENvbm5lY3Rpb25zIEdQVC5cXFwiXFxuICBkYXRhLXR5cGU9XFxcImJ1dHRvblxcXCJcXG4gIGRhdGEtY2FsbGJhY2s9XFxcInN5bmNfZm9yX2NoYXRncHRcXFwiXFxuPjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcInNldHRpbmctY29tcG9uZW50XFxcIlxcbiAgZGF0YS1uYW1lPVxcXCJPcGVuIFNtYXJ0IENvbm5lY3Rpb25zIEdQVFxcXCJcXG4gIGRhdGEtYnRuLXRleHQ9XFxcIk9wZW5cXFwiXFxuICBkYXRhLWRlc2NyaXB0aW9uPSdDaGF0IHdpdGggeW91ciBub3RlcyBpbiBDaGF0R1BULiBSZXF1aXJlcyBhIENoYXRHUFQgUGx1cyBhY2NvdW50LidcXG4gIGRhdGEtdHlwZT1cXFwiYnV0dG9uXFxcIlxcbiAgZGF0YS1ocmVmPVxcXCJodHRwczovL2NoYXQub3BlbmFpLmNvbS9nL2ctU2xERHAwN2JtLXNtYXJ0LWNvbm5lY3Rpb25zLWZvci1vYnNpZGlhblxcXCJcXG4+PC9kaXY+XCJcbn0iLCAiKGZ1bmN0aW9uKGYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIiYmdHlwZW9mIG1vZHVsZSE9PVwidW5kZWZpbmVkXCIpe21vZHVsZS5leHBvcnRzPWYoKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXSxmKX1lbHNle3ZhciBnO2lmKHR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiKXtnPXdpbmRvd31lbHNlIGlmKHR5cGVvZiBnbG9iYWwhPT1cInVuZGVmaW5lZFwiKXtnPWdsb2JhbH1lbHNlIGlmKHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIil7Zz1zZWxmfWVsc2V7Zz10aGlzfWcuZWpzPWYoKX19KShmdW5jdGlvbigpe3ZhciBkZWZpbmUsbW9kdWxlLGV4cG9ydHM7cmV0dXJuIGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSgpKHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcInVzZSBzdHJpY3RcIjt2YXIgZnM9cmVxdWlyZShcImZzXCIpO3ZhciBwYXRoPXJlcXVpcmUoXCJwYXRoXCIpO3ZhciB1dGlscz1yZXF1aXJlKFwiLi91dGlsc1wiKTt2YXIgc2NvcGVPcHRpb25XYXJuZWQ9ZmFsc2U7dmFyIF9WRVJTSU9OX1NUUklORz1yZXF1aXJlKFwiLi4vcGFja2FnZS5qc29uXCIpLnZlcnNpb247dmFyIF9ERUZBVUxUX09QRU5fREVMSU1JVEVSPVwiPFwiO3ZhciBfREVGQVVMVF9DTE9TRV9ERUxJTUlURVI9XCI+XCI7dmFyIF9ERUZBVUxUX0RFTElNSVRFUj1cIiVcIjt2YXIgX0RFRkFVTFRfTE9DQUxTX05BTUU9XCJsb2NhbHNcIjt2YXIgX05BTUU9XCJlanNcIjt2YXIgX1JFR0VYX1NUUklORz1cIig8JSV8JSU+fDwlPXw8JS18PCVffDwlI3w8JXwlPnwtJT58XyU+KVwiO3ZhciBfT1BUU19QQVNTQUJMRV9XSVRIX0RBVEE9W1wiZGVsaW1pdGVyXCIsXCJzY29wZVwiLFwiY29udGV4dFwiLFwiZGVidWdcIixcImNvbXBpbGVEZWJ1Z1wiLFwiY2xpZW50XCIsXCJfd2l0aFwiLFwicm1XaGl0ZXNwYWNlXCIsXCJzdHJpY3RcIixcImZpbGVuYW1lXCIsXCJhc3luY1wiXTt2YXIgX09QVFNfUEFTU0FCTEVfV0lUSF9EQVRBX0VYUFJFU1M9X09QVFNfUEFTU0FCTEVfV0lUSF9EQVRBLmNvbmNhdChcImNhY2hlXCIpO3ZhciBfQk9NPS9eXFx1RkVGRi87dmFyIF9KU19JREVOVElGSUVSPS9eW2EtekEtWl8kXVswLTlhLXpBLVpfJF0qJC87ZXhwb3J0cy5jYWNoZT11dGlscy5jYWNoZTtleHBvcnRzLmZpbGVMb2FkZXI9ZnMucmVhZEZpbGVTeW5jO2V4cG9ydHMubG9jYWxzTmFtZT1fREVGQVVMVF9MT0NBTFNfTkFNRTtleHBvcnRzLnByb21pc2VJbXBsPW5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzO1wiKSgpLlByb21pc2U7ZXhwb3J0cy5yZXNvbHZlSW5jbHVkZT1mdW5jdGlvbihuYW1lLGZpbGVuYW1lLGlzRGlyKXt2YXIgZGlybmFtZT1wYXRoLmRpcm5hbWU7dmFyIGV4dG5hbWU9cGF0aC5leHRuYW1lO3ZhciByZXNvbHZlPXBhdGgucmVzb2x2ZTt2YXIgaW5jbHVkZVBhdGg9cmVzb2x2ZShpc0Rpcj9maWxlbmFtZTpkaXJuYW1lKGZpbGVuYW1lKSxuYW1lKTt2YXIgZXh0PWV4dG5hbWUobmFtZSk7aWYoIWV4dCl7aW5jbHVkZVBhdGgrPVwiLmVqc1wifXJldHVybiBpbmNsdWRlUGF0aH07ZnVuY3Rpb24gcmVzb2x2ZVBhdGhzKG5hbWUscGF0aHMpe3ZhciBmaWxlUGF0aDtpZihwYXRocy5zb21lKGZ1bmN0aW9uKHYpe2ZpbGVQYXRoPWV4cG9ydHMucmVzb2x2ZUluY2x1ZGUobmFtZSx2LHRydWUpO3JldHVybiBmcy5leGlzdHNTeW5jKGZpbGVQYXRoKX0pKXtyZXR1cm4gZmlsZVBhdGh9fWZ1bmN0aW9uIGdldEluY2x1ZGVQYXRoKHBhdGgsb3B0aW9ucyl7dmFyIGluY2x1ZGVQYXRoO3ZhciBmaWxlUGF0aDt2YXIgdmlld3M9b3B0aW9ucy52aWV3czt2YXIgbWF0Y2g9L15bQS1aYS16XSs6XFxcXHxeXFwvLy5leGVjKHBhdGgpO2lmKG1hdGNoJiZtYXRjaC5sZW5ndGgpe3BhdGg9cGF0aC5yZXBsYWNlKC9eXFwvKi8sXCJcIik7aWYoQXJyYXkuaXNBcnJheShvcHRpb25zLnJvb3QpKXtpbmNsdWRlUGF0aD1yZXNvbHZlUGF0aHMocGF0aCxvcHRpb25zLnJvb3QpfWVsc2V7aW5jbHVkZVBhdGg9ZXhwb3J0cy5yZXNvbHZlSW5jbHVkZShwYXRoLG9wdGlvbnMucm9vdHx8XCIvXCIsdHJ1ZSl9fWVsc2V7aWYob3B0aW9ucy5maWxlbmFtZSl7ZmlsZVBhdGg9ZXhwb3J0cy5yZXNvbHZlSW5jbHVkZShwYXRoLG9wdGlvbnMuZmlsZW5hbWUpO2lmKGZzLmV4aXN0c1N5bmMoZmlsZVBhdGgpKXtpbmNsdWRlUGF0aD1maWxlUGF0aH19aWYoIWluY2x1ZGVQYXRoJiZBcnJheS5pc0FycmF5KHZpZXdzKSl7aW5jbHVkZVBhdGg9cmVzb2x2ZVBhdGhzKHBhdGgsdmlld3MpfWlmKCFpbmNsdWRlUGF0aCYmdHlwZW9mIG9wdGlvbnMuaW5jbHVkZXIhPT1cImZ1bmN0aW9uXCIpe3Rocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgdGhlIGluY2x1ZGUgZmlsZSBcIicrb3B0aW9ucy5lc2NhcGVGdW5jdGlvbihwYXRoKSsnXCInKX19cmV0dXJuIGluY2x1ZGVQYXRofWZ1bmN0aW9uIGhhbmRsZUNhY2hlKG9wdGlvbnMsdGVtcGxhdGUpe3ZhciBmdW5jO3ZhciBmaWxlbmFtZT1vcHRpb25zLmZpbGVuYW1lO3ZhciBoYXNUZW1wbGF0ZT1hcmd1bWVudHMubGVuZ3RoPjE7aWYob3B0aW9ucy5jYWNoZSl7aWYoIWZpbGVuYW1lKXt0aHJvdyBuZXcgRXJyb3IoXCJjYWNoZSBvcHRpb24gcmVxdWlyZXMgYSBmaWxlbmFtZVwiKX1mdW5jPWV4cG9ydHMuY2FjaGUuZ2V0KGZpbGVuYW1lKTtpZihmdW5jKXtyZXR1cm4gZnVuY31pZighaGFzVGVtcGxhdGUpe3RlbXBsYXRlPWZpbGVMb2FkZXIoZmlsZW5hbWUpLnRvU3RyaW5nKCkucmVwbGFjZShfQk9NLFwiXCIpfX1lbHNlIGlmKCFoYXNUZW1wbGF0ZSl7aWYoIWZpbGVuYW1lKXt0aHJvdyBuZXcgRXJyb3IoXCJJbnRlcm5hbCBFSlMgZXJyb3I6IG5vIGZpbGUgbmFtZSBvciB0ZW1wbGF0ZSBcIitcInByb3ZpZGVkXCIpfXRlbXBsYXRlPWZpbGVMb2FkZXIoZmlsZW5hbWUpLnRvU3RyaW5nKCkucmVwbGFjZShfQk9NLFwiXCIpfWZ1bmM9ZXhwb3J0cy5jb21waWxlKHRlbXBsYXRlLG9wdGlvbnMpO2lmKG9wdGlvbnMuY2FjaGUpe2V4cG9ydHMuY2FjaGUuc2V0KGZpbGVuYW1lLGZ1bmMpfXJldHVybiBmdW5jfWZ1bmN0aW9uIHRyeUhhbmRsZUNhY2hlKG9wdGlvbnMsZGF0YSxjYil7dmFyIHJlc3VsdDtpZighY2Ipe2lmKHR5cGVvZiBleHBvcnRzLnByb21pc2VJbXBsPT1cImZ1bmN0aW9uXCIpe3JldHVybiBuZXcgZXhwb3J0cy5wcm9taXNlSW1wbChmdW5jdGlvbihyZXNvbHZlLHJlamVjdCl7dHJ5e3Jlc3VsdD1oYW5kbGVDYWNoZShvcHRpb25zKShkYXRhKTtyZXNvbHZlKHJlc3VsdCl9Y2F0Y2goZXJyKXtyZWplY3QoZXJyKX19KX1lbHNle3Rocm93IG5ldyBFcnJvcihcIlBsZWFzZSBwcm92aWRlIGEgY2FsbGJhY2sgZnVuY3Rpb25cIil9fWVsc2V7dHJ5e3Jlc3VsdD1oYW5kbGVDYWNoZShvcHRpb25zKShkYXRhKX1jYXRjaChlcnIpe3JldHVybiBjYihlcnIpfWNiKG51bGwscmVzdWx0KX19ZnVuY3Rpb24gZmlsZUxvYWRlcihmaWxlUGF0aCl7cmV0dXJuIGV4cG9ydHMuZmlsZUxvYWRlcihmaWxlUGF0aCl9ZnVuY3Rpb24gaW5jbHVkZUZpbGUocGF0aCxvcHRpb25zKXt2YXIgb3B0cz11dGlscy5zaGFsbG93Q29weSh1dGlscy5jcmVhdGVOdWxsUHJvdG9PYmpXaGVyZVBvc3NpYmxlKCksb3B0aW9ucyk7b3B0cy5maWxlbmFtZT1nZXRJbmNsdWRlUGF0aChwYXRoLG9wdHMpO2lmKHR5cGVvZiBvcHRpb25zLmluY2x1ZGVyPT09XCJmdW5jdGlvblwiKXt2YXIgaW5jbHVkZXJSZXN1bHQ9b3B0aW9ucy5pbmNsdWRlcihwYXRoLG9wdHMuZmlsZW5hbWUpO2lmKGluY2x1ZGVyUmVzdWx0KXtpZihpbmNsdWRlclJlc3VsdC5maWxlbmFtZSl7b3B0cy5maWxlbmFtZT1pbmNsdWRlclJlc3VsdC5maWxlbmFtZX1pZihpbmNsdWRlclJlc3VsdC50ZW1wbGF0ZSl7cmV0dXJuIGhhbmRsZUNhY2hlKG9wdHMsaW5jbHVkZXJSZXN1bHQudGVtcGxhdGUpfX19cmV0dXJuIGhhbmRsZUNhY2hlKG9wdHMpfWZ1bmN0aW9uIHJldGhyb3coZXJyLHN0cixmbG5tLGxpbmVubyxlc2Mpe3ZhciBsaW5lcz1zdHIuc3BsaXQoXCJcXG5cIik7dmFyIHN0YXJ0PU1hdGgubWF4KGxpbmVuby0zLDApO3ZhciBlbmQ9TWF0aC5taW4obGluZXMubGVuZ3RoLGxpbmVubyszKTt2YXIgZmlsZW5hbWU9ZXNjKGZsbm0pO3ZhciBjb250ZXh0PWxpbmVzLnNsaWNlKHN0YXJ0LGVuZCkubWFwKGZ1bmN0aW9uKGxpbmUsaSl7dmFyIGN1cnI9aStzdGFydCsxO3JldHVybihjdXJyPT1saW5lbm8/XCIgPj4gXCI6XCIgICAgXCIpK2N1cnIrXCJ8IFwiK2xpbmV9KS5qb2luKFwiXFxuXCIpO2Vyci5wYXRoPWZpbGVuYW1lO2Vyci5tZXNzYWdlPShmaWxlbmFtZXx8XCJlanNcIikrXCI6XCIrbGluZW5vK1wiXFxuXCIrY29udGV4dCtcIlxcblxcblwiK2Vyci5tZXNzYWdlO3Rocm93IGVycn1mdW5jdGlvbiBzdHJpcFNlbWkoc3RyKXtyZXR1cm4gc3RyLnJlcGxhY2UoLzsoXFxzKiQpLyxcIiQxXCIpfWV4cG9ydHMuY29tcGlsZT1mdW5jdGlvbiBjb21waWxlKHRlbXBsYXRlLG9wdHMpe3ZhciB0ZW1wbDtpZihvcHRzJiZvcHRzLnNjb3BlKXtpZighc2NvcGVPcHRpb25XYXJuZWQpe2NvbnNvbGUud2FybihcImBzY29wZWAgb3B0aW9uIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBFSlMgM1wiKTtzY29wZU9wdGlvbldhcm5lZD10cnVlfWlmKCFvcHRzLmNvbnRleHQpe29wdHMuY29udGV4dD1vcHRzLnNjb3BlfWRlbGV0ZSBvcHRzLnNjb3BlfXRlbXBsPW5ldyBUZW1wbGF0ZSh0ZW1wbGF0ZSxvcHRzKTtyZXR1cm4gdGVtcGwuY29tcGlsZSgpfTtleHBvcnRzLnJlbmRlcj1mdW5jdGlvbih0ZW1wbGF0ZSxkLG8pe3ZhciBkYXRhPWR8fHV0aWxzLmNyZWF0ZU51bGxQcm90b09ialdoZXJlUG9zc2libGUoKTt2YXIgb3B0cz1vfHx1dGlscy5jcmVhdGVOdWxsUHJvdG9PYmpXaGVyZVBvc3NpYmxlKCk7aWYoYXJndW1lbnRzLmxlbmd0aD09Mil7dXRpbHMuc2hhbGxvd0NvcHlGcm9tTGlzdChvcHRzLGRhdGEsX09QVFNfUEFTU0FCTEVfV0lUSF9EQVRBKX1yZXR1cm4gaGFuZGxlQ2FjaGUob3B0cyx0ZW1wbGF0ZSkoZGF0YSl9O2V4cG9ydHMucmVuZGVyRmlsZT1mdW5jdGlvbigpe3ZhciBhcmdzPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7dmFyIGZpbGVuYW1lPWFyZ3Muc2hpZnQoKTt2YXIgY2I7dmFyIG9wdHM9e2ZpbGVuYW1lOmZpbGVuYW1lfTt2YXIgZGF0YTt2YXIgdmlld09wdHM7aWYodHlwZW9mIGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoLTFdPT1cImZ1bmN0aW9uXCIpe2NiPWFyZ3MucG9wKCl9aWYoYXJncy5sZW5ndGgpe2RhdGE9YXJncy5zaGlmdCgpO2lmKGFyZ3MubGVuZ3RoKXt1dGlscy5zaGFsbG93Q29weShvcHRzLGFyZ3MucG9wKCkpfWVsc2V7aWYoZGF0YS5zZXR0aW5ncyl7aWYoZGF0YS5zZXR0aW5ncy52aWV3cyl7b3B0cy52aWV3cz1kYXRhLnNldHRpbmdzLnZpZXdzfWlmKGRhdGEuc2V0dGluZ3NbXCJ2aWV3IGNhY2hlXCJdKXtvcHRzLmNhY2hlPXRydWV9dmlld09wdHM9ZGF0YS5zZXR0aW5nc1tcInZpZXcgb3B0aW9uc1wiXTtpZih2aWV3T3B0cyl7dXRpbHMuc2hhbGxvd0NvcHkob3B0cyx2aWV3T3B0cyl9fXV0aWxzLnNoYWxsb3dDb3B5RnJvbUxpc3Qob3B0cyxkYXRhLF9PUFRTX1BBU1NBQkxFX1dJVEhfREFUQV9FWFBSRVNTKX1vcHRzLmZpbGVuYW1lPWZpbGVuYW1lfWVsc2V7ZGF0YT11dGlscy5jcmVhdGVOdWxsUHJvdG9PYmpXaGVyZVBvc3NpYmxlKCl9cmV0dXJuIHRyeUhhbmRsZUNhY2hlKG9wdHMsZGF0YSxjYil9O2V4cG9ydHMuVGVtcGxhdGU9VGVtcGxhdGU7ZXhwb3J0cy5jbGVhckNhY2hlPWZ1bmN0aW9uKCl7ZXhwb3J0cy5jYWNoZS5yZXNldCgpfTtmdW5jdGlvbiBUZW1wbGF0ZSh0ZXh0LG9wdHMpe29wdHM9b3B0c3x8dXRpbHMuY3JlYXRlTnVsbFByb3RvT2JqV2hlcmVQb3NzaWJsZSgpO3ZhciBvcHRpb25zPXV0aWxzLmNyZWF0ZU51bGxQcm90b09ialdoZXJlUG9zc2libGUoKTt0aGlzLnRlbXBsYXRlVGV4dD10ZXh0O3RoaXMubW9kZT1udWxsO3RoaXMudHJ1bmNhdGU9ZmFsc2U7dGhpcy5jdXJyZW50TGluZT0xO3RoaXMuc291cmNlPVwiXCI7b3B0aW9ucy5jbGllbnQ9b3B0cy5jbGllbnR8fGZhbHNlO29wdGlvbnMuZXNjYXBlRnVuY3Rpb249b3B0cy5lc2NhcGV8fG9wdHMuZXNjYXBlRnVuY3Rpb258fHV0aWxzLmVzY2FwZVhNTDtvcHRpb25zLmNvbXBpbGVEZWJ1Zz1vcHRzLmNvbXBpbGVEZWJ1ZyE9PWZhbHNlO29wdGlvbnMuZGVidWc9ISFvcHRzLmRlYnVnO29wdGlvbnMuZmlsZW5hbWU9b3B0cy5maWxlbmFtZTtvcHRpb25zLm9wZW5EZWxpbWl0ZXI9b3B0cy5vcGVuRGVsaW1pdGVyfHxleHBvcnRzLm9wZW5EZWxpbWl0ZXJ8fF9ERUZBVUxUX09QRU5fREVMSU1JVEVSO29wdGlvbnMuY2xvc2VEZWxpbWl0ZXI9b3B0cy5jbG9zZURlbGltaXRlcnx8ZXhwb3J0cy5jbG9zZURlbGltaXRlcnx8X0RFRkFVTFRfQ0xPU0VfREVMSU1JVEVSO29wdGlvbnMuZGVsaW1pdGVyPW9wdHMuZGVsaW1pdGVyfHxleHBvcnRzLmRlbGltaXRlcnx8X0RFRkFVTFRfREVMSU1JVEVSO29wdGlvbnMuc3RyaWN0PW9wdHMuc3RyaWN0fHxmYWxzZTtvcHRpb25zLmNvbnRleHQ9b3B0cy5jb250ZXh0O29wdGlvbnMuY2FjaGU9b3B0cy5jYWNoZXx8ZmFsc2U7b3B0aW9ucy5ybVdoaXRlc3BhY2U9b3B0cy5ybVdoaXRlc3BhY2U7b3B0aW9ucy5yb290PW9wdHMucm9vdDtvcHRpb25zLmluY2x1ZGVyPW9wdHMuaW5jbHVkZXI7b3B0aW9ucy5vdXRwdXRGdW5jdGlvbk5hbWU9b3B0cy5vdXRwdXRGdW5jdGlvbk5hbWU7b3B0aW9ucy5sb2NhbHNOYW1lPW9wdHMubG9jYWxzTmFtZXx8ZXhwb3J0cy5sb2NhbHNOYW1lfHxfREVGQVVMVF9MT0NBTFNfTkFNRTtvcHRpb25zLnZpZXdzPW9wdHMudmlld3M7b3B0aW9ucy5hc3luYz1vcHRzLmFzeW5jO29wdGlvbnMuZGVzdHJ1Y3R1cmVkTG9jYWxzPW9wdHMuZGVzdHJ1Y3R1cmVkTG9jYWxzO29wdGlvbnMubGVnYWN5SW5jbHVkZT10eXBlb2Ygb3B0cy5sZWdhY3lJbmNsdWRlIT1cInVuZGVmaW5lZFwiPyEhb3B0cy5sZWdhY3lJbmNsdWRlOnRydWU7aWYob3B0aW9ucy5zdHJpY3Qpe29wdGlvbnMuX3dpdGg9ZmFsc2V9ZWxzZXtvcHRpb25zLl93aXRoPXR5cGVvZiBvcHRzLl93aXRoIT1cInVuZGVmaW5lZFwiP29wdHMuX3dpdGg6dHJ1ZX10aGlzLm9wdHM9b3B0aW9uczt0aGlzLnJlZ2V4PXRoaXMuY3JlYXRlUmVnZXgoKX1UZW1wbGF0ZS5tb2Rlcz17RVZBTDpcImV2YWxcIixFU0NBUEVEOlwiZXNjYXBlZFwiLFJBVzpcInJhd1wiLENPTU1FTlQ6XCJjb21tZW50XCIsTElURVJBTDpcImxpdGVyYWxcIn07VGVtcGxhdGUucHJvdG90eXBlPXtjcmVhdGVSZWdleDpmdW5jdGlvbigpe3ZhciBzdHI9X1JFR0VYX1NUUklORzt2YXIgZGVsaW09dXRpbHMuZXNjYXBlUmVnRXhwQ2hhcnModGhpcy5vcHRzLmRlbGltaXRlcik7dmFyIG9wZW49dXRpbHMuZXNjYXBlUmVnRXhwQ2hhcnModGhpcy5vcHRzLm9wZW5EZWxpbWl0ZXIpO3ZhciBjbG9zZT11dGlscy5lc2NhcGVSZWdFeHBDaGFycyh0aGlzLm9wdHMuY2xvc2VEZWxpbWl0ZXIpO3N0cj1zdHIucmVwbGFjZSgvJS9nLGRlbGltKS5yZXBsYWNlKC88L2csb3BlbikucmVwbGFjZSgvPi9nLGNsb3NlKTtyZXR1cm4gbmV3IFJlZ0V4cChzdHIpfSxjb21waWxlOmZ1bmN0aW9uKCl7dmFyIHNyYzt2YXIgZm47dmFyIG9wdHM9dGhpcy5vcHRzO3ZhciBwcmVwZW5kZWQ9XCJcIjt2YXIgYXBwZW5kZWQ9XCJcIjt2YXIgZXNjYXBlRm49b3B0cy5lc2NhcGVGdW5jdGlvbjt2YXIgY3Rvcjt2YXIgc2FuaXRpemVkRmlsZW5hbWU9b3B0cy5maWxlbmFtZT9KU09OLnN0cmluZ2lmeShvcHRzLmZpbGVuYW1lKTpcInVuZGVmaW5lZFwiO2lmKCF0aGlzLnNvdXJjZSl7dGhpcy5nZW5lcmF0ZVNvdXJjZSgpO3ByZXBlbmRlZCs9JyAgdmFyIF9fb3V0cHV0ID0gXCJcIjtcXG4nK1wiICBmdW5jdGlvbiBfX2FwcGVuZChzKSB7IGlmIChzICE9PSB1bmRlZmluZWQgJiYgcyAhPT0gbnVsbCkgX19vdXRwdXQgKz0gcyB9XFxuXCI7aWYob3B0cy5vdXRwdXRGdW5jdGlvbk5hbWUpe2lmKCFfSlNfSURFTlRJRklFUi50ZXN0KG9wdHMub3V0cHV0RnVuY3Rpb25OYW1lKSl7dGhyb3cgbmV3IEVycm9yKFwib3V0cHV0RnVuY3Rpb25OYW1lIGlzIG5vdCBhIHZhbGlkIEpTIGlkZW50aWZpZXIuXCIpfXByZXBlbmRlZCs9XCIgIHZhciBcIitvcHRzLm91dHB1dEZ1bmN0aW9uTmFtZStcIiA9IF9fYXBwZW5kO1wiK1wiXFxuXCJ9aWYob3B0cy5sb2NhbHNOYW1lJiYhX0pTX0lERU5USUZJRVIudGVzdChvcHRzLmxvY2Fsc05hbWUpKXt0aHJvdyBuZXcgRXJyb3IoXCJsb2NhbHNOYW1lIGlzIG5vdCBhIHZhbGlkIEpTIGlkZW50aWZpZXIuXCIpfWlmKG9wdHMuZGVzdHJ1Y3R1cmVkTG9jYWxzJiZvcHRzLmRlc3RydWN0dXJlZExvY2Fscy5sZW5ndGgpe3ZhciBkZXN0cnVjdHVyaW5nPVwiICB2YXIgX19sb2NhbHMgPSAoXCIrb3B0cy5sb2NhbHNOYW1lK1wiIHx8IHt9KSxcXG5cIjtmb3IodmFyIGk9MDtpPG9wdHMuZGVzdHJ1Y3R1cmVkTG9jYWxzLmxlbmd0aDtpKyspe3ZhciBuYW1lPW9wdHMuZGVzdHJ1Y3R1cmVkTG9jYWxzW2ldO2lmKCFfSlNfSURFTlRJRklFUi50ZXN0KG5hbWUpKXt0aHJvdyBuZXcgRXJyb3IoXCJkZXN0cnVjdHVyZWRMb2NhbHNbXCIraStcIl0gaXMgbm90IGEgdmFsaWQgSlMgaWRlbnRpZmllci5cIil9aWYoaT4wKXtkZXN0cnVjdHVyaW5nKz1cIixcXG4gIFwifWRlc3RydWN0dXJpbmcrPW5hbWUrXCIgPSBfX2xvY2Fscy5cIituYW1lfXByZXBlbmRlZCs9ZGVzdHJ1Y3R1cmluZytcIjtcXG5cIn1pZihvcHRzLl93aXRoIT09ZmFsc2Upe3ByZXBlbmRlZCs9XCIgIHdpdGggKFwiK29wdHMubG9jYWxzTmFtZStcIiB8fCB7fSkge1wiK1wiXFxuXCI7YXBwZW5kZWQrPVwiICB9XCIrXCJcXG5cIn1hcHBlbmRlZCs9XCIgIHJldHVybiBfX291dHB1dDtcIitcIlxcblwiO3RoaXMuc291cmNlPXByZXBlbmRlZCt0aGlzLnNvdXJjZSthcHBlbmRlZH1pZihvcHRzLmNvbXBpbGVEZWJ1Zyl7c3JjPVwidmFyIF9fbGluZSA9IDFcIitcIlxcblwiK1wiICAsIF9fbGluZXMgPSBcIitKU09OLnN0cmluZ2lmeSh0aGlzLnRlbXBsYXRlVGV4dCkrXCJcXG5cIitcIiAgLCBfX2ZpbGVuYW1lID0gXCIrc2FuaXRpemVkRmlsZW5hbWUrXCI7XCIrXCJcXG5cIitcInRyeSB7XCIrXCJcXG5cIit0aGlzLnNvdXJjZStcIn0gY2F0Y2ggKGUpIHtcIitcIlxcblwiK1wiICByZXRocm93KGUsIF9fbGluZXMsIF9fZmlsZW5hbWUsIF9fbGluZSwgZXNjYXBlRm4pO1wiK1wiXFxuXCIrXCJ9XCIrXCJcXG5cIn1lbHNle3NyYz10aGlzLnNvdXJjZX1pZihvcHRzLmNsaWVudCl7c3JjPVwiZXNjYXBlRm4gPSBlc2NhcGVGbiB8fCBcIitlc2NhcGVGbi50b1N0cmluZygpK1wiO1wiK1wiXFxuXCIrc3JjO2lmKG9wdHMuY29tcGlsZURlYnVnKXtzcmM9XCJyZXRocm93ID0gcmV0aHJvdyB8fCBcIityZXRocm93LnRvU3RyaW5nKCkrXCI7XCIrXCJcXG5cIitzcmN9fWlmKG9wdHMuc3RyaWN0KXtzcmM9J1widXNlIHN0cmljdFwiO1xcbicrc3JjfWlmKG9wdHMuZGVidWcpe2NvbnNvbGUubG9nKHNyYyl9aWYob3B0cy5jb21waWxlRGVidWcmJm9wdHMuZmlsZW5hbWUpe3NyYz1zcmMrXCJcXG5cIitcIi8vIyBzb3VyY2VVUkw9XCIrc2FuaXRpemVkRmlsZW5hbWUrXCJcXG5cIn10cnl7aWYob3B0cy5hc3luYyl7dHJ5e2N0b3I9bmV3IEZ1bmN0aW9uKFwicmV0dXJuIChhc3luYyBmdW5jdGlvbigpe30pLmNvbnN0cnVjdG9yO1wiKSgpfWNhdGNoKGUpe2lmKGUgaW5zdGFuY2VvZiBTeW50YXhFcnJvcil7dGhyb3cgbmV3IEVycm9yKFwiVGhpcyBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IGFzeW5jL2F3YWl0XCIpfWVsc2V7dGhyb3cgZX19fWVsc2V7Y3Rvcj1GdW5jdGlvbn1mbj1uZXcgY3RvcihvcHRzLmxvY2Fsc05hbWUrXCIsIGVzY2FwZUZuLCBpbmNsdWRlLCByZXRocm93XCIsc3JjKX1jYXRjaChlKXtpZihlIGluc3RhbmNlb2YgU3ludGF4RXJyb3Ipe2lmKG9wdHMuZmlsZW5hbWUpe2UubWVzc2FnZSs9XCIgaW4gXCIrb3B0cy5maWxlbmFtZX1lLm1lc3NhZ2UrPVwiIHdoaWxlIGNvbXBpbGluZyBlanNcXG5cXG5cIjtlLm1lc3NhZ2UrPVwiSWYgdGhlIGFib3ZlIGVycm9yIGlzIG5vdCBoZWxwZnVsLCB5b3UgbWF5IHdhbnQgdG8gdHJ5IEVKUy1MaW50OlxcblwiO2UubWVzc2FnZSs9XCJodHRwczovL2dpdGh1Yi5jb20vUnlhblppbS9FSlMtTGludFwiO2lmKCFvcHRzLmFzeW5jKXtlLm1lc3NhZ2UrPVwiXFxuXCI7ZS5tZXNzYWdlKz1cIk9yLCBpZiB5b3UgbWVhbnQgdG8gY3JlYXRlIGFuIGFzeW5jIGZ1bmN0aW9uLCBwYXNzIGBhc3luYzogdHJ1ZWAgYXMgYW4gb3B0aW9uLlwifX10aHJvdyBlfXZhciByZXR1cm5lZEZuPW9wdHMuY2xpZW50P2ZuOmZ1bmN0aW9uIGFub255bW91cyhkYXRhKXt2YXIgaW5jbHVkZT1mdW5jdGlvbihwYXRoLGluY2x1ZGVEYXRhKXt2YXIgZD11dGlscy5zaGFsbG93Q29weSh1dGlscy5jcmVhdGVOdWxsUHJvdG9PYmpXaGVyZVBvc3NpYmxlKCksZGF0YSk7aWYoaW5jbHVkZURhdGEpe2Q9dXRpbHMuc2hhbGxvd0NvcHkoZCxpbmNsdWRlRGF0YSl9cmV0dXJuIGluY2x1ZGVGaWxlKHBhdGgsb3B0cykoZCl9O3JldHVybiBmbi5hcHBseShvcHRzLmNvbnRleHQsW2RhdGF8fHV0aWxzLmNyZWF0ZU51bGxQcm90b09ialdoZXJlUG9zc2libGUoKSxlc2NhcGVGbixpbmNsdWRlLHJldGhyb3ddKX07aWYob3B0cy5maWxlbmFtZSYmdHlwZW9mIE9iamVjdC5kZWZpbmVQcm9wZXJ0eT09PVwiZnVuY3Rpb25cIil7dmFyIGZpbGVuYW1lPW9wdHMuZmlsZW5hbWU7dmFyIGJhc2VuYW1lPXBhdGguYmFzZW5hbWUoZmlsZW5hbWUscGF0aC5leHRuYW1lKGZpbGVuYW1lKSk7dHJ5e09iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXR1cm5lZEZuLFwibmFtZVwiLHt2YWx1ZTpiYXNlbmFtZSx3cml0YWJsZTpmYWxzZSxlbnVtZXJhYmxlOmZhbHNlLGNvbmZpZ3VyYWJsZTp0cnVlfSl9Y2F0Y2goZSl7fX1yZXR1cm4gcmV0dXJuZWRGbn0sZ2VuZXJhdGVTb3VyY2U6ZnVuY3Rpb24oKXt2YXIgb3B0cz10aGlzLm9wdHM7aWYob3B0cy5ybVdoaXRlc3BhY2Upe3RoaXMudGVtcGxhdGVUZXh0PXRoaXMudGVtcGxhdGVUZXh0LnJlcGxhY2UoL1tcXHJcXG5dKy9nLFwiXFxuXCIpLnJlcGxhY2UoL15cXHMrfFxccyskL2dtLFwiXCIpfXRoaXMudGVtcGxhdGVUZXh0PXRoaXMudGVtcGxhdGVUZXh0LnJlcGxhY2UoL1sgXFx0XSo8JV8vZ20sXCI8JV9cIikucmVwbGFjZSgvXyU+WyBcXHRdKi9nbSxcIl8lPlwiKTt2YXIgc2VsZj10aGlzO3ZhciBtYXRjaGVzPXRoaXMucGFyc2VUZW1wbGF0ZVRleHQoKTt2YXIgZD10aGlzLm9wdHMuZGVsaW1pdGVyO3ZhciBvPXRoaXMub3B0cy5vcGVuRGVsaW1pdGVyO3ZhciBjPXRoaXMub3B0cy5jbG9zZURlbGltaXRlcjtpZihtYXRjaGVzJiZtYXRjaGVzLmxlbmd0aCl7bWF0Y2hlcy5mb3JFYWNoKGZ1bmN0aW9uKGxpbmUsaW5kZXgpe3ZhciBjbG9zaW5nO2lmKGxpbmUuaW5kZXhPZihvK2QpPT09MCYmbGluZS5pbmRleE9mKG8rZCtkKSE9PTApe2Nsb3Npbmc9bWF0Y2hlc1tpbmRleCsyXTtpZighKGNsb3Npbmc9PWQrY3x8Y2xvc2luZz09XCItXCIrZCtjfHxjbG9zaW5nPT1cIl9cIitkK2MpKXt0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIG1hdGNoaW5nIGNsb3NlIHRhZyBmb3IgXCInK2xpbmUrJ1wiLicpfX1zZWxmLnNjYW5MaW5lKGxpbmUpfSl9fSxwYXJzZVRlbXBsYXRlVGV4dDpmdW5jdGlvbigpe3ZhciBzdHI9dGhpcy50ZW1wbGF0ZVRleHQ7dmFyIHBhdD10aGlzLnJlZ2V4O3ZhciByZXN1bHQ9cGF0LmV4ZWMoc3RyKTt2YXIgYXJyPVtdO3ZhciBmaXJzdFBvczt3aGlsZShyZXN1bHQpe2ZpcnN0UG9zPXJlc3VsdC5pbmRleDtpZihmaXJzdFBvcyE9PTApe2Fyci5wdXNoKHN0ci5zdWJzdHJpbmcoMCxmaXJzdFBvcykpO3N0cj1zdHIuc2xpY2UoZmlyc3RQb3MpfWFyci5wdXNoKHJlc3VsdFswXSk7c3RyPXN0ci5zbGljZShyZXN1bHRbMF0ubGVuZ3RoKTtyZXN1bHQ9cGF0LmV4ZWMoc3RyKX1pZihzdHIpe2Fyci5wdXNoKHN0cil9cmV0dXJuIGFycn0sX2FkZE91dHB1dDpmdW5jdGlvbihsaW5lKXtpZih0aGlzLnRydW5jYXRlKXtsaW5lPWxpbmUucmVwbGFjZSgvXig/OlxcclxcbnxcXHJ8XFxuKS8sXCJcIik7dGhpcy50cnVuY2F0ZT1mYWxzZX1pZighbGluZSl7cmV0dXJuIGxpbmV9bGluZT1saW5lLnJlcGxhY2UoL1xcXFwvZyxcIlxcXFxcXFxcXCIpO2xpbmU9bGluZS5yZXBsYWNlKC9cXG4vZyxcIlxcXFxuXCIpO2xpbmU9bGluZS5yZXBsYWNlKC9cXHIvZyxcIlxcXFxyXCIpO2xpbmU9bGluZS5yZXBsYWNlKC9cIi9nLCdcXFxcXCInKTt0aGlzLnNvdXJjZSs9JyAgICA7IF9fYXBwZW5kKFwiJytsaW5lKydcIiknK1wiXFxuXCJ9LHNjYW5MaW5lOmZ1bmN0aW9uKGxpbmUpe3ZhciBzZWxmPXRoaXM7dmFyIGQ9dGhpcy5vcHRzLmRlbGltaXRlcjt2YXIgbz10aGlzLm9wdHMub3BlbkRlbGltaXRlcjt2YXIgYz10aGlzLm9wdHMuY2xvc2VEZWxpbWl0ZXI7dmFyIG5ld0xpbmVDb3VudD0wO25ld0xpbmVDb3VudD1saW5lLnNwbGl0KFwiXFxuXCIpLmxlbmd0aC0xO3N3aXRjaChsaW5lKXtjYXNlIG8rZDpjYXNlIG8rZCtcIl9cIjp0aGlzLm1vZGU9VGVtcGxhdGUubW9kZXMuRVZBTDticmVhaztjYXNlIG8rZCtcIj1cIjp0aGlzLm1vZGU9VGVtcGxhdGUubW9kZXMuRVNDQVBFRDticmVhaztjYXNlIG8rZCtcIi1cIjp0aGlzLm1vZGU9VGVtcGxhdGUubW9kZXMuUkFXO2JyZWFrO2Nhc2UgbytkK1wiI1wiOnRoaXMubW9kZT1UZW1wbGF0ZS5tb2Rlcy5DT01NRU5UO2JyZWFrO2Nhc2UgbytkK2Q6dGhpcy5tb2RlPVRlbXBsYXRlLm1vZGVzLkxJVEVSQUw7dGhpcy5zb3VyY2UrPScgICAgOyBfX2FwcGVuZChcIicrbGluZS5yZXBsYWNlKG8rZCtkLG8rZCkrJ1wiKScrXCJcXG5cIjticmVhaztjYXNlIGQrZCtjOnRoaXMubW9kZT1UZW1wbGF0ZS5tb2Rlcy5MSVRFUkFMO3RoaXMuc291cmNlKz0nICAgIDsgX19hcHBlbmQoXCInK2xpbmUucmVwbGFjZShkK2QrYyxkK2MpKydcIiknK1wiXFxuXCI7YnJlYWs7Y2FzZSBkK2M6Y2FzZVwiLVwiK2QrYzpjYXNlXCJfXCIrZCtjOmlmKHRoaXMubW9kZT09VGVtcGxhdGUubW9kZXMuTElURVJBTCl7dGhpcy5fYWRkT3V0cHV0KGxpbmUpfXRoaXMubW9kZT1udWxsO3RoaXMudHJ1bmNhdGU9bGluZS5pbmRleE9mKFwiLVwiKT09PTB8fGxpbmUuaW5kZXhPZihcIl9cIik9PT0wO2JyZWFrO2RlZmF1bHQ6aWYodGhpcy5tb2RlKXtzd2l0Y2godGhpcy5tb2RlKXtjYXNlIFRlbXBsYXRlLm1vZGVzLkVWQUw6Y2FzZSBUZW1wbGF0ZS5tb2Rlcy5FU0NBUEVEOmNhc2UgVGVtcGxhdGUubW9kZXMuUkFXOmlmKGxpbmUubGFzdEluZGV4T2YoXCIvL1wiKT5saW5lLmxhc3RJbmRleE9mKFwiXFxuXCIpKXtsaW5lKz1cIlxcblwifX1zd2l0Y2godGhpcy5tb2RlKXtjYXNlIFRlbXBsYXRlLm1vZGVzLkVWQUw6dGhpcy5zb3VyY2UrPVwiICAgIDsgXCIrbGluZStcIlxcblwiO2JyZWFrO2Nhc2UgVGVtcGxhdGUubW9kZXMuRVNDQVBFRDp0aGlzLnNvdXJjZSs9XCIgICAgOyBfX2FwcGVuZChlc2NhcGVGbihcIitzdHJpcFNlbWkobGluZSkrXCIpKVwiK1wiXFxuXCI7YnJlYWs7Y2FzZSBUZW1wbGF0ZS5tb2Rlcy5SQVc6dGhpcy5zb3VyY2UrPVwiICAgIDsgX19hcHBlbmQoXCIrc3RyaXBTZW1pKGxpbmUpK1wiKVwiK1wiXFxuXCI7YnJlYWs7Y2FzZSBUZW1wbGF0ZS5tb2Rlcy5DT01NRU5UOmJyZWFrO2Nhc2UgVGVtcGxhdGUubW9kZXMuTElURVJBTDp0aGlzLl9hZGRPdXRwdXQobGluZSk7YnJlYWt9fWVsc2V7dGhpcy5fYWRkT3V0cHV0KGxpbmUpfX1pZihzZWxmLm9wdHMuY29tcGlsZURlYnVnJiZuZXdMaW5lQ291bnQpe3RoaXMuY3VycmVudExpbmUrPW5ld0xpbmVDb3VudDt0aGlzLnNvdXJjZSs9XCIgICAgOyBfX2xpbmUgPSBcIit0aGlzLmN1cnJlbnRMaW5lK1wiXFxuXCJ9fX07ZXhwb3J0cy5lc2NhcGVYTUw9dXRpbHMuZXNjYXBlWE1MO2V4cG9ydHMuX19leHByZXNzPWV4cG9ydHMucmVuZGVyRmlsZTtleHBvcnRzLlZFUlNJT049X1ZFUlNJT05fU1RSSU5HO2V4cG9ydHMubmFtZT1fTkFNRTtpZih0eXBlb2Ygd2luZG93IT1cInVuZGVmaW5lZFwiKXt3aW5kb3cuZWpzPWV4cG9ydHN9fSx7XCIuLi9wYWNrYWdlLmpzb25cIjo2LFwiLi91dGlsc1wiOjIsZnM6MyxwYXRoOjR9XSwyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcInVzZSBzdHJpY3RcIjt2YXIgcmVnRXhwQ2hhcnM9L1t8XFxcXHt9KClbXFxdXiQrKj8uXS9nO3ZhciBoYXNPd25Qcm9wZXJ0eT1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O3ZhciBoYXNPd249ZnVuY3Rpb24ob2JqLGtleSl7cmV0dXJuIGhhc093blByb3BlcnR5LmFwcGx5KG9iaixba2V5XSl9O2V4cG9ydHMuZXNjYXBlUmVnRXhwQ2hhcnM9ZnVuY3Rpb24oc3RyaW5nKXtpZighc3RyaW5nKXtyZXR1cm5cIlwifXJldHVybiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlZ0V4cENoYXJzLFwiXFxcXCQmXCIpfTt2YXIgX0VOQ09ERV9IVE1MX1JVTEVTPXtcIiZcIjpcIiZhbXA7XCIsXCI8XCI6XCImbHQ7XCIsXCI+XCI6XCImZ3Q7XCIsJ1wiJzpcIiYjMzQ7XCIsXCInXCI6XCImIzM5O1wifTt2YXIgX01BVENIX0hUTUw9L1smPD4nXCJdL2c7ZnVuY3Rpb24gZW5jb2RlX2NoYXIoYyl7cmV0dXJuIF9FTkNPREVfSFRNTF9SVUxFU1tjXXx8Y312YXIgZXNjYXBlRnVuY1N0cj1cInZhciBfRU5DT0RFX0hUTUxfUlVMRVMgPSB7XFxuXCIrJyAgICAgIFwiJlwiOiBcIiZhbXA7XCJcXG4nKycgICAgLCBcIjxcIjogXCImbHQ7XCJcXG4nKycgICAgLCBcIj5cIjogXCImZ3Q7XCJcXG4nKycgICAgLCBcXCdcIlxcJzogXCImIzM0O1wiXFxuJysnICAgICwgXCJcXCdcIjogXCImIzM5O1wiXFxuJytcIiAgICB9XFxuXCIrXCIgICwgX01BVENIX0hUTUwgPSAvWyY8PidcXFwiXS9nO1xcblwiK1wiZnVuY3Rpb24gZW5jb2RlX2NoYXIoYykge1xcblwiK1wiICByZXR1cm4gX0VOQ09ERV9IVE1MX1JVTEVTW2NdIHx8IGM7XFxuXCIrXCJ9O1xcblwiO2V4cG9ydHMuZXNjYXBlWE1MPWZ1bmN0aW9uKG1hcmt1cCl7cmV0dXJuIG1hcmt1cD09dW5kZWZpbmVkP1wiXCI6U3RyaW5nKG1hcmt1cCkucmVwbGFjZShfTUFUQ0hfSFRNTCxlbmNvZGVfY2hhcil9O2Z1bmN0aW9uIGVzY2FwZVhNTFRvU3RyaW5nKCl7cmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaXMpK1wiO1xcblwiK2VzY2FwZUZ1bmNTdHJ9dHJ5e2lmKHR5cGVvZiBPYmplY3QuZGVmaW5lUHJvcGVydHk9PT1cImZ1bmN0aW9uXCIpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmVzY2FwZVhNTCxcInRvU3RyaW5nXCIse3ZhbHVlOmVzY2FwZVhNTFRvU3RyaW5nfSl9ZWxzZXtleHBvcnRzLmVzY2FwZVhNTC50b1N0cmluZz1lc2NhcGVYTUxUb1N0cmluZ319Y2F0Y2goZXJyKXtjb25zb2xlLndhcm4oXCJVbmFibGUgdG8gc2V0IGVzY2FwZVhNTC50b1N0cmluZyAoaXMgdGhlIEZ1bmN0aW9uIHByb3RvdHlwZSBmcm96ZW4/KVwiKX1leHBvcnRzLnNoYWxsb3dDb3B5PWZ1bmN0aW9uKHRvLGZyb20pe2Zyb209ZnJvbXx8e307aWYodG8hPT1udWxsJiZ0byE9PXVuZGVmaW5lZCl7Zm9yKHZhciBwIGluIGZyb20pe2lmKCFoYXNPd24oZnJvbSxwKSl7Y29udGludWV9aWYocD09PVwiX19wcm90b19fXCJ8fHA9PT1cImNvbnN0cnVjdG9yXCIpe2NvbnRpbnVlfXRvW3BdPWZyb21bcF19fXJldHVybiB0b307ZXhwb3J0cy5zaGFsbG93Q29weUZyb21MaXN0PWZ1bmN0aW9uKHRvLGZyb20sbGlzdCl7bGlzdD1saXN0fHxbXTtmcm9tPWZyb218fHt9O2lmKHRvIT09bnVsbCYmdG8hPT11bmRlZmluZWQpe2Zvcih2YXIgaT0wO2k8bGlzdC5sZW5ndGg7aSsrKXt2YXIgcD1saXN0W2ldO2lmKHR5cGVvZiBmcm9tW3BdIT1cInVuZGVmaW5lZFwiKXtpZighaGFzT3duKGZyb20scCkpe2NvbnRpbnVlfWlmKHA9PT1cIl9fcHJvdG9fX1wifHxwPT09XCJjb25zdHJ1Y3RvclwiKXtjb250aW51ZX10b1twXT1mcm9tW3BdfX19cmV0dXJuIHRvfTtleHBvcnRzLmNhY2hlPXtfZGF0YTp7fSxzZXQ6ZnVuY3Rpb24oa2V5LHZhbCl7dGhpcy5fZGF0YVtrZXldPXZhbH0sZ2V0OmZ1bmN0aW9uKGtleSl7cmV0dXJuIHRoaXMuX2RhdGFba2V5XX0scmVtb3ZlOmZ1bmN0aW9uKGtleSl7ZGVsZXRlIHRoaXMuX2RhdGFba2V5XX0scmVzZXQ6ZnVuY3Rpb24oKXt0aGlzLl9kYXRhPXt9fX07ZXhwb3J0cy5oeXBoZW5Ub0NhbWVsPWZ1bmN0aW9uKHN0cil7cmV0dXJuIHN0ci5yZXBsYWNlKC8tW2Etel0vZyxmdW5jdGlvbihtYXRjaCl7cmV0dXJuIG1hdGNoWzFdLnRvVXBwZXJDYXNlKCl9KX07ZXhwb3J0cy5jcmVhdGVOdWxsUHJvdG9PYmpXaGVyZVBvc3NpYmxlPWZ1bmN0aW9uKCl7aWYodHlwZW9mIE9iamVjdC5jcmVhdGU9PVwiZnVuY3Rpb25cIil7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5jcmVhdGUobnVsbCl9fWlmKCEoe19fcHJvdG9fXzpudWxsfWluc3RhbmNlb2YgT2JqZWN0KSl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJue19fcHJvdG9fXzpudWxsfX19cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJue319fSgpfSx7fV0sMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7fSx7fV0sNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHByb2Nlc3Mpe2Z1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KHBhcnRzLGFsbG93QWJvdmVSb290KXt2YXIgdXA9MDtmb3IodmFyIGk9cGFydHMubGVuZ3RoLTE7aT49MDtpLS0pe3ZhciBsYXN0PXBhcnRzW2ldO2lmKGxhc3Q9PT1cIi5cIil7cGFydHMuc3BsaWNlKGksMSl9ZWxzZSBpZihsYXN0PT09XCIuLlwiKXtwYXJ0cy5zcGxpY2UoaSwxKTt1cCsrfWVsc2UgaWYodXApe3BhcnRzLnNwbGljZShpLDEpO3VwLS19fWlmKGFsbG93QWJvdmVSb290KXtmb3IoO3VwLS07dXApe3BhcnRzLnVuc2hpZnQoXCIuLlwiKX19cmV0dXJuIHBhcnRzfWV4cG9ydHMucmVzb2x2ZT1mdW5jdGlvbigpe3ZhciByZXNvbHZlZFBhdGg9XCJcIixyZXNvbHZlZEFic29sdXRlPWZhbHNlO2Zvcih2YXIgaT1hcmd1bWVudHMubGVuZ3RoLTE7aT49LTEmJiFyZXNvbHZlZEFic29sdXRlO2ktLSl7dmFyIHBhdGg9aT49MD9hcmd1bWVudHNbaV06cHJvY2Vzcy5jd2QoKTtpZih0eXBlb2YgcGF0aCE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5nc1wiKX1lbHNlIGlmKCFwYXRoKXtjb250aW51ZX1yZXNvbHZlZFBhdGg9cGF0aCtcIi9cIityZXNvbHZlZFBhdGg7cmVzb2x2ZWRBYnNvbHV0ZT1wYXRoLmNoYXJBdCgwKT09PVwiL1wifXJlc29sdmVkUGF0aD1ub3JtYWxpemVBcnJheShmaWx0ZXIocmVzb2x2ZWRQYXRoLnNwbGl0KFwiL1wiKSxmdW5jdGlvbihwKXtyZXR1cm4hIXB9KSwhcmVzb2x2ZWRBYnNvbHV0ZSkuam9pbihcIi9cIik7cmV0dXJuKHJlc29sdmVkQWJzb2x1dGU/XCIvXCI6XCJcIikrcmVzb2x2ZWRQYXRofHxcIi5cIn07ZXhwb3J0cy5ub3JtYWxpemU9ZnVuY3Rpb24ocGF0aCl7dmFyIGlzQWJzb2x1dGU9ZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpLHRyYWlsaW5nU2xhc2g9c3Vic3RyKHBhdGgsLTEpPT09XCIvXCI7cGF0aD1ub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdChcIi9cIiksZnVuY3Rpb24ocCl7cmV0dXJuISFwfSksIWlzQWJzb2x1dGUpLmpvaW4oXCIvXCIpO2lmKCFwYXRoJiYhaXNBYnNvbHV0ZSl7cGF0aD1cIi5cIn1pZihwYXRoJiZ0cmFpbGluZ1NsYXNoKXtwYXRoKz1cIi9cIn1yZXR1cm4oaXNBYnNvbHV0ZT9cIi9cIjpcIlwiKStwYXRofTtleHBvcnRzLmlzQWJzb2x1dGU9ZnVuY3Rpb24ocGF0aCl7cmV0dXJuIHBhdGguY2hhckF0KDApPT09XCIvXCJ9O2V4cG9ydHMuam9pbj1mdW5jdGlvbigpe3ZhciBwYXRocz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMCk7cmV0dXJuIGV4cG9ydHMubm9ybWFsaXplKGZpbHRlcihwYXRocyxmdW5jdGlvbihwLGluZGV4KXtpZih0eXBlb2YgcCE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudHMgdG8gcGF0aC5qb2luIG11c3QgYmUgc3RyaW5nc1wiKX1yZXR1cm4gcH0pLmpvaW4oXCIvXCIpKX07ZXhwb3J0cy5yZWxhdGl2ZT1mdW5jdGlvbihmcm9tLHRvKXtmcm9tPWV4cG9ydHMucmVzb2x2ZShmcm9tKS5zdWJzdHIoMSk7dG89ZXhwb3J0cy5yZXNvbHZlKHRvKS5zdWJzdHIoMSk7ZnVuY3Rpb24gdHJpbShhcnIpe3ZhciBzdGFydD0wO2Zvcig7c3RhcnQ8YXJyLmxlbmd0aDtzdGFydCsrKXtpZihhcnJbc3RhcnRdIT09XCJcIilicmVha312YXIgZW5kPWFyci5sZW5ndGgtMTtmb3IoO2VuZD49MDtlbmQtLSl7aWYoYXJyW2VuZF0hPT1cIlwiKWJyZWFrfWlmKHN0YXJ0PmVuZClyZXR1cm5bXTtyZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LGVuZC1zdGFydCsxKX12YXIgZnJvbVBhcnRzPXRyaW0oZnJvbS5zcGxpdChcIi9cIikpO3ZhciB0b1BhcnRzPXRyaW0odG8uc3BsaXQoXCIvXCIpKTt2YXIgbGVuZ3RoPU1hdGgubWluKGZyb21QYXJ0cy5sZW5ndGgsdG9QYXJ0cy5sZW5ndGgpO3ZhciBzYW1lUGFydHNMZW5ndGg9bGVuZ3RoO2Zvcih2YXIgaT0wO2k8bGVuZ3RoO2krKyl7aWYoZnJvbVBhcnRzW2ldIT09dG9QYXJ0c1tpXSl7c2FtZVBhcnRzTGVuZ3RoPWk7YnJlYWt9fXZhciBvdXRwdXRQYXJ0cz1bXTtmb3IodmFyIGk9c2FtZVBhcnRzTGVuZ3RoO2k8ZnJvbVBhcnRzLmxlbmd0aDtpKyspe291dHB1dFBhcnRzLnB1c2goXCIuLlwiKX1vdXRwdXRQYXJ0cz1vdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtyZXR1cm4gb3V0cHV0UGFydHMuam9pbihcIi9cIil9O2V4cG9ydHMuc2VwPVwiL1wiO2V4cG9ydHMuZGVsaW1pdGVyPVwiOlwiO2V4cG9ydHMuZGlybmFtZT1mdW5jdGlvbihwYXRoKXtpZih0eXBlb2YgcGF0aCE9PVwic3RyaW5nXCIpcGF0aD1wYXRoK1wiXCI7aWYocGF0aC5sZW5ndGg9PT0wKXJldHVyblwiLlwiO3ZhciBjb2RlPXBhdGguY2hhckNvZGVBdCgwKTt2YXIgaGFzUm9vdD1jb2RlPT09NDc7dmFyIGVuZD0tMTt2YXIgbWF0Y2hlZFNsYXNoPXRydWU7Zm9yKHZhciBpPXBhdGgubGVuZ3RoLTE7aT49MTstLWkpe2NvZGU9cGF0aC5jaGFyQ29kZUF0KGkpO2lmKGNvZGU9PT00Nyl7aWYoIW1hdGNoZWRTbGFzaCl7ZW5kPWk7YnJlYWt9fWVsc2V7bWF0Y2hlZFNsYXNoPWZhbHNlfX1pZihlbmQ9PT0tMSlyZXR1cm4gaGFzUm9vdD9cIi9cIjpcIi5cIjtpZihoYXNSb290JiZlbmQ9PT0xKXtyZXR1cm5cIi9cIn1yZXR1cm4gcGF0aC5zbGljZSgwLGVuZCl9O2Z1bmN0aW9uIGJhc2VuYW1lKHBhdGgpe2lmKHR5cGVvZiBwYXRoIT09XCJzdHJpbmdcIilwYXRoPXBhdGgrXCJcIjt2YXIgc3RhcnQ9MDt2YXIgZW5kPS0xO3ZhciBtYXRjaGVkU2xhc2g9dHJ1ZTt2YXIgaTtmb3IoaT1wYXRoLmxlbmd0aC0xO2k+PTA7LS1pKXtpZihwYXRoLmNoYXJDb2RlQXQoaSk9PT00Nyl7aWYoIW1hdGNoZWRTbGFzaCl7c3RhcnQ9aSsxO2JyZWFrfX1lbHNlIGlmKGVuZD09PS0xKXttYXRjaGVkU2xhc2g9ZmFsc2U7ZW5kPWkrMX19aWYoZW5kPT09LTEpcmV0dXJuXCJcIjtyZXR1cm4gcGF0aC5zbGljZShzdGFydCxlbmQpfWV4cG9ydHMuYmFzZW5hbWU9ZnVuY3Rpb24ocGF0aCxleHQpe3ZhciBmPWJhc2VuYW1lKHBhdGgpO2lmKGV4dCYmZi5zdWJzdHIoLTEqZXh0Lmxlbmd0aCk9PT1leHQpe2Y9Zi5zdWJzdHIoMCxmLmxlbmd0aC1leHQubGVuZ3RoKX1yZXR1cm4gZn07ZXhwb3J0cy5leHRuYW1lPWZ1bmN0aW9uKHBhdGgpe2lmKHR5cGVvZiBwYXRoIT09XCJzdHJpbmdcIilwYXRoPXBhdGgrXCJcIjt2YXIgc3RhcnREb3Q9LTE7dmFyIHN0YXJ0UGFydD0wO3ZhciBlbmQ9LTE7dmFyIG1hdGNoZWRTbGFzaD10cnVlO3ZhciBwcmVEb3RTdGF0ZT0wO2Zvcih2YXIgaT1wYXRoLmxlbmd0aC0xO2k+PTA7LS1pKXt2YXIgY29kZT1wYXRoLmNoYXJDb2RlQXQoaSk7aWYoY29kZT09PTQ3KXtpZighbWF0Y2hlZFNsYXNoKXtzdGFydFBhcnQ9aSsxO2JyZWFrfWNvbnRpbnVlfWlmKGVuZD09PS0xKXttYXRjaGVkU2xhc2g9ZmFsc2U7ZW5kPWkrMX1pZihjb2RlPT09NDYpe2lmKHN0YXJ0RG90PT09LTEpc3RhcnREb3Q9aTtlbHNlIGlmKHByZURvdFN0YXRlIT09MSlwcmVEb3RTdGF0ZT0xfWVsc2UgaWYoc3RhcnREb3QhPT0tMSl7cHJlRG90U3RhdGU9LTF9fWlmKHN0YXJ0RG90PT09LTF8fGVuZD09PS0xfHxwcmVEb3RTdGF0ZT09PTB8fHByZURvdFN0YXRlPT09MSYmc3RhcnREb3Q9PT1lbmQtMSYmc3RhcnREb3Q9PT1zdGFydFBhcnQrMSl7cmV0dXJuXCJcIn1yZXR1cm4gcGF0aC5zbGljZShzdGFydERvdCxlbmQpfTtmdW5jdGlvbiBmaWx0ZXIoeHMsZil7aWYoeHMuZmlsdGVyKXJldHVybiB4cy5maWx0ZXIoZik7dmFyIHJlcz1bXTtmb3IodmFyIGk9MDtpPHhzLmxlbmd0aDtpKyspe2lmKGYoeHNbaV0saSx4cykpcmVzLnB1c2goeHNbaV0pfXJldHVybiByZXN9dmFyIHN1YnN0cj1cImFiXCIuc3Vic3RyKC0xKT09PVwiYlwiP2Z1bmN0aW9uKHN0cixzdGFydCxsZW4pe3JldHVybiBzdHIuc3Vic3RyKHN0YXJ0LGxlbil9OmZ1bmN0aW9uKHN0cixzdGFydCxsZW4pe2lmKHN0YXJ0PDApc3RhcnQ9c3RyLmxlbmd0aCtzdGFydDtyZXR1cm4gc3RyLnN1YnN0cihzdGFydCxsZW4pfX0pLmNhbGwodGhpcyxyZXF1aXJlKFwiX3Byb2Nlc3NcIikpfSx7X3Byb2Nlc3M6NX1dLDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe3ZhciBwcm9jZXNzPW1vZHVsZS5leHBvcnRzPXt9O3ZhciBjYWNoZWRTZXRUaW1lb3V0O3ZhciBjYWNoZWRDbGVhclRpbWVvdXQ7ZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpe3Rocm93IG5ldyBFcnJvcihcInNldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9ZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCgpe3Rocm93IG5ldyBFcnJvcihcImNsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKX0oZnVuY3Rpb24oKXt0cnl7aWYodHlwZW9mIHNldFRpbWVvdXQ9PT1cImZ1bmN0aW9uXCIpe2NhY2hlZFNldFRpbWVvdXQ9c2V0VGltZW91dH1lbHNle2NhY2hlZFNldFRpbWVvdXQ9ZGVmYXVsdFNldFRpbW91dH19Y2F0Y2goZSl7Y2FjaGVkU2V0VGltZW91dD1kZWZhdWx0U2V0VGltb3V0fXRyeXtpZih0eXBlb2YgY2xlYXJUaW1lb3V0PT09XCJmdW5jdGlvblwiKXtjYWNoZWRDbGVhclRpbWVvdXQ9Y2xlYXJUaW1lb3V0fWVsc2V7Y2FjaGVkQ2xlYXJUaW1lb3V0PWRlZmF1bHRDbGVhclRpbWVvdXR9fWNhdGNoKGUpe2NhY2hlZENsZWFyVGltZW91dD1kZWZhdWx0Q2xlYXJUaW1lb3V0fX0pKCk7ZnVuY3Rpb24gcnVuVGltZW91dChmdW4pe2lmKGNhY2hlZFNldFRpbWVvdXQ9PT1zZXRUaW1lb3V0KXtyZXR1cm4gc2V0VGltZW91dChmdW4sMCl9aWYoKGNhY2hlZFNldFRpbWVvdXQ9PT1kZWZhdWx0U2V0VGltb3V0fHwhY2FjaGVkU2V0VGltZW91dCkmJnNldFRpbWVvdXQpe2NhY2hlZFNldFRpbWVvdXQ9c2V0VGltZW91dDtyZXR1cm4gc2V0VGltZW91dChmdW4sMCl9dHJ5e3JldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwwKX1jYXRjaChlKXt0cnl7cmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLGZ1biwwKX1jYXRjaChlKXtyZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsZnVuLDApfX19ZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcil7aWYoY2FjaGVkQ2xlYXJUaW1lb3V0PT09Y2xlYXJUaW1lb3V0KXtyZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcil9aWYoKGNhY2hlZENsZWFyVGltZW91dD09PWRlZmF1bHRDbGVhclRpbWVvdXR8fCFjYWNoZWRDbGVhclRpbWVvdXQpJiZjbGVhclRpbWVvdXQpe2NhY2hlZENsZWFyVGltZW91dD1jbGVhclRpbWVvdXQ7cmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpfXRyeXtyZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcil9Y2F0Y2goZSl7dHJ5e3JldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLG1hcmtlcil9Y2F0Y2goZSl7cmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsbWFya2VyKX19fXZhciBxdWV1ZT1bXTt2YXIgZHJhaW5pbmc9ZmFsc2U7dmFyIGN1cnJlbnRRdWV1ZTt2YXIgcXVldWVJbmRleD0tMTtmdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKXtpZighZHJhaW5pbmd8fCFjdXJyZW50UXVldWUpe3JldHVybn1kcmFpbmluZz1mYWxzZTtpZihjdXJyZW50UXVldWUubGVuZ3RoKXtxdWV1ZT1jdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKX1lbHNle3F1ZXVlSW5kZXg9LTF9aWYocXVldWUubGVuZ3RoKXtkcmFpblF1ZXVlKCl9fWZ1bmN0aW9uIGRyYWluUXVldWUoKXtpZihkcmFpbmluZyl7cmV0dXJufXZhciB0aW1lb3V0PXJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtkcmFpbmluZz10cnVlO3ZhciBsZW49cXVldWUubGVuZ3RoO3doaWxlKGxlbil7Y3VycmVudFF1ZXVlPXF1ZXVlO3F1ZXVlPVtdO3doaWxlKCsrcXVldWVJbmRleDxsZW4pe2lmKGN1cnJlbnRRdWV1ZSl7Y3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpfX1xdWV1ZUluZGV4PS0xO2xlbj1xdWV1ZS5sZW5ndGh9Y3VycmVudFF1ZXVlPW51bGw7ZHJhaW5pbmc9ZmFsc2U7cnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpfXByb2Nlc3MubmV4dFRpY2s9ZnVuY3Rpb24oZnVuKXt2YXIgYXJncz1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKTtpZihhcmd1bWVudHMubGVuZ3RoPjEpe2Zvcih2YXIgaT0xO2k8YXJndW1lbnRzLmxlbmd0aDtpKyspe2FyZ3NbaS0xXT1hcmd1bWVudHNbaV19fXF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLGFyZ3MpKTtpZihxdWV1ZS5sZW5ndGg9PT0xJiYhZHJhaW5pbmcpe3J1blRpbWVvdXQoZHJhaW5RdWV1ZSl9fTtmdW5jdGlvbiBJdGVtKGZ1bixhcnJheSl7dGhpcy5mdW49ZnVuO3RoaXMuYXJyYXk9YXJyYXl9SXRlbS5wcm90b3R5cGUucnVuPWZ1bmN0aW9uKCl7dGhpcy5mdW4uYXBwbHkobnVsbCx0aGlzLmFycmF5KX07cHJvY2Vzcy50aXRsZT1cImJyb3dzZXJcIjtwcm9jZXNzLmJyb3dzZXI9dHJ1ZTtwcm9jZXNzLmVudj17fTtwcm9jZXNzLmFyZ3Y9W107cHJvY2Vzcy52ZXJzaW9uPVwiXCI7cHJvY2Vzcy52ZXJzaW9ucz17fTtmdW5jdGlvbiBub29wKCl7fXByb2Nlc3Mub249bm9vcDtwcm9jZXNzLmFkZExpc3RlbmVyPW5vb3A7cHJvY2Vzcy5vbmNlPW5vb3A7cHJvY2Vzcy5vZmY9bm9vcDtwcm9jZXNzLnJlbW92ZUxpc3RlbmVyPW5vb3A7cHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnM9bm9vcDtwcm9jZXNzLmVtaXQ9bm9vcDtwcm9jZXNzLnByZXBlbmRMaXN0ZW5lcj1ub29wO3Byb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lcj1ub29wO3Byb2Nlc3MubGlzdGVuZXJzPWZ1bmN0aW9uKG5hbWUpe3JldHVybltdfTtwcm9jZXNzLmJpbmRpbmc9ZnVuY3Rpb24obmFtZSl7dGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcIil9O3Byb2Nlc3MuY3dkPWZ1bmN0aW9uKCl7cmV0dXJuXCIvXCJ9O3Byb2Nlc3MuY2hkaXI9ZnVuY3Rpb24oZGlyKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWRcIil9O3Byb2Nlc3MudW1hc2s9ZnVuY3Rpb24oKXtyZXR1cm4gMH19LHt9XSw2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXttb2R1bGUuZXhwb3J0cz17bmFtZTpcImVqc1wiLGRlc2NyaXB0aW9uOlwiRW1iZWRkZWQgSmF2YVNjcmlwdCB0ZW1wbGF0ZXNcIixrZXl3b3JkczpbXCJ0ZW1wbGF0ZVwiLFwiZW5naW5lXCIsXCJlanNcIl0sdmVyc2lvbjpcIjMuMS45XCIsYXV0aG9yOlwiTWF0dGhldyBFZXJuaXNzZSA8bWRlQGZsZWVnaXgub3JnPiAoaHR0cDovL2ZsZWVnaXgub3JnKVwiLGxpY2Vuc2U6XCJBcGFjaGUtMi4wXCIsYmluOntlanM6XCIuL2Jpbi9jbGkuanNcIn0sbWFpbjpcIi4vbGliL2Vqcy5qc1wiLGpzZGVsaXZyOlwiZWpzLm1pbi5qc1wiLHVucGtnOlwiZWpzLm1pbi5qc1wiLHJlcG9zaXRvcnk6e3R5cGU6XCJnaXRcIix1cmw6XCJnaXQ6Ly9naXRodWIuY29tL21kZS9lanMuZ2l0XCJ9LGJ1Z3M6XCJodHRwczovL2dpdGh1Yi5jb20vbWRlL2Vqcy9pc3N1ZXNcIixob21lcGFnZTpcImh0dHBzOi8vZ2l0aHViLmNvbS9tZGUvZWpzXCIsZGVwZW5kZW5jaWVzOntqYWtlOlwiXjEwLjguNVwifSxkZXZEZXBlbmRlbmNpZXM6e2Jyb3dzZXJpZnk6XCJeMTYuNS4xXCIsZXNsaW50OlwiXjYuOC4wXCIsXCJnaXQtZGlyZWN0b3J5LWRlcGxveVwiOlwiXjEuNS4xXCIsanNkb2M6XCJeNC4wLjJcIixcImxydS1jYWNoZVwiOlwiXjQuMC4xXCIsbW9jaGE6XCJeMTAuMi4wXCIsXCJ1Z2xpZnktanNcIjpcIl4zLjMuMTZcIn0sZW5naW5lczp7bm9kZTpcIj49MC4xMC4wXCJ9LHNjcmlwdHM6e3Rlc3Q6XCJtb2NoYSAtdSB0ZGRcIn19fSx7fV19LHt9LFsxXSkoMSl9KTtcbiIsICJ7XG4gIFwiZW5cIjoge1xuICAgIFwicHJvbm91bnNcIjogW1wibXlcIiwgXCJJXCIsIFwibWVcIiwgXCJtaW5lXCIsIFwib3VyXCIsIFwib3Vyc1wiLCBcInVzXCIsIFwid2VcIl0sXG4gICAgXCJwcm9tcHRcIjogXCJCYXNlZCBvbiB5b3VyIG5vdGVzXCIsXG4gICAgXCJpbml0aWFsX21lc3NhZ2VcIjogXCJIaSwgSSdtIENoYXRHUFQgd2l0aCBhY2Nlc3MgdG8geW91ciBub3RlcyB2aWEgU21hcnQgQ29ubmVjdGlvbnMuIEFzayBtZSBhIHF1ZXN0aW9uIGFib3V0IHlvdXIgbm90ZXMgYW5kIEknbGwgdHJ5IHRvIGFuc3dlciBpdC5cIlxuICB9LFxuICBcImVzXCI6IHtcbiAgICBcInByb25vdW5zXCI6IFtcIm1pXCIsIFwieW9cIiwgXCJtXHUwMEVEXCIsIFwidFx1MDBGQVwiXSxcbiAgICBcInByb21wdFwiOiBcIkJhc1x1MDBFMW5kb3NlIGVuIHN1cyBub3Rhc1wiLFxuICAgIFwiaW5pdGlhbF9tZXNzYWdlXCI6IFwiSG9sYSwgc295IENoYXRHUFQgY29uIGFjY2VzbyBhIHR1cyBhcHVudGVzIGEgdHJhdlx1MDBFOXMgZGUgU21hcnQgQ29ubmVjdGlvbnMuIEhhem1lIHVuYSBwcmVndW50YSBzb2JyZSB0dXMgYXB1bnRlcyBlIGludGVudGFyXHUwMEU5IHJlc3BvbmRlcnRlLlwiXG4gIH0sXG4gIFwiZnJcIjoge1xuICAgIFwicHJvbm91bnNcIjogW1wibWVcIiwgXCJtb25cIiwgXCJtYVwiLCBcIm1lc1wiLCBcIm1vaVwiLCBcIm5vdXNcIiwgXCJub3RyZVwiLCBcIm5vc1wiLCBcImplXCIsIFwiaidcIiwgXCJtJ1wiXSxcbiAgICBcInByb21wdFwiOiBcIkQnYXByXHUwMEU4cyB2b3Mgbm90ZXNcIixcbiAgICBcImluaXRpYWxfbWVzc2FnZVwiOiBcIkJvbmpvdXIsIGplIHN1aXMgQ2hhdEdQVCBldCBqJ2FpIGFjY1x1MDBFOHMgXHUwMEUwIHZvcyBub3RlcyB2aWEgU21hcnQgQ29ubmVjdGlvbnMuIFBvc2V6LW1vaSB1bmUgcXVlc3Rpb24gc3VyIHZvcyBub3RlcyBldCBqJ2Vzc2FpZXJhaSBkJ3kgclx1MDBFOXBvbmRyZS5cIlxuICB9LFxuICBcImRlXCI6IHtcbiAgICBcInByb25vdW5zXCI6IFtcIm1laW5cIiwgXCJtZWluZVwiLCBcIm1laW5lblwiLCBcIm1laW5lclwiLCBcIm1laW5lc1wiLCBcIm1pclwiLCBcInVuc1wiLCBcInVuc2VyXCIsIFwidW5zZXJlblwiLCBcInVuc2VyZXJcIiwgXCJ1bnNlcmVzXCJdLFxuICAgIFwicHJvbXB0XCI6IFwiQmFzaWVyZW5kIGF1ZiBJaHJlbiBOb3RpemVuXCIsXG4gICAgXCJpbml0aWFsX21lc3NhZ2VcIjogXCJIYWxsbywgaWNoIGJpbiBDaGF0R1BUIHVuZCBoYWJlIFx1MDBGQ2JlciBTbWFydCBDb25uZWN0aW9ucyBadWdhbmcgenUgSWhyZW4gTm90aXplbi4gU3RlbGxlbiBTaWUgbWlyIGVpbmUgRnJhZ2UgenUgSWhyZW4gTm90aXplbiB1bmQgaWNoIHdlcmRlIHZlcnN1Y2hlbiwgc2llIHp1IGJlYW50d29ydGVuLlwiXG4gIH0sXG4gIFwiaXRcIjoge1xuICAgIFwicHJvbm91bnNcIjogW1wibWlvXCIsIFwibWlhXCIsIFwibWllaVwiLCBcIm1pZVwiLCBcIm5vaVwiLCBcIm5vc3Ryb1wiLCBcIm5vc3RyaVwiLCBcIm5vc3RyYVwiLCBcIm5vc3RyZVwiXSxcbiAgICBcInByb21wdFwiOiBcIlN1bGxhIGJhc2UgZGVnbGkgYXBwdW50aVwiLFxuICAgIFwiaW5pdGlhbF9tZXNzYWdlXCI6IFwiQ2lhbywgc29ubyBDaGF0R1BUIGUgaG8gYWNjZXNzbyBhaSB0dW9pIGFwcHVudGkgdHJhbWl0ZSBTbWFydCBDb25uZWN0aW9ucy4gRmF0ZW1pIHVuYSBkb21hbmRhIHN1aSB2b3N0cmkgYXBwdW50aSBlIGNlcmNoZXJcdTAwRjIgZGkgcmlzcG9uZGVydmkuXCJcbiAgfVxufSIsICIvKipcbiAqIEFudGhyb3BpY0FkYXB0ZXIgY2xhc3MgcHJvdmlkZXMgbWV0aG9kcyB0byBhZGFwdCB0aGUgY2hhdCBtb2RlbCBpbnRlcmFjdGlvbnMgc3BlY2lmaWNhbGx5IGZvciB0aGUgQW50aHJvcGljIG1vZGVsLlxuICogSXQgaW5jbHVkZXMgbWV0aG9kcyB0byBwcmVwYXJlIHJlcXVlc3QgYm9kaWVzLCBjb3VudCBhbmQgZXN0aW1hdGUgdG9rZW5zLCBhbmQgaGFuZGxlIHRvb2wgY2FsbHMgYW5kIG1lc3NhZ2VzLlxuICovXG5jbGFzcyBBbnRocm9waWNBZGFwdGVyIHtcbiAgLyoqXG4gICAqIFByZXBhcmVzIHRoZSByZXF1ZXN0IGJvZHkgZm9yIHRoZSBBbnRocm9waWMgQVBJIGJ5IGNvbnZlcnRpbmcgQ2hhdE1MIGZvcm1hdCB0byBhIGZvcm1hdCBjb21wYXRpYmxlIHdpdGggQW50aHJvcGljLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIFRoZSBvcHRpb25zIG9iamVjdCBjb250YWluaW5nIG1lc3NhZ2VzIGFuZCBvdGhlciBwYXJhbWV0ZXJzIGluIENoYXRNTCBmb3JtYXQuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSByZXF1ZXN0IGJvZHkgZm9ybWF0dGVkIGZvciB0aGUgQW50aHJvcGljIEFQSS5cbiAgICovXG4gIHByZXBhcmVfcmVxdWVzdF9ib2R5KG9wdHMpIHsgcmV0dXJuIGNoYXRtbF90b19hbnRocm9waWMob3B0cyk7IH1cbiAgLyoqXG4gICAqIENvdW50cyB0aGUgdG9rZW5zIGluIHRoZSBpbnB1dCBieSBlc3RpbWF0aW5nIHRoZW0sIGFzIHRoZSBBbnRocm9waWMgbW9kZWwgZG9lcyBub3QgcHJvdmlkZSBhIGRpcmVjdCBtZXRob2QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gaW5wdXQgLSBUaGUgaW5wdXQgdGV4dCBvciBvYmplY3QgdG8gY291bnQgdG9rZW5zIGluLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxudW1iZXI+fSBUaGUgZXN0aW1hdGVkIG51bWJlciBvZiB0b2tlbnMgaW4gdGhlIGlucHV0LlxuICAgKi9cbiAgYXN5bmMgY291bnRfdG9rZW5zKGlucHV0KSB7XG4gICAgLy8gQ3VycmVudGx5LCB0aGUgQW50aHJvcGljIG1vZGVsIGRvZXMgbm90IHByb3ZpZGUgYSB3YXkgdG8gY291bnQgdG9rZW5zXG4gICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVfdG9rZW5zKGlucHV0KTtcbiAgfVxuICAvKipcbiAgICogRXN0aW1hdGVzIHRoZSBudW1iZXIgb2YgdG9rZW5zIGluIHRoZSBpbnB1dCBiYXNlZCBvbiBhIHJvdWdoIGF2ZXJhZ2UgdG9rZW4gc2l6ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBpbnB1dCAtIFRoZSBpbnB1dCB0ZXh0IG9yIG9iamVjdCB0byBlc3RpbWF0ZSB0b2tlbnMgaW4uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBlc3RpbWF0ZWQgbnVtYmVyIG9mIHRva2Vucy5cbiAgICovXG4gIGVzdGltYXRlX3Rva2VucyhpbnB1dCl7XG4gICAgaWYodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JykgaW5wdXQgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgLy8gTm90ZTogVGhlIGRpdmlzaW9uIGJ5IDYgaXMgYSByb3VnaCBlc3RpbWF0ZSBiYXNlZCBvbiBvYnNlcnZlZCBhdmVyYWdlIHRva2VuIHNpemUuXG4gICAgcmV0dXJuIE1hdGguY2VpbChpbnB1dC5sZW5ndGggLyA2KTsgLy8gVXNlIE1hdGguY2VpbCBmb3IgYSBtb3JlIGFjY3VyYXRlIGNvdW50XG4gIH1cbiAgLyoqXG4gICAqIEV4dHJhY3RzIHRoZSBmaXJzdCB0b29sIGNhbGwgZnJvbSB0aGUgSlNPTiByZXNwb25zZSBjb250ZW50LlxuICAgKiBAcGFyYW0ge09iamVjdH0ganNvbiAtIFRoZSBKU09OIHJlc3BvbnNlIGZyb20gd2hpY2ggdG8gZXh0cmFjdCB0aGUgdG9vbCBjYWxsLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9IFRoZSBmaXJzdCB0b29sIGNhbGwgZm91bmQsIG9yIG51bGwgaWYgbm9uZSBleGlzdC5cbiAgICovXG4gIGdldF90b29sX2NhbGwoanNvbil7XG4gICAgcmV0dXJuIGpzb24uY29udGVudC5maW5kKG1zZyA9PiBtc2cudHlwZSA9PT0gJ3Rvb2xfdXNlJyk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgaW5wdXQgY29udGVudCBvZiBhIHRvb2wgY2FsbC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHRvb2xfY2FsbCAtIFRoZSB0b29sIGNhbGwgb2JqZWN0IGZyb20gd2hpY2ggdG8gZXh0cmFjdCB0aGUgaW5wdXQuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBpbnB1dCBvZiB0aGUgdG9vbCBjYWxsLlxuICAgKi9cbiAgZ2V0X3Rvb2xfY2FsbF9jb250ZW50KHRvb2xfY2FsbCl7XG4gICAgcmV0dXJuIHRvb2xfY2FsbC5pbnB1dDtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBuYW1lIG9mIHRoZSB0b29sIGZyb20gYSB0b29sIGNhbGwgb2JqZWN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gdG9vbF9jYWxsIC0gVGhlIHRvb2wgY2FsbCBvYmplY3QgZnJvbSB3aGljaCB0byBleHRyYWN0IHRoZSBuYW1lLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgdG9vbC5cbiAgICovXG4gIGdldF90b29sX25hbWUodG9vbF9jYWxsKXtcbiAgICByZXR1cm4gdG9vbF9jYWxsLm5hbWU7XG4gIH1cbiAgLyoqXG4gICAqIEV4dHJhY3RzIHRoZSBmaXJzdCBtZXNzYWdlIGZyb20gdGhlIEpTT04gcmVzcG9uc2UgY29udGVudC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGpzb24gLSBUaGUgSlNPTiByZXNwb25zZSBmcm9tIHdoaWNoIHRvIGV4dHJhY3QgdGhlIG1lc3NhZ2UuXG4gICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH0gVGhlIGZpcnN0IG1lc3NhZ2UgZm91bmQsIG9yIG51bGwgaWYgbm9uZSBleGlzdC5cbiAgICovXG4gIGdldF9tZXNzYWdlKGpzb24peyByZXR1cm4ganNvbi5jb250ZW50Py5bMF07IH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgY29udGVudCBvZiB0aGUgZmlyc3QgbWVzc2FnZSBmcm9tIHRoZSBKU09OIHJlc3BvbnNlLlxuICAgKiBAcGFyYW0ge09iamVjdH0ganNvbiAtIFRoZSBKU09OIHJlc3BvbnNlIGZyb20gd2hpY2ggdG8gZXh0cmFjdCB0aGUgbWVzc2FnZSBjb250ZW50LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IFRoZSBjb250ZW50IG9mIHRoZSBmaXJzdCBtZXNzYWdlLCBvciBudWxsIGlmIG5vIG1lc3NhZ2UgaXMgZm91bmQuXG4gICAqL1xuICBnZXRfbWVzc2FnZV9jb250ZW50KGpzb24pIHsgcmV0dXJuIHRoaXMuZ2V0X21lc3NhZ2UoanNvbik/Llt0aGlzLmdldF9tZXNzYWdlKGpzb24pPy50eXBlXTsgfVxufVxuZXhwb3J0cy5BbnRocm9waWNBZGFwdGVyID0gQW50aHJvcGljQWRhcHRlcjtcbi8vIGh0dHBzOi8vZG9jcy5hbnRocm9waWMuY29tL2NsYXVkZS9yZWZlcmVuY2UvbWVzc2FnZXNfcG9zdFxuLyoqXG4gKiBDb252ZXJ0IGEgQ2hhdE1MIG9iamVjdCB0byBhbiBBbnRocm9waWMgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIFRoZSBDaGF0TUwgb2JqZWN0XG4gKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiBjb252ZXJ0cyBhIENoYXRNTCBvYmplY3QgdG8gYW4gQW50aHJvcGljIG9iamVjdC4gSXQgZmlsdGVycyBvdXQgc3lzdGVtIG1lc3NhZ2VzIGFuZCBhZGRzIGEgc3lzdGVtIG1lc3NhZ2UgcHJpb3IgdG8gdGhlIGxhc3QgdXNlciBtZXNzYWdlLlxuICogQHJldHVybnMge09iamVjdH0gLSBUaGUgQW50aHJvcGljIG9iamVjdFxuICovXG5mdW5jdGlvbiBjaGF0bWxfdG9fYW50aHJvcGljKG9wdHMpIHtcbiAgY29uc3QgbWVzc2FnZXMgPSBvcHRzLm1lc3NhZ2VzXG4gICAgLmZpbHRlcihtc2cgPT4gbXNnLnJvbGUgIT09ICdzeXN0ZW0nKVxuICAgIC5tYXAobSA9PiB7XG4gICAgICBpZih0eXBlb2YgbS5jb250ZW50ID09PSAnc3RyaW5nJykgcmV0dXJuIHsgcm9sZTogbS5yb2xlLCBjb250ZW50OiBtLmNvbnRlbnQgfTtcbiAgICAgIGlmKEFycmF5LmlzQXJyYXkobS5jb250ZW50KSl7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBtLmNvbnRlbnQuZmlsdGVyKGMgPT4gYy50eXBlID09PSAndGV4dCcpLm1hcChjID0+IGMudGV4dCkuam9pbignXFxuJyk7XG4gICAgICAgIHJldHVybiB7IHJvbGU6IG0ucm9sZSwgY29udGVudCB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG07XG4gICAgfSlcbiAgO1xuICBjb25zdCB7IG1vZGVsLCBtYXhfdG9rZW5zLCB0ZW1wZXJhdHVyZSwgdG9vbHMsIH0gPSBvcHRzO1xuICAvLyBETzogaGFuZGxlZCBiZXR0ZXIgKFNtYXJ0IENvbm5lY3Rpb25zIHNwZWNpZmljKVxuICAvLyBnZXQgaW5kZXggb2YgbGFzdCBzeXN0ZW0gbWVzc2FnZVxuICBjb25zdCBsYXN0X3N5c3RlbV9pZHggPSBvcHRzLm1lc3NhZ2VzLmZpbmRMYXN0SW5kZXgobXNnID0+IG1zZy5yb2xlID09PSAnc3lzdGVtJyAmJiBtc2cuY29udGVudC5pbmNsdWRlcygnLS0tQkVHSU4nKSk7XG4gIGlmIChsYXN0X3N5c3RlbV9pZHggPiAtMSkge1xuICAgIGNvbnN0IHN5c3RlbV9wcm9tcHQgPSAnPGNvbnRleHQ+XFxuJyArIG9wdHMubWVzc2FnZXNbbGFzdF9zeXN0ZW1faWR4XS5jb250ZW50ICsgJ1xcbjwvY29udGV4dD5cXG4nO1xuICAgIG1lc3NhZ2VzW21lc3NhZ2VzLmxlbmd0aCAtIDFdLmNvbnRlbnQgPSBzeXN0ZW1fcHJvbXB0ICsgbWVzc2FnZXNbbWVzc2FnZXMubGVuZ3RoIC0gMV0uY29udGVudDtcbiAgfVxuICBjb25zb2xlLmxvZyhtZXNzYWdlcyk7XG4gIGNvbnN0IG91dCA9IHtcbiAgICBtZXNzYWdlcyxcbiAgICBtb2RlbCxcbiAgICBtYXhfdG9rZW5zLFxuICAgIHRlbXBlcmF0dXJlLFxuICB9XG4gIGlmKHRvb2xzKXtcbiAgICBvdXQudG9vbHMgPSB0b29scy5tYXAodG9vbCA9PiAoe1xuICAgICAgbmFtZTogdG9vbC5mdW5jdGlvbi5uYW1lLFxuICAgICAgZGVzY3JpcHRpb246IHRvb2wuZnVuY3Rpb24uZGVzY3JpcHRpb24sXG4gICAgICBpbnB1dF9zY2hlbWE6IHRvb2wuZnVuY3Rpb24ucGFyYW1ldGVycyxcbiAgICB9KSk7XG4gICAgLy8gYWRkIFwiVXNlIHRoZSAke3Rvb2wubmFtZX0gdG9vbFwiIHRvIHRoZSBsYXN0IHVzZXIgbWVzc2FnZVxuICAgIGNvbnN0IHRvb2xfcHJvbXB0ID0gYFVzZSB0aGUgXCIke291dC50b29sc1swXS5uYW1lfVwiIHRvb2whYDtcbiAgICBjb25zdCBsYXN0X3VzZXJfaWR4ID0gb3V0Lm1lc3NhZ2VzLmZpbmRMYXN0SW5kZXgobXNnID0+IG1zZy5yb2xlID09PSAndXNlcicpO1xuICAgIG91dC5tZXNzYWdlc1tsYXN0X3VzZXJfaWR4XS5jb250ZW50ICs9ICdcXG4nICsgdG9vbF9wcm9tcHQ7XG4gICAgb3V0LnN5c3RlbSA9IGBSZXF1aXJlZDogdXNlIHRoZSBcIiR7b3V0LnRvb2xzWzBdLm5hbWV9XCIgdG9vbCFgO1xuICB9XG4gIC8vIERPOiBoYW5kbGVkIGJldHRlciAoU21hcnQgQ29ubmVjdGlvbnMgc3BlY2lmaWMpXG4gIC8vIGlmIHN5c3RlbSBtZXNzYWdlIGV4aXN0cyBwcmlvciB0byBsYXN0X3N5c3RlbV9pZHggQU5EIGRvZXMgbm90IGluY2x1ZGUgXCItLS1CRUdJTlwiIHRoZW4gYWRkIHRvIGJvZHkuc3lzdGVtXG4gIGNvbnN0IGxhc3Rfbm9uX2NvbnRleHRfc3lzdGVtX2lkeCA9IG9wdHMubWVzc2FnZXMuZmluZExhc3RJbmRleChtc2cgPT4gbXNnLnJvbGUgPT09ICdzeXN0ZW0nICYmICFtc2cuY29udGVudC5pbmNsdWRlcygnLS0tQkVHSU4nKSk7XG4gIGlmKGxhc3Rfbm9uX2NvbnRleHRfc3lzdGVtX2lkeCA+IC0xKSBvdXQuc3lzdGVtID0gb3B0cy5tZXNzYWdlc1tsYXN0X25vbl9jb250ZXh0X3N5c3RlbV9pZHhdLmNvbnRlbnQ7XG4gIHJldHVybiBvdXQ7XG59XG5leHBvcnRzLmNoYXRtbF90b19hbnRocm9waWMgPSBjaGF0bWxfdG9fYW50aHJvcGljO1xuXG4iLCAiLyoqXG4gKiBDb2hlcmVBZGFwdGVyIGNsYXNzIGlzIGRlc2lnbmVkIHRvIGFkYXB0IHRoZSBTbWFydENoYXRNb2RlbCdzIGludGVyYWN0aW9uIHdpdGggdGhlIENvaGVyZSBBUEkuXG4gKiBJdCBwcm92aWRlcyBtZXRob2RzIHRvIHByZXBhcmUgcmVxdWVzdCBib2RpZXMsIGhhbmRsZSBzdHJlYW1pbmcgZGF0YSwgYW5kIGV4dHJhY3QgbWVzc2FnZSBjb250ZW50IGZyb20gcmVzcG9uc2VzLlxuICovXG5jbGFzcyBDb2hlcmVBZGFwdGVyIHtcbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgQ2hhdE1MIG9iamVjdCB0byBhIGZvcm1hdCBzdWl0YWJsZSBmb3IgYSByZXF1ZXN0IHRvIHRoZSBDb2hlcmUgQVBJLlxuICAgKiBAcGFyYW0ge09iamVjdH0gY2hhdG1sIC0gVGhlIENoYXRNTCBvYmplY3QgY29udGFpbmluZyB0aGUgY2hhdCBoaXN0b3J5IGFuZCBvdGhlciBwYXJhbWV0ZXJzLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcmVxdWVzdCBib2R5IGZvcm1hdHRlZCBmb3IgdGhlIENvaGVyZSBBUEkuXG4gICAqL1xuICBwcmVwYXJlX3JlcXVlc3RfYm9keShjaGF0bWwpIHsgcmV0dXJuIGNoYXRtbF90b19jb2hlcmUoY2hhdG1sKTsgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0cyB0aGUgbWVzc2FnZSBjb250ZW50IGZyb20gYSBKU09OIHJlc3BvbnNlIGZyb20gdGhlIENvaGVyZSBBUEkuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBqc29uIC0gVGhlIEpTT04gcmVzcG9uc2Ugb2JqZWN0IGZyb20gd2hpY2ggdG8gZXh0cmFjdCB0aGUgdGV4dCBjb250ZW50LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZXh0cmFjdGVkIHRleHQgY29udGVudCBmcm9tIHRoZSByZXNwb25zZS5cbiAgICovXG4gIGdldF9tZXNzYWdlX2NvbnRlbnQoanNvbikgeyByZXR1cm4ganNvbi50ZXh0OyB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3NlcyBzdHJlYW1pbmcgZGF0YSByZWNlaXZlZCBmcm9tIHRoZSBDb2hlcmUgQVBJIGFuZCBleHRyYWN0cyB0ZXh0IGNodW5rcy5cbiAgICogVGhpcyBtZXRob2QgaGFuZGxlcyB0aGUgYWNjdW11bGF0aW9uIG9mIHRleHQgZGF0YSBvdmVyIG11bHRpcGxlIGV2ZW50cyBhbmQgbWFuYWdlcyB0aGUgc3RhdGUgb2YgdGhlIHN0cmVhbS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gVGhlIGV2ZW50IG9iamVjdCBjb250YWluaW5nIHN0cmVhbWluZyBkYXRhLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgYWNjdW11bGF0ZWQgdGV4dCBjaHVuayBleHRyYWN0ZWQgZnJvbSB0aGUgc3RyZWFtLlxuICAgKi9cbiAgZ2V0X3RleHRfY2h1bmtfZnJvbV9zdHJlYW0oZXZlbnQpIHtcbiAgICBpZighdGhpcy5sYXN0X2xpbmVfaW5kZXgpIHRoaXMubGFzdF9saW5lX2luZGV4ID0gMDtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5sYXN0X2xpbmVfdGltZW91dCk7XG4gICAgdGhpcy5sYXN0X2xpbmVfdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmxhc3RfbGluZV9pbmRleCA9IDA7XG4gICAgfSwgMTAwMDApO1xuICAgIGNvbnN0IGRhdGEgPSBldmVudC5zb3VyY2UueGhyLnJlc3BvbnNlVGV4dDtcbiAgICAvLyBzcGxpdCBieSBuZXdsaW5lIGFuZCBnZXQgbGFzdFxuICAgIGNvbnN0IGxpbmVzID0gZGF0YS5zcGxpdCgnXFxuJykuc2xpY2UodGhpcy5sYXN0X2xpbmVfaW5kZXgpO1xuICAgIGNvbnNvbGUubG9nKGxpbmVzKTtcbiAgICB0aGlzLmxhc3RfbGluZV9pbmRleCArPSBsaW5lcy5sZW5ndGg7XG4gICAgY29uc3QgdGV4dF9jaHVuayA9IGxpbmVzXG4gICAgICAgIC5maWx0ZXIoKGxpbmUpID0+IGxpbmUudHJpbSgpICE9PSAnJylcbiAgICAgICAgLm1hcCgobGluZSkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2cobGluZSk7XG4gICAgICAgICAgICBjb25zdCBqc29uID0gSlNPTi5wYXJzZShsaW5lKTtcbiAgICAgICAgICAgIGlmKGpzb24uZXZlbnRfdHlwZSA9PT0gJ3N0cmVhbS1lbmQnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3N0cmVhbS1lbmQnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZF9vZl9zdHJlYW0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZF9vZl9zdHJlYW0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LCAzMDAwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ganNvbi50ZXh0O1xuICAgICAgICB9KVxuICAgICAgICAuam9pbignJyk7XG4gICAgY29uc29sZS5sb2codGV4dF9jaHVuayk7XG4gICAgcmV0dXJuIHRleHRfY2h1bms7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiB0aGUgZW5kIG9mIHRoZSBzdHJlYW0gaGFzIGJlZW4gcmVhY2hlZCBiYXNlZCBvbiB0aGUgZXZlbnQgZGF0YS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gVGhlIGV2ZW50IG9iamVjdCB0aGF0IG1heSBpbmRpY2F0ZSB0aGUgZW5kIG9mIHRoZSBzdHJlYW0uXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBlbmQgb2YgdGhlIHN0cmVhbSBpcyBpbmRpY2F0ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzX2VuZF9vZl9zdHJlYW0oZXZlbnQpIHsgcmV0dXJuIHRoaXMuZW5kX29mX3N0cmVhbTsgfVxufVxuZXhwb3J0cy5Db2hlcmVBZGFwdGVyID0gQ29oZXJlQWRhcHRlcjtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIENoYXRNTCBvYmplY3QgaW50byBhIGZvcm1hdCBzdWl0YWJsZSBmb3IgdGhlIENvaGVyZSBBUEkuXG4gKiBUaGlzIGZ1bmN0aW9uIHByZXBhcmVzIHRoZSBkYXRhIGJ5IHN0cnVjdHVyaW5nIGl0IGFjY29yZGluZyB0byB0aGUgcmVxdWlyZW1lbnRzIG9mIHRoZSBDb2hlcmUgQVBJLFxuICogaW5jbHVkaW5nIHRoZSBtb2RlbCB0byB1c2UsIHRoZSBjaGF0IGhpc3RvcnkgZXhjbHVkaW5nIHRoZSBsYXN0IHVzZXIgbWVzc2FnZSwgYW5kIHRoZSBsYXN0IG1lc3NhZ2Ugc2VwYXJhdGVseS5cbiAqIFxuICogQHBhcmFtIHtPYmplY3R9IGNoYXRtbCAtIFRoZSBDaGF0TUwgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG1vZGVsLCBtZXNzYWdlcywgYW5kIG90aGVyIHBhcmFtZXRlcnMgbGlrZSB0ZW1wZXJhdHVyZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBmb3JtYXR0ZWQgb2JqZWN0IGZvciB0aGUgQ29oZXJlIEFQSSByZXF1ZXN0LCBjb250YWluaW5nIHRoZSBtb2RlbCwgY2hhdCBoaXN0b3J5LCBsYXN0IG1lc3NhZ2UsIGFuZCB0ZW1wZXJhdHVyZS5cbiAqL1xuZnVuY3Rpb24gY2hhdG1sX3RvX2NvaGVyZShjaGF0bWwpIHtcbiAgICBjb25zdCBjb2hlcmUgPSB7XG4gICAgICAgIG1vZGVsOiBjaGF0bWwubW9kZWwsXG4gICAgICAgIC8vIHNraXAgbGFzdCB1c2VyIG1lc3NhZ2VcbiAgICAgICAgY2hhdF9oaXN0b3J5OiBjaGF0bWwubWVzc2FnZXNcbiAgICAgICAgICAgIC5zbGljZSgwLCAtMSlcbiAgICAgICAgICAgIC5tYXAoKG1lc3NhZ2UpID0+ICh7XG4gICAgICAgICAgICAgICAgcm9sZTogbWVzc2FnZS5yb2xlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHBhcnNlX21lc3NhZ2VfY29udGVudF90b19zdHJpbmcobWVzc2FnZSksXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgLFxuICAgICAgICBtZXNzYWdlOiBwYXJzZV9tZXNzYWdlX2NvbnRlbnRfdG9fc3RyaW5nKGNoYXRtbC5tZXNzYWdlc1tjaGF0bWwubWVzc2FnZXMubGVuZ3RoIC0gMV0pLFxuICAgICAgICB0ZW1wZXJhdHVyZTogY2hhdG1sLnRlbXBlcmF0dXJlLFxuICAgICAgICAvLyBzdHJlYW06IGNoYXRtbC5zdHJlYW0gLy8gY3VycmVudGx5IG5vdCBzdXBwb3J0ZWRcbiAgICB9O1xuICAgIHJldHVybiBjb2hlcmU7XG59XG5leHBvcnRzLmNoYXRtbF90b19jb2hlcmUgPSBjaGF0bWxfdG9fY29oZXJlO1xuXG5mdW5jdGlvbiBwYXJzZV9tZXNzYWdlX2NvbnRlbnRfdG9fc3RyaW5nKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShtZXNzYWdlLmNvbnRlbnQpID8gbWVzc2FnZS5jb250ZW50LmZpbHRlcihjID0+IGMudHlwZSA9PT0gJ3RleHQnKS5tYXAoYyA9PiBjLnRleHQpLmpvaW4oJ1xcbicpIDogbWVzc2FnZS5jb250ZW50O1xufVxuXG4iLCAiLyoqXG4gKiBHZW1pbmlBZGFwdGVyIGNsYXNzIHByb3ZpZGVzIG1ldGhvZHMgdG8gYWRhcHQgdGhlIGNoYXQgbW9kZWwgaW50ZXJhY3Rpb25zIHNwZWNpZmljYWxseSBmb3IgdGhlIEdlbWluaSBtb2RlbC5cbiAqIEl0IGluY2x1ZGVzIG1ldGhvZHMgdG8gcHJlcGFyZSByZXF1ZXN0IGJvZGllcywgaGFuZGxlIHRvb2wgY2FsbHMgYW5kIG1lc3NhZ2VzLCBhbmQgbWFuYWdlIHN0cmVhbWluZyByZXNwb25zZXMuXG4gKi9cbmNsYXNzIEdlbWluaUFkYXB0ZXIge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIEdlbWluaUFkYXB0ZXIgaW5zdGFuY2Ugd2l0aCBhIHNwZWNpZmllZCBtb2RlbCBjb25maWd1cmF0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWwgLSBUaGUgbW9kZWwgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihtb2RlbCkgeyB0aGlzLm1vZGVsID0gbW9kZWw7IH1cblxuICAvKipcbiAgICogUHJlcGFyZXMgdGhlIHJlcXVlc3QgYm9keSBmb3IgdGhlIEdlbWluaSBBUEkgYnkgY29udmVydGluZyBDaGF0TUwgZm9ybWF0IHRvIGEgZm9ybWF0IGNvbXBhdGlibGUgd2l0aCBHZW1pbmkuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5IC0gVGhlIG9wdGlvbnMgb2JqZWN0IGNvbnRhaW5pbmcgbWVzc2FnZXMgYW5kIG90aGVyIHBhcmFtZXRlcnMgaW4gQ2hhdE1MIGZvcm1hdC5cbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIHJlcXVlc3QgYm9keSBmb3JtYXR0ZWQgZm9yIHRoZSBHZW1pbmkgQVBJLlxuICAgKi9cbiAgcHJlcGFyZV9yZXF1ZXN0X2JvZHkoYm9keSkgeyByZXR1cm4gY2hhdG1sX3RvX2dlbWluaShib2R5KTsgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0cyB0aGUgZmlyc3QgdG9vbCBjYWxsIGZyb20gdGhlIEpTT04gcmVzcG9uc2UgY29udGVudC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGpzb24gLSBUaGUgSlNPTiByZXNwb25zZSBmcm9tIHdoaWNoIHRvIGV4dHJhY3QgdGhlIHRvb2wgY2FsbC5cbiAgICogQHJldHVybnMge09iamVjdHxudWxsfSBUaGUgZmlyc3QgdG9vbCBjYWxsIGZvdW5kLCBvciBudWxsIGlmIG5vbmUgZXhpc3QuXG4gICAqL1xuICBnZXRfdG9vbF9jYWxsKGpzb24pIHsgcmV0dXJuIGpzb24uY2FuZGlkYXRlcz8uWzBdPy5jb250ZW50Py5wYXJ0cz8uWzBdPy5mdW5jdGlvbkNhbGw7IH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBuYW1lIG9mIHRoZSB0b29sIGZyb20gYSB0b29sIGNhbGwgb2JqZWN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gdG9vbF9jYWxsIC0gVGhlIHRvb2wgY2FsbCBvYmplY3QgZnJvbSB3aGljaCB0byBleHRyYWN0IHRoZSBuYW1lLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IFRoZSBuYW1lIG9mIHRoZSB0b29sLCBvciBudWxsIGlmIG5vdCBhdmFpbGFibGUuXG4gICAqL1xuICBnZXRfdG9vbF9uYW1lKHRvb2xfY2FsbCkgeyByZXR1cm4gdG9vbF9jYWxsPy5uYW1lOyB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgaW5wdXQgY29udGVudCBvZiBhIHRvb2wgY2FsbC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHRvb2xfY2FsbCAtIFRoZSB0b29sIGNhbGwgb2JqZWN0IGZyb20gd2hpY2ggdG8gZXh0cmFjdCB0aGUgaW5wdXQuXG4gICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH0gVGhlIGlucHV0IG9mIHRoZSB0b29sIGNhbGwsIG9yIG51bGwgaWYgbm90IGF2YWlsYWJsZS5cbiAgICovXG4gIGdldF90b29sX2NhbGxfY29udGVudCh0b29sX2NhbGwpIHsgcmV0dXJuIHRvb2xfY2FsbD8uYXJnczsgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0cyB0aGUgZmlyc3QgbWVzc2FnZSBmcm9tIHRoZSBKU09OIHJlc3BvbnNlIGNvbnRlbnQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBqc29uIC0gVGhlIEpTT04gcmVzcG9uc2UgZnJvbSB3aGljaCB0byBleHRyYWN0IHRoZSBtZXNzYWdlLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9IFRoZSBmaXJzdCBtZXNzYWdlIGZvdW5kLCBvciBudWxsIGlmIG5vbmUgZXhpc3QuXG4gICAqL1xuICBnZXRfbWVzc2FnZShqc29uKSB7IHJldHVybiBqc29uLmNhbmRpZGF0ZXM/LlswXTsgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGNvbnRlbnQgb2YgdGhlIGZpcnN0IG1lc3NhZ2UgZnJvbSB0aGUgSlNPTiByZXNwb25zZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGpzb24gLSBUaGUgSlNPTiByZXNwb25zZSBmcm9tIHdoaWNoIHRvIGV4dHJhY3QgdGhlIG1lc3NhZ2UgY29udGVudC5cbiAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBUaGUgY29udGVudCBvZiB0aGUgZmlyc3QgbWVzc2FnZSwgb3IgbnVsbCBpZiBubyBtZXNzYWdlIGlzIGZvdW5kLlxuICAgKi9cbiAgZ2V0X21lc3NhZ2VfY29udGVudChqc29uKSB7IHJldHVybiB0aGlzLmdldF9tZXNzYWdlKGpzb24pPy5jb250ZW50Py5wYXJ0cy5tYXAocGFydCA9PiBwYXJ0LnRleHQpLmpvaW4oJycpOyB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgZXNjYXBlZCBuZXdsaW5lcyBpbiBhIHN0cmVhbWluZyB0ZXh0IGNodW5rLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBUaGUgc3RyZWFtaW5nIGV2ZW50IGNvbnRhaW5pbmcgdGhlIGRhdGEuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSB0ZXh0IGNodW5rIHdpdGggZXNjYXBlZCBuZXdsaW5lcyByZXBsYWNlZC5cbiAgICovXG4gIGdldF90ZXh0X2NodW5rX2Zyb21fc3RyZWFtKGV2ZW50KSB7IHJldHVybiBldmVudC5kYXRhLnJlcGxhY2UoL1xcXFxuL2csICdcXG4nKTsgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBzdHJlYW1pbmcgcmVzcG9uc2UgaGFzIGVuZGVkIGJhc2VkIG9uIHRoZSByZWFkeVN0YXRlIG9mIHRoZSBYTUxIdHRwUmVxdWVzdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gVGhlIHN0cmVhbWluZyBldmVudC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHN0cmVhbSBoYXMgZW5kZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzX2VuZF9vZl9zdHJlYW0oZXZlbnQpIHsgcmV0dXJuIGV2ZW50LnNvdXJjZS54aHIucmVhZHlTdGF0ZSA9PT0gNDsgfVxuXG4gIC8qKlxuICAgKiBDb3VudHMgdGhlIHRva2VucyBpbiB0aGUgaW5wdXQgYnkgbWFraW5nIGFuIEFQSSByZXF1ZXN0IHRvIHRoZSBHZW1pbmkgdG9rZW4gY291bnRpbmcgZW5kcG9pbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gaW5wdXQgLSBUaGUgaW5wdXQgdGV4dCBvciBvYmplY3QgdG8gY291bnQgdG9rZW5zIGluLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxudW1iZXI+fSBUaGUgdG90YWwgbnVtYmVyIG9mIHRva2VucyBpbiB0aGUgaW5wdXQuXG4gICAqL1xuICBhc3luYyBjb3VudF90b2tlbnMoaW5wdXQpIHtcbiAgICBjb25zdCByZXEgPSB7XG4gICAgICB1cmw6IGBodHRwczovL2dlbmVyYXRpdmVsYW5ndWFnZS5nb29nbGVhcGlzLmNvbS92MWJldGEvbW9kZWxzL2dlbWluaS1wcm86Y291bnRUb2tlbnM/a2V5PSR7dGhpcy5tb2RlbC5hcGlfa2V5fWAsXG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgIH07XG4gICAgbGV0IGJvZHk7XG4gICAgaWYodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykgYm9keSA9IGNoYXRtbF90b19nZW1pbmkoeyBtZXNzYWdlczogW3sgcm9sZTogJ3VzZXInLCBjb250ZW50OiBpbnB1dCB9XSB9KTtcbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkgYm9keSA9IGNoYXRtbF90b19nZW1pbmkoeyBtZXNzYWdlczogaW5wdXQgfSk7XG4gICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JykgYm9keSA9IGNoYXRtbF90b19nZW1pbmkoaW5wdXQpO1xuICAgIGVsc2UgcmV0dXJuIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBjb3VudF90b2tlbnNcIiwgaW5wdXQpO1xuICAgIGRlbGV0ZSBib2R5LmdlbmVyYXRpb25Db25maWc7XG4gICAgZGVsZXRlIGJvZHkuc2FmZXR5U2V0dGluZ3M7XG4gICAgcmVxLmJvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5KTtcbiAgICBjb25zdCByZXNwID0gYXdhaXQgdGhpcy5tb2RlbC5yZXF1ZXN0X2FkYXB0ZXIocmVxKTtcbiAgICByZXR1cm4gcmVzcD8uanNvbj8udG90YWxUb2tlbnM7XG4gIH1cblxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgc3RhbmRhcmQgQVBJIGVuZHBvaW50IHdpdGggdGhlIEFQSSBrZXkgYXBwZW5kZWQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgZW5kcG9pbnQgVVJMIGZvciBub24tc3RyZWFtaW5nIHJlcXVlc3RzLlxuICAgKi9cbiAgZ2V0IGVuZHBvaW50KCkgeyByZXR1cm4gdGhpcy5tb2RlbC5jb25maWcuZW5kcG9pbnQucmVwbGFjZSgnTU9ERUxfTkFNRScsIHRoaXMubW9kZWwubW9kZWxfbmFtZSkgKyBcIj9rZXk9XCIgKyB0aGlzLm1vZGVsLmFwaV9rZXk7IH1cblxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgc3RyZWFtaW5nIEFQSSBlbmRwb2ludCB3aXRoIHRoZSBBUEkga2V5IGFwcGVuZGVkLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIGVuZHBvaW50IFVSTCBmb3Igc3RyZWFtaW5nIHJlcXVlc3RzLlxuICAgKi9cbiAgZ2V0IGVuZHBvaW50X3N0cmVhbWluZygpIHsgcmV0dXJuIHRoaXMubW9kZWwuY29uZmlnLmVuZHBvaW50X3N0cmVhbWluZy5yZXBsYWNlKCdNT0RFTF9OQU1FJywgdGhpcy5tb2RlbC5tb2RlbF9uYW1lKSArIFwiP2tleT1cIiArIHRoaXMubW9kZWwuYXBpX2tleTsgfVxufVxuZXhwb3J0cy5HZW1pbmlBZGFwdGVyID0gR2VtaW5pQWRhcHRlcjtcblxuLyoqXG4gKiBDb252ZXJ0IGEgQ2hhdE1MIG9iamVjdCB0byBhIEdlbWluaSBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gVGhlIENoYXRNTCBvYmplY3RcbiAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIGNvbnZlcnRzIGEgQ2hhdE1MIG9iamVjdCB0byBhIEdlbWluaSBvYmplY3QuIEl0IGZpbHRlcnMgb3V0IHN5c3RlbSBtZXNzYWdlcyBhbmQgYWRkcyBhIHN5c3RlbSBtZXNzYWdlIHByaW9yIHRvIHRoZSBsYXN0IHVzZXIgbWVzc2FnZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IC0gVGhlIEdlbWluaSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gY2hhdG1sX3RvX2dlbWluaShvcHRzKSB7XG4gIC8vIC8vIGRlZXAgY29weSBtZXNzYWdlc1xuICAvLyBjb25zdCBtZXNzYWdlcyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob3B0cy5tZXNzYWdlcykpLmZpbHRlcihtc2cgPT4gbXNnLnJvbGUgIT09ICdzeXN0ZW0nKTtcbiAgLy8gLy8gbWVyZ2Ugc3lzdGVtIHJvbGVzIGludG9tIHN1YnNlcXVlbnQgdXNlciByb2xlc1xuICAvLyBvcHRzLm1lc3NhZ2VzLmZvckVhY2goKG1zZywgaSkgPT4ge1xuICAvLyAgIGlmIChtc2cucm9sZSA9PT0gJ3N5c3RlbScpIHtcbiAgLy8gICAgIGlmICghbWVzc2FnZXNbaSArIDFdKSByZXR1cm4gY29uc29sZS5lcnJvcihcIlN5c3RlbSBtZXNzYWdlIHdpdGhvdXQgc3Vic2VxdWVudCB1c2VyIG1lc3NhZ2VcIik7XG4gIC8vICAgICBjb25zdCBzeXN0ZW1fcHJvbXB0ID0gJy0tLUJFR0lOIElNUE9SVEFOVCBDT05URVhULS0tXFxuJyArIG1zZy5jb250ZW50ICsgJ1xcbi0tLUVORCBJTVBPUlRBTlQgQ09OVEVYVC0tLVxcblxcbic7XG4gIC8vICAgICBtZXNzYWdlc1tpICsgMV0uY29udGVudCA9IHN5c3RlbV9wcm9tcHQgKyAobWVzc2FnZXNbaSArIDFdLmNvbnRlbnQgfHwgJycpO1xuICAvLyAgIH1cbiAgLy8gfSk7XG4gIGNvbnN0IG1lc3NhZ2VzID0gb3B0cy5tZXNzYWdlcy5maWx0ZXIobXNnID0+IG1zZy5yb2xlICE9PSAnc3lzdGVtJyk7XG4gIC8vIERPOiBoYW5kbGVkIGJldHRlciAoU21hcnQgQ29ubmVjdGlvbnMgc3BlY2lmaWMpXG4gIC8vIGdldCBpbmRleCBvZiBsYXN0IHN5c3RlbSBtZXNzYWdlXG4gIGNvbnN0IGxhc3Rfc3lzdGVtX2lkeCA9IG9wdHMubWVzc2FnZXMuZmluZExhc3RJbmRleChtc2cgPT4gbXNnLnJvbGUgPT09ICdzeXN0ZW0nICYmIG1zZy5jb250ZW50LmluY2x1ZGVzKCctLS1CRUdJTicpKTtcbiAgaWYgKGxhc3Rfc3lzdGVtX2lkeCA+IC0xKSB7XG4gICAgY29uc3Qgc3lzdGVtX3Byb21wdCA9ICctLS1CRUdJTiBJTVBPUlRBTlQgQ09OVEVYVC0tLVxcbicgKyBvcHRzLm1lc3NhZ2VzW2xhc3Rfc3lzdGVtX2lkeF0uY29udGVudCArICdcXG4tLS1FTkQgSU1QT1JUQU5UIENPTlRFWFQtLS1cXG5cXG4nO1xuICAgIG1lc3NhZ2VzW21lc3NhZ2VzLmxlbmd0aCAtIDFdLmNvbnRlbnQgPSBzeXN0ZW1fcHJvbXB0ICsgbWVzc2FnZXNbbWVzc2FnZXMubGVuZ3RoIC0gMV0uY29udGVudDtcbiAgfVxuICBjb25zdCBib2R5ID0ge1xuICAgIGNvbnRlbnRzOiBtZXNzYWdlc1xuICAgICAgLmZpbHRlcihtc2cgPT4gbXNnLnJvbGUgIT09ICdzeXN0ZW0nKSAvLyBmaWx0ZXIgb3V0IHN5c3RlbSBtZXNzYWdlc1xuICAgICAgLm1hcChtc2cgPT4gKHtcbiAgICAgICAgcm9sZTogbXNnLnJvbGUgPT09ICdhc3Npc3RhbnQnID8gJ21vZGVsJyA6IG1zZy5yb2xlLFxuICAgICAgICBwYXJ0czogQXJyYXkuaXNBcnJheShtc2cuY29udGVudCkgPyBbe3RleHQ6IG1zZy5jb250ZW50LmZpbHRlcihjID0+IGMudHlwZSA9PT0gJ3RleHQnKS5tYXAoYyA9PiBjLnRleHQpLmpvaW4oJ1xcbicpfV0gOiBbeyB0ZXh0OiBtc2cuY29udGVudCB9XVxuICAgICAgfSkpLFxuICAgIGdlbmVyYXRpb25Db25maWc6IHtcbiAgICAgIHRlbXBlcmF0dXJlOiBvcHRzLnRlbXBlcmF0dXJlIHx8IDAuOSxcbiAgICAgIHRvcEs6IG9wdHMudG9wSyB8fCAxLFxuICAgICAgdG9wUDogb3B0cy50b3BQIHx8IDEsXG4gICAgICBtYXhPdXRwdXRUb2tlbnM6IG9wdHMubWF4X3Rva2VucyB8fCAyMDQ4LFxuICAgICAgc3RvcFNlcXVlbmNlczogb3B0cy5zdG9wU2VxdWVuY2VzIHx8IFtdLFxuICAgICAgY2FuZGlkYXRlX2NvdW50OiBvcHRzLm4gfHwgMSxcbiAgICB9LFxuICAgIHNhZmV0eVNldHRpbmdzOiBbXG4gICAgICB7XG4gICAgICAgIGNhdGVnb3J5OiBcIkhBUk1fQ0FURUdPUllfSEFSQVNTTUVOVFwiLFxuICAgICAgICB0aHJlc2hvbGQ6IFwiQkxPQ0tfTk9ORVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjYXRlZ29yeTogXCJIQVJNX0NBVEVHT1JZX0hBVEVfU1BFRUNIXCIsXG4gICAgICAgIHRocmVzaG9sZDogXCJCTE9DS19OT05FXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNhdGVnb3J5OiBcIkhBUk1fQ0FURUdPUllfU0VYVUFMTFlfRVhQTElDSVRcIixcbiAgICAgICAgdGhyZXNob2xkOiBcIkJMT0NLX05PTkVcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2F0ZWdvcnk6IFwiSEFSTV9DQVRFR09SWV9EQU5HRVJPVVNfQ09OVEVOVFwiLFxuICAgICAgICB0aHJlc2hvbGQ6IFwiQkxPQ0tfTk9ORVwiXG4gICAgICB9XG4gICAgXVxuICB9O1xuICBjb25zdCBzeXN0ZW1faW5zdHJ1Y3Rpb25zID0gb3B0cy5tZXNzYWdlcy5maWx0ZXIobXNnID0+IG1zZy5yb2xlID09PSAnc3lzdGVtJyAmJiAhbXNnLmNvbnRlbnQuaW5jbHVkZXMoJy0tLUJFR0lOJykpO1xuICBpZihzeXN0ZW1faW5zdHJ1Y3Rpb25zLmxlbmd0aCA+IDApIGJvZHkuc3lzdGVtSW5zdHJ1Y3Rpb24gPSB7IHBhcnRzOiBzeXN0ZW1faW5zdHJ1Y3Rpb25zLm1hcChtc2cgPT4gKHsgdGV4dDogbXNnLmNvbnRlbnQgfSkpIH07XG4gIGlmKG9wdHMudG9vbHMpe1xuICAgIGJvZHkudG9vbHMgPSBbe1xuICAgICAgZnVuY3Rpb25fZGVjbGFyYXRpb25zOiBvcHRzLnRvb2xzLm1hcCh0b29sID0+ICh7XG4gICAgICAgIG5hbWU6IHRvb2wuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgZGVzY3JpcHRpb246IHRvb2wuZnVuY3Rpb24uZGVzY3JpcHRpb24sXG4gICAgICAgIHBhcmFtZXRlcnM6IHRvb2wuZnVuY3Rpb24ucGFyYW1ldGVycyxcbiAgICAgIH0pKVxuICAgIH1dO1xuICAgIGJvZHkudG9vbF9jb25maWcgPSB7XG4gICAgICBmdW5jdGlvbl9jYWxsaW5nX2NvbmZpZzoge1xuICAgICAgICBtb2RlOiBcIkFOWVwiXG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB0b29sX3Byb21wdCA9IGBVc2UgdGhlIFwiJHtib2R5LnRvb2xzWzBdLmZ1bmN0aW9uX2RlY2xhcmF0aW9uc1swXS5uYW1lfVwiIHRvb2whYDtcbiAgICBjb25zdCBsYXN0X3VzZXJfaWR4ID0gYm9keS5jb250ZW50cy5maW5kTGFzdEluZGV4KG1zZyA9PiBtc2cucm9sZSA9PT0gJ3VzZXInKTtcbiAgICBib2R5LmNvbnRlbnRzW2xhc3RfdXNlcl9pZHhdLnBhcnRzWzBdLnRleHQgKz0gJ1xcbicgKyB0b29sX3Byb21wdDtcbiAgfVxuICByZXR1cm4gYm9keTtcbn1cbmV4cG9ydHMuY2hhdG1sX3RvX2dlbWluaSA9IGNoYXRtbF90b19nZW1pbmk7IiwgImNvbnN0IHsgQW50aHJvcGljQWRhcHRlciB9ID0gcmVxdWlyZSgnLi9hZGFwdGVycy9hbnRocm9waWMnKTtcbmNvbnN0IHsgQ29oZXJlQWRhcHRlciB9ID0gcmVxdWlyZSgnLi9hZGFwdGVycy9jb2hlcmUnKTtcbmNvbnN0IHsgR2VtaW5pQWRhcHRlciB9ID0gcmVxdWlyZSgnLi9hZGFwdGVycy9nZW1pbmknKTtcbmV4cG9ydHMuQW50aHJvcGljID0gQW50aHJvcGljQWRhcHRlcjtcbmV4cG9ydHMuQ29oZXJlID0gQ29oZXJlQWRhcHRlcjtcbmV4cG9ydHMuR2VtaW5pID0gR2VtaW5pQWRhcHRlcjtcblxuIiwgIntcbiAgXCJvcGVuYWlcIjoge1xuICAgIFwiZGVzY3JpcHRpb25cIjogXCJPcGVuQUlcIixcbiAgICBcInR5cGVcIjogXCJBUElcIixcbiAgICBcImVuZHBvaW50XCI6IFwiaHR0cHM6Ly9hcGkub3BlbmFpLmNvbS92MS9jaGF0L2NvbXBsZXRpb25zXCIsXG4gICAgXCJzdHJlYW1pbmdcIjogdHJ1ZSxcbiAgICBcImFjdGlvbnNcIjogdHJ1ZSxcbiAgICBcImZldGNoX21vZGVsc1wiOiB0cnVlLFxuICAgIFwiZGVmYXVsdF9tb2RlbFwiOiBcImdwdC0zLjUtdHVyYm9cIixcbiAgICBcInNpZ251cF91cmxcIjogXCJodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vYXBpLWtleXNcIlxuICB9LFxuICBcImdvb2dsZV9nZW1pbmlcIjoge1xuICAgIFwiZGVzY3JpcHRpb25cIjogXCJHb29nbGUgR2VtaW5pXCIsXG4gICAgXCJ0eXBlXCI6IFwiQVBJXCIsXG4gICAgXCJhcGlfa2V5X2hlYWRlclwiOiBcIm5vbmVcIixcbiAgICBcImVuZHBvaW50XCI6IFwiaHR0cHM6Ly9nZW5lcmF0aXZlbGFuZ3VhZ2UuZ29vZ2xlYXBpcy5jb20vdjFiZXRhL21vZGVscy9NT0RFTF9OQU1FOmdlbmVyYXRlQ29udGVudFwiLFxuICAgIFwiZW5kcG9pbnRfc3RyZWFtaW5nXCI6IFwiaHR0cHM6Ly9nZW5lcmF0aXZlbGFuZ3VhZ2UuZ29vZ2xlYXBpcy5jb20vdjFiZXRhL21vZGVscy9NT0RFTF9OQU1FOnN0cmVhbUdlbmVyYXRlQ29udGVudFwiLFxuICAgIFwic3RyZWFtaW5nXCI6IHRydWUsXG4gICAgXCJhY3Rpb25zXCI6IHRydWUsXG4gICAgXCJhZGFwdGVyXCI6IFwiR2VtaW5pXCIsXG4gICAgXCJmZXRjaF9tb2RlbHNcIjogdHJ1ZSxcbiAgICBcImRlZmF1bHRfbW9kZWxcIjogXCJnZW1pbmktMS4wLXByb1wiLFxuICAgIFwic2lnbnVwX3VybFwiOiBcImh0dHBzOi8vYWkuZ29vZ2xlLmRldi9cIlxuICB9LFxuICBcIm9wZW5fcm91dGVyXCI6IHtcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiT3BlbiBSb3V0ZXJcIixcbiAgICBcInR5cGVcIjogXCJBUElcIixcbiAgICBcImVuZHBvaW50XCI6IFwiaHR0cHM6Ly9vcGVucm91dGVyLmFpL2FwaS92MS9jaGF0L2NvbXBsZXRpb25zXCIsXG4gICAgXCJzdHJlYW1pbmdcIjogdHJ1ZSxcbiAgICBcImZldGNoX21vZGVsc1wiOiB0cnVlLFxuICAgIFwiZGVmYXVsdF9tb2RlbFwiOiBcIm1pc3RyYWxhaS9taXN0cmFsLTdiLWluc3RydWN0OmZyZWVcIixcbiAgICBcInNpZ251cF91cmxcIjogXCJodHRwczovL2FjY291bnRzLm9wZW5yb3V0ZXIuYWkvc2lnbi11cD9yZWRpcmVjdF91cmw9aHR0cHMlM0ElMkYlMkZvcGVucm91dGVyLmFpJTJGa2V5c1wiXG4gIH0sXG4gIFwiY29oZXJlXCI6IHtcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQ29oZXJlIENvbW1hbmQtUlwiLFxuICAgIFwidHlwZVwiOiBcIkFQSVwiLFxuICAgIFwiZW5kcG9pbnRcIjogXCJodHRwczovL2FwaS5jb2hlcmUuYWkvdjEvY2hhdFwiLFxuICAgIFwic3RyZWFtaW5nXCI6IGZhbHNlLFxuICAgIFwiYWRhcHRlclwiOiBcIkNvaGVyZVwiLFxuICAgIFwiZmV0Y2hfbW9kZWxzXCI6IHRydWUsXG4gICAgXCJkZWZhdWx0X21vZGVsXCI6IFwiY29tbWFuZC1yXCIsXG4gICAgXCJzaWdudXBfdXJsXCI6IFwiaHR0cHM6Ly9kYXNoYm9hcmQuY29oZXJlLmNvbS93ZWxjb21lL3JlZ2lzdGVyP3JlZGlyZWN0X3VyaT0lMkZhcGkta2V5c1wiXG4gIH0sXG4gIFwiYW50aHJvcGljXCI6IHtcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQW50aHJvcGljIENsYXVkZVwiLFxuICAgIFwidHlwZVwiOiBcIkFQSVwiLFxuICAgIFwiZW5kcG9pbnRcIjogXCJodHRwczovL2FwaS5hbnRocm9waWMuY29tL3YxL21lc3NhZ2VzXCIsXG4gICAgXCJzdHJlYW1pbmdcIjogZmFsc2UsXG4gICAgXCJhcGlfa2V5X2hlYWRlclwiOiBcIngtYXBpLWtleVwiLFxuICAgIFwiaGVhZGVyc1wiOiB7XG4gICAgICBcImFudGhyb3BpYy12ZXJzaW9uXCI6IFwiMjAyMy0wNi0wMVwiLFxuICAgICAgXCJhbnRocm9waWMtYmV0YVwiOiBcInRvb2xzLTIwMjQtMDQtMDRcIlxuICAgIH0sXG4gICAgXCJhZGFwdGVyXCI6IFwiQW50aHJvcGljXCIsXG4gICAgXCJhY3Rpb25zXCI6IHRydWUsXG4gICAgXCJmZXRjaF9tb2RlbHNcIjogdHJ1ZSxcbiAgICBcImRlZmF1bHRfbW9kZWxcIjogXCJjbGF1ZGUtMy1zb25uZXQtMjAyNDAyMjlcIixcbiAgICBcInNpZ251cF91cmxcIjogXCJodHRwczovL2NvbnNvbGUuYW50aHJvcGljLmNvbS9sb2dpbj9yZXR1cm5Ubz0lMkZzZXR0aW5ncyUyRmtleXNcIlxuICB9LFxuICBcImN1c3RvbV9sb2NhbFwiOiB7XG4gICAgXCJtb2RlbF9uYW1lXCI6IFwiY3VzdG9tX2xvY2FsXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkN1c3RvbSBMb2NhbCAoT3BlbkFJIGZvcm1hdClcIixcbiAgICBcInR5cGVcIjogXCJBUElcIlxuICB9LFxuICBcImN1c3RvbV9hcGlcIjoge1xuICAgIFwibW9kZWxfbmFtZVwiOiBcImN1c3RvbV9hcGlcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQ3VzdG9tIEFQSSAoT3BlbkFJIGZvcm1hdClcIixcbiAgICBcInR5cGVcIjogXCJBUElcIlxuICB9XG59XG5cbiIsICIvKipcbiAgIGNvbnN0IHRvb2xzX2V4YW1wbGUgPSBbXG4gICAge1xuICAgICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIixcbiAgICAgIFwiZnVuY3Rpb25cIjoge1xuICAgICAgICBcIm5hbWVcIjogXCJnZXRfY3VycmVudF93ZWF0aGVyXCIsXG4gICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJHZXQgdGhlIGN1cnJlbnQgd2VhdGhlciBpbiBhIGdpdmVuIGxvY2F0aW9uXCIsXG4gICAgICAgIFwicGFyYW1ldGVyc1wiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gICAgICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjoge1xuICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBjaXR5IGFuZCBzdGF0ZSwgZS5nLiBTYW4gRnJhbmNpc2NvLCBDQVwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwidW5pdFwiOiB7XCJ0eXBlXCI6IFwic3RyaW5nXCIsIFwiZW51bVwiOiBbXCJjZWxzaXVzXCIsIFwiZmFocmVuaGVpdFwiXX0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcImxvY2F0aW9uXCJdLFxuICAgICAgICB9LFxuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCIsXG4gICAgXCJmdW5jdGlvblwiOiB7XG4gICAgICBcIm5hbWVcIjogXCJsb29rdXBcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJTZW1hbnRpYyBzZWFyY2hcIixcbiAgICAgIFwicGFyYW1ldGVyc1wiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICAgICAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgICAgIFwiaHlwb3RoZXRpY2Fsc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgICAgICAgXCJpdGVtc1wiOiB7XCJ0eXBlXCI6IFwic3RyaW5nXCJ9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5dO1xuICovXG4vKipcbiAqIFZhbGlkYXRlcyBhIHRvb2wgY2FsbCBhZ2FpbnN0IGl0cyBzcGVjaWZpY2F0aW9uIHRvIGVuc3VyZSBhbGwgcGFyYW1ldGVycyBhcmUgY29ycmVjdC5cbiAqIFRoaXMgZnVuY3Rpb24gY2hlY2tzIGlmIGFsbCBwcm92aWRlZCBrZXlzIGluIHRoZSB0b29sIGNhbGwgY29udGVudCBtYXRjaCB0aGUgZXhwZWN0ZWQgdHlwZXMsXG4gKiBoYW5kbGVzIHR5cGUgY29lcmNpb24gZm9yIG51bWVyaWMgdmFsdWVzLCB2YWxpZGF0ZXMgYWdhaW5zdCBlbnVtcywgYW5kIGVuc3VyZXMgYWxsIHJlcXVpcmVkXG4gKiBwYXJhbWV0ZXJzIGFyZSBwcmVzZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0b29sIC0gVGhlIHRvb2wgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZ1bmN0aW9uIHNwZWNpZmljYXRpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gdG9vbF9jYWxsX2NvbnRlbnQgLSBUaGUgYWN0dWFsIHBhcmFtZXRlcnMgcGFzc2VkIHRvIHRoZSB0b29sIGZ1bmN0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IC0gUmV0dXJucyB0cnVlIGlmIHRoZSB0b29sIGNhbGwgaXMgdmFsaWQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gLSBUaHJvd3MgYW4gZXJyb3IgaWYgYW55IHZhbGlkYXRpb24gZmFpbHMuXG4gKi9cbmZ1bmN0aW9uIGlzX3ZhbGlkX3Rvb2xfY2FsbCh0b29sLCB0b29sX2NhbGxfY29udGVudCkge1xuICBjb25zdCBwcm9wcyA9IHRvb2wuZnVuY3Rpb24ucGFyYW1ldGVycy5wcm9wZXJ0aWVzO1xuICBpZiAoT2JqZWN0LmtleXModG9vbF9jYWxsX2NvbnRlbnQpLmxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRvb2wgY2FsbDogb2JqZWN0IGlzIGVtcHR5YCk7XG4gIC8vIGNoZWNrIGlmIGFsbCBrZXlzIGFyZSBpbiB0b29sIHNwZWNcbiAgT2JqZWN0LmVudHJpZXModG9vbF9jYWxsX2NvbnRlbnQpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmICghcHJvcHNba2V5XSkgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRvb2wgY2FsbDogbWlzc2luZyBrZXkgJHtrZXl9IGluIHRvb2wgc3BlY2AsIHByb3BzKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgcHJvcHNba2V5XS50eXBlID09PSAnYXJyYXknKSB7XG4gICAgICAvLyBjaGVjayBpZiBhbGwgaXRlbXMgaW4gdGhlIGFycmF5IGFyZSBvZiB0aGUgc2FtZSB0eXBlXG4gICAgICBjb25zdCBpdGVtVHlwZSA9IHR5cGVvZiB2YWx1ZVswXTtcbiAgICAgIGlmICghdmFsdWUuZXZlcnkoaXRlbSA9PiB0eXBlb2YgaXRlbSA9PT0gaXRlbVR5cGUpKSB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdG9vbCBjYWxsOiBhcnJheSBpdGVtcyBhcmUgbm90IG9mIHRoZSBzYW1lIHR5cGVgKTtcbiAgICAgIC8vIGNoZWNrIGlmIHRoZSBhcnJheSBpdGVtcyBhcmUgb2YgdGhlIHNhbWUgdHlwZSBhcyB0aGUgc3BlY1xuICAgICAgaWYgKHByb3BzW2tleV0uaXRlbXMudHlwZSAhPT0gaXRlbVR5cGUpIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0b29sIGNhbGw6IGFycmF5IGl0ZW1zIGFyZSBub3Qgb2YgdGhlIHNhbWUgdHlwZSBhcyB0aGUgc3BlY2ApO1xuICAgIH0gZWxzZSBpZiAocHJvcHNba2V5XS50eXBlICE9PSB0eXBlb2YgdmFsdWUpIHtcbiAgICAgIGlmIChwcm9wc1trZXldLnR5cGUgPT09ICdudW1iZXInICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgdmFsdWUgaXMgYSB2YWxpZCBudW1iZXJcbiAgICAgICAgaWYgKGlzTmFOKE51bWJlcih2YWx1ZSkpKSB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdG9vbCBjYWxsOiB2YWx1ZSAke3ZhbHVlfSBpcyBub3QgYSB2YWxpZCBudW1iZXJgKTtcbiAgICAgICAgdG9vbF9jYWxsX2NvbnRlbnRba2V5XSA9IE51bWJlcih2YWx1ZSk7IC8vIGNvZXJjZSB0byBudW1iZXIgKHNob3VsZCBtdXRhdGUgdG9vbF9jYWxsX2NvbnRlbnQpXG4gICAgICB9IGVsc2UgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRvb2wgY2FsbDogdmFsdWUgJHt2YWx1ZX0gaXMgbm90IG9mIHR5cGUgJHtwcm9wc1trZXldLnR5cGV9YCk7XG4gICAgfVxuICAgIGlmIChwcm9wc1trZXldLmVudW0gJiYgIXByb3BzW2tleV0uZW51bS5pbmNsdWRlcyh2YWx1ZSkpIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0b29sIGNhbGw6IHZhbHVlICR7dmFsdWV9IGlzIG5vdCBpbiBlbnVtICR7cHJvcHNba2V5XS5lbnVtfWApO1xuICB9KTtcbiAgLy8gY2hlY2sgaWYgYWxsIHJlcXVpcmVkIGtleXMgYXJlIHByZXNlbnRcbiAgdG9vbC5mdW5jdGlvbi5wYXJhbWV0ZXJzLnJlcXVpcmVkPy5mb3JFYWNoKGtleSA9PiB7XG4gICAgaWYgKCF0b29sX2NhbGxfY29udGVudFtrZXldKSB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdG9vbCBjYWxsOiBtaXNzaW5nIHJlcXVpcmVkIGtleSAke2tleX1gKTtcbiAgfSk7XG4gIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5pc192YWxpZF90b29sX2NhbGwgPSBpc192YWxpZF90b29sX2NhbGw7XG4iLCAiY2xhc3MgU21hcnRTdHJlYW1lciB7XG4gIGNvbnN0cnVjdG9yKHVybCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgbWV0aG9kID0gJ0dFVCcsXG4gICAgICBoZWFkZXJzID0ge30sXG4gICAgICBib2R5ID0gbnVsbCxcbiAgICAgIHdpdGhDcmVkZW50aWFscyA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy53aXRoQ3JlZGVudGlhbHMgPSB3aXRoQ3JlZGVudGlhbHM7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSB0aGlzLkNPTk5FQ1RJTkc7XG4gICAgdGhpcy5wcm9ncmVzcyA9IDA7XG4gICAgdGhpcy5jaHVuayA9ICcnO1xuICAgIHRoaXMubGFzdF9ldmVudF9pZCA9ICcnO1xuICAgIHRoaXMueGhyID0gbnVsbDtcbiAgICB0aGlzLkZJRUxEX1NFUEFSQVRPUiA9ICc6JztcbiAgICB0aGlzLklOSVRJQUxJWklORyA9IC0xO1xuICAgIHRoaXMuQ09OTkVDVElORyA9IDA7XG4gICAgdGhpcy5PUEVOID0gMTtcbiAgICB0aGlzLkNMT1NFRCA9IDI7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhbiBldmVudCBsaXN0ZW5lciBmb3IgdGhlIHNwZWNpZmllZCBldmVudCB0eXBlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBldmVudC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgLSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gdGhlIGV2ZW50IGlzIHRyaWdnZXJlZC5cbiAgICovXG4gIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAoIXRoaXMubGlzdGVuZXJzW3R5cGVdKSB0aGlzLmxpc3RlbmVyc1t0eXBlXSA9IFtdO1xuICAgIGlmICghdGhpcy5saXN0ZW5lcnNbdHlwZV0uaW5jbHVkZXMobGlzdGVuZXIpKSB0aGlzLmxpc3RlbmVyc1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuIGV2ZW50IGxpc3RlbmVyIGZyb20gdGhlIFNtYXJ0U3RyZWFtZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgb2YgZXZlbnQgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lciBmcm9tLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciAtIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiB0byByZW1vdmUuXG4gICAqL1xuICByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKCF0aGlzLmxpc3RlbmVyc1t0eXBlXSkgcmV0dXJuO1xuICAgIHRoaXMubGlzdGVuZXJzW3R5cGVdID0gdGhpcy5saXN0ZW5lcnNbdHlwZV0uZmlsdGVyKChjYWxsYmFjaykgPT4gY2FsbGJhY2sgIT09IGxpc3RlbmVyKTtcbiAgICBpZiAodGhpcy5saXN0ZW5lcnNbdHlwZV0ubGVuZ3RoID09PSAwKSBkZWxldGUgdGhpcy5saXN0ZW5lcnNbdHlwZV07XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhbiBldmVudCB0byB0aGUgYXBwcm9wcmlhdGUgZXZlbnQgaGFuZGxlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IHRvIGJlIGRpc3BhdGNoZWQuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSAtIFJldHVybnMgdHJ1ZSBpZiB0aGUgZXZlbnQgd2FzIHN1Y2Nlc3NmdWxseSBkaXNwYXRjaGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7XG4gICAgaWYgKCFldmVudCkgcmV0dXJuIHRydWU7XG4gICAgZXZlbnQuc291cmNlID0gdGhpcztcbiAgICBjb25zdCBvbkhhbmRsZXIgPSAnb24nICsgZXZlbnQudHlwZTtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIG9uSGFuZGxlcikpIHtcbiAgICAgIHRoaXNbb25IYW5kbGVyXS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLmxpc3RlbmVyc1tldmVudC50eXBlXSkge1xuICAgICAgdGhpcy5saXN0ZW5lcnNbZXZlbnQudHlwZV0uZm9yRWFjaCgoY2FsbGJhY2spID0+IHtcbiAgICAgICAgY2FsbGJhY2soZXZlbnQpO1xuICAgICAgICByZXR1cm4gIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQ7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhdGVzIHRoZSBzdHJlYW1pbmcgcHJvY2Vzcy5cbiAgICovXG4gIHN0cmVhbSgpIHtcbiAgICB0aGlzLiNzZXRSZWFkeVN0YXRlKHRoaXMuQ09OTkVDVElORyk7XG4gICAgdGhpcy54aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB0aGlzLnhoci5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIHRoaXMuI29uU3RyZWFtUHJvZ3Jlc3MuYmluZCh0aGlzKSk7XG4gICAgdGhpcy54aHIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuI29uU3RyZWFtTG9hZGVkLmJpbmQodGhpcykpO1xuICAgIHRoaXMueGhyLmFkZEV2ZW50TGlzdGVuZXIoJ3JlYWR5c3RhdGVjaGFuZ2UnLCB0aGlzLiNjaGVja1N0cmVhbUNsb3NlZC5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLnhoci5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIHRoaXMuI29uU3RyZWFtRmFpbHVyZS5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLnhoci5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIHRoaXMuI29uU3RyZWFtQWJvcnQuYmluZCh0aGlzKSk7XG4gICAgdGhpcy54aHIub3Blbih0aGlzLm1ldGhvZCwgdGhpcy51cmwpO1xuICAgIGZvciAoY29uc3QgaGVhZGVyIGluIHRoaXMuaGVhZGVycykge1xuICAgICAgdGhpcy54aHIuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXIsIHRoaXMuaGVhZGVyc1toZWFkZXJdKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubGFzdF9ldmVudF9pZCkgdGhpcy54aHIuc2V0UmVxdWVzdEhlYWRlcignTGFzdC1FdmVudC1JRCcsIHRoaXMubGFzdF9ldmVudF9pZCk7XG4gICAgdGhpcy54aHIud2l0aENyZWRlbnRpYWxzID0gdGhpcy53aXRoQ3JlZGVudGlhbHM7XG4gICAgdGhpcy54aHIuc2VuZCh0aGlzLmJvZHkpO1xuICB9XG4gIC8qKlxuICAgKiBFbmRzIHRoZSBzdHJlYW1lciBjb25uZWN0aW9uLlxuICAgKiBBYm9ydHMgdGhlIGN1cnJlbnQgWEhSIHJlcXVlc3QgYW5kIHNldHMgdGhlIHJlYWR5IHN0YXRlIHRvIENMT1NFRC5cbiAgICovXG4gIGVuZCgpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSB0aGlzLkNMT1NFRCkgcmV0dXJuO1xuICAgIHRoaXMueGhyLmFib3J0KCk7XG4gICAgdGhpcy54aHIgPSBudWxsO1xuICAgIHRoaXMuI3NldFJlYWR5U3RhdGUodGhpcy5DTE9TRUQpO1xuICB9XG5cbiAgLy8gcHJpdmF0ZSBtZXRob2RzXG4gICNzZXRSZWFkeVN0YXRlKHN0YXRlKSB7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ3JlYWR5U3RhdGVDaGFuZ2UnKTtcbiAgICBldmVudC5yZWFkeVN0YXRlID0gc3RhdGU7XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gc3RhdGU7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgfVxuICAjb25TdHJlYW1GYWlsdXJlKGUpIHtcbiAgICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnZXJyb3InKTtcbiAgICBldmVudC5kYXRhID0gZS5jdXJyZW50VGFyZ2V0LnJlc3BvbnNlO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgdGhpcy5lbmQoKTtcbiAgfVxuICAjb25TdHJlYW1BYm9ydChlKSB7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Fib3J0Jyk7XG4gICAgdGhpcy5lbmQoKTtcbiAgfVxuICAjb25TdHJlYW1Qcm9ncmVzcyhlKSB7XG4gICAgaWYgKCF0aGlzLnhocikgcmV0dXJuO1xuICAgIGlmICh0aGlzLnhoci5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgdGhpcy4jb25TdHJlYW1GYWlsdXJlKGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSB0aGlzLkNPTk5FQ1RJTkcpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ29wZW4nKSk7XG4gICAgICB0aGlzLiNzZXRSZWFkeVN0YXRlKHRoaXMuT1BFTik7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnhoci5yZXNwb25zZVRleHQuc3Vic3RyaW5nKHRoaXMucHJvZ3Jlc3MpO1xuICAgIHRoaXMucHJvZ3Jlc3MgKz0gZGF0YS5sZW5ndGg7XG4gICAgLy8gZGF0YS5zcGxpdCgvKFxcclxcbnxcXHJ8XFxuKXsyfS9nKS5mb3JFYWNoKChwYXJ0KSA9PiB7XG4gICAgZGF0YS5zcGxpdCgvKFxcclxcbnxcXHJ8XFxuKS9nKS5mb3JFYWNoKChwYXJ0KSA9PiB7XG4gICAgICBpZiAocGFydC50cmltKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh0aGlzLiNwYXJzZUV2ZW50Q2h1bmsodGhpcy5jaHVuay50cmltKCkpKTtcbiAgICAgICAgdGhpcy5jaHVuayA9ICcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jaHVuayArPSBwYXJ0O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gICNvblN0cmVhbUxvYWRlZChlKSB7XG4gICAgdGhpcy4jb25TdHJlYW1Qcm9ncmVzcyhlKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQodGhpcy4jcGFyc2VFdmVudENodW5rKHRoaXMuY2h1bmspKTtcbiAgICB0aGlzLmNodW5rID0gJyc7XG4gIH1cbiAgI3BhcnNlRXZlbnRDaHVuayhjaHVuaykge1xuICAgIGlmICghY2h1bmsgfHwgY2h1bmsubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBlID0geyBpZDogbnVsbCwgcmV0cnk6IG51bGwsIGRhdGE6ICcnLCBldmVudDogJ21lc3NhZ2UnLCB0ZXh0OiAnJyB9O1xuICAgIGNodW5rLnNwbGl0KC8oXFxyXFxufFxccnxcXG4pLykuZm9yRWFjaCgobGluZSkgPT4ge1xuICAgICAgLy8gbGluZSA9IGxpbmUudHJpbVJpZ2h0KCk7XG4gICAgICBsaW5lID0gbGluZS50cmltKCk7XG4gICAgICBjb25zdCBpbmRleCA9IGxpbmUuaW5kZXhPZih0aGlzLkZJRUxEX1NFUEFSQVRPUik7XG4gICAgICBpZiAoaW5kZXggPD0gMCkgcmV0dXJuO1xuICAgICAgLy8gY29uc3QgZmllbGQgPSBsaW5lLnN1YnN0cmluZygwLCBpbmRleCk7XG4gICAgICAvLyBhbHNvIHJlbW92ZSBxdW90ZXNcbiAgICAgIGNvbnN0IGZpZWxkID0gbGluZS5zdWJzdHJpbmcoMCwgaW5kZXgpLnJlcGxhY2UoL15cInxcIiQvZywgJycpO1xuICAgICAgaWYoIVsnaWQnLCAncmV0cnknLCAnZGF0YScsICdldmVudCcsICd0ZXh0J10uaW5jbHVkZXMoZmllbGQpKSByZXR1cm47XG4gICAgICAvLyBpZiAoIShmaWVsZCBpbiBlKSkgcmV0dXJuO1xuICAgICAgLy8gY29uc3QgdmFsdWUgPSBsaW5lLnN1YnN0cmluZyhpbmRleCArIDEpLnRyaW1MZWZ0KCk7XG4gICAgICBjb25zdCB2YWx1ZSA9IGxpbmUuc3Vic3RyaW5nKGluZGV4ICsgMSkudHJpbSgpLnJlcGxhY2UoL15cInxcIiQvZywgJycpO1xuICAgICAgLy8gaWYgKGZpZWxkID09PSAnZGF0YScpIGVbZmllbGRdICs9IHZhbHVlO1xuICAgICAgLy8gZWxzZSBlW2ZpZWxkXSA9IHZhbHVlO1xuICAgICAgZS5kYXRhICs9IHZhbHVlO1xuICAgIH0pO1xuICAgIGlmIChlLmlkKSB0aGlzLmxhc3RfZXZlbnRfaWQgPSBlLmlkO1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KGUuZXZlbnQgfHwgJ21lc3NhZ2UnKTtcbiAgICBldmVudC5pZCA9IGUuaWQ7XG4gICAgZXZlbnQuZGF0YSA9IGUuZGF0YSB8fCAnJztcbiAgICBldmVudC5sYXN0X2V2ZW50X2lkID0gdGhpcy5sYXN0X2V2ZW50X2lkO1xuICAgIHJldHVybiBldmVudDtcbiAgfVxuICAjY2hlY2tTdHJlYW1DbG9zZWQoKSB7XG4gICAgaWYgKCF0aGlzLnhocikgcmV0dXJuO1xuICAgIGlmICh0aGlzLnhoci5yZWFkeVN0YXRlID09PSBYTUxIdHRwUmVxdWVzdC5ET05FKSB0aGlzLiNzZXRSZWFkeVN0YXRlKHRoaXMuQ0xPU0VEKTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuU21hcnRTdHJlYW1lciA9IFNtYXJ0U3RyZWFtZXI7XG4iLCAiYXN5bmMgZnVuY3Rpb24gZmV0Y2hfb3Blbl9yb3V0ZXJfbW9kZWxzKCkge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJ2h0dHBzOi8vb3BlbnJvdXRlci5haS9hcGkvdjEvbW9kZWxzJyk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZXR3b3JrIHJlc3BvbnNlIHdhcyBub3Qgb2snKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICBjb25zb2xlLmxvZygnTW9kZWwgZGF0YSByZXRyaWV2ZWQ6JywgZGF0YSk7XG4gICAgcmV0dXJuIGRhdGEuZGF0YVxuICAgICAgLy8gLmZpbHRlcihtb2RlbCA9PiAhbW9kZWwuaWQuaW5jbHVkZXMoJ2luc3RydWN0JykpXG4gICAgICAubWFwKG1vZGVsID0+ICh7XG4gICAgICAgIG1vZGVsX25hbWU6IG1vZGVsLmlkLFxuICAgICAgICBrZXk6IG1vZGVsLmlkLFxuICAgICAgICBtYXhfaW5wdXRfdG9rZW5zOiBtb2RlbC5jb250ZXh0X2xlbmd0aCxcbiAgICAgICAgZGVzY3JpcHRpb246IG1vZGVsLm5hbWUsXG4gICAgICAgIGFjdGlvbnM6IG1vZGVsLmRlc2NyaXB0aW9uLmluY2x1ZGVzKCd0b29sIHVzZScpIHx8IG1vZGVsLmRlc2NyaXB0aW9uLmluY2x1ZGVzKCdmdW5jdGlvbiBjYWxsJylcbiAgICAgIH0pKVxuICAgIDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggbW9kZWwgZGF0YTonLCBlcnJvcik7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5leHBvcnRzLmZldGNoX29wZW5fcm91dGVyX21vZGVscyA9IGZldGNoX29wZW5fcm91dGVyX21vZGVsczsiLCAiY29uc3QgbW9kZWxfY29udGV4dCA9IHtcbiAgXCJncHQtMy41LXR1cmJvXCI6IHtcbiAgICBcImNvbnRleHRcIjogMTYzODUsXG4gICAgXCJtYXhfb3V0XCI6IDQwOTZcbiAgfSxcbiAgXCJncHQtMy41LXR1cmJvLTAxMjVcIjoge1xuICAgIFwiY29udGV4dFwiOiAxNjM4NSxcbiAgICBcIm1heF9vdXRcIjogNDA5NlxuICB9LFxuICBcImdwdC0zLjUtdHVyYm8tMDMwMVwiOiB7XG4gICAgXCJjb250ZXh0XCI6IDQwOTcsXG4gICAgXCJtYXhfb3V0XCI6IDQwOTdcbiAgfSxcbiAgXCJncHQtMy41LXR1cmJvLTA2MTNcIjoge1xuICAgIFwiY29udGV4dFwiOiA0MDk3LFxuICAgIFwibWF4X291dFwiOiA0MDk3XG4gIH0sXG4gIFwiZ3B0LTMuNS10dXJiby0xMTA2XCI6IHtcbiAgICBcImNvbnRleHRcIjogMTYzODUsXG4gICAgXCJtYXhfb3V0XCI6IDQwOTZcbiAgfSxcbiAgXCJncHQtMy41LXR1cmJvLTE2a1wiOiB7XG4gICAgXCJjb250ZXh0XCI6IDE2Mzg1LFxuICAgIFwibWF4X291dFwiOiAxNjM4NVxuICB9LFxuICBcImdwdC0zLjUtdHVyYm8tMTZrLTA2MTNcIjoge1xuICAgIFwiY29udGV4dFwiOiAxNjM4NSxcbiAgICBcIm1heF9vdXRcIjogMTYzODVcbiAgfSxcbiAgXCJncHQtNFwiOiB7XG4gICAgXCJjb250ZXh0XCI6IDgxOTIsXG4gICAgXCJtYXhfb3V0XCI6IDgxOTJcbiAgfSxcbiAgXCJncHQtNC0wMTI1LXByZXZpZXdcIjoge1xuICAgIFwiY29udGV4dFwiOiAxMjgwMDAsXG4gICAgXCJtYXhfb3V0XCI6IDQwOTZcbiAgfSxcbiAgXCJncHQtNC0wMzE0XCI6IHtcbiAgICBcImNvbnRleHRcIjogODE5MixcbiAgICBcIm1heF9vdXRcIjogODE5MlxuICB9LFxuICBcImdwdC00LTA2MTNcIjoge1xuICAgIFwiY29udGV4dFwiOiA4MTkyLFxuICAgIFwibWF4X291dFwiOiA4MTkyXG4gIH0sXG4gIFwiZ3B0LTQtMTEwNi1wcmV2aWV3XCI6IHtcbiAgICBcImNvbnRleHRcIjogMTI4MDAwLFxuICAgIFwibWF4X291dFwiOiA0MDk2XG4gIH0sXG4gIFwiZ3B0LTQtMTEwNi12aXNpb24tcHJldmlld1wiOiB7XG4gICAgXCJjb250ZXh0XCI6IDEyODAwMCxcbiAgICBcIm1heF9vdXRcIjogNDA5NlxuICB9LFxuICBcImdwdC00LTMya1wiOiB7XG4gICAgXCJjb250ZXh0XCI6IDMyNzY4LFxuICAgIFwibWF4X291dFwiOiAzMjc2OFxuICB9LFxuICBcImdwdC00LTMyay0wMzE0XCI6IHtcbiAgICBcImNvbnRleHRcIjogMzI3NjgsXG4gICAgXCJtYXhfb3V0XCI6IDMyNzY4XG4gIH0sXG4gIFwiZ3B0LTQtMzJrLTA2MTNcIjoge1xuICAgIFwiY29udGV4dFwiOiAzMjc2OCxcbiAgICBcIm1heF9vdXRcIjogMzI3NjhcbiAgfSxcbiAgXCJncHQtNC10dXJib1wiOiB7XG4gICAgXCJjb250ZXh0XCI6IDEyODAwMCxcbiAgICBcIm1heF9vdXRcIjogNDA5NlxuICB9LFxuICBcImdwdC00LXR1cmJvLXByZXZpZXdcIjoge1xuICAgIFwiY29udGV4dFwiOiAxMjgwMDAsXG4gICAgXCJtYXhfb3V0XCI6IDQwOTZcbiAgfSxcbiAgXCJncHQtNC12aXNpb24tcHJldmlld1wiOiB7XG4gICAgXCJjb250ZXh0XCI6IDEyODAwMCxcbiAgICBcIm1heF9vdXRcIjogNDA5NlxuICB9XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaF9vcGVuYWlfbW9kZWxzKGFwaV9rZXkpIHtcbiAgaWYgKCFhcGlfa2V5KSB7XG4gICAgY29uc29sZS5lcnJvcignTm8gQVBJIGtleSBwcm92aWRlZCcpO1xuICAgIHJldHVybiBbXTtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJ2h0dHBzOi8vYXBpLm9wZW5haS5jb20vdjEvbW9kZWxzJywge1xuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHthcGlfa2V5fWAsXG4gICAgICB9LFxuICAgIH0pO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTmV0d29yayByZXNwb25zZSB3YXMgbm90IG9rJyk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgY29uc29sZS5sb2coJ01vZGVsIGRhdGEgcmV0cmlldmVkOicsIGRhdGEpO1xuICAgIHJldHVybiBkYXRhLmRhdGFcbiAgICAgIC5maWx0ZXIobW9kZWwgPT4gbW9kZWwuaWQuc3RhcnRzV2l0aCgnZ3B0LScpICYmICFtb2RlbC5pZC5pbmNsdWRlcygnLWluc3RydWN0JykpXG4gICAgICAubWFwKG1vZGVsID0+IHtcbiAgICAgICAgY29uc3Qgb3V0ID0ge21vZGVsX25hbWU6IG1vZGVsLmlkLCBrZXk6IG1vZGVsLmlkfTtcbiAgICAgICAgaWYobW9kZWxfY29udGV4dFttb2RlbC5pZF0pIHtcbiAgICAgICAgICBvdXQubWF4X2lucHV0X3Rva2VucyA9IG1vZGVsX2NvbnRleHRbbW9kZWwuaWRdLmNvbnRleHQ7XG4gICAgICAgICAgb3V0LmRlc2NyaXB0aW9uID0gYGNvbnRleHQ6ICR7bW9kZWxfY29udGV4dFttb2RlbC5pZF0uY29udGV4dH0sIG91dHB1dDogJHttb2RlbF9jb250ZXh0W21vZGVsLmlkXS5tYXhfb3V0fWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgIH0pXG4gICAgO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBtb2RlbCBkYXRhOicsIGVycm9yKTtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cbmV4cG9ydHMuZmV0Y2hfb3BlbmFpX21vZGVscyA9IGZldGNoX29wZW5haV9tb2RlbHM7IiwgImFzeW5jIGZ1bmN0aW9uIGZldGNoX2dvb2dsZV9nZW1pbmlfbW9kZWxzKGFwaV9rZXkpIHtcbiAgaWYgKCFhcGlfa2V5KSB7XG4gICAgY29uc29sZS5lcnJvcignTm8gQVBJIGtleSBwcm92aWRlZCcpO1xuICAgIHJldHVybiBbXTtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJ2h0dHBzOi8vZ2VuZXJhdGl2ZWxhbmd1YWdlLmdvb2dsZWFwaXMuY29tL3YxYmV0YS9tb2RlbHM/a2V5PScgKyBhcGlfa2V5KTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05ldHdvcmsgcmVzcG9uc2Ugd2FzIG5vdCBvaycpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIGNvbnNvbGUubG9nKCdNb2RlbCBkYXRhIHJldHJpZXZlZDonLCBkYXRhKTtcbiAgICByZXR1cm4gZGF0YS5tb2RlbHNcbiAgICAgIC5maWx0ZXIobW9kZWwgPT4gbW9kZWwubmFtZS5zdGFydHNXaXRoKCdtb2RlbHMvZ2VtaW5pJykpXG4gICAgICAubWFwKG1vZGVsID0+IHtcbiAgICAgICAgY29uc3Qgb3V0ID0ge1xuICAgICAgICAgIG1vZGVsX25hbWU6IG1vZGVsLm5hbWUuc3BsaXQoJy8nKS5wb3AoKSwgXG4gICAgICAgICAga2V5OiBtb2RlbC5uYW1lLnNwbGl0KCcvJykucG9wKCksXG4gICAgICAgICAgbWF4X2lucHV0X3Rva2VuczogbW9kZWwuaW5wdXRUb2tlbkxpbWl0LFxuICAgICAgICAgIG1heF9vdXRwdXRfdG9rZW5zOiBtb2RlbC5tYXhPdXRwdXRUb2tlbnMsXG4gICAgICAgICAgZGVzY3JpcHRpb246IG1vZGVsLmRlc2NyaXB0aW9uXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgICB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggbW9kZWwgZGF0YTonLCBlcnJvcik7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5leHBvcnRzLmZldGNoX2dvb2dsZV9nZW1pbmlfbW9kZWxzID0gZmV0Y2hfZ29vZ2xlX2dlbWluaV9tb2RlbHM7IiwgIi8vIGN1cmwgLS1yZXF1ZXN0IEdFVCBcXFxuLy8gICAtLXVybCBodHRwczovL2FwaS5jb2hlcmUuYWkvdjEvbW9kZWxzIFxcXG4vLyAgIC0taGVhZGVyICdhY2NlcHQ6IGFwcGxpY2F0aW9uL2pzb24nIFxcXG4vLyAgIC0taGVhZGVyIFwiQXV0aG9yaXphdGlvbjogYmVhcmVyICRDT19BUElfS0VZXCJcblxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hfY29oZXJlX21vZGVscyhhcGlfa2V5KSB7XG4gIGlmICghYXBpX2tleSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ05vIEFQSSBrZXkgcHJvdmlkZWQnKTtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCdodHRwczovL2FwaS5jb2hlcmUuYWkvdjEvbW9kZWxzJywge1xuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHthcGlfa2V5fWAsXG4gICAgICB9LFxuICAgIH0pO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTmV0d29yayByZXNwb25zZSB3YXMgbm90IG9rJyk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgY29uc29sZS5sb2coJ01vZGVsIGRhdGEgcmV0cmlldmVkOicsIGRhdGEpO1xuICAgIHJldHVybiBkYXRhLm1vZGVsc1xuICAgICAgLmZpbHRlcihtb2RlbCA9PiBtb2RlbC5uYW1lLnN0YXJ0c1dpdGgoJ2NvbW1hbmQtJykpXG4gICAgICAubWFwKG1vZGVsID0+IHtcbiAgICAgICAgY29uc3Qgb3V0ID0ge1xuICAgICAgICAgIG1vZGVsX25hbWU6IG1vZGVsLm5hbWUsXG4gICAgICAgICAga2V5OiBtb2RlbC5uYW1lLFxuICAgICAgICAgIG1heF9pbnB1dF90b2tlbnM6IG1vZGVsLmNvbnRleHRfbGVuZ3RoLFxuICAgICAgICAgIHRva2VuaXplcl91cmw6IG1vZGVsLnRva2VuaXplcl91cmwsXG4gICAgICAgICAgZmluZXR1bmVkOiBtb2RlbC5maW5ldHVuZWQsXG4gICAgICAgICAgZGVzY3JpcHRpb246IGBNYXggaW5wdXQgdG9rZW5zOiAke21vZGVsLmNvbnRleHRfbGVuZ3RofSwgRmluZXR1bmVkOiAke21vZGVsLmZpbmV0dW5lZH1gXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgICB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggbW9kZWwgZGF0YTonLCBlcnJvcik7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5leHBvcnRzLmZldGNoX2NvaGVyZV9tb2RlbHMgPSBmZXRjaF9jb2hlcmVfbW9kZWxzO1xuXG4iLCAiLy8gZmFrZSBpdCBiZWNhdXNlIGFudGhyb3BpYyBkb2Vzbid0IGhhdmUgbW9kZWwgbGlzdCBBUEkgZW5kcG9pbnRcbmFzeW5jIGZ1bmN0aW9uIGZldGNoX2FudGhyb3BpY19tb2RlbHMoKSB7XG4gIHJldHVybiBbe1xuICAgIFwia2V5XCI6IFwiY2xhdWRlLTMtb3B1cy0yMDI0MDIyOVwiLFxuICAgIFwibW9kZWxfbmFtZVwiOiBcImNsYXVkZS0zLW9wdXMtMjAyNDAyMjlcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQW50aHJvcGljJ3MgQ2xhdWRlIG1vZGVsXCIsXG4gICAgXCJtYXhfaW5wdXRfdG9rZW5zXCI6IDIwMDAwMCxcbiAgICBcIm1heF9vdXRwdXRfdG9rZW5zXCI6IDQwMDAsXG4gIH0sXG4gIHtcbiAgICBrZXk6IFwiY2xhdWRlLTMtc29ubmV0LTIwMjQwMjI5XCIsXG4gICAgXCJtb2RlbF9uYW1lXCI6IFwiY2xhdWRlLTMtc29ubmV0LTIwMjQwMjI5XCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkFudGhyb3BpYydzIFNvbm5ldCBtb2RlbFwiLFxuICAgIFwibWF4X2lucHV0X3Rva2Vuc1wiOiAyMDAwMDAsXG4gICAgXCJtYXhfb3V0cHV0X3Rva2Vuc1wiOiA0MDAwLFxuICB9LFxuICB7XG4gICAga2V5OiBcImNsYXVkZS0zLWhhaWt1LTIwMjQwMzA3XCIsXG4gICAgXCJtb2RlbF9uYW1lXCI6IFwiY2xhdWRlLTMtaGFpa3UtMjAyNDAzMDdcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQW50aHJvcGljJ3MgSGFpa3UgbW9kZWxcIixcbiAgICBcIm1heF9pbnB1dF90b2tlbnNcIjogMjAwMDAwLFxuICAgIFwibWF4X291dHB1dF90b2tlbnNcIjogNDAwMCxcbiAgfV07XG59XG5leHBvcnRzLmZldGNoX2FudGhyb3BpY19tb2RlbHMgPSBmZXRjaF9hbnRocm9waWNfbW9kZWxzO1xuXG4iLCAiY29uc3QgeyBmZXRjaF9vcGVuX3JvdXRlcl9tb2RlbHMgfSA9IHJlcXVpcmUoJy4vb3Blbl9yb3V0ZXInKTtcbmNvbnN0IHsgZmV0Y2hfb3BlbmFpX21vZGVscyB9ID0gcmVxdWlyZSgnLi9vcGVuYWknKTtcbmNvbnN0IHsgZmV0Y2hfZ29vZ2xlX2dlbWluaV9tb2RlbHMgfSA9IHJlcXVpcmUoJy4vZ29vZ2xlX2dlbWluaScpO1xuY29uc3QgeyBmZXRjaF9jb2hlcmVfbW9kZWxzIH0gPSByZXF1aXJlKCcuL2NvaGVyZScpO1xuY29uc3QgeyBmZXRjaF9hbnRocm9waWNfbW9kZWxzIH0gPSByZXF1aXJlKCcuL2FudGhyb3BpYycpO1xuZXhwb3J0cy5vcGVuX3JvdXRlciA9IGZldGNoX29wZW5fcm91dGVyX21vZGVscztcbmV4cG9ydHMub3BlbmFpID0gZmV0Y2hfb3BlbmFpX21vZGVscztcbmV4cG9ydHMuZ29vZ2xlX2dlbWluaSA9IGZldGNoX2dvb2dsZV9nZW1pbmlfbW9kZWxzO1xuZXhwb3J0cy5jb2hlcmUgPSBmZXRjaF9jb2hlcmVfbW9kZWxzO1xuZXhwb3J0cy5hbnRocm9waWMgPSBmZXRjaF9hbnRocm9waWNfbW9kZWxzO1xuXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBCcmlhbiBKb3NlcGggUGV0cm9cblxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXG4vLyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4vLyBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbi8vIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbi8vIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuLy8gRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuLy8gTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRVxuLy8gTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTlxuLy8gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4vLyBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuY29uc3QgYWRhcHRlcnMgPSByZXF1aXJlKCcuL2FkYXB0ZXJzJyk7XG5jb25zdCBwbGF0Zm9ybXMgPSByZXF1aXJlKCcuL3BsYXRmb3Jtcy5qc29uJyk7XG5jb25zdCB7IGlzX3ZhbGlkX3Rvb2xfY2FsbCB9ID0gcmVxdWlyZSgnLi91dGlscy9pc192YWxpZF90b29sX2NhbGwnKTtcbmNvbnN0IHsgU21hcnRTdHJlYW1lciB9ID0gcmVxdWlyZSgnLi9zdHJlYW1lcicpO1xuY29uc3QgZmV0Y2hfbW9kZWxzID0gcmVxdWlyZShcIi4vbW9kZWxzL2ZldGNoXCIpO1xuLyoqXG4gKiBTbWFydENoYXRNb2RlbCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXRpZXMgdG8gaGFuZGxlIGNoYXQgaW50ZXJhY3Rpb25zIHdpdGggdmFyaW91cyBtb2RlbHMgYW5kIGFkYXB0ZXJzLlxuICogSXQgc3VwcG9ydHMgc3RyZWFtaW5nIGFuZCBub24tc3RyZWFtaW5nIHJlc3BvbnNlcywgdG9vbCBjYWxscywgYW5kIGN1c3RvbWl6YXRpb25zIHRocm91Z2ggb3B0aW9ucy5cbiAqL1xuY2xhc3MgU21hcnRDaGF0TW9kZWwge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhbiBpbnN0YW5jZSBvZiBTbWFydENoYXRNb2RlbCB3aXRoIHNwZWNpZmllZCBlbnZpcm9ubWVudCwgbW9kZWwga2V5LCBhbmQgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG1haW4gLSBUaGUgbWFpbiBlbnZpcm9ubWVudCBjb250ZXh0LCB0eXBpY2FsbHkgY29udGFpbmluZyBjb25maWd1cmF0aW9ucyBhbmQgc3RhdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwbGF0Zm9ybV9rZXkgLSBLZXkgdG8gc2VsZWN0IHRoZSBzcGVjaWZpYyBtb2RlbCBjb25maWd1cmF0aW9uIGZyb20gbW9kZWxzLmpzb24uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9jb25maWcgLSBPcHRpb25hbCBwYXJhbWV0ZXJzIHRvIG92ZXJyaWRlIG1vZGVsIGNvbmZpZ3VyYXRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3IobWFpbiwgcGxhdGZvcm1fa2V5LCBtb2RlbF9jb25maWc9e30pIHtcbiAgICB0aGlzLmVudiA9IG1haW47XG4gICAgdGhpcy5tYWluID0gdGhpcy5lbnY7IC8vIERFUFJFQ0FURURcbiAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgIC4uLihwbGF0Zm9ybXNbcGxhdGZvcm1fa2V5XSB8fCB7fSksXG4gICAgICAuLi5tb2RlbF9jb25maWcsIC8vIG92ZXJyaWRlIGRlZmF1bHQgcGxhdGZvcm0gY29uZmlnXG4gICAgfVxuICAgIHRoaXMucGxhdGZvcm1fa2V5ID0gcGxhdGZvcm1fa2V5O1xuICAgIHRoaXMuYWN0aXZlX3N0cmVhbSA9IG51bGw7XG4gICAgdGhpcy5fcmVxdWVzdF9hZGFwdGVyID0gbnVsbDtcbiAgICB0aGlzLnBsYXRmb3JtcyA9IHBsYXRmb3JtcztcbiAgICBpZih0aGlzLmNvbmZpZy5hZGFwdGVyKSB0aGlzLmFkYXB0ZXIgPSBuZXcgYWRhcHRlcnNbdGhpcy5jb25maWcuYWRhcHRlcl0odGhpcyk7XG4gICAgY29uc29sZS5sb2codGhpcy5hZGFwdGVyKTtcbiAgfVxuICBzdGF0aWMgZ2V0IG1vZGVscygpIHsgcmV0dXJuIHBsYXRmb3JtczsgfVxuICBnZXQgZGVmYXVsdF9vcHRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0ZW1wZXJhdHVyZTogMC4zLFxuICAgICAgdG9wX3A6IDEsXG4gICAgICBwcmVzZW5jZV9wZW5hbHR5OiAwLFxuICAgICAgZnJlcXVlbmN5X3BlbmFsdHk6IDAsXG4gICAgICBuOiAxLFxuICAgICAgbW9kZWw6IHRoaXMubW9kZWxfbmFtZSxcbiAgICAgIG1heF90b2tlbnM6IHRoaXMubWF4X291dHB1dF90b2tlbnMsXG4gICAgfTtcbiAgfVxuICBhc3luYyByZXF1ZXN0X21pZGRsZXdhcmVzKG9wdHMpIHsgcmV0dXJuIG9wdHM7IH1cbiAgLyoqXG4gICAqIENvbXBsZXRlcyB0aGUgY2hhdCBpbnRlcmFjdGlvbiBieSBwcm9jZXNzaW5nIHRoZSBwcm92aWRlZCBvcHRpb25zLCBtYWtpbmcgYW4gQVBJIHJlcXVlc3QsIGFuZCBoYW5kbGluZyB0aGUgcmVzcG9uc2UuXG4gICAqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIGJvdGggc3RyZWFtaW5nIGFuZCBub24tc3RyZWFtaW5nIHJlc3BvbnNlcywgYW5kIGNhbiBoYW5kbGUgdG9vbCBjYWxscyBpZiBzcGVjaWZpZWQgaW4gdGhlIHJlc3BvbnNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIFRoZSBvcHRpb25zIGZvciB0aGUgY2hhdCBjb21wbGV0aW9uIHdoaWNoIG1heSBpbmNsdWRlIHNldHRpbmdzIGxpa2UgdGVtcGVyYXR1cmUsIG1heCB0b2tlbnMsIGV0Yy5cbiAgICogQHBhcmFtIHtib29sZWFufSByZW5kZXIgLSBGbGFnIHRvIGRldGVybWluZSBpZiB0aGUgcmVzcG9uc2Ugc2hvdWxkIGJlIHJlbmRlcmVkIGluIHRoZSBVSS5cbiAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nfHZvaWQ+fSAtIFJldHVybnMgdGhlIGNoYXQgcmVzcG9uc2UgY29udGVudCBvciBoYW5kbGVzIHRvb2wgb3V0cHV0cyByZWN1cnNpdmVseS4gSW4gY2FzZSBvZiBlcnJvcnMsIGl0IG1heSByZXR1cm4gYW4gZXJyb3IgbWVzc2FnZS5cbiAgICovXG4gIGFzeW5jIGNvbXBsZXRlKG9wdHM9e30sIHJlbmRlcj10cnVlKSB7XG4gICAgaWYoIXRoaXMuYmFzZV9tb2RlbF9jb25maWcpe1xuICAgICAgdGhpcy5iYXNlX21vZGVsX2NvbmZpZyA9IGF3YWl0IHRoaXMuZ2V0X2Jhc2VfbW9kZWxfY29uZmlnKCk7XG4gICAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgICAgLi4udGhpcy5iYXNlX21vZGVsX2NvbmZpZyxcbiAgICAgICAgLi4udGhpcy5jb25maWcsXG4gICAgICB9O1xuICAgIH1cbiAgICBvcHRzID0ge1xuICAgICAgLi4udGhpcy5kZWZhdWx0X29wdHMsXG4gICAgICBtZXNzYWdlczogKGF3YWl0IHRoaXMuY3VycmVudD8uZ2V0X2NoYXRfbWwoKSk/Lm1lc3NhZ2VzIHx8IFtdLFxuICAgICAgLi4ub3B0cyxcbiAgICB9O1xuICAgIGlmKG9wdHMuc3RyZWFtICE9PSBmYWxzZSAmJiB0aGlzLmNvbmZpZy5zdHJlYW1pbmcgJiYgIXRoaXMuY3VycmVudC50b29sX2Nob2ljZSkgb3B0cy5zdHJlYW0gPSB0cnVlOyAvLyBubyBzdHJlYW1pbmcgaWYgdG9vbF9jaG9pY2UgaXMgc2V0XG4gICAgZWxzZSBvcHRzLnN0cmVhbSA9IGZhbHNlO1xuICAgIG9wdHMgPSBhd2FpdCB0aGlzLnJlcXVlc3RfbWlkZGxld2FyZXMoSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvcHRzKSkpO1xuICAgIGNvbnN0IHJlcSA9IHtcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0aGlzLmFwaV9rZXl9YFxuICAgICAgfSxcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgfTtcbiAgICBpZiAodGhpcy5jb25maWcuaGVhZGVycykgcmVxLmhlYWRlcnMgPSB7IC4uLnJlcS5oZWFkZXJzLCAuLi50aGlzLmNvbmZpZy5oZWFkZXJzIH07XG4gICAgaWYgKHRoaXMuY29uZmlnLmFwaV9rZXlfaGVhZGVyKSB7XG4gICAgICBpZih0aGlzLmNvbmZpZy5hcGlfa2V5X2hlYWRlciAhPT0gJ25vbmUnKSByZXEuaGVhZGVyc1t0aGlzLmNvbmZpZy5hcGlfa2V5X2hlYWRlcl0gPSB0aGlzLmFwaV9rZXk7XG4gICAgICBkZWxldGUgcmVxLmhlYWRlcnMuQXV0aG9yaXphdGlvbjtcbiAgICB9XG4gICAgLy8gYm9keSBjb25zdGFudCBzdG9yZXMgY2hhdG1sIGZvciBsYXRlclxuICAgIGNvbnN0IGJvZHkgPSB0eXBlb2YgdGhpcy5lbnYuYWN0aW9ucz8ucHJlcGFyZV9yZXF1ZXN0X2JvZHkgPT09ICdmdW5jdGlvbicgPyB0aGlzLmVudi5hY3Rpb25zLnByZXBhcmVfcmVxdWVzdF9ib2R5KG9wdHMpIDogeyAuLi5vcHRzIH07XG4gICAgLy8gYWRhcHRlciBjYW4gbW9kaWZ5IGJvZHkgYmFzZWQgb24gcGxhdGZvcm1cbiAgICByZXEuYm9keSA9IEpTT04uc3RyaW5naWZ5KHR5cGVvZiB0aGlzLmFkYXB0ZXI/LnByZXBhcmVfcmVxdWVzdF9ib2R5ID09PSAnZnVuY3Rpb24nID8gdGhpcy5hZGFwdGVyLnByZXBhcmVfcmVxdWVzdF9ib2R5KGJvZHkpIDogYm9keSk7XG4gICAgY29uc29sZS5sb2cocmVxKTtcbiAgICB0cnkge1xuICAgICAgaWYob3B0cy5zdHJlYW0pIHJldHVybiBhd2FpdCB0aGlzLnN0cmVhbShyZXEpO1xuICAgICAgLy8gSEFORExFIE5PTi1TVFJFQU1JTkcgKGluY2x1ZGVzIGFsbCBmdW5jdGlvbiBjYWxscylcbiAgICAgIGNvbnN0IHJlc3BfanNvbiA9IGF3YWl0IHRoaXMucmVxdWVzdChyZXEpO1xuICAgICAgaWYocmVzcF9qc29uLmVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IocmVzcF9qc29uLmVycm9yKTtcbiAgICAgICAgaWYocmVuZGVyKSB0aGlzLmRvbmVfaGFuZGxlcihcIipBUEkgRXJyb3IuIFNlZSBjb25zb2xlIGxvZ3MgZm9yIGRldGFpbHMuKlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gaWYgaXMgdG9vbF9jYWxsLCBoYW5kbGUgdG9vbF9jYWxsIGFuZCByZXR1cm5cbiAgICAgIGNvbnN0IHRvb2xfY2FsbCA9IHRoaXMuZ2V0X3Rvb2xfY2FsbChyZXNwX2pzb24pO1xuICAgICAgaWYodG9vbF9jYWxsKXtcbiAgICAgICAgdGhpcy5lbnYuY2hhdHMuY3VycmVudC50b29sX2Nob2ljZSA9IG51bGw7IC8vIElNUE9SVEFOVDogcHJldmVudCBpbmZpbml0ZSBsb29wXG4gICAgICAgIC8vIGlmICh0aGlzLmN1cnJlbnQudG9vbF9jaG9pY2UgIT09IFwiYXV0b1wiKSB0aGlzLmN1cnJlbnQudG9vbF9jaG9pY2UgPSBudWxsOyAvLyByZW1vdmUgdG9vbF9jaG9pY2UgZnJvbSBjdXJyZW50IGlmIG5vdCBhdXRvIChwcmV2ZW50IGluZmluaXRlIGxvb3ApXG4gICAgICAgIGNvbnN0IHRvb2xfbmFtZSA9IHRoaXMuZ2V0X3Rvb2xfbmFtZSh0b29sX2NhbGwpO1xuICAgICAgICBjb25zdCB0b29sX2NhbGxfY29udGVudCA9IHRoaXMuZ2V0X3Rvb2xfY2FsbF9jb250ZW50KHRvb2xfY2FsbCk7XG4gICAgICAgIGNvbnN0IHRvb2wgPSBib2R5LnRvb2xzLmZpbmQoKHQpID0+IHQuZnVuY3Rpb24ubmFtZSA9PT0gdG9vbF9uYW1lKTsgLy8gcGxhdGZvcm0tYWdub3N0aWNcbiAgICAgICAgaWYoaXNfdmFsaWRfdG9vbF9jYWxsKHRvb2wsIHRvb2xfY2FsbF9jb250ZW50KSl7XG4gICAgICAgICAgYXdhaXQgdGhpcy5jdXJyZW50LmFkZF9tZXNzYWdlKHsgcm9sZTogJ2Fzc2lzdGFudCcsIHRvb2xfY2FsbHM6IFt7XG4gICAgICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgICBuYW1lOiB0b29sX25hbWUsXG4gICAgICAgICAgICAgIGFyZ3VtZW50czogSlNPTi5zdHJpbmdpZnkodG9vbF9jYWxsX2NvbnRlbnQpLFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1dIH0pO1xuICAgICAgICAgIGNvbnN0IHRvb2xfaGFuZGxlciA9IHRoaXMuZ2V0X3Rvb2xfaGFuZGxlcih0b29sX25hbWUpO1xuICAgICAgICAgIGlmKCF0b29sX2hhbmRsZXIpIHJldHVybiBjb25zb2xlLmVycm9yKGBUb29sICR7dG9vbF9uYW1lfSBub3QgZm91bmRgKTtcbiAgICAgICAgICBjb25zdCB0b29sX291dHB1dCA9IGF3YWl0IHRvb2xfaGFuZGxlcih0aGlzLmVudiwgdG9vbF9jYWxsX2NvbnRlbnQpO1xuICAgICAgICAgIGlmKHRvb2xfb3V0cHV0KSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmN1cnJlbnQuYWRkX3Rvb2xfb3V0cHV0KHRvb2xfbmFtZSwgdG9vbF9vdXRwdXQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUoe30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgLy8gRE86IHVzZSB0b29sIHNwZWNzIHRvIGNvZXJjZSB0b29sX2NhbGwgdG8gbWF0Y2ggdG9vbC5mdW5jdGlvbi5wYXJhbWV0ZXJzXG4gICAgICAgICAgY29uc29sZS5lcnJvcihgSW52YWxpZCB0b29sIGNhbGw6ICR7dG9vbF9jYWxsfWApO1xuICAgICAgICAgIGlmKHJlbmRlcikgdGhpcy5kb25lX2hhbmRsZXIoXCIqSW52YWxpZCB0b29sIGNhbGwuIFNlZSBjb25zb2xlIGxvZ3MgZm9yIGRldGFpbHMuKlwiKTtcbiAgICAgICAgICByZXR1cm4gXCIqSW52YWxpZCB0b29sIGNhbGwuIFNlZSBjb25zb2xlIGxvZ3MgZm9yIGRldGFpbHMuKlwiO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKHJlbmRlcikgdGhpcy5kb25lX2hhbmRsZXIodGhpcy5nZXRfbWVzc2FnZV9jb250ZW50KHJlc3BfanNvbikpO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0X21lc3NhZ2VfY29udGVudChyZXNwX2pzb24pO1xuICAgICAgLy8gY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgLy8gbmV3IE5vdGljZShgU21hcnQgQ29ubmVjdGlvbnMgQVBJIEVycm9yIDo6ICR7ZXJyfWApO1xuICAgIH1cbiAgfVxuICAvLyBIQU5ETEUgVE9PTFNcbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgdG9vbCBoYW5kbGVyIGZ1bmN0aW9uIGJhc2VkIG9uIHRoZSB0b29sIG5hbWUgZnJvbSB0aGUgZW52aXJvbm1lbnQncyBhY3Rpb25zLlxuICAgKiBUaGlzIG1ldGhvZCBjYW4gYmUgb3ZlcnJpZGRlbiB0byB1c2UgY3VzdG9tIGxvZ2ljIGZvciBoYW5kbGluZyB0b29scy5cbiAgICogXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b29sX25hbWUgLSBUaGUgbmFtZSBvZiB0aGUgdG9vbCBmb3Igd2hpY2ggdGhlIGhhbmRsZXIgaXMgdG8gYmUgcmV0cmlldmVkLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFRoZSBoYW5kbGVyIGZ1bmN0aW9uIGZvciB0aGUgc3BlY2lmaWVkIHRvb2wuXG4gICAqL1xuICBnZXRfdG9vbF9oYW5kbGVyKHRvb2xfbmFtZSkgeyByZXR1cm4gdGhpcy5lbnYuYWN0aW9ucy5hY3Rpb25zW3Rvb2xfbmFtZV0uaGFuZGxlcjsgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0cyB0aGUgdG9vbCBjYWxsIGluZm9ybWF0aW9uIGZyb20gYSBKU09OIHJlc3BvbnNlLiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBhZGFwdGVyLXNwZWNpZmljIGxvZ2ljLlxuICAgKiBJZiBubyBhZGFwdGVyIG1ldGhvZCBpcyBwcm92aWRlZCwgaXQgZGVmYXVsdHMgdG8gdGhlIGV4cGVjdGVkIE9wZW5BSSBKU09OIGZvcm1hdC5cbiAgICogXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBqc29uIC0gVGhlIEpTT04gcmVzcG9uc2UgZnJvbSB3aGljaCB0byBleHRyYWN0IHRoZSB0b29sIGNhbGwuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBmaXJzdCB0b29sIGNhbGwgZm91bmQgaW4gdGhlIHJlc3BvbnNlLlxuICAgKi9cbiAgZ2V0X3Rvb2xfY2FsbChqc29uKSB7XG4gICAgaWYodHlwZW9mIHRoaXMuYWRhcHRlcj8uZ2V0X3Rvb2xfY2FsbCA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXMuYWRhcHRlci5nZXRfdG9vbF9jYWxsKGpzb24pO1xuICAgIHJldHVybiBqc29uLmNob2ljZXM/LlswXS5tZXNzYWdlLnRvb2xfY2FsbHM/LlswXTsgLy8gT3BlbkFJIGZvcm1hdFxuICB9IFxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSB0b29sIG5hbWUgZnJvbSBhIHRvb2wgY2FsbCBvYmplY3QuIFN1cHBvcnRzIGFkYXB0ZXItc3BlY2lmaWMgaW1wbGVtZW50YXRpb25zLlxuICAgKiBEZWZhdWx0cyB0byBleHRyYWN0aW5nIHRoZSBuYW1lIGRpcmVjdGx5IGZyb20gdGhlIHRvb2wgY2FsbCBzdHJ1Y3R1cmUuXG4gICAqIFxuICAgKiBAcGFyYW0ge09iamVjdH0gdG9vbF9jYWxsIC0gVGhlIHRvb2wgY2FsbCBvYmplY3QgZnJvbSB3aGljaCB0byBleHRyYWN0IHRoZSB0b29sIG5hbWUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSB0b29sLlxuICAgKi9cbiAgZ2V0X3Rvb2xfbmFtZSh0b29sX2NhbGwpIHtcbiAgICBpZih0eXBlb2YgdGhpcy5hZGFwdGVyPy5nZXRfdG9vbF9uYW1lID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpcy5hZGFwdGVyLmdldF90b29sX25hbWUodG9vbF9jYWxsKTtcbiAgICByZXR1cm4gdG9vbF9jYWxsLmZ1bmN0aW9uLm5hbWU7XG4gIH1cblxuICAvKipcbiAgICogRXh0cmFjdHMgdGhlIHRvb2wgY2FsbCBjb250ZW50IGZyb20gYSB0b29sIGNhbGwgb2JqZWN0LiBTdXBwb3J0cyBhZGFwdGVyLXNwZWNpZmljIGxvZ2ljLlxuICAgKiBEZWZhdWx0cyB0byBwYXJzaW5nIHRoZSAnYXJndW1lbnRzJyBmaWVsZCBvZiB0aGUgdG9vbCBjYWxsIGZ1bmN0aW9uIGFzIEpTT04uXG4gICAqIFxuICAgKiBAcGFyYW0ge09iamVjdH0gdG9vbF9jYWxsIC0gVGhlIHRvb2wgY2FsbCBvYmplY3QgZnJvbSB3aGljaCB0byBleHRyYWN0IHRoZSBjb250ZW50LlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcGFyc2VkIGFyZ3VtZW50cyBvZiB0aGUgdG9vbCBjYWxsLlxuICAgKi9cbiAgZ2V0X3Rvb2xfY2FsbF9jb250ZW50KHRvb2xfY2FsbCkge1xuICAgIGlmKHR5cGVvZiB0aGlzLmFkYXB0ZXI/LmdldF90b29sX2NhbGxfY29udGVudCA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXMuYWRhcHRlci5nZXRfdG9vbF9jYWxsX2NvbnRlbnQodG9vbF9jYWxsKTtcbiAgICByZXR1cm4gSlNPTi5wYXJzZSh0b29sX2NhbGwuZnVuY3Rpb24uYXJndW1lbnRzKTtcbiAgfVxuXG4gIC8vIEhBTkRMRSBNRVNTQUdFU1xuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBtZXNzYWdlIG9iamVjdCBmcm9tIGEgSlNPTiByZXNwb25zZS4gU3VwcG9ydHMgYWRhcHRlci1zcGVjaWZpYyBpbXBsZW1lbnRhdGlvbnMuXG4gICAqIERlZmF1bHRzIHRvIGhhbmRsaW5nIGJvdGggT3BlbkFJIGFuZCBPbGxhbWEgZm9ybWF0cyBieSBjaGVja2luZyBmb3IgbWVzc2FnZSBzdHJ1Y3R1cmVzIGluICdjaG9pY2VzJy5cbiAgICogXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBqc29uIC0gVGhlIEpTT04gcmVzcG9uc2UgZnJvbSB3aGljaCB0byBleHRyYWN0IHRoZSBtZXNzYWdlLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgbWVzc2FnZSBvYmplY3QgZXh0cmFjdGVkIGZyb20gdGhlIHJlc3BvbnNlLlxuICAgKi9cbiAgZ2V0X21lc3NhZ2UoanNvbikge1xuICAgIGlmKHR5cGVvZiB0aGlzLmFkYXB0ZXI/LmdldF9tZXNzYWdlID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpcy5hZGFwdGVyLmdldF9tZXNzYWdlKGpzb24pO1xuICAgIHJldHVybiBqc29uLmNob2ljZXM/LlswXS5tZXNzYWdlIHx8IGpzb24ubWVzc2FnZTsgLy8gc3VwcG9ydHMgT3BlbkFJIGFuZCBPbGxhbWFcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0cyB0aGUgY29udGVudCBvZiBhIG1lc3NhZ2UgZnJvbSBhIEpTT04gcmVzcG9uc2UuIFN1cHBvcnRzIGFkYXB0ZXItc3BlY2lmaWMgaW1wbGVtZW50YXRpb25zLlxuICAgKiBUaGlzIG1ldGhvZCByZWxpZXMgb24gYGdldF9tZXNzYWdlYCB0byBmaXJzdCByZXRyaWV2ZSB0aGUgbWVzc2FnZSBvYmplY3QuXG4gICAqIFxuICAgKiBAcGFyYW0ge09iamVjdH0ganNvbiAtIFRoZSBKU09OIHJlc3BvbnNlIGZyb20gd2hpY2ggdG8gZXh0cmFjdCB0aGUgbWVzc2FnZSBjb250ZW50LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29udGVudCBvZiB0aGUgbWVzc2FnZS5cbiAgICovXG4gIGdldF9tZXNzYWdlX2NvbnRlbnQoanNvbikge1xuICAgIGlmKHR5cGVvZiB0aGlzLmFkYXB0ZXI/LmdldF9tZXNzYWdlX2NvbnRlbnQgPT09ICdmdW5jdGlvbicpIHJldHVybiB0aGlzLmFkYXB0ZXIuZ2V0X21lc3NhZ2VfY29udGVudChqc29uKTtcbiAgICByZXR1cm4gdGhpcy5nZXRfbWVzc2FnZShqc29uKS5jb250ZW50O1xuICB9XG5cbiAgYXN5bmMgcmVxdWVzdChyZXEpe1xuICAgIHJlcS51cmwgPSB0aGlzLmVuZHBvaW50O1xuICAgIHJlcS50aHJvdyA9IGZhbHNlO1xuICAgIC8vIGhhbmRsZSBmYWxsYmFjayB0byBmZXRjaCAoYWxsb3dzIGZvciBvdmVyd3JpdGluZyBpbiBjaGlsZCBjbGFzc2VzKVxuICAgIGNvbnN0IHJlc3AgPSB0aGlzLl9yZXF1ZXN0X2FkYXB0ZXIgPyBhd2FpdCB0aGlzLl9yZXF1ZXN0X2FkYXB0ZXIocmVxKSA6IGF3YWl0IGZldGNoKHRoaXMuZW5kcG9pbnQsIHJlcSk7XG4gICAgY29uc29sZS5sb2cocmVzcCk7XG4gICAgY29uc3QgcmVzcF9qc29uID0gYXdhaXQgdGhpcy5nZXRfcmVzcF9qc29uKHJlc3ApO1xuICAgIGNvbnNvbGUubG9nKHJlc3BfanNvbik7XG4gICAgcmV0dXJuIHJlc3BfanNvbjtcbiAgfVxuICBhc3luYyBnZXRfcmVzcF9qc29uKHJlc3ApIHsgcmV0dXJuICh0eXBlb2YgcmVzcC5qc29uID09PSAnZnVuY3Rpb24nKSA/IGF3YWl0IHJlc3AuanNvbigpIDogYXdhaXQgcmVzcC5qc29uOyB9XG4gIGdldCByZXF1ZXN0X2FkYXB0ZXIoKXsgcmV0dXJuIHRoaXMuX3JlcXVlc3RfYWRhcHRlcjsgfVxuXG4gIGFzeW5jIHN0cmVhbShyZXEpIHtcbiAgICBjb25zb2xlLmxvZyhcIlN0cmVhbWluZyBSZXF1ZXN0OiBcIik7XG4gICAgY29uc29sZS5sb2cocmVxKTtcbiAgICBjb25zdCBmdWxsX3RleHQgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcInN0cmVhbVwiLCBvcHRzKTtcbiAgICAgICAgdGhpcy5hY3RpdmVfc3RyZWFtID0gbmV3IFNtYXJ0U3RyZWFtZXIodGhpcy5lbmRwb2ludF9zdHJlYW1pbmcsIHJlcSk7XG4gICAgICAgIGxldCBjdXJyX3RleHQgPSBcIlwiO1xuICAgICAgICB0aGlzLmFjdGl2ZV9zdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKGUpID0+IHtcbiAgICAgICAgICBpZih0aGlzLmlzX2VuZF9vZl9zdHJlYW0oZSkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcF9zdHJlYW0oKTtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGN1cnJfdGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCB0ZXh0X2NodW5rID0gdGhpcy5nZXRfdGV4dF9jaHVua19mcm9tX3N0cmVhbShlKTtcbiAgICAgICAgICBpZighdGV4dF9jaHVuaykgcmV0dXJuO1xuICAgICAgICAgIGN1cnJfdGV4dCArPSB0ZXh0X2NodW5rO1xuICAgICAgICAgIHRoaXMuY2h1bmtfaGFuZGxlcih0ZXh0X2NodW5rKTsgLy8gY2FsbCB0aGUgY2h1bmsgaGFuZGxlciBpZiBpdCBleGlzdHNcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHVubmVjZXNzYXJ5P1xuICAgICAgICB0aGlzLmFjdGl2ZV9zdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcihcInJlYWR5c3RhdGVjaGFuZ2VcIiwgKGUpID0+IHtcbiAgICAgICAgICBpZiAoZS5yZWFkeVN0YXRlID49IDIpIGNvbnNvbGUubG9nKFwiUmVhZHlTdGF0ZTogXCIgKyBlLnJlYWR5U3RhdGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hY3RpdmVfc3RyZWFtLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoZSkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgdGhpcy5kb25lX2hhbmRsZXIoXCIqQVBJIEVycm9yLiBTZWUgY29uc29sZSBsb2dzIGZvciBkZXRhaWxzLipcIik7XG4gICAgICAgICAgdGhpcy5zdG9wX3N0cmVhbSgpO1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWN0aXZlX3N0cmVhbS5zdHJlYW0oKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgIHRoaXMuc3RvcF9zdHJlYW0oKTtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5kb25lX2hhbmRsZXIoZnVsbF90ZXh0KTsgLy8gaGFuZGxlZCBpbiBjb21wbGV0ZSgpXG4gICAgcmV0dXJuIGZ1bGxfdGV4dDtcbiAgfVxuICBnZXRfdGV4dF9jaHVua19mcm9tX3N0cmVhbShldmVudCkge1xuICAgIGlmKHR5cGVvZiB0aGlzLmFkYXB0ZXI/LmdldF90ZXh0X2NodW5rX2Zyb21fc3RyZWFtID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpcy5hZGFwdGVyLmdldF90ZXh0X2NodW5rX2Zyb21fc3RyZWFtKGV2ZW50KTtcbiAgICBsZXQgcmVzcCA9IG51bGw7XG4gICAgbGV0IHRleHRfY2h1bmsgPSAnJztcbiAgICAvLyBETzogaXMgdGhpcyB0cnkvY2F0Y2ggc3RpbGwgbmVjZXNzYXJ5P1xuICAgIHRyeSB7XG4gICAgICByZXNwID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcbiAgICAgIHRleHRfY2h1bmsgPSByZXNwLmNob2ljZXNbMF0uZGVsdGEuY29udGVudDtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICBjb25zb2xlLmxvZyhldmVudC5kYXRhKTtcbiAgICAgIGlmIChldmVudC5kYXRhLmluZGV4T2YoJ317JykgPiAtMSkgZXZlbnQuZGF0YSA9IGV2ZW50LmRhdGEucmVwbGFjZSgvfXsvZywgJ30seycpO1xuICAgICAgcmVzcCA9IEpTT04ucGFyc2UoYFske2V2ZW50LmRhdGF9XWApO1xuICAgICAgcmVzcC5mb3JFYWNoKChyKSA9PiB7XG4gICAgICAgIGlmIChyLmNob2ljZXMpIHRleHRfY2h1bmsgKz0gci5jaG9pY2VzWzBdLmRlbHRhLmNvbnRlbnQ7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHRfY2h1bms7XG4gIH1cbiAgaXNfZW5kX29mX3N0cmVhbShldmVudCkge1xuICAgIGlmKHR5cGVvZiB0aGlzLmFkYXB0ZXI/LmlzX2VuZF9vZl9zdHJlYW0gPT09ICdmdW5jdGlvbicpIHJldHVybiB0aGlzLmFkYXB0ZXIuaXNfZW5kX29mX3N0cmVhbShldmVudCk7XG4gICAgcmV0dXJuIGV2ZW50LmRhdGEgPT09IFwiW0RPTkVdXCI7IC8vIHVzZSBkZWZhdWx0IE9wZW5BSSBmb3JtYXRcbiAgfVxuXG4gIHN0b3Bfc3RyZWFtKCkge1xuICAgIGlmICh0aGlzLmFjdGl2ZV9zdHJlYW0pIHtcbiAgICAgIHRoaXMuYWN0aXZlX3N0cmVhbS5lbmQoKTtcbiAgICAgIHRoaXMuYWN0aXZlX3N0cmVhbSA9IG51bGw7XG4gICAgfVxuICB9XG4gIGRvbmVfaGFuZGxlcihmdWxsX3N0cikge1xuICAgIC8vIFNob3VsZCBoYW5kbGU6XG4gICAgLy8gMS4gQWRkIG1lc3NhZ2UgdG8gY3VycmVudCBjaGF0IGhpc3RvcnlcbiAgICAvLyAyLiBVcGRhdGUgY2hhdCBVSVxuICAgIGlmKHR5cGVvZiB0aGlzLm1haW4uZG9uZV9oYW5kbGVyID09PSAnZnVuY3Rpb24nKSB0aGlzLm1haW4uZG9uZV9oYW5kbGVyKGZ1bGxfc3RyKTtcbiAgfVxuICBjaHVua19oYW5kbGVyKHRleHRfY2h1bmspIHtcbiAgICAvLyBTaG91bGQgaGFuZGxlOlxuICAgIC8vIDEuIFVwZGF0ZSBjaGF0IFVJXG4gICAgaWYodHlwZW9mIHRoaXMubWFpbi5jaHVua19oYW5kbGVyID09PSAnZnVuY3Rpb24nKSB0aGlzLm1haW4uY2h1bmtfaGFuZGxlcih0ZXh0X2NodW5rKTtcbiAgfVxuICBhc3luYyBjb3VudF90b2tlbnMoaW5wdXQpIHtcbiAgICBpZih0eXBlb2YgdGhpcy5hZGFwdGVyPy5jb3VudF90b2tlbnMgPT09ICdmdW5jdGlvbicpIHJldHVybiBhd2FpdCB0aGlzLmFkYXB0ZXIuY291bnRfdG9rZW5zKGlucHV0KTtcbiAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZV90b2tlbnMoaW5wdXQpO1xuICB9XG4gIGVzdGltYXRlX3Rva2VucyhpbnB1dCkge1xuICAgIGlmKHR5cGVvZiB0aGlzLmFkYXB0ZXI/LmVzdGltYXRlX3Rva2VucyA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXMuYWRhcHRlci5lc3RpbWF0ZV90b2tlbnMoaW5wdXQpO1xuICAgIGlmKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcpIGlucHV0ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICAgIHJldHVybiBpbnB1dC5sZW5ndGggLyA0O1xuICB9XG4gIGFzeW5jIHRlc3RfYXBpX2tleSgpIHtcbiAgICBjb25zb2xlLmxvZyh0aGlzLmFwaV9rZXkpO1xuICAgIHRyeXtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgIG1lc3NhZ2VzOiBbXG4gICAgICAgICAgeyByb2xlOiBcInVzZXJcIiwgY29udGVudDogXCJIZWxsb1wiIH0sXG4gICAgICAgIF0sXG4gICAgICAgIHRlbXBlcmF0dXJlOiAwLFxuICAgICAgICBtYXhfdG9rZW5zOiAxMDAsXG4gICAgICAgIHN0cmVhbTogZmFsc2UsXG4gICAgICAgIG46IDEsXG4gICAgICB9O1xuICAgICAgaWYodGhpcy5jb25maWcuZmV0Y2hfbW9kZWxzKSB7XG4gICAgICAgIHJlcXVlc3QubW9kZWwgPSB0aGlzLmNvbmZpZy5kZWZhdWx0X21vZGVsO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IHRoaXMuY29tcGxldGUocmVxdWVzdCwgZmFsc2UpO1xuICAgICAgY29uc29sZS5sb2cocmVzcCk7XG4gICAgICBpZighcmVzcCkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfWNhdGNoKGVycil7XG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGFzeW5jIGdldF9tb2RlbHMoKSB7XG4gICAgLy8gY29uc3QgZnhfbmFtZSA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmNoYXRfbW9kZWxfcGxhdGZvcm1fa2V5O1xuICAgIGlmKHRoaXMucGxhdGZvcm1zW3RoaXMucGxhdGZvcm1fa2V5XT8uZmV0Y2hfbW9kZWxzICYmIHR5cGVvZiBmZXRjaF9tb2RlbHNbdGhpcy5wbGF0Zm9ybV9rZXldID09PSBcImZ1bmN0aW9uXCIpe1xuICAgICAgY29uc3QgbW9kZWxzID0gYXdhaXQgZmV0Y2hfbW9kZWxzW3RoaXMucGxhdGZvcm1fa2V5XSh0aGlzLmFwaV9rZXkpO1xuICAgICAgaWYobW9kZWxzKSB7XG4gICAgICAgIC8vIHNvcnQgYWxwaGFiZXRpY2FsbHkgYnkgbW9kZWwgbmFtZVxuICAgICAgICBtb2RlbHMuc29ydCgoYSwgYikgPT4gYS5tb2RlbF9uYW1lLmxvY2FsZUNvbXBhcmUoYi5tb2RlbF9uYW1lKSk7XG4gICAgICAgIHJldHVybiBtb2RlbHM7XG4gICAgICB9ZWxzZSBjb25zb2xlLmVycm9yKGBObyBtb2RlbHMgZm91bmQgZm9yICR7dGhpcy5wbGF0Zm9ybV9rZXl9YCwgbW9kZWxzKTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGFzeW5jIGdldF9iYXNlX21vZGVsX2NvbmZpZygpIHtcbiAgICBjb25zdCBtb2RlbHMgPSBhd2FpdCB0aGlzLmdldF9tb2RlbHMoKTtcbiAgICByZXR1cm4gbW9kZWxzLmZpbmQoKG0pID0+IG0ua2V5ID09PSB0aGlzLm1vZGVsX25hbWUpO1xuICB9XG4gIC8vIGdldHRlcnNcbiAgZ2V0IGFwaV9rZXkoKSB7IHJldHVybiB0aGlzLmNvbmZpZy5hcGlfa2V5OyB9XG4gIGdldCBjdXJyZW50KCkgeyByZXR1cm4gdGhpcy5lbnYuY2hhdHM/LmN1cnJlbnQ7IH1cbiAgLy8gdXNlIGVuZHBvaW50IG9mIGNvbWJpbmUgcHJvdG9jb2wsIGhvc3RuYW1lLCBwb3J0LCBhbmQgcGF0aFxuICBnZXQgZW5kcG9pbnQoKSB7XG4gICAgaWYodHlwZW9mIHRoaXMuYWRhcHRlcj8uZW5kcG9pbnQgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gdGhpcy5hZGFwdGVyLmVuZHBvaW50LnJlcGxhY2UoJ01PREVMX05BTUUnLCB0aGlzLm1vZGVsX25hbWUpO1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5lbmRwb2ludCB8fCB0aGlzLmNvbmZpZy5wcm90b2NvbCArIFwiOi8vXCIgKyB0aGlzLmNvbmZpZy5ob3N0bmFtZSArICh0aGlzLmNvbmZpZy5wb3J0ID8gXCI6XCIgKyB0aGlzLmNvbmZpZy5wb3J0IDogXCJcIikgKyB0aGlzLmVuZHBvaW50X3BhdGg7XG4gIH1cbiAgZ2V0IGVuZHBvaW50X3N0cmVhbWluZygpIHtcbiAgICBpZih0eXBlb2YgdGhpcy5hZGFwdGVyPy5lbmRwb2ludF9zdHJlYW1pbmcgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gdGhpcy5hZGFwdGVyLmVuZHBvaW50X3N0cmVhbWluZy5yZXBsYWNlKCdNT0RFTF9OQU1FJywgdGhpcy5tb2RlbF9uYW1lKTtcbiAgICByZXR1cm4gdGhpcy5jb25maWcuZW5kcG9pbnRfc3RyZWFtaW5nIHx8IHRoaXMuZW5kcG9pbnQ7XG4gIH1cbiAgZ2V0IGVuZHBvaW50X3BhdGgoKSB7IHJldHVybiB0aGlzLmNvbmZpZy5wYXRoLnN0YXJ0c1dpdGgoJy8nKSA/IHRoaXMuY29uZmlnLnBhdGggOiAnLycgKyB0aGlzLmNvbmZpZy5wYXRoOyB9XG4gIGdldCBtYXhfaW5wdXRfdG9rZW5zKCkgeyByZXR1cm4gdGhpcy5jb25maWcubWF4X2lucHV0X3Rva2VuczsgfVxuICBnZXQgbWF4X291dHB1dF90b2tlbnMoKSB7IHJldHVybiB0aGlzLmNvbmZpZy5tYXhfb3V0cHV0X3Rva2VuczsgfVxuICBnZXQgbW9kZWxfbmFtZSgpIHsgcmV0dXJuIHRoaXMuY29uZmlnLm1vZGVsX25hbWUgfHwgdGhpcy5jb25maWcuZGVmYXVsdF9tb2RlbDsgfVxufVxuZXhwb3J0cy5TbWFydENoYXRNb2RlbCA9IFNtYXJ0Q2hhdE1vZGVsO1xuXG4iLCAiY29uc3QgU2NUcmFuc2xhdGlvbnMgPSByZXF1aXJlKFwiLi9TY1RyYW5zbGF0aW9uc1wiKTtcbmNvbnN0IHsgU21hcnRDaGF0TW9kZWwgfSA9IHJlcXVpcmUoXCJzbWFydC1jaGF0LW1vZGVsXCIpO1xuY2xhc3MgU2NDaGF0TW9kZWwgZXh0ZW5kcyBTbWFydENoYXRNb2RlbCB7XG4gIGFzeW5jIGRvbmVfaGFuZGxlcihmdWxsX3N0cikge1xuICAgIGF3YWl0IHRoaXMuZW52LmNoYXRfdWkubmV3X21lc3NhZ2UoZnVsbF9zdHIsIFwiYXNzaXN0YW50XCIpO1xuICAgIHRoaXMuZW52LmNoYXRzLmN1cnJlbnQuYWRkX21lc3NhZ2UoeyByb2xlOiBcImFzc2lzdGFudFwiLCBjb250ZW50OiBmdWxsX3N0ciB9KTtcbiAgICB0aGlzLmVudi5jaGF0X3VpLmNsZWFyX3N0cmVhbWluZ191eCgpOyAvLyByZWR1bmRhbnQgd2hlbiBzdHJlYW1pbmcsIGZvciBjb21wbGV0aW9uIHRlc3RpbmdcbiAgfVxuICBhc3luYyBjaHVua19oYW5kbGVyKHRleHRfY2h1bmspIHtcbiAgICBhd2FpdCB0aGlzLmVudi5jaGF0X3VpLm5ld19tZXNzYWdlKHRleHRfY2h1bmssIFwiYXNzaXN0YW50XCIsIHRydWUpO1xuICB9XG4gIGFzeW5jIHJlcXVlc3RfbWlkZGxld2FyZXMob3B0cykge1xuICAgIC8vIGNvbnZlcnQgY29udGV4dCBjb2RlYmxvY2tzIHRvIHByb21wdCBjb250ZXh0XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwob3B0cy5tZXNzYWdlcy5tYXAoYXN5bmMgKG1zZywgaSkgPT4ge1xuICAgICAgY29uc3QgY29udGV4dF9zdGFydCA9IFwiYGBgc2MtY29udGV4dFwiO1xuICAgICAgLy8gcmVwbGFjZSBsb29rdXAgdG9vbCBjYWxsIHdpdGggY29udGV4dCBjb2RlYmxvY2sgKHByaW9yIHRvIHJlbmRlcmluZyBjb250ZXh0IGNvZGVibG9jayBhcyBwcm9tcHQgY29udGV4dClcbiAgICAgIGlmIChtc2cucm9sZSA9PT0gXCJ0b29sXCIgJiYgbXNnLnRvb2xfY2FsbF9pZCA9PT0gXCJsb29rdXBcIikge1xuICAgICAgICBtc2cucm9sZSA9IFwic3lzdGVtXCI7XG4gICAgICAgIG1zZy5jb250ZW50ID0gY29udGV4dF9zdGFydCArIFwiXFxuXCIgKyBKU09OLnBhcnNlKG1zZy5jb250ZW50KS5tYXAoYyA9PiBjLnBhdGgpLmpvaW4oJ1xcbicpICsgXCJcXG5gYGBcIjtcbiAgICAgIH1cbiAgICAgIGlmIChtc2cucm9sZSA9PT0gXCJzeXN0ZW1cIiAmJiBtc2cuY29udGVudC5pbmNsdWRlcyhjb250ZXh0X3N0YXJ0KSkge1xuICAgICAgICBjb25zdCBjb250ZXh0X3N0YXJ0X2kgPSBtc2cuY29udGVudC5pbmRleE9mKGNvbnRleHRfc3RhcnQpICsgY29udGV4dF9zdGFydC5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGNvbnRleHRfZW5kX2kgPSBtc2cuY29udGVudC5zdWJzdHJpbmcoY29udGV4dF9zdGFydF9pKS5pbmRleE9mKFwiYGBgXCIpO1xuICAgICAgICBjb25zdCByYXdfY29udGVudHMgPSBtc2cuY29udGVudC5zdWJzdHJpbmcoY29udGV4dF9zdGFydF9pLCBjb250ZXh0X3N0YXJ0X2kgKyBjb250ZXh0X2VuZF9pKTtcbiAgICAgICAgY29uc3QgZW50aXRpZXMgPSB0aGlzLmVudi5wbHVnaW4uZ2V0X2VudGl0aWVzX2Zyb21fY29udGV4dF9jb2RlYmxvY2socmF3X2NvbnRlbnRzKTtcbiAgICAgICAgbGV0IGNvbnRleHQgPSBbXTtcbiAgICAgICAgbGV0IHRva2VucyA9IFtdO1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChlbnRpdGllcy5tYXAoYXN5bmMgKGVudGl0eSwgaSkgPT4ge1xuICAgICAgICAgIGlmICghZW50aXR5Py5nZXRfYXNfY29udGV4dCkgcmV0dXJuIGNvbnNvbGUubG9nKGVudGl0eSk7XG4gICAgICAgICAgY29udGV4dFtpXSA9IGF3YWl0IGVudGl0eS5nZXRfYXNfY29udGV4dCh7IGkgfSk7XG4gICAgICAgICAgdG9rZW5zW2ldID0gYXdhaXQgdGhpcy5jb3VudF90b2tlbnMoY29udGV4dFtpXSk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgbGV0IHRvdGFsX3Rva2VucyA9IDA7XG4gICAgICAgIGxldCBjdCA9IDA7XG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0XG4gICAgICAgICAgLnJlZHVjZSgoYWNjLCBjLCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWMpIHJldHVybiBhY2M7XG4gICAgICAgICAgICBpZiAodG90YWxfdG9rZW5zICsgdG9rZW5zW2ldID4gdGhpcy5tYXhfaW5wdXRfdG9rZW5zKSByZXR1cm4gYWNjO1xuICAgICAgICAgICAgdG90YWxfdG9rZW5zICs9IHRva2Vuc1tpXTtcbiAgICAgICAgICAgIGN0Kys7XG4gICAgICAgICAgICBpZiAoYWNjKSBhY2MgKz0gJ1xcbic7XG4gICAgICAgICAgICByZXR1cm4gYWNjICsgYztcbiAgICAgICAgICB9LCAnJyk7XG4gICAgICAgIG1zZy5jb250ZW50ID0gdGhpcy5nZXRfcHJvbXB0X2NvbnRleHRfcHJlZml4KHsgY3QgfSkgKyAnXFxuJyArIGNvbnRleHQ7XG4gICAgICB9XG4gICAgICBjb25zdCBzeXNfc3RhcnQgPSBcImBgYHNjLXN5c3RlbVwiO1xuICAgICAgaWYgKG1zZy5yb2xlID09PSBcInN5c3RlbVwiICYmIG1zZy5jb250ZW50LmluY2x1ZGVzKHN5c19zdGFydCkpIHtcbiAgICAgICAgY29uc3Qgc3lzX3N0YXJ0X2kgPSBtc2cuY29udGVudC5pbmRleE9mKHN5c19zdGFydCkgKyBzeXNfc3RhcnQubGVuZ3RoO1xuICAgICAgICBjb25zdCBzeXNfZW5kX2kgPSBtc2cuY29udGVudC5zdWJzdHJpbmcoc3lzX3N0YXJ0X2kpLmluZGV4T2YoXCJgYGBcIik7XG4gICAgICAgIGNvbnN0IHN5c19wcm9tcHRzID0gbXNnLmNvbnRlbnQuc3Vic3RyaW5nKHN5c19zdGFydF9pLCBzeXNfc3RhcnRfaSArIHN5c19lbmRfaSkuc3BsaXQoJ1xcbicpLmZpbHRlcihsbiA9PiBsbi50cmltKCkpO1xuICAgICAgICBjb25zb2xlLmxvZyhzeXNfcHJvbXB0cyk7XG4gICAgICAgIG1zZy5jb250ZW50ID0gXCJcIjtcbiAgICAgICAgZm9yIChjb25zdCBzeXNfcHJvbXB0IG9mIHN5c19wcm9tcHRzKSB7XG4gICAgICAgICAgY29uc3QgdGZpbGUgPSB0aGlzLmVudi5zeXN0ZW1fcHJvbXB0cy5maW5kKGZpbGUgPT4gZmlsZS5iYXNlbmFtZSA9PT0gc3lzX3Byb21wdCk7XG4gICAgICAgICAgY29uc3Qgbm90ZV9jb250ZW50ID0gYXdhaXQgdGhpcy5lbnYucGx1Z2luLmJyYWluLmNhY2hlZF9yZWFkKHRmaWxlKTtcbiAgICAgICAgICBpZiAobXNnLmNvbnRlbnQpIG1zZy5jb250ZW50ICs9ICdcXG4nO1xuICAgICAgICAgIG1zZy5jb250ZW50ICs9IG5vdGVfY29udGVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1zZztcbiAgICB9KSk7XG4gICAgLy8gcmVtb3ZlIGFzc2lzdGFudCBtZXNzYWdlcyB3aXRob3V0IGNvbnRlbnQgKGluY2x1ZGluZyB0b29sIGNhbGxzKVxuICAgIG9wdHMubWVzc2FnZXMgPSBvcHRzLm1lc3NhZ2VzLmZpbHRlcihtc2cgPT4gbXNnLnJvbGUgIT09IFwiYXNzaXN0YW50XCIgfHwgbXNnLmNvbnRlbnQpO1xuICAgIGNvbnNvbGUubG9nKG9wdHMubWVzc2FnZXMpO1xuICAgIHJldHVybiBvcHRzO1xuICB9XG4gIGdldF9wcm9tcHRfY29udGV4dF9wcmVmaXgocGFyYW1zID0ge30pIHtcbiAgICByZXR1cm4gYEFudGljaXBhdGUgdGhlIHR5cGUgb2YgYW5zd2VyIGRlc2lyZWQgYnkgdGhlIHVzZXIuYFxuICAgICAgKyBgIEltYWdpbmUgdGhlIGZvbGxvd2luZyR7cGFyYW1zLmN0ID8gXCIgXCIgKyBwYXJhbXMuY3QgOiBcIlwifSBub3RlcyB3ZXJlIHdyaXR0ZW4gYnkgdGhlIHVzZXIgYW5kIGNvbnRhaW4gYWxsIHRoZSBuZWNlc3NhcnkgaW5mb3JtYXRpb24gdG8gYW5zd2VyIHRoZSB1c2VyJ3MgcXVlc3Rpb24uYFxuICAgICAgKyBgIEJlZ2luIHJlc3BvbnNlcyB3aXRoIFwiJHtTY1RyYW5zbGF0aW9uc1t0aGlzLmVudi5wbHVnaW4uc2V0dGluZ3MubGFuZ3VhZ2VdLnByb21wdH0uLi5cImA7XG4gIH1cbn1cbmV4cG9ydHMuU2NDaGF0TW9kZWwgPSBTY0NoYXRNb2RlbDtcbiIsICJmdW5jdGlvbiBtZXNzYWdlX2NvbnRlbnRfYXJyYXlfdG9fbWFya2Rvd24oY29udGVudCkge1xuICBsZXQgbWFya2Rvd24gPSAnJztcbiAgY29udGVudC5mb3JFYWNoKChjLCBpKSA9PiB7XG4gICAgaWYgKGMudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICBpZiAoYy50ZXh0LnN0YXJ0c1dpdGgoJ0ltYWdlIGNhcHRpb246ICcpKSB7XG4gICAgICAgIC8vIGlmIGxhc3QgY29udGVudCBpcyBpbWFnZV91cmwsIGFkZCB0aGUgaW1hZ2VfdXJsIHRvIHRoZSBtYXJrZG93blxuICAgICAgICBpZiAoY29udGVudFtpIC0gMV0/LnR5cGUgPT09ICdpbWFnZV91cmwnKSB7XG4gICAgICAgICAgbWFya2Rvd24gPSBtYXJrZG93bi5zcGxpdCgnXFxuJykuc2xpY2UoMCwgLTIpLmpvaW4oJ1xcbicpO1xuICAgICAgICAgIG1hcmtkb3duICs9IGBcXG4hWyR7Yy50ZXh0LnNwbGl0KCc6JylbMV0udHJpbSgpfV0oJHtjb250ZW50W2kgLSAxXS5pbWFnZV91cmwudXJsfSlgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hcmtkb3duICs9IGAke2MudGV4dH1gO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXJrZG93biArPSBgJHtjLnRleHR9YDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGMudHlwZSA9PT0gJ2ltYWdlX3VybCcpIG1hcmtkb3duICs9IGAhW10oJHtjLmltYWdlX3VybC51cmx9KWA7XG4gICAgbWFya2Rvd24gKz0gJ1xcbic7XG4gIH0pO1xuICByZXR1cm4gbWFya2Rvd24udHJpbSgpO1xufVxuZXhwb3J0cy5tZXNzYWdlX2NvbnRlbnRfYXJyYXlfdG9fbWFya2Rvd24gPSBtZXNzYWdlX2NvbnRlbnRfYXJyYXlfdG9fbWFya2Rvd247XG4iLCAiY29uc3QgeyBtZXNzYWdlX2NvbnRlbnRfYXJyYXlfdG9fbWFya2Rvd24gfSA9IHJlcXVpcmUoXCIuLi9zbWFydC1jaGF0cy91dGlscy9tZXNzYWdlX2NvbnRlbnRfYXJyYXlfdG9fbWFya2Rvd25cIik7XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHVzZXIgaW50ZXJmYWNlIGZvciBTbWFydENoYXQuXG4gKiBUaGlzIGNsYXNzIGhhbmRsZXMgdGhlIHJlbmRlcmluZyBhbmQgaW50ZXJhY3Rpb24gbG9naWMgZm9yIHRoZSBjaGF0IGludGVyZmFjZS5cbiAqL1xuY2xhc3MgU21hcnRDaGF0c1VJIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgU21hcnRDaGF0c1VJLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW52IC0gVGhlIGVudmlyb25tZW50IG9iamVjdCBjb250YWluaW5nIGNvbmZpZ3VyYXRpb25zIGFuZCB1dGlsaXRpZXMuXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciAtIFRoZSBIVE1MIGNvbnRhaW5lciBlbGVtZW50IGZvciB0aGUgY2hhdCBVSS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVudiwgY29udGFpbmVyKSB7XG4gICAgdGhpcy5lbnYgPSBlbnY7XG4gICAgdGhpcy5tYWluID0gdGhpcy5lbnY7IC8vIERFUFJFQ0FURURcbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLnRlbXBsYXRlcyA9IHRoaXMuZW52LnRlbXBsYXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm92aWRlcyBhIGNvbnRleHQgZm9yIHRoZSB2aWV3IHJlbmRlcmluZy4gU2hvdWxkIGJlIG92ZXJyaWRkZW4gaW4gc3ViY2xhc3Nlcy5cbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIGNvbnRleHQgb2JqZWN0IGZvciB0aGUgdmlldy5cbiAgICovXG4gIGdldCB2aWV3X2NvbnRleHQoKSB7IHJldHVybiB7IC8qIG92ZXJyaWRlICovIH07IH1cblxuICAvKipcbiAgICogUmVuZGVycyB0ZW1wbGF0ZXMgdXNpbmcgdGhlIGVudmlyb25tZW50J3MgcmVuZGVyaW5nIGVuZ2luZS5cbiAgICogQHBhcmFtIHsuLi5hbnl9IGFyZ3MgLSBBcmd1bWVudHMgaW5jbHVkaW5nIHRlbXBsYXRlIGFuZCBkYXRhIHRvIHJlbmRlci5cbiAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gVGhlIHJlbmRlcmVkIEhUTUwgc3RyaW5nLlxuICAgKi9cbiAgYXN5bmMgcmVuZGVyKC4uLmFyZ3MpIHsgcmV0dXJuIGF3YWl0IHRoaXMuZW52LmVqcy5yZW5kZXIoLi4uYXJncyk7IH1cblxuICAvKipcbiAgICogRGlzcGxheXMgYSBub3RpY2UgbWVzc2FnZSBpbiB0aGUgY29uc29sZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBUaGUgbWVzc2FnZSB0byBkaXNwbGF5LlxuICAgKi9cbiAgc2hvd19ub3RpY2UobWVzc2FnZSkgeyBjb25zb2xlLmxvZyhtZXNzYWdlKTsgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgY2hhdCBVSSBieSBjbGVhcmluZyB0aGUgY29udGFpbmVyIGFuZCByZW5kZXJpbmcgdGhlIGluaXRpYWwgY2hhdCB0ZW1wbGF0ZS5cbiAgICovXG4gIGFzeW5jIGluaXQoKSB7XG4gICAgY29uc29sZS5sb2coXCJpbml0IFNtYXJ0Q2hhdFJlbmRlcmVyXCIpO1xuICAgIGNvbnNvbGUubG9nKHRoaXMuY29udGFpbmVyKTtcbiAgICB0aGlzLmNvbnRhaW5lci5pbm5lckhUTUwgPSBcIlwiO1xuICAgIGNvbnNvbGUubG9nKHRoaXMuZW52LmNoYXRzLmN1cnJlbnQpO1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmdldF92aWV3X2RhdGEoKTtcbiAgICB0aGlzLmNvbnRhaW5lci5pbm5lckhUTUwgPSBhd2FpdCB0aGlzLnJlbmRlcih0aGlzLnRlbXBsYXRlcy5zbWFydF9jaGF0LCBkYXRhLCB7IGNvbnRleHQ6IHRoaXMudmlld19jb250ZXh0LCBybVdoaXRlc3BhY2U6IHRydWUgfSk7XG4gICAgdGhpcy5wb3N0X3Byb2Nlc3MoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIG5ldyB1c2VyIG1lc3NhZ2VzLCB1cGRhdGVzIHRoZSBVSSwgYW5kIHRyaWdnZXJzIHJlbmRlcmluZyBvZiB0eXBpbmcgaW5kaWNhdG9yLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcl9pbnB1dCAtIFRoZSB1c2VyJ3MgaW5wdXQgbWVzc2FnZS5cbiAgICovXG4gIGFzeW5jIG5ld191c2VyX21lc3NhZ2UodXNlcl9pbnB1dCkge1xuICAgIGF3YWl0IHRoaXMubmV3X21lc3NhZ2UodXNlcl9pbnB1dCwgXCJ1c2VyXCIpO1xuICAgIHRoaXMuc2V0X3N0cmVhbWluZ191eCgpO1xuICAgIGF3YWl0IHRoaXMucmVuZGVyX2RvdGRvdGRvdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBvc3QtaW5pdGlhbGl6YXRpb24gcHJvY2Vzc2luZywgc3VjaCBhcyBhZGRpbmcgbGlzdGVuZXJzIGFuZCBwcm9jZXNzaW5nIG1lc3NhZ2VzLlxuICAgKi9cbiAgYXN5bmMgcG9zdF9wcm9jZXNzKCkge1xuICAgIHRoaXMuYWRkX2xpc3RlbmVycygpO1xuICAgIHRoaXMubWVzc2FnZXMuZm9yRWFjaCh0aGlzLm1lc3NhZ2VfcG9zdF9wcm9jZXNzLmJpbmQodGhpcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBsYWNlaG9sZGVyIGZvciBhZGRpbmcgbGlzdGVuZXJzLiBTaG91bGQgYmUgb3ZlcnJpZGRlbiBpbiBzdWJjbGFzc2VzLlxuICAgKi9cbiAgYWRkX2xpc3RlbmVycygpIHsgfVxuXG4gIC8qKlxuICAgKiBQbGFjZWhvbGRlciBmb3IgbWVzc2FnZSBwb3N0LXByb2Nlc3NpbmcuIFNob3VsZCBiZSBvdmVycmlkZGVuIGluIHN1YmNsYXNzZXMuXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG1zZ19lbG0gLSBUaGUgbWVzc2FnZSBlbGVtZW50IHRvIHByb2Nlc3MuXG4gICAqL1xuICBtZXNzYWdlX3Bvc3RfcHJvY2Vzcyhtc2dfZWxtKSB7IH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHZpZXcgZGF0YSBmb3IgcmVuZGVyaW5nIHRoZSBjaGF0IGludGVyZmFjZS5cbiAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgZGF0YSBmb3IgdGhlIHZpZXcuXG4gICAqL1xuICBhZGRfbWVzc2FnZV9saXN0ZW5lcnMobXNnX2VsbSkgeyB9IC8vIE9WRVJSSURFXG4gIGFzeW5jIGdldF92aWV3X2RhdGEoKSB7XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgIG5hbWU6IHRoaXMuZW52LmNoYXRzLmN1cnJlbnQ/Lm5hbWUgfHwgXCJVTlRJVExFRCBDSEFUXCIsXG4gICAgICBtZXNzYWdlczogYXdhaXQgdGhpcy5lbnYuY2hhdHMuY3VycmVudC5nZXRfbWVzc2FnZXNfaHRtbCgpLFxuICAgIH07XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBpbnB1dCBsaXN0ZW5lcnMgdG8gdGhlIGNoYXQgZm9ybSBmb3IgaGFuZGxpbmcgc3BlY2lhbCBrZXlzIGFuZCBzZW5kaW5nIG1lc3NhZ2VzLlxuICAgKi9cbiAgYWRkX2NoYXRfaW5wdXRfbGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IGNoYXRfaW5wdXQgPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiLnNjLWNoYXQtZm9ybVwiKTtcbiAgICBjb25zdCB0ZXh0YXJlYSA9IGNoYXRfaW5wdXQucXVlcnlTZWxlY3RvcihcInRleHRhcmVhXCIpO1xuICAgIHRoaXMuYnJhY2tldHNfY3QgPSAwO1xuICAgIHRoaXMucHJldmVudF9pbnB1dCA9IGZhbHNlO1xuICAgIGNoYXRfaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIChlKSA9PiB7XG4gICAgICBpZiAoW1wiW1wiLCBcIi9cIiwgXCJAXCJdLmluZGV4T2YoZS5rZXkpID09PSAtMSkgcmV0dXJuOyAvLyBza2lwIGlmIGtleSBpcyBub3QgWyBvciAvIG9yIEBcbiAgICAgIGNvbnN0IGNhcmV0X3BvcyA9IHRleHRhcmVhLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgLy8gaWYga2V5IGlzIG9wZW4gc3F1YXJlIGJyYWNrZXRcbiAgICAgIGlmIChlLmtleSA9PT0gXCJbXCIpIHtcbiAgICAgICAgLy8gaWYgcHJldmlvdXMgY2hhciBpcyBbXG4gICAgICAgIGlmICh0ZXh0YXJlYS52YWx1ZVtjYXJldF9wb3MgLSAyXSA9PT0gXCJbXCIpIHtcbiAgICAgICAgICAvLyBvcGVuIGZpbGUgc3VnZ2VzdGlvbiBtb2RhbFxuICAgICAgICAgIHRoaXMub3Blbl9maWxlX3N1Z2dlc3Rpb25fbW9kYWwoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYnJhY2tldHNfY3QgPSAwO1xuICAgICAgfVxuICAgICAgLy8gaWYgLyBpcyBwcmVzc2VkXG4gICAgICBpZiAoZS5rZXkgPT09IFwiL1wiKSB7XG4gICAgICAgIC8vIGdldCBjYXJldCBwb3NpdGlvblxuICAgICAgICAvLyBpZiB0aGlzIGlzIGZpcnN0IGNoYXIgb3IgcHJldmlvdXMgY2hhciBpcyBzcGFjZVxuICAgICAgICBpZiAodGV4dGFyZWEudmFsdWUubGVuZ3RoID09PSAxIHx8IHRleHRhcmVhLnZhbHVlW2NhcmV0X3BvcyAtIDJdID09PSBcIiBcIikge1xuICAgICAgICAgIC8vIG9wZW4gZm9sZGVyIHN1Z2dlc3Rpb24gbW9kYWxcbiAgICAgICAgICB0aGlzLm9wZW5fZm9sZGVyX3N1Z2dlc3Rpb25fbW9kYWwoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGlmIEAgaXMgcHJlc3NlZFxuICAgICAgaWYgKGUua2V5ID09PSBcIkBcIikge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcImNhcmV0X3Bvc1wiLCBjYXJldF9wb3MpO1xuICAgICAgICAvLyBnZXQgY2FyZXQgcG9zaXRpb25cbiAgICAgICAgLy8gaWYgdGhpcyBpcyBmaXJzdCBjaGFyIG9yIHByZXZpb3VzIGNoYXIgaXMgc3BhY2VcbiAgICAgICAgaWYgKHRleHRhcmVhLnZhbHVlLmxlbmd0aCA9PT0gMSB8fCB0ZXh0YXJlYS52YWx1ZVtjYXJldF9wb3MgLSAyXSA9PT0gXCIgXCIpIHtcbiAgICAgICAgICAvLyBvcGVuIHN5c3RlbSBwcm9tcHQgc3VnZ2VzdGlvbiBtb2RhbFxuICAgICAgICAgIHRoaXMub3Blbl9zeXN0ZW1fcHJvbXB0X21vZGFsKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9KTtcbiAgICBjaGF0X2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIChlKSA9PiB7XG4gICAgICBpZiAoZS5rZXkgPT09IFwiRW50ZXJcIiAmJiBlLnNoaWZ0S2V5KSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKHRoaXMucHJldmVudF9pbnB1dCkge1xuICAgICAgICAgIHRoaXMuc2hvd19ub3RpY2UoXCJXYWl0IHVudGlsIGN1cnJlbnQgcmVzcG9uc2UgaXMgZmluaXNoZWQuXCIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBnZXQgdGV4dCBmcm9tIHRleHRhcmVhXG4gICAgICAgIGxldCB1c2VyX2lucHV0ID0gdGV4dGFyZWEudmFsdWU7XG4gICAgICAgIC8vIGNsZWFyIHRleHRhcmVhXG4gICAgICAgIHRleHRhcmVhLnZhbHVlID0gXCJcIjtcbiAgICAgICAgLy8gaW5pdGlhdGUgcmVzcG9uc2UgZnJvbSBhc3Npc3RhbnRcbiAgICAgICAgdGhpcy5lbnYuY2hhdHMuY3VycmVudC5uZXdfdXNlcl9tZXNzYWdlKHVzZXJfaW5wdXQpO1xuICAgICAgfVxuICAgICAgdGV4dGFyZWEuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuICAgICAgdGV4dGFyZWEuc3R5bGUuaGVpZ2h0ID0gKHRleHRhcmVhLnNjcm9sbEhlaWdodCkgKyAncHgnO1xuICAgIH0pO1xuICAgIGNvbnN0IGFib3J0X2J1dHRvbiA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIjc2MtYWJvcnQtYnV0dG9uXCIpO1xuICAgIGFib3J0X2J1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgLy8gYWJvcnQgY3VycmVudCByZXNwb25zZVxuICAgICAgdGhpcy5lbnYuY2hhdF9tb2RlbC5zdG9wX3N0cmVhbSgpO1xuICAgIH0pO1xuICAgIGNvbnN0IGJ1dHRvbiA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIjc2Mtc2VuZC1idXR0b25cIik7XG4gICAgLy8gYWRkIGV2ZW50IGxpc3RlbmVyIHRvIGJ1dHRvblxuICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMucHJldmVudF9pbnB1dCkge1xuICAgICAgICB0aGlzLnNob3dfbm90aWNlKFwiV2FpdCB1bnRpbCBjdXJyZW50IHJlc3BvbnNlIGlzIGZpbmlzaGVkLlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gZ2V0IHRleHQgZnJvbSB0ZXh0YXJlYVxuICAgICAgbGV0IHVzZXJfaW5wdXQgPSB0ZXh0YXJlYS52YWx1ZTtcbiAgICAgIC8vIGNsZWFyIHRleHRhcmVhXG4gICAgICB0ZXh0YXJlYS52YWx1ZSA9IFwiXCI7XG4gICAgICAvLyBpbml0aWF0ZSByZXNwb25zZSBmcm9tIGFzc2lzdGFudFxuICAgICAgdGhpcy5lbnYuY2hhdHMuY3VycmVudC5uZXdfdXNlcl9tZXNzYWdlKHVzZXJfaW5wdXQpO1xuICAgIH0pO1xuICB9XG4gIC8vIHJlbmRlciBtZXNzYWdlXG4gIGFzeW5jIG5ld19tZXNzYWdlKGNvbnRlbnQsIHJvbGUgPSBcImFzc2lzdGFudFwiLCBhcHBlbmRfbGFzdCA9IGZhbHNlKSB7XG4gICAgLy8gaWYgZG90ZG90ZG90IGludGVydmFsIGlzIHNldCwgdGhlbiBjbGVhciBpdFxuICAgIGlmICh0aGlzLmRvdGRvdGRvdF9pbnRlcnZhbCkge1xuICAgICAgaWYoIXRoaXMubGFzdF9tc2cpIHRoaXMubWVzc2FnZV9jb250YWluZXIuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsIGF3YWl0IHRoaXMuZ2V0X21lc3NhZ2VfaHRtbChyb2xlLCBjb250ZW50KSk7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuZG90ZG90ZG90X2ludGVydmFsKTtcbiAgICAgIHRoaXMuZG90ZG90ZG90X2ludGVydmFsID0gbnVsbDtcbiAgICAgIHRoaXMubGFzdF9tc2dfY29udGVudC5pbm5lckhUTUwgPSAnJzsgLy8gY2xlYXIgbGFzdCBtZXNzYWdlXG4gICAgICB0aGlzLmxhc3RfbXNnLmRhdGFzZXQuY29udGVudCA9IFwiXCI7XG4gICAgfVxuICAgIGlmKHRoaXMubGFzdF9tc2cgJiYgIXRoaXMubGFzdF9tc2cuZGF0YXNldC5jb250ZW50KSB0aGlzLmxhc3RfbXNnLmRhdGFzZXQuY29udGVudCA9IFwiXCI7XG4gICAgaWYgKGFwcGVuZF9sYXN0KSB7XG4gICAgICB0aGlzLmxhc3RfbXNnX2NvbnRlbnQuaW5uZXJIVE1MICs9IGNvbnRlbnQ7XG4gICAgICB0aGlzLmxhc3RfbXNnLmRhdGFzZXQuY29udGVudCArPSBjb250ZW50O1xuICAgICAgaWYgKGNvbnRlbnQuaW5kZXhPZignXFxuJykgPiAtMSkgdGhpcy5yZW5kZXJfbWRfYXNfaHRtbCh0aGlzLmxhc3RfbXNnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMubGFzdF9mcm9tICE9PSByb2xlKSB7XG4gICAgICAgIGNvbnN0IGh0bWwgPSBhd2FpdCB0aGlzLmdldF9tZXNzYWdlX2h0bWwocm9sZSwgY29udGVudCk7XG4gICAgICAgIHRoaXMubWVzc2FnZV9jb250YWluZXIuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsIGh0bWwpOyAvLyBhcHBlbmQgaHRtbCB0byB0aGlzLm1lc3NhZ2VfY29udGFpbmVyIHdoaWxlIHByZXNlcnZpbmcgb3RoZXIgZWxlbWVudHMgaW4gdGhpcy5tZXNzYWdlX2NvbnRhaW5lci5cbiAgICAgICAgdGhpcy5sYXN0X2Zyb20gPSByb2xlOyAvLyBzZXQgbGFzdCBmcm9tXG4gICAgICAgIHRoaXMubGFzdF9tc2cuZGF0YXNldC5jb250ZW50ID0gY29udGVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGFzdF9tc2dfY29udGVudC5pbm5lckhUTUwgPSBjb250ZW50O1xuICAgICAgICB0aGlzLmxhc3RfbXNnLmRhdGFzZXQuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICB9XG4gICAgICB0aGlzLm1lc3NhZ2VfcG9zdF9wcm9jZXNzKHRoaXMubGFzdF9tc2cpO1xuICAgIH1cbiAgICB0aGlzLm1lc3NhZ2VfY29udGFpbmVyLnNjcm9sbFRvcCA9IHRoaXMubWVzc2FnZV9jb250YWluZXIuc2Nyb2xsSGVpZ2h0O1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBIVE1MIGZvciBhIG1lc3NhZ2UgYmFzZWQgb24gdGhlIHJvbGUgYW5kIGNvbnRlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByb2xlIC0gVGhlIHJvbGUgb2YgdGhlIG1lc3NhZ2Ugc2VuZGVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCAtIFRoZSBjb250ZW50IG9mIHRoZSBtZXNzYWdlLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBUaGUgSFRNTCBzdHJpbmcgZm9yIHRoZSBtZXNzYWdlLlxuICAgKi9cbiAgYXN5bmMgZ2V0X21lc3NhZ2VfaHRtbChyb2xlLCBjb250ZW50KSB7XG4gICAgaWYoQXJyYXkuaXNBcnJheShjb250ZW50KSkgY29udGVudCA9IG1lc3NhZ2VfY29udGVudF9hcnJheV90b19tYXJrZG93bihjb250ZW50KTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5yZW5kZXIodGhpcy50ZW1wbGF0ZXMuc21hcnRfY2hhdF9tc2csIHsgcm9sZSwgY29udGVudCB9LCB7IGNvbnRleHQ6IHRoaXMudmlld19jb250ZXh0LCBybVdoaXRlc3BhY2U6IHRydWUgfSk7XG4gIH1cblxuICBhc3luYyBnZXRfc3lzdGVtX21lc3NhZ2VfaHRtbChtc2cpIHtcbiAgICBsZXQgeyBjb250ZW50LCByb2xlIH0gPSBtc2c7XG4gICAgaWYoY29udGVudC5pbmNsdWRlcygnYGBgc2Mtc3lzdGVtJykpIHtcbiAgICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoL2BgYHNjLXN5c3RlbXxgYGAvZywgXCJcIikudHJpbSgpO1xuICAgICAgY29udGVudCA9IFwic3lzdGVtIHByb21wdHM6IFwiICsgY29udGVudC5zcGxpdCgnXFxuJykuZmlsdGVyKGxuID0+IGxuLnRyaW0oKSkuam9pbignLCAnKTtcbiAgICB9XG4gICAgaWYoY29udGVudC5pbmNsdWRlcygnYGBgc2MtY29udGV4dCcpKSB7XG4gICAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC9gYGBzYy1jb250ZXh0fGBgYC9nLCBcIlwiKS50cmltKCk7XG4gICAgICBjb250ZW50ID0gXCJjb250ZXh0OiBcIiArIGNvbnRlbnQuc3BsaXQoJ1xcbicpLmZpbHRlcihsbiA9PiBsbi50cmltKCkpLmpvaW4oJywgJyk7XG4gICAgICBpZihjb250ZW50Lmxlbmd0aCA+IDEwMCkgY29udGVudCA9IGNvbnRlbnQuc3Vic3RyaW5nKDAsIDEwMCkgKyBcIi4uLlwiO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5yZW5kZXIodGhpcy50ZW1wbGF0ZXMuc21hcnRfY2hhdF9zeXN0ZW1fbXNnLCB7IGNvbnRlbnQsIHJvbGUgfSwgeyBjb250ZXh0OiB0aGlzLnZpZXdfY29udGV4dCwgcm1XaGl0ZXNwYWNlOiB0cnVlIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydHMgc2VsZWN0ZWQgdGV4dCBmcm9tIGEgc3VnZ2VzdGlvbiBtb2RhbCBpbnRvIHRoZSBjaGF0IGlucHV0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5zZXJ0X3RleHQgLSBUaGUgdGV4dCB0byBpbnNlcnQuXG4gICAqL1xuICBpbnNlcnRfc2VsZWN0aW9uKGluc2VydF90ZXh0KSB7XG4gICAgY29uc3QgdGV4dGFyZWEgPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiLnNjLWNoYXQtZm9ybSB0ZXh0YXJlYVwiKTtcbiAgICBsZXQgY2FyZXRfcG9zID0gdGV4dGFyZWEuc2VsZWN0aW9uU3RhcnQ7XG4gICAgbGV0IHRleHRfYmVmb3JlID0gdGV4dGFyZWEudmFsdWUuc3Vic3RyaW5nKDAsIGNhcmV0X3Bvcyk7XG4gICAgbGV0IHRleHRfYWZ0ZXIgPSB0ZXh0YXJlYS52YWx1ZS5zdWJzdHJpbmcoY2FyZXRfcG9zLCB0ZXh0YXJlYS52YWx1ZS5sZW5ndGgpO1xuICAgIHRleHRhcmVhLnZhbHVlID0gdGV4dF9iZWZvcmUgKyBpbnNlcnRfdGV4dCArIHRleHRfYWZ0ZXI7XG4gICAgdGV4dGFyZWEuc2VsZWN0aW9uU3RhcnQgPSBjYXJldF9wb3MgKyBpbnNlcnRfdGV4dC5sZW5ndGg7XG4gICAgdGV4dGFyZWEuc2VsZWN0aW9uRW5kID0gY2FyZXRfcG9zICsgaW5zZXJ0X3RleHQubGVuZ3RoO1xuICAgIHRleHRhcmVhLmZvY3VzKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIHR5cGluZyBpbmRpY2F0b3IgKFwiLi4uXCIpIGFuZCBzZXRzIGFuIGludGVydmFsIHRvIGFuaW1hdGUgaXQuXG4gICAqL1xuICBhc3luYyByZW5kZXJfZG90ZG90ZG90KCkge1xuICAgIGlmICh0aGlzLmRvdGRvdGRvdF9pbnRlcnZhbCkgY2xlYXJJbnRlcnZhbCh0aGlzLmRvdGRvdGRvdF9pbnRlcnZhbCk7XG4gICAgYXdhaXQgdGhpcy5uZXdfbWVzc2FnZShcIi4uLlwiLCBcImFzc2lzdGFudFwiKTtcbiAgICBsZXQgZG90cyA9IDA7XG4gICAgY29uc3QgY3Vycl9tc2cgPSB0aGlzLmxhc3RfbXNnX2NvbnRlbnQ7XG4gICAgY3Vycl9tc2cuaW5uZXJIVE1MID0gJy4uLic7XG4gICAgdGhpcy5kb3Rkb3Rkb3RfaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBkb3RzKys7XG4gICAgICBpZiAoZG90cyA+IDMpIGRvdHMgPSAxO1xuICAgICAgY3Vycl9tc2cuaW5uZXJIVE1MID0gJy4nLnJlcGVhdChkb3RzKTtcbiAgICB9LCA1MDApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG1lc3NhZ2UgY29udGFpbmVyIGVsZW1lbnQuXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gVGhlIG1lc3NhZ2UgY29udGFpbmVyLlxuICAgKi9cbiAgZ2V0IG1lc3NhZ2VfY29udGFpbmVyKCkgeyByZXR1cm4gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcihcIi5zYy1tZXNzYWdlLWNvbnRhaW5lclwiKTsgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsYXN0IG1lc3NhZ2UgY29udGVudCBlbGVtZW50LlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IFRoZSBsYXN0IG1lc3NhZ2UgY29udGVudCBlbGVtZW50LlxuICAgKi9cbiAgZ2V0IGxhc3RfbXNnKCkgeyByZXR1cm4gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcihcIi5zYy1tZXNzYWdlLWNvbnRhaW5lclwiKS5sYXN0RWxlbWVudENoaWxkLnF1ZXJ5U2VsZWN0b3IoXCIuc2MtbWVzc2FnZS1jb250ZW50XCIpOyB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxhc3QgbWVzc2FnZSBjb250ZW50IHNwYW4gZWxlbWVudC5cbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSBUaGUgbGFzdCBtZXNzYWdlIGNvbnRlbnQgc3BhbiBlbGVtZW50LlxuICAgKi9cbiAgZ2V0IGxhc3RfbXNnX2NvbnRlbnQoKSB7IHJldHVybiB0aGlzLmxhc3RfbXNnLnF1ZXJ5U2VsZWN0b3IoXCJzcGFuOm5vdCguc2MtbXNnLWJ1dHRvbilcIik7IH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgbWVzc2FnZSBjb250ZW50IGVsZW1lbnRzLlxuICAgKiBAcmV0dXJucyB7Tm9kZUxpc3RPZjxIVE1MRWxlbWVudD59IEEgTm9kZUxpc3Qgb2YgbWVzc2FnZSBjb250ZW50IGVsZW1lbnRzLlxuICAgKi9cbiAgZ2V0IG1lc3NhZ2VzKCkgeyByZXR1cm4gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcIi5zYy1tZXNzYWdlLWNvbnRhaW5lciAuc2MtbWVzc2FnZS1jb250ZW50XCIpOyB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHVzZXIgaW50ZXJmYWNlIHRvIGEgXCJzdHJlYW1pbmdcIiBtb2RlLCBkaXNhYmxpbmcgaW5wdXQgYW5kIHNob3dpbmcgYW4gYWJvcnQgYnV0dG9uLlxuICAgKi9cbiAgc2V0X3N0cmVhbWluZ191eCgpIHtcbiAgICB0aGlzLnByZXZlbnRfaW5wdXQgPSB0cnVlO1xuICAgIC8vIGhpZGUgc2VuZCBidXR0b25cbiAgICBpZiAodGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcihcIiNzYy1zZW5kLWJ1dHRvblwiKSlcbiAgICAgIHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIjc2Mtc2VuZC1idXR0b25cIikuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIC8vIHNob3cgYWJvcnQgYnV0dG9uXG4gICAgaWYgKHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIjc2MtYWJvcnQtYnV0dG9uXCIpKVxuICAgICAgdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcihcIiNzYy1hYm9ydC1idXR0b25cIikuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIHVzZXIgaW50ZXJmYWNlIGZyb20gXCJzdHJlYW1pbmdcIiBtb2RlIHRvIG5vcm1hbC5cbiAgICovXG4gIHVuc2V0X3N0cmVhbWluZ191eCgpIHtcbiAgICB0aGlzLnByZXZlbnRfaW5wdXQgPSBmYWxzZTtcbiAgICAvLyBzaG93IHNlbmQgYnV0dG9uLCByZW1vdmUgZGlzcGxheSBub25lXG4gICAgaWYgKHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIjc2Mtc2VuZC1idXR0b25cIikpXG4gICAgICB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiI3NjLXNlbmQtYnV0dG9uXCIpLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgIC8vIGhpZGUgYWJvcnQgYnV0dG9uXG4gICAgaWYgKHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIjc2MtYWJvcnQtYnV0dG9uXCIpKVxuICAgICAgdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcihcIiNzYy1hYm9ydC1idXR0b25cIikuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyBhbnkgc3RyZWFtaW5nIHVzZXIgaW50ZXJmYWNlIGVmZmVjdHMsIHN1Y2ggYXMgaW50ZXJ2YWxzIGFuZCB0ZW1wb3JhcnkgZWxlbWVudHMuXG4gICAqL1xuICBjbGVhcl9zdHJlYW1pbmdfdXgoKSB7XG4gICAgdGhpcy51bnNldF9zdHJlYW1pbmdfdXgoKTtcbiAgICBpZiAodGhpcy5kb3Rkb3Rkb3RfaW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5kb3Rkb3Rkb3RfaW50ZXJ2YWwpO1xuICAgICAgdGhpcy5kb3Rkb3Rkb3RfaW50ZXJ2YWwgPSBudWxsO1xuICAgICAgLy8gcmVtb3ZlIHBhcmVudCBvZiBhY3RpdmVfZWxtXG4gICAgICB0aGlzLmFjdGl2ZV9lbG0ucGFyZW50RWxlbWVudC5yZW1vdmUoKTtcbiAgICAgIHRoaXMuYWN0aXZlX2VsbSA9IG51bGw7XG4gICAgfVxuICB9XG59XG5leHBvcnRzLlNtYXJ0Q2hhdHNVSSA9IFNtYXJ0Q2hhdHNVSTsiLCAiY29uc3QgeyBJdGVtVmlldyB9ID0gcmVxdWlyZShcIm9ic2lkaWFuXCIpO1xuY29uc3Qgdmlld3MgPSByZXF1aXJlKFwiLi4vYnVpbGQvdmlld3MuanNvblwiKTtcbmNvbnN0IGVqcyA9IHJlcXVpcmUoXCIuLi9lanMubWluXCIpO1xuXG4vLyBoYW5kbGUgcmVuZGVyaW5nIEVKUyB2aWV3c1xuY2xhc3MgU21hcnRPYnNpZGlhblZpZXcgZXh0ZW5kcyBJdGVtVmlldyB7XG4gIGNvbnN0cnVjdG9yKGxlYWYsIHBsdWdpbikge1xuICAgIHN1cGVyKGxlYWYpO1xuICAgIHRoaXMuYXBwID0gcGx1Z2luLmFwcDtcbiAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcbiAgICB0aGlzLnNldHRpbmdzID0gcGx1Z2luLnNldHRpbmdzO1xuICAgIHRoaXMudGVtcGxhdGVzID0gdmlld3M7XG4gICAgdGhpcy5lanMgPSBlanM7XG4gIH1cbiAgcmVuZGVyX3RlbXBsYXRlKHRlbXBsYXRlX25hbWUsIGRhdGEpIHtcbiAgICAvLyBjb25zb2xlLmxvZyhcInJlbmRlcmluZyB0ZW1wbGF0ZVwiLCB0ZW1wbGF0ZV9uYW1lKTtcbiAgICBpZiAoIXRoaXMudGVtcGxhdGVzW3RlbXBsYXRlX25hbWVdKSB0aHJvdyBuZXcgRXJyb3IoYFRlbXBsYXRlICcke3RlbXBsYXRlX25hbWV9JyBub3QgZm91bmQuYCk7XG4gICAgcmV0dXJuIGVqcy5yZW5kZXIodGhpcy50ZW1wbGF0ZXNbdGVtcGxhdGVfbmFtZV0sIGRhdGEsIHsgY29udGV4dDogdGhpcy52aWV3X2NvbnRleHQgfSk7XG4gIH1cbiAgZ2V0IHZpZXdfY29udGV4dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gYXBwOiB0aGlzLnBsdWdpbi5hcHAsXG4gICAgICBhdHRyaWJ1dGlvbjogdGhpcy50ZW1wbGF0ZXMuYXR0cmlidXRpb24sXG4gICAgICBnZXRfaWNvbjogdGhpcy5nZXRfaWNvbi5iaW5kKHRoaXMpLFxuICAgICAgc2V0dGluZ3M6IHRoaXMucGx1Z2luLnNldHRpbmdzLFxuICAgIH07XG4gIH1cbiAgZ2V0X2ljb24obmFtZSkgeyByZXR1cm4gdGhpcy5wbHVnaW4ub2JzaWRpYW4uZ2V0SWNvbihuYW1lKS5vdXRlckhUTUw7IH1cbiAgc3RhdGljIGdldCB2aWV3X3R5cGUoKSB7IH1cbiAgc3RhdGljIGdldF9sZWFmKHdvcmtzcGFjZSkgeyByZXR1cm4gd29ya3NwYWNlLmdldExlYXZlc09mVHlwZSh0aGlzLnZpZXdfdHlwZSk/LmZpbmQoKGxlYWYpID0+IGxlYWYudmlldyBpbnN0YW5jZW9mIHRoaXMpOyB9XG4gIHN0YXRpYyBnZXRfdmlldyh3b3Jrc3BhY2UpIHsgcmV0dXJuIHRoaXMuZ2V0X2xlYWYod29ya3NwYWNlKT8udmlldzsgfVxuICBzdGF0aWMgb3Blbih3b3Jrc3BhY2UsIGFjdGl2ZSA9IHRydWUpIHtcbiAgICBpZiAodGhpcy5nZXRfbGVhZih3b3Jrc3BhY2UpKSB0aGlzLmdldF9sZWFmKHdvcmtzcGFjZSkuc2V0Vmlld1N0YXRlKHsgdHlwZTogdGhpcy52aWV3X3R5cGUsIGFjdGl2ZSB9KTtcbiAgICBlbHNlIHdvcmtzcGFjZS5nZXRSaWdodExlYWYoZmFsc2UpLnNldFZpZXdTdGF0ZSh7IHR5cGU6IHRoaXMudmlld190eXBlLCBhY3RpdmUgfSk7XG4gICAgaWYod29ya3NwYWNlLnJpZ2h0U3BsaXQuY29sbGFwc2VkKSB3b3Jrc3BhY2UucmlnaHRTcGxpdC50b2dnbGUoKTtcbiAgfVxuICBzdGF0aWMgaXNfb3Blbih3b3Jrc3BhY2UpIHsgcmV0dXJuIHRoaXMuZ2V0X2xlYWYod29ya3NwYWNlKT8udmlldyBpbnN0YW5jZW9mIHRoaXM7IH1cbn1cbmV4cG9ydHMuU21hcnRPYnNpZGlhblZpZXcgPSBTbWFydE9ic2lkaWFuVmlldztcbiIsICJjb25zdCB7IFNtYXJ0T2JzaWRpYW5WaWV3IH0gPSByZXF1aXJlKFwiLi9zbWFydF9vYnNpZGlhbl92aWV3XCIpO1xuY2xhc3MgU2NDaGF0VmlldyBleHRlbmRzIFNtYXJ0T2JzaWRpYW5WaWV3IHtcbiAgY29uc3RydWN0b3IobGVhZiwgcGx1Z2luKSB7XG4gICAgc3VwZXIobGVhZiwgcGx1Z2luKTtcbiAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcbiAgICB0aGlzLmVudiA9IHRoaXMucGx1Z2luLmVudjtcbiAgICB0aGlzLmNvbmZpZyA9IHRoaXMucGx1Z2luLnNldHRpbmdzO1xuICB9XG4gIHN0YXRpYyBnZXQgdmlld190eXBlKCkgeyByZXR1cm4gXCJzbWFydC1jb25uZWN0aW9ucy1jaGF0LXZpZXdcIjsgfVxuICBnZXREaXNwbGF5VGV4dCgpIHsgcmV0dXJuIFwiU21hcnQgQ29ubmVjdGlvbnMgQ2hhdFwiOyB9XG4gIGdldEljb24oKSB7IHJldHVybiBcIm1lc3NhZ2Utc3F1YXJlXCI7IH1cbiAgZ2V0Vmlld1R5cGUoKSB7IHJldHVybiBTY0NoYXRWaWV3LnZpZXdfdHlwZTsgfVxuICBhc3luYyBvbk9wZW4oKSB7IHRoaXMuYXBwLndvcmtzcGFjZS5vbkxheW91dFJlYWR5KHRoaXMuaW5pdGlhbGl6ZS5iaW5kKHRoaXMpKTsgfVxuICBhc3luYyBpbml0aWFsaXplKCkge1xuICAgIGlmKCF0aGlzLmVudi5lbnRpdGllc19sb2FkZWQpe1xuICAgICAgLy8gc2V0IGxvYWRpbmcgbWVzc2FnZVxuICAgICAgdGhpcy5jb250YWluZXJFbC5pbm5lckhUTUwgPSBcIkxvYWRpbmcgU21hcnQgQ29ubmVjdGlvbnMuLi5cIjtcbiAgICAgIC8vIHdhaXQgZm9yIGVudGl0aWVzIHRvIGJlIGluaXRpYWxpemVkXG4gICAgICB3aGlsZSAoIXRoaXMuZW52LmVudGl0aWVzX2xvYWRlZCkgYXdhaXQgbmV3IFByb21pc2UociA9PiBzZXRUaW1lb3V0KHIsIDIwMDApKTtcbiAgICB9XG4gICAgaWYodGhpcy5lbnYuY2hhdF91aSkgdGhpcy5lbnYuY2hhdF91aS5jb250YWluZXIgPSB0aGlzLmNvbnRhaW5lckVsOyAvLyBzZXQgbmV3IGNvbnRhaW5lciBpZiBjaGF0X3VpIGV4aXN0c1xuICAgIC8vIHdhaXQgZm9yIGNoYXRzIHRvIGJlIGluaXRpYWxpemVkXG4gICAgd2hpbGUgKCF0aGlzLmVudi5jaGF0cykgYXdhaXQgbmV3IFByb21pc2UociA9PiBzZXRUaW1lb3V0KHIsIDMwMCkpO1xuICAgIGF3YWl0IHRoaXMuZW52LmNoYXRzLm5ldygpO1xuICAgIHRoaXMuYXBwLndvcmtzcGFjZS5yZWdpc3RlckhvdmVyTGlua1NvdXJjZShTY0NoYXRWaWV3LnZpZXdfdHlwZSwge1xuICAgICAgZGlzcGxheTogJ1NtYXJ0IENoYXQgTGlua3MnLFxuICAgICAgZGVmYXVsdE1vZDogdHJ1ZSxcbiAgICB9KTtcbiAgfVxuICBvbkNsb3NlKCkge1xuICAgIHRoaXMuYXBwLndvcmtzcGFjZS51bnJlZ2lzdGVySG92ZXJMaW5rU291cmNlKFNjQ2hhdFZpZXcudmlld190eXBlKTtcbiAgfVxufVxuXG4vLyBFWFBPUlRTXG5leHBvcnRzLlNjQ2hhdFZpZXcgPSBTY0NoYXRWaWV3OyIsICJjb25zdCB7IFNldHRpbmcgfSA9IHJlcXVpcmUoXCJvYnNpZGlhblwiKTtcbi8vIGNvbnN0IGVqcyA9IHJlcXVpcmUoXCIuLi9lanMubWluXCIpO1xuY2xhc3MgU21hcnRTZXR0aW5ncyB7XG4gIGNvbnN0cnVjdG9yKGVudiwgY29udGFpbmVyLCB0ZW1wbGF0ZV9uYW1lID0gXCJzbWFydF9zZXR0aW5nc1wiKSB7XG4gICAgdGhpcy5lbnYgPSBlbnY7XG4gICAgdGhpcy5wbHVnaW4gPSB0aGlzLmVudi5wbHVnaW47XG4gICAgdGhpcy5zZXR0aW5ncyA9IHRoaXMucGx1Z2luLnNldHRpbmdzO1xuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMudGVtcGxhdGVfbmFtZSA9IHRlbXBsYXRlX25hbWU7XG4gICAgdGhpcy5lanMgPSB0aGlzLmVudi5lanM7XG4gICAgdGhpcy50ZW1wbGF0ZXMgPSB0aGlzLmVudi50ZW1wbGF0ZXM7XG4gIH1cbiAgYXN5bmMgcmVuZGVyKCkge1xuICAgIGNvbnN0IHZpZXdfZGF0YSA9ICh0eXBlb2YgdGhpcy5nZXRfdmlld19kYXRhID09PSBcImZ1bmN0aW9uXCIpID8gYXdhaXQgdGhpcy5nZXRfdmlld19kYXRhKCkgOiB0aGlzLnZpZXdfZGF0YTtcbiAgICB0aGlzLnJlbmRlcl90ZW1wbGF0ZSh2aWV3X2RhdGEpO1xuICAgIHRoaXMucmVuZGVyX2NvbXBvbmVudHMoKTtcbiAgfVxuICByZW5kZXJfdGVtcGxhdGUodmlld19kYXRhID0gbnVsbCkge1xuICAgIGlmICghdGhpcy50ZW1wbGF0ZSkgdGhyb3cgbmV3IEVycm9yKGBTZXR0aW5ncyB0ZW1wbGF0ZSBub3QgZm91bmQuYCk7XG4gICAgdGhpcy5jb250YWluZXIuZW1wdHkoKTtcbiAgICB0aGlzLmNvbnRhaW5lci5pbm5lckhUTUwgPSB0aGlzLmVqcy5yZW5kZXIodGhpcy50ZW1wbGF0ZSwgdmlld19kYXRhIHx8IHRoaXMudmlld19kYXRhLCB7IGNvbnRleHQ6IHRoaXMgfSk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlKHNldHRpbmcsIHZhbHVlKSB7XG4gICAgY29uc29sZS5sb2coXCJzYXZpbmcgc2V0dGluZzogXCIgKyBzZXR0aW5nKTtcbiAgICBpZiAoc2V0dGluZy5pbmNsdWRlcyhcIi5cIikpIHtcbiAgICAgIGxldCBwYXJ0cyA9IHNldHRpbmcuc3BsaXQoXCIuXCIpO1xuICAgICAgbGV0IG9iaiA9IHRoaXMucGx1Z2luLnNldHRpbmdzO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgaWYgKCFvYmpbcGFydHNbaV1dKSBvYmpbcGFydHNbaV1dID0ge307XG4gICAgICAgIG9iaiA9IG9ialtwYXJ0c1tpXV07XG4gICAgICB9XG4gICAgICBvYmpbcGFydHNbcGFydHMubGVuZ3RoIC0gMV1dID0gKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikgPyB2YWx1ZS50cmltKCkgOiB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Nbc2V0dGluZ10gPSAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSA/IHZhbHVlLnRyaW0oKSA6IHZhbHVlO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlX3NldHRpbmdzKHRydWUpO1xuICAgIGNvbnNvbGUubG9nKFwic2F2ZWQgc2V0dGluZ3NcIik7XG4gICAgY29uc29sZS5sb2codGhpcy5wbHVnaW4uc2V0dGluZ3MpO1xuICB9XG4gIHJlbmRlcl9jb21wb25lbnRzKCkge1xuICAgIHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuc2V0dGluZy1jb21wb25lbnRcIikuZm9yRWFjaChlbG0gPT4ge1xuICAgICAgY29uc3Qgc2V0dGluZ19lbG0gPSBuZXcgU2V0dGluZyhlbG0pO1xuICAgICAgaWYgKGVsbS5kYXRhc2V0Lm5hbWUpIHNldHRpbmdfZWxtLnNldE5hbWUoZWxtLmRhdGFzZXQubmFtZSk7XG4gICAgICBpZiAoZWxtLmRhdGFzZXQuZGVzY3JpcHRpb24pIHNldHRpbmdfZWxtLmRlc2NFbC5pbm5lckhUTUwgPSBlbG0uZGF0YXNldC5kZXNjcmlwdGlvbjtcbiAgICAgIGNvbnN0IHNldHRpbmcgPSBlbG0uZGF0YXNldC5zZXR0aW5nO1xuICAgICAgaWYgKGVsbS5kYXRhc2V0LnR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgIHNldHRpbmdfZWxtLmFkZFRleHQodGV4dCA9PiB7XG4gICAgICAgICAgdGV4dC5zZXRQbGFjZWhvbGRlcihlbG0uZGF0YXNldC5wbGFjZWhvbGRlciB8fCBcIlwiKTtcbiAgICAgICAgICB0ZXh0LnNldFZhbHVlKHRoaXMuZ2V0X3NldHRpbmcoc2V0dGluZykpO1xuICAgICAgICAgIGxldCBkZWJvdW5jZVRpbWVyO1xuICAgICAgICAgIGlmIChlbG0uZGF0YXNldC5idXR0b24pIHtcbiAgICAgICAgICAgIHNldHRpbmdfZWxtLmFkZEJ1dHRvbihidXR0b24gPT4ge1xuICAgICAgICAgICAgICBidXR0b24uc2V0QnV0dG9uVGV4dChlbG0uZGF0YXNldC5idXR0b24pO1xuICAgICAgICAgICAgICBidXR0b24ub25DbGljayhhc3luYyAoKSA9PiB0aGlzLmhhbmRsZV9vbl9jaGFuZ2Uoc2V0dGluZywgdGV4dC5nZXRWYWx1ZSgpLCBlbG0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoZGVib3VuY2VUaW1lcik7XG4gICAgICAgICAgICAgIGRlYm91bmNlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuaGFuZGxlX29uX2NoYW5nZShzZXR0aW5nLCB2YWx1ZSwgZWxtKSwgMjAwMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChlbG0uZGF0YXNldC50eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHNldHRpbmdfZWxtLmFkZFRleHQobnVtYmVyID0+IHtcbiAgICAgICAgICBudW1iZXIuaW5wdXRFbC50eXBlID0gXCJudW1iZXJcIjtcbiAgICAgICAgICBudW1iZXIuc2V0UGxhY2Vob2xkZXIoZWxtLmRhdGFzZXQucGxhY2Vob2xkZXIgfHwgXCJcIik7XG4gICAgICAgICAgbnVtYmVyLmlucHV0RWwudmFsdWUgPSBwYXJzZUludCh0aGlzLmdldF9zZXR0aW5nKHNldHRpbmcpKTtcbiAgICAgICAgICBudW1iZXIuaW5wdXRFbC5taW4gPSBlbG0uZGF0YXNldC5taW4gfHwgMDtcbiAgICAgICAgICBpZiAoZWxtLmRhdGFzZXQubWF4KSBudW1iZXIuaW5wdXRFbC5tYXggPSBlbG0uZGF0YXNldC5tYXg7XG4gICAgICAgICAgbGV0IGRlYm91bmNlVGltZXI7XG4gICAgICAgICAgbnVtYmVyLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGRlYm91bmNlVGltZXIpO1xuICAgICAgICAgICAgZGVib3VuY2VUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5oYW5kbGVfb25fY2hhbmdlKHNldHRpbmcsIHBhcnNlSW50KHZhbHVlKSwgZWxtKSwgMjAwMCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChlbG0uZGF0YXNldC50eXBlID09PSBcImRyb3Bkb3duXCIpIHtcbiAgICAgICAgc2V0dGluZ19lbG0uYWRkRHJvcGRvd24oZHJvcGRvd24gPT4ge1xuICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGVsbS5kYXRhc2V0KVxuICAgICAgICAgICAgLmZpbHRlcigoW2ssIHZdKSA9PiBrLnN0YXJ0c1dpdGgoXCJvcHRpb25cIikpXG4gICAgICAgICAgICAuZm9yRWFjaCgoW2ssIHZdKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IFt2YWx1ZSwgbmFtZV0gPSB2LnNwbGl0KFwifFwiKTtcbiAgICAgICAgICAgICAgZHJvcGRvd24uYWRkT3B0aW9uKHZhbHVlLCBuYW1lIHx8IHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIGRyb3Bkb3duLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4gdGhpcy5oYW5kbGVfb25fY2hhbmdlKHNldHRpbmcsIHZhbHVlLCBlbG0pKTtcbiAgICAgICAgICBkcm9wZG93bi5zZXRWYWx1ZSh0aGlzLmdldF9zZXR0aW5nKHNldHRpbmcpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGVsbS5kYXRhc2V0LnR5cGUgPT09IFwiYnV0dG9uXCIpIHtcbiAgICAgICAgc2V0dGluZ19lbG0uYWRkQnV0dG9uKGJ1dHRvbiA9PiB7XG4gICAgICAgICAgYnV0dG9uLnNldEJ1dHRvblRleHQoZWxtLmRhdGFzZXQuYnRuVGV4dCB8fCBlbG0uZGF0YXNldC5uYW1lKTtcbiAgICAgICAgICBidXR0b24ub25DbGljayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoZWxtLmRhdGFzZXQuY29uZmlybSkge1xuICAgICAgICAgICAgICBjb25zdCBjb25maXJtYXRpb25fbWVzc2FnZSA9IGVsbS5kYXRhc2V0LmNvbmZpcm07XG4gICAgICAgICAgICAgIGlmICghY29uZmlybShjb25maXJtYXRpb25fbWVzc2FnZSkpIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbG0uZGF0YXNldC5ocmVmKSB3aW5kb3cub3BlbihlbG0uZGF0YXNldC5ocmVmKTtcbiAgICAgICAgICAgIGlmIChlbG0uZGF0YXNldC5jYWxsYmFjaykgdGhpc1tlbG0uZGF0YXNldC5jYWxsYmFja10oc2V0dGluZyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChlbG0uZGF0YXNldC50eXBlID09PSBcInRvZ2dsZVwiKSB7XG4gICAgICAgIHNldHRpbmdfZWxtLmFkZFRvZ2dsZSh0b2dnbGUgPT4ge1xuICAgICAgICAgIHRvZ2dsZS5zZXRWYWx1ZSh0aGlzLmdldF9zZXR0aW5nKHNldHRpbmcpKTtcbiAgICAgICAgICB0b2dnbGUub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB0aGlzLmhhbmRsZV9vbl9jaGFuZ2Uoc2V0dGluZywgdmFsdWUsIGVsbSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChlbG0uZGF0YXNldC5kaXNhYmxlZCkgc2V0dGluZ19lbG0uc2V0RGlzYWJsZWQodHJ1ZSk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgaGFuZGxlX29uX2NoYW5nZShzZXR0aW5nLCB2YWx1ZSwgZWxtKSB7XG4gICAgYXdhaXQgdGhpcy51cGRhdGUoc2V0dGluZywgdmFsdWUpO1xuICAgIGlmIChlbG0uZGF0YXNldC5jYWxsYmFjaykgdGhpc1tlbG0uZGF0YXNldC5jYWxsYmFja10oc2V0dGluZywgdmFsdWUsIGVsbSk7XG4gIH1cbiAgZ2V0X3NldHRpbmcoc2V0dGluZykge1xuICAgIGlmIChzZXR0aW5nLmluY2x1ZGVzKFwiLlwiKSkge1xuICAgICAgbGV0IHBhcnRzID0gc2V0dGluZy5zcGxpdChcIi5cIik7XG4gICAgICBsZXQgb2JqID0gdGhpcy5wbHVnaW4uc2V0dGluZ3M7XG4gICAgICBmb3IgKGxldCBwYXJ0IG9mIHBhcnRzLnNsaWNlKDAsIC0xKSkge1xuICAgICAgICBpZiAob2JqW3BhcnRdID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzLnBsdWdpbi5jb25zdHJ1Y3Rvci5kZWZhdWx0c1tzZXR0aW5nXTsgLy8gRmFsbGJhY2sgdG8gZGVmYXVsdCBpZiBwYXRoIGlzIGJyb2tlblxuICAgICAgICBvYmogPSBvYmpbcGFydF07XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqW3BhcnRzW3BhcnRzLmxlbmd0aCAtIDFdXSB8fCB0aGlzLnBsdWdpbi5jb25zdHJ1Y3Rvci5kZWZhdWx0c1tzZXR0aW5nXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucGx1Z2luLnNldHRpbmdzW3NldHRpbmddIHx8IHRoaXMucGx1Z2luLmNvbnN0cnVjdG9yLmRlZmF1bHRzW3NldHRpbmddO1xuICAgIH1cbiAgfVxuICAvLyBvdmVycmlkZSBpbiBzdWJjbGFzcyAocmVxdWlyZWQpXG4gIGdldCB0ZW1wbGF0ZSgpIHsgcmV0dXJuIFwiXCI7IH0gLy8gZWpzIHRlbXBsYXRlIHN0cmluZ1xuICBnZXQgdmlld19kYXRhKCkgeyByZXR1cm4ge307IH0gLy8gb2JqZWN0IHByb3BlcnRpZXMgYXZhaWxhYmxlIGluIHRlbXBsYXRlXG59XG5leHBvcnRzLlNtYXJ0U2V0dGluZ3MgPSBTbWFydFNldHRpbmdzOyIsICJjb25zdCBTY1RyYW5zbGF0aW9ucyA9IHJlcXVpcmUoXCIuL1NjVHJhbnNsYXRpb25zXCIpO1xuY29uc3QgeyBTbWFydFNldHRpbmdzIH0gPSByZXF1aXJlKFwiLi9zbWFydF9zZXR0aW5nc1wiKTtcbi8vIFNtYXJ0IENvbm5lY3Rpb25zIFNwZWNpZmljIFNldHRpbmdzXG5jbGFzcyBTbWFydENoYXRTZXR0aW5ncyBleHRlbmRzIFNtYXJ0U2V0dGluZ3Mge1xuICB1cGRhdGVfc21hcnRfY2hhdF9mb2xkZXIoKSB7IHRoaXMucGx1Z2luLnVwZGF0ZV9zbWFydF9jaGF0X2ZvbGRlcigpOyB9XG4gIGFzeW5jIGNoYW5nZWRfc21hcnRfY2hhdF9tb2RlbChyZW5kZXIgPSB0cnVlKXtcbiAgICBjb25zdCBwbGF0Zm9ybV9jb25maWcgPSB0aGlzLnBsdWdpbi5lbnYuY2hhdF9tb2RlbC5wbGF0Zm9ybXNbdGhpcy5wbHVnaW4uc2V0dGluZ3MuY2hhdF9tb2RlbF9wbGF0Zm9ybV9rZXldO1xuICAgIGNvbnN0IHNtYXJ0X2NoYXRfbW9kZWxfY29uZmlnID0gcGxhdGZvcm1fY29uZmlnIHx8IHt9O1xuICAgIGlmKHNtYXJ0X2NoYXRfbW9kZWxfY29uZmlnLm1vZGVsX25hbWUpe1xuICAgICAgY29uc3QgcGxhdGZvcm1fbW9kZWxzID0gYXdhaXQgdGhpcy5wbHVnaW4uZW52LmNoYXRfbW9kZWwuZ2V0X21vZGVscygpO1xuICAgICAgY29uc3QgbW9kZWxfY29uZmlnID0gcGxhdGZvcm1fbW9kZWxzLmZpbmQobSA9PiBtLm1vZGVsX25hbWUgPT09IHNtYXJ0X2NoYXRfbW9kZWxfY29uZmlnLm1vZGVsX25hbWUpO1xuICAgICAgY29uc29sZS5sb2coXCJtb2RlbF9jb25maWdcIiwgbW9kZWxfY29uZmlnKTtcbiAgICAgIGlmKG1vZGVsX2NvbmZpZykgT2JqZWN0LmFzc2lnbihzbWFydF9jaGF0X21vZGVsX2NvbmZpZywgbW9kZWxfY29uZmlnKTtcbiAgICAgIGNvbnNvbGUubG9nKFwic21hcnRfY2hhdF9tb2RlbF9jb25maWdcIiwgc21hcnRfY2hhdF9tb2RlbF9jb25maWcpO1xuICAgIH1cbiAgICB0aGlzLnBsdWdpbi5zYXZlX3NldHRpbmdzKHRydWUpO1xuICAgIHRoaXMucGx1Z2luLmVudi5jaGF0X21vZGVsID0gbnVsbDtcbiAgICB0aGlzLnBsdWdpbi5lbnYuaW5pdF9jaGF0X21vZGVsKCk7XG4gICAgaWYocmVuZGVyKSB0aGlzLnJlbmRlcigpO1xuICB9XG4gIGFzeW5jIHRlc3RfY2hhdF9hcGlfa2V5KCl7XG4gICAgYXdhaXQgdGhpcy5jaGFuZ2VkX3NtYXJ0X2NoYXRfbW9kZWwoKTtcbiAgICBjb25zdCByZXNwID0gYXdhaXQgdGhpcy5wbHVnaW4uZW52LmNoYXRfbW9kZWwudGVzdF9hcGlfa2V5KCk7XG4gICAgaWYocmVzcCkgcmV0dXJuIHRoaXMucGx1Z2luLm5vdGljZXMuc2hvdygnYXBpIGtleSB0ZXN0IHBhc3MnLCBcIlN1Y2Nlc3MhIEFQSSBrZXkgaXMgdmFsaWRcIik7XG4gICAgdGhpcy5wbHVnaW4ubm90aWNlcy5zaG93KCdhcGkga2V5IHRlc3QgZmFpbCcsIFwiRXJyb3I6IEFQSSBrZXkgaXMgaW52YWxpZCFcIik7XG4gIH1cbiAgZ2V0IHNlbGZfcmVmX2xpc3QoKSB7IHJldHVybiBcIkN1cnJlbnQ6IFwiICsgU2NUcmFuc2xhdGlvbnNbdGhpcy5jb25maWcubGFuZ3VhZ2VdLnByb25vdW5zLmpvaW4oXCIsIFwiKTsgfVxuICBnZXQgdGVtcGxhdGUoKSB7IHJldHVybiB0aGlzLnRlbXBsYXRlc1snc21hcnRfY2hhdF9zZXR0aW5ncyddOyB9XG4gIGFzeW5jIGdldF92aWV3X2RhdGEoKSB7XG4gICAgY29uc3Qgdmlld19kYXRhID0ge1xuICAgICAgc2V0dGluZ3M6IHRoaXMucGx1Z2luLnNldHRpbmdzLFxuICAgICAgY2hhdF9wbGF0Zm9ybTogdGhpcy5lbnYuY2hhdF9tb2RlbC5wbGF0Zm9ybXNbdGhpcy5wbHVnaW4uc2V0dGluZ3MuY2hhdF9tb2RlbF9wbGF0Zm9ybV9rZXldLFxuICAgICAgY2hhdF9wbGF0Zm9ybXM6IHRoaXMuZW52LmNoYXRfbW9kZWw/LnBsYXRmb3JtcyA/IE9iamVjdC5rZXlzKHRoaXMuZW52LmNoYXRfbW9kZWwucGxhdGZvcm1zKS5tYXAocGxhdGZvcm1fa2V5ID0+ICh7IGtleTogcGxhdGZvcm1fa2V5LCAuLi4odGhpcy5lbnYuY2hhdF9tb2RlbD8ucGxhdGZvcm1zW3BsYXRmb3JtX2tleV0gfHwge30pIH0pKSA6IFtdLFxuICAgIH07XG4gICAgdmlld19kYXRhLnBsYXRmb3JtX2NoYXRfbW9kZWxzID0gYXdhaXQgdGhpcy5wbHVnaW4uZW52LmNoYXRfbW9kZWwuZ2V0X21vZGVscygpO1xuICAgIHZpZXdfZGF0YS5zbWFydF9jaGF0X3NldHRpbmdzID0gdGhpcy5lanMucmVuZGVyKHRoaXMudGVtcGxhdGUsIHZpZXdfZGF0YSk7XG4gICAgcmV0dXJuIHZpZXdfZGF0YTtcbiAgfVxufVxuZXhwb3J0cy5TbWFydENoYXRTZXR0aW5ncyA9IFNtYXJ0Q2hhdFNldHRpbmdzO1xuXG5cbiIsICJjb25zdCB7IFNtYXJ0Q2hhdHNVSSB9ID0gcmVxdWlyZShcInNtYXJ0LWNoYXRzL3NtYXJ0X2NoYXRzX3VpXCIpO1xuY29uc3QgeyBTY0NoYXRWaWV3IH0gPSByZXF1aXJlKFwiLi9zY19jaGF0X3ZpZXdcIik7XG5jb25zdCB7IEZ1enp5U3VnZ2VzdE1vZGFsLCB9ID0gcmVxdWlyZShcIm9ic2lkaWFuXCIpO1xuY29uc3QgeyBTbWFydENoYXRTZXR0aW5ncyB9ID0gcmVxdWlyZShcIi4vc21hcnRfY2hhdF9zZXR0aW5nc1wiKTtcblxuY2xhc3MgU2NDaGF0c1VJIGV4dGVuZHMgU21hcnRDaGF0c1VJIHtcbiAgZ2V0IHZpZXdfY29udGV4dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYXR0cmlidXRpb246IHRoaXMudGVtcGxhdGVzLmF0dHJpYnV0aW9uLFxuICAgICAgZ2V0X2ljb246IHRoaXMuZW52LnBsdWdpbi5jaGF0X3ZpZXcuZ2V0X2ljb24uYmluZCh0aGlzLmVudi5wbHVnaW4uY2hhdF92aWV3KSxcbiAgICB9O1xuICB9XG4gIGdldCBvYnNpZGlhbigpIHsgcmV0dXJuIHRoaXMuZW52LnBsdWdpbi5vYnNpZGlhbjsgfVxuICBzaG93X25vdGljZShtZXNzYWdlKSB7IHRoaXMuZW52LnBsdWdpbi5zaG93X25vdGljZShtZXNzYWdlKTsgfVxuICBhZGRfbGlzdGVuZXJzKCkge1xuICAgIC8vIGNoYXQgbmFtZSBpbnB1dFxuICAgIGNvbnN0IGNoYXRfbmFtZV9pbnB1dCA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIuc2MtY2hhdC1uYW1lLWlucHV0XCIpO1xuICAgIGNoYXRfbmFtZV9pbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIChldmVudCkgPT4geyB0aGlzLmVudi5jaGF0cy5jdXJyZW50LnJlbmFtZShldmVudC50YXJnZXQudmFsdWUpOyB9KTtcbiAgICAvLyBvcGVuIGNvbnZlcnNhdGlvbiBpbiBub3RlIGJ1dHRvblxuICAgIGNvbnN0IG9wZW5faW5fbm90ZV9idG4gPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiYnV0dG9uW3RpdGxlPSdPcGVuIENvbnZlcnNhdGlvbiBOb3RlJ11cIik7XG4gICAgb3Blbl9pbl9ub3RlX2J0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgbGlua190ZmlsZSA9IHRoaXMuZW52LnBsdWdpbi5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaXJzdExpbmtwYXRoRGVzdCh0aGlzLmVudi5jaGF0cy5jdXJyZW50Lm5hbWUsIFwiL1wiKTtcbiAgICAgIGxldCBsZWFmID0gdGhpcy5lbnYucGx1Z2luLmFwcC53b3Jrc3BhY2UuZ2V0TGVhZih0cnVlKTtcbiAgICAgIGxlYWYub3BlbkZpbGUobGlua190ZmlsZSk7XG4gICAgfSk7XG4gICAgLy8gc2V0dGluZ3MgYnV0dG9uXG4gICAgY29uc3Qgc2V0dGluZ3NfYnRuID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcihcImJ1dHRvblt0aXRsZT0nU2V0dGluZ3MnXVwiKTtcbiAgICBzZXR0aW5nc19idG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHNldHRpbmdzX2NvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIjc2V0dGluZ3NcIik7XG4gICAgICAvLyBpZiBoYXMgY29udGVudHMsIGNsZWFyXG4gICAgICBpZihzZXR0aW5nc19jb250YWluZXIuaW5uZXJIVE1MKSByZXR1cm4gc2V0dGluZ3NfY29udGFpbmVyLmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAvLyBpZiBubyBzZXR0aW5ncywgY3JlYXRlXG4gICAgICBpZighdGhpcy5jaGF0X3NldHRpbmdzKSB0aGlzLmNoYXRfc2V0dGluZ3MgPSBuZXcgU21hcnRDaGF0U2V0dGluZ3ModGhpcy5lbnYsIHNldHRpbmdzX2NvbnRhaW5lcik7XG4gICAgICBlbHNlIHRoaXMuY2hhdF9zZXR0aW5ncy5jb250YWluZXIgPSBzZXR0aW5nc19jb250YWluZXI7XG4gICAgICB0aGlzLmNoYXRfc2V0dGluZ3MucmVuZGVyKCk7XG4gICAgICAvLyBFbmhhbmNlZCB0cmFuc2l0aW9uOiBzbW9vdGggYmFja2dyb3VuZCBjb2xvciBjaGFuZ2Ugd2l0aCBlYXNlLWluLW91dCBlZmZlY3RcbiAgICAgIHNldHRpbmdzX2NvbnRhaW5lci5zdHlsZS50cmFuc2l0aW9uID0gXCJiYWNrZ3JvdW5kLWNvbG9yIDAuNXMgZWFzZS1pbi1vdXRcIjtcbiAgICAgIHNldHRpbmdzX2NvbnRhaW5lci5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcInZhcigtLWJvbGQtY29sb3IpXCI7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHsgc2V0dGluZ3NfY29udGFpbmVyLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwiXCI7IH0sIDUwMCk7XG4gICAgfSk7XG4gICAgLy8gY2hhdCBoaXN0b3J5IGJ1dHRvblxuICAgIGNvbnN0IGhpc3RvcnlfYnRuID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcihcImJ1dHRvblt0aXRsZT0nQ2hhdCBIaXN0b3J5J11cIik7XG4gICAgaGlzdG9yeV9idG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHsgdGhpcy5lbnYuY2hhdHMub3Blbl9tb2RhbCgpOyB9KTtcbiAgICAvLyBuZXcgY2hhdCBidXR0b25cbiAgICBjb25zdCBuZXdfY2hhdF9idG4gPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiYnV0dG9uW3RpdGxlPSdOZXcgQ2hhdCddXCIpO1xuICAgIG5ld19jaGF0X2J0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4geyB0aGlzLmVudi5jaGF0cy5uZXcoKTsgfSk7XG4gICAgLy8gYWRkIGNoYXQgaW5wdXQgbGlzdGVuZXJzXG4gICAgdGhpcy5hZGRfY2hhdF9pbnB1dF9saXN0ZW5lcnMoKTtcbiAgfVxuICBhc3luYyBtZXNzYWdlX3Bvc3RfcHJvY2Vzcyhtc2dfZWxtKSB7XG4gICAgYXdhaXQgdGhpcy5yZW5kZXJfbWRfYXNfaHRtbChtc2dfZWxtKTtcbiAgICB0aGlzLmhhbmRsZV9saW5rc19pbl9tZXNzYWdlKG1zZ19lbG0pO1xuICAgIHRoaXMuYWRkX21lc3NhZ2VfbGlzdGVuZXJzKG1zZ19lbG0pO1xuICB9XG4gIGFzeW5jIHJlbmRlcl9tZF9hc19odG1sKG1zZ19lbG0pIHtcbiAgICBjb25zdCB0ZXh0X2VsbSA9IG1zZ19lbG0ucXVlcnlTZWxlY3RvcihcInNwYW46bm90KC5zYy1tc2ctYnV0dG9uKVwiKTtcbiAgICAvLyBnZXQgZnJvbSBkYXRhLWNvbnRlbnQgb3IgdGV4dENvbnRlbnRcbiAgICBjb25zdCB0ZXh0ID0gbXNnX2VsbS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNvbnRlbnRcIikgfHwgdGV4dF9lbG0udGV4dENvbnRlbnQ7XG4gICAgdGV4dF9lbG0uaW5uZXJIVE1MID0gJyc7XG4gICAgLy8gYXdhaXQgdGhpcy5vYnNpZGlhbi5NYXJrZG93blJlbmRlcmVyLnJlbmRlck1hcmtkb3duKHRleHQsIHRleHRfZWxtLCAnP25vLWRhdGF2aWV3JywgbmV3IHRoaXMub2JzaWRpYW4uQ29tcG9uZW50KCkpO1xuICAgIGF3YWl0IHRoaXMub2JzaWRpYW4uTWFya2Rvd25SZW5kZXJlci5yZW5kZXIodGhpcy5lbnYucGx1Z2luLmFwcCwgdGV4dCwgdGV4dF9lbG0sICc/bm8tZGF0YXZpZXcnLCBuZXcgdGhpcy5vYnNpZGlhbi5Db21wb25lbnQoKSk7XG4gIH1cbiAgaGFuZGxlX2xpbmtzX2luX21lc3NhZ2UobXNnX2VsbSkge1xuICAgIGNvbnN0IGxpbmtzID0gbXNnX2VsbS5xdWVyeVNlbGVjdG9yQWxsKFwiYVwiKTtcbiAgICAvLyBpZiB0aGlzIGFjdGl2ZSBlbGVtZW50IGNvbnRhaW5zIGEgbGlua1xuICAgIGlmIChsaW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGxpbmsgPSBsaW5rc1tpXTtcbiAgICAgICAgY29uc3QgbGlua190ZXh0ID0gbGluay5nZXRBdHRyaWJ1dGUoXCJkYXRhLWhyZWZcIik7XG4gICAgICAgIC8vIHRyaWdnZXIgaG92ZXIgZXZlbnQgb24gbGlua1xuICAgICAgICBsaW5rLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW92ZXJcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgdGhpcy5lbnYucGx1Z2luLmFwcC53b3Jrc3BhY2UudHJpZ2dlcihcImhvdmVyLWxpbmtcIiwge1xuICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICBzb3VyY2U6IFNjQ2hhdFZpZXcudmlld190eXBlLFxuICAgICAgICAgICAgaG92ZXJQYXJlbnQ6IGxpbmsucGFyZW50RWxlbWVudCxcbiAgICAgICAgICAgIHRhcmdldEVsOiBsaW5rLFxuICAgICAgICAgICAgLy8gZXh0cmFjdCBsaW5rIHRleHQgZnJvbSBhLmRhdGEtaHJlZlxuICAgICAgICAgICAgbGlua3RleHQ6IGxpbmtfdGV4dFxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gdHJpZ2dlciBvcGVuIGxpbmsgZXZlbnQgb24gbGlua1xuICAgICAgICBsaW5rLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICBjb25zdCBsaW5rX3RmaWxlID0gdGhpcy5lbnYucGx1Z2luLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZpcnN0TGlua3BhdGhEZXN0KGxpbmtfdGV4dCwgXCIvXCIpO1xuICAgICAgICAgIC8vIHByb3Blcmx5IGhhbmRsZSBpZiB0aGUgbWV0YS9jdHJsIGtleSBpcyBwcmVzc2VkXG4gICAgICAgICAgY29uc3QgbW9kID0gdGhpcy5vYnNpZGlhbi5LZXltYXAuaXNNb2RFdmVudChldmVudCk7XG4gICAgICAgICAgLy8gZ2V0IG1vc3QgcmVjZW50IGxlYWZcbiAgICAgICAgICBsZXQgbGVhZiA9IHRoaXMuZW52LnBsdWdpbi5hcHAud29ya3NwYWNlLmdldExlYWYobW9kKTtcbiAgICAgICAgICBsZWFmLm9wZW5GaWxlKGxpbmtfdGZpbGUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYWRkX21lc3NhZ2VfbGlzdGVuZXJzKG1zZ19lbG0pIHtcbiAgICBjb25zdCBjb3B5X2J1dHRvbiA9IG1zZ19lbG0ucXVlcnlTZWxlY3RvcihcInNwYW4uc2MtbXNnLWJ1dHRvblt0aXRsZT0nQ29weSBtZXNzYWdlIHRvIGNsaXBib2FyZCddXCIpO1xuICAgIGNvcHlfYnV0dG9uPy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGUpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKFwiY29weSBtZXNzYWdlIHRvIGNsaXBib2FyZFwiKTtcbiAgICAgIGNvbnN0IG1zZ19jb250ZW50X2VsbSA9IGUudGFyZ2V0LmNsb3Nlc3QoXCIuc2MtbWVzc2FnZS1jb250ZW50XCIpO1xuICAgICAgY29uc29sZS5sb2cobXNnX2NvbnRlbnRfZWxtKTtcbiAgICAgIGNvbnN0IG1zZ19jb250ZW50ID0gbXNnX2NvbnRlbnRfZWxtLmdldEF0dHJpYnV0ZShcImRhdGEtY29udGVudFwiKSB8fCBtc2dfY29udGVudF9lbG0ucXVlcnlTZWxlY3RvcihcInNwYW46bm90KC5zYy1tc2ctYnV0dG9uKVwiKS50ZXh0Q29udGVudDtcbiAgICAgIGNvbnNvbGUubG9nKG1zZ19jb250ZW50KTtcbiAgICAgIG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KG1zZ19jb250ZW50KTtcbiAgICAgIHRoaXMuZW52LnBsdWdpbi5zaG93X25vdGljZShcIk1lc3NhZ2UgY29waWVkIHRvIGNsaXBib2FyZFwiKTtcbiAgICB9KTtcbiAgfVxuICAvLyBvcGVuIGZpbGUgc3VnZ2VzdGlvbiBtb2RhbFxuICBvcGVuX2ZpbGVfc3VnZ2VzdGlvbl9tb2RhbCgpIHtcbiAgICAvLyBvcGVuIGZpbGUgc3VnZ2VzdGlvbiBtb2RhbFxuICAgIGlmICghdGhpcy5maWxlX3NlbGVjdG9yKSB0aGlzLmZpbGVfc2VsZWN0b3IgPSBuZXcgU2NGaWxlU2VsZWN0TW9kYWwodGhpcy5lbnYucGx1Z2luLmFwcCwgdGhpcy5lbnYpO1xuICAgIHRoaXMuZmlsZV9zZWxlY3Rvci5vcGVuKCk7XG4gIH1cbiAgLy8gb3BlbiBmb2xkZXIgc3VnZ2VzdGlvbiBtb2RhbFxuICBhc3luYyBvcGVuX2ZvbGRlcl9zdWdnZXN0aW9uX21vZGFsKCkge1xuICAgIGlmICghdGhpcy5mb2xkZXJfc2VsZWN0b3IpIHtcbiAgICAgIGNvbnN0IGZvbGRlcnMgPSBhd2FpdCB0aGlzLmVudi5wbHVnaW4uZ2V0X2ZvbGRlcnMoKTtcbiAgICAgIHRoaXMuZm9sZGVyX3NlbGVjdG9yID0gbmV3IFNjRm9sZGVyU2VsZWN0TW9kYWwodGhpcy5lbnYucGx1Z2luLmFwcCwgdGhpcy5lbnYsIGZvbGRlcnMpOyAvLyBjcmVhdGUgZm9sZGVyIHN1Z2dlc3Rpb24gbW9kYWxcbiAgICB9XG4gICAgdGhpcy5mb2xkZXJfc2VsZWN0b3Iub3BlbigpOyAvLyBvcGVuIGZvbGRlciBzdWdnZXN0aW9uIG1vZGFsXG4gIH1cbiAgYXN5bmMgb3Blbl9zeXN0ZW1fcHJvbXB0X21vZGFsKCkge1xuICAgIGlmICghdGhpcy5zeXN0ZW1fcHJvbXB0X3NlbGVjdG9yKSB0aGlzLnN5c3RlbV9wcm9tcHRfc2VsZWN0b3IgPSBuZXcgU2NTeXN0ZW1Qcm9tcHRTZWxlY3RNb2RhbCh0aGlzLmVudi5wbHVnaW4uYXBwLCB0aGlzLmVudik7XG4gICAgdGhpcy5zeXN0ZW1fcHJvbXB0X3NlbGVjdG9yLm9wZW4oKTtcbiAgfVxufVxuZXhwb3J0cy5TY0NoYXRzVUkgPSBTY0NoYXRzVUk7XG5cbi8vIEZpbGUgU2VsZWN0IEZ1enp5IFN1Z2dlc3QgTW9kYWxcbmNsYXNzIFNjRmlsZVNlbGVjdE1vZGFsIGV4dGVuZHMgRnV6enlTdWdnZXN0TW9kYWwge1xuICBjb25zdHJ1Y3RvcihhcHAsIGVudikge1xuICAgIHN1cGVyKGFwcCk7XG4gICAgdGhpcy5hcHAgPSBhcHA7XG4gICAgdGhpcy5lbnYgPSBlbnY7XG4gICAgLy8gdGhpcy52aWV3ID0gdmlldztcbiAgICB0aGlzLnNldFBsYWNlaG9sZGVyKFwiVHlwZSB0aGUgbmFtZSBvZiBhIGZpbGUuLi5cIik7XG4gIH1cbiAgLy8gZ2V0IGFsbCBtYXJrZG93biBmaWxlc1xuICBnZXRJdGVtcygpIHsgcmV0dXJuIHRoaXMuYXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKS5zb3J0KChhLCBiKSA9PiBhLmJhc2VuYW1lLmxvY2FsZUNvbXBhcmUoYi5iYXNlbmFtZSkpOyB9XG4gIGdldEl0ZW1UZXh0KGl0ZW0pIHsgcmV0dXJuIGl0ZW0uYmFzZW5hbWU7IH1cbiAgb25DaG9vc2VJdGVtKGZpbGUpIHsgdGhpcy5lbnYuY2hhdF91aS5pbnNlcnRfc2VsZWN0aW9uKGZpbGUuYmFzZW5hbWUgKyBcIl1dIFwiKTsgfVxufVxuLy8gRm9sZGVyIFNlbGVjdCBGdXp6eSBTdWdnZXN0IE1vZGFsXG5jbGFzcyBTY0ZvbGRlclNlbGVjdE1vZGFsIGV4dGVuZHMgRnV6enlTdWdnZXN0TW9kYWwge1xuICBjb25zdHJ1Y3RvcihhcHAsIGVudiwgZm9sZGVycykge1xuICAgIHN1cGVyKGFwcCk7XG4gICAgdGhpcy5hcHAgPSBhcHA7XG4gICAgdGhpcy5lbnYgPSBlbnY7XG4gICAgdGhpcy5mb2xkZXJzID0gZm9sZGVycztcbiAgICAvLyB0aGlzLnZpZXcgPSB2aWV3O1xuICAgIHRoaXMuc2V0UGxhY2Vob2xkZXIoXCJUeXBlIHRoZSBuYW1lIG9mIGEgZm9sZGVyLi4uXCIpO1xuICB9XG4gIGdldEl0ZW1zKCkgeyByZXR1cm4gdGhpcy5mb2xkZXJzOyB9XG4gIGdldEl0ZW1UZXh0KGl0ZW0pIHsgcmV0dXJuIGl0ZW07IH1cbiAgb25DaG9vc2VJdGVtKGZvbGRlcikgeyB0aGlzLmVudi5jaGF0X3VpLmluc2VydF9zZWxlY3Rpb24oZm9sZGVyICsgXCIvIFwiKTsgfVxufVxuY2xhc3MgU2NTeXN0ZW1Qcm9tcHRTZWxlY3RNb2RhbCBleHRlbmRzIEZ1enp5U3VnZ2VzdE1vZGFsIHtcbiAgY29uc3RydWN0b3IoYXBwLCBlbnYpIHtcbiAgICBzdXBlcihhcHApO1xuICAgIHRoaXMuYXBwID0gYXBwO1xuICAgIHRoaXMuZW52ID0gZW52O1xuICAgIHRoaXMuc2V0UGxhY2Vob2xkZXIoXCJUeXBlIHRoZSBuYW1lIG9mIGEgc3lzdGVtIHByb21wdC4uLlwiKTtcbiAgfVxuICAvLyBnZXRJdGVtcygpIHsgcmV0dXJuIHRoaXMuZW52LnN5c3RlbV9wcm9tcHRzOyB9XG4gIGdldEl0ZW1zKCkgeyByZXR1cm4gdGhpcy5lbnYuc3lzdGVtX3Byb21wdHM7IH1cbiAgZ2V0SXRlbVRleHQoaXRlbSkgeyByZXR1cm4gaXRlbS5iYXNlbmFtZTsgfVxuICBvbkNob29zZUl0ZW0ocHJvbXB0KSB7IHRoaXMuZW52LmNoYXRfdWkuaW5zZXJ0X3NlbGVjdGlvbignXCInICsgcHJvbXB0LmJhc2VuYW1lICsgJ1wiJyk7IH1cbn0iLCAiLyoqXG4gKiBSZXByZXNlbnRzIGEgY2hhdCBzZXNzaW9uIHdpdGhpbiBhIFNtYXJ0Q2hhdCBlbnZpcm9ubWVudCwgaGFuZGxpbmcgdGhlIGNyZWF0aW9uLFxuICogbWFuaXB1bGF0aW9uLCBhbmQgc3RvcmFnZSBvZiBjaGF0IGRhdGEgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdCAoQ2hhdE1MKS5cbiAqIFxuICogQGNsYXNzXG4gKiBAcGFyYW0ge1NtYXJ0RW52fSBlbnYgLSBUaGUgU21hcnRDaGF0IGVudmlyb25tZW50IG9iamVjdCB3aGljaCBwcm92aWRlcyBjb250ZXh0IGFuZCB1dGlsaXRpZXMuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgY2hhdCBzZXNzaW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IFtkYXRhPScnXSAtIEluaXRpYWwgZGF0YSBmb3IgdGhlIGNoYXQgc2Vzc2lvbiwgdHlwaWNhbGx5IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuXG4gKi9cbmNsYXNzIFNtYXJ0Q2hhdCB7XG4gIGNvbnN0cnVjdG9yKGVudiwga2V5LCBkYXRhPScnKSB7XG4gICAgdGhpcy5lbnYgPSBlbnY7XG4gICAgdGhpcy5jaGF0cyA9IHRoaXMuZW52LmNoYXRzO1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5zY29wZSA9IHt9O1xuICAgIC8vIGV4cG9ydGVkIGZvciBjb252ZW5pZW5jZSAodW5uZWNlc3Nhcnk/Pz8gbWF5IGxvYWQgdGhlIGNoYXRzIGRpcmVjdGx5KVxuICAgIGlmKHRoaXMuY2hhdHMpIHRoaXMuY2hhdHMuaXRlbXNbdGhpcy5rZXldID0gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgU21hcnRDaGF0IGluc3RhbmNlIHdpdGggYSB1bmlxdWUga2V5IG9yIGEgZGVmYXVsdCBvbmUuXG4gICAqIFxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7U21hcnRFbnZ9IGVudiAtIFRoZSBTbWFydENoYXQgZW52aXJvbm1lbnQgb2JqZWN0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2tleT1udWxsXSAtIE9wdGlvbmFsIGtleSBmb3IgdGhlIGNoYXQgc2Vzc2lvbi4gSWYgbm90IHByb3ZpZGVkLCBhIGRlZmF1bHQgaXMgZ2VuZXJhdGVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2RhdGE9JyddIC0gSW5pdGlhbCBkYXRhIGZvciB0aGUgY2hhdCBzZXNzaW9uLlxuICAgKiBAcmV0dXJucyB7U21hcnRDaGF0fSBBIG5ldyBpbnN0YW5jZSBvZiBTbWFydENoYXQuXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlKGVudiwga2V5PW51bGwsIGRhdGE9JycpIHtcbiAgICBpZigha2V5KSBrZXkgPSAnVU5USVRMRUQgQ0hBVCAnICsgZ2V0X2ZpbGVfZGF0ZV9zdHJpbmcoKTtcbiAgICBjb25zdCBjaGF0ID0gbmV3IHRoaXMoZW52LCBrZXksIGRhdGEpO1xuICAgIHJldHVybiBjaGF0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBmaWxlIHBhdGggZm9yIHRoZSBjdXJyZW50IGNoYXQgc2Vzc2lvbiBiYXNlZCBvbiBpdHMga2V5IGFuZCBmaWxlIHR5cGUuXG4gICAqIFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZmlsZSBwYXRoIGZvciB0aGUgY2hhdCBzZXNzaW9uLlxuICAgKi9cbiAgZ2V0IGZpbGVfcGF0aCgpIHsgcmV0dXJuIGAke3RoaXMuY2hhdHMuZm9sZGVyfS8ke3RoaXMua2V5fS4ke3RoaXMuZmlsZV90eXBlfWA7IH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbmFtZSAoa2V5KSBvZiB0aGUgY2hhdCBzZXNzaW9uLlxuICAgKiBcbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGtleSBvZiB0aGUgY2hhdCBzZXNzaW9uLlxuICAgKi9cbiAgZ2V0IG5hbWUoKSB7IHJldHVybiB0aGlzLmtleTsgfVxuXG4gIC8qKlxuICAgKiBSZW5hbWVzIHRoZSBjdXJyZW50IGNoYXQgc2Vzc2lvbiBhbmQgdXBkYXRlcyB0aGUgc3RvcmFnZSByZWZlcmVuY2VzLlxuICAgKiBcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5ld19pZCAtIFRoZSBuZXcgaWRlbnRpZmllciBmb3IgdGhlIGNoYXQgc2Vzc2lvbi5cbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBhc3luYyByZW5hbWUobmV3X2lkKSB7XG4gICAgLy8gY29uc29sZS5sb2coJ3JlbmFtaW5nJywgdGhpcy5rZXksIG5ld19pZCk7XG4gICAgaWYgKHRoaXMua2V5ID09PSBuZXdfaWQpIHJldHVybjtcbiAgICBpZihhd2FpdCB0aGlzLmV4aXN0cygpKSBhd2FpdCB0aGlzLmRlbGV0ZSgpO1xuICAgIGRlbGV0ZSB0aGlzLmNoYXRzLml0ZW1zW3RoaXMua2V5XTtcbiAgICB0aGlzLmtleSA9IG5ld19pZDtcbiAgICB0aGlzLmNoYXRzLml0ZW1zW3RoaXMua2V5XSA9IHRoaXM7XG4gICAgYXdhaXQgdGhpcy5zYXZlKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGFsbCBtZXNzYWdlcyBmcm9tIHRoZSBjaGF0IHNlc3Npb24gYW5kIGNvbnZlcnRzIHRoZW0gdG8gSFRNTCBmb3JtYXQuXG4gICAqIFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBBIHN0cmluZyBjb250YWluaW5nIGFsbCBtZXNzYWdlcyBpbiBIVE1MIGZvcm1hdC5cbiAgICovXG4gIGFzeW5jIGdldF9tZXNzYWdlc19odG1sKCl7XG4gICAgY29uc3QgbWVzc2FnZXMgPSBhd2FpdCB0aGlzLmdldF9tZXNzYWdlcygpO1xuICAgIGNvbnN0IGh0bWwgPSBhd2FpdCBQcm9taXNlLmFsbChtZXNzYWdlcy5tYXAoYXN5bmMgbXNnID0+IHtcbiAgICAgIGlmKCFtc2cuY29udGVudCkgcmV0dXJuICcnO1xuICAgICAgaWYobXNnLnJvbGUgPT09ICdzeXN0ZW0nKSByZXR1cm4gYXdhaXQgdGhpcy5lbnYuY2hhdF91aS5nZXRfc3lzdGVtX21lc3NhZ2VfaHRtbChtc2cpO1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZW52LmNoYXRfdWkuZ2V0X21lc3NhZ2VfaHRtbChtc2cucm9sZSwgbXNnLmNvbnRlbnQpO1xuICAgIH0pKTtcbiAgICByZXR1cm4gaHRtbC5qb2luKCcnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgbmV3IG1lc3NhZ2UgdG8gdGhlIGNoYXQgc2Vzc2lvbi5cbiAgICogXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbbXNnPXt9XSAtIFRoZSBtZXNzYWdlIG9iamVjdCB0byBhZGQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgYXN5bmMgYWRkX21lc3NhZ2UobXNnPXt9KXtcbiAgICBjb25zdCBjaGF0X21sID0gYXdhaXQgdGhpcy5nZXRfY2hhdF9tbCgpO1xuICAgIGNoYXRfbWwubWVzc2FnZXMucHVzaChtc2cpO1xuICAgIGF3YWl0IHRoaXMudXBkYXRlKGNoYXRfbWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgb3V0cHV0IGZyb20gYSB0b29sIHRvIHRoZSBjaGF0IHNlc3Npb24gYXMgYSBtZXNzYWdlLlxuICAgKiBcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvb2xfbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSB0b29sLlxuICAgKiBAcGFyYW0geyp9IHRvb2xfb3V0cHV0IC0gVGhlIG91dHB1dCBmcm9tIHRoZSB0b29sLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIGFzeW5jIGFkZF90b29sX291dHB1dCh0b29sX25hbWUsIHRvb2xfb3V0cHV0KXtcbiAgICBpZih0eXBlb2YgdGhpcy5lbnYuYWN0aW9ucy5wYXJzZV90b29sX291dHB1dCA9PT0gJ2Z1bmN0aW9uJyl7XG4gICAgICBjb25zdCBtZXNzYWdlID0gYXdhaXQgdGhpcy5lbnYuYWN0aW9ucy5wYXJzZV90b29sX291dHB1dCh0b29sX25hbWUsIHRvb2xfb3V0cHV0KTtcbiAgICAgIGlmKG1lc3NhZ2UpIHJldHVybiBhd2FpdCB0aGlzLmFkZF9tZXNzYWdlKG1lc3NhZ2UpO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLmFkZF9tZXNzYWdlKHtyb2xlOiAndG9vbCcsIHRvb2xfY2FsbF9pZDogdG9vbF9uYW1lLCBjb250ZW50OiBKU09OLnN0cmluZ2lmeSh0b29sX291dHB1dCl9KTtcbiAgfVxuXG4gIC8vIGZpbGUtdHlwZSBzcGVjaWZpYyBwYXJzaW5nIGFuZCBmb3JtYXR0aW5nIG92ZXJyaWRlc1xuICAvKipcbiAgICogVXBkYXRlcyB0aGUgY2hhdCBzZXNzaW9uIGRhdGEgd2l0aCB0aGUgcHJvdmlkZWQgQ2hhdE1MIG9iamVjdCBhbmQgc2F2ZXMgaXQuXG4gICAqIFxuICAgKiBAcGFyYW0ge09iamVjdH0gY2hhdF9tbCAtIFRoZSBDaGF0TUwgb2JqZWN0IHRvIHVwZGF0ZSB0aGUgc2Vzc2lvbiB3aXRoLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIGFzeW5jIHVwZGF0ZShjaGF0X21sKXtcbiAgICB0aGlzLmRhdGEgPSB0aGlzLmZyb21fY2hhdG1sKGNoYXRfbWwpO1xuICAgIGF3YWl0IHRoaXMuc2F2ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNhdmVzIHRoZSBjdXJyZW50IGNoYXQgc2Vzc2lvbiBkYXRhIHRvIHRoZSBmaWxlIHN5c3RlbS5cbiAgICogXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgYXN5bmMgc2F2ZSgpIHsgcmV0dXJuIGF3YWl0IHRoaXMuY2hhdHMuc2F2ZSh0aGlzLmZpbGVfcGF0aCwgdGhpcy5kYXRhKTsgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIHRoZSBjaGF0IHNlc3Npb24gZmlsZSBmcm9tIHRoZSBmaWxlIHN5c3RlbS5cbiAgICogXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgYXN5bmMgZGVsZXRlKCkgeyByZXR1cm4gYXdhaXQgdGhpcy5jaGF0cy5kZWxldGUodGhpcy5maWxlX3BhdGgpOyB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgY2hhdCBzZXNzaW9uIGZpbGUgZXhpc3RzIGluIHRoZSBmaWxlIHN5c3RlbS5cbiAgICogXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSBUcnVlIGlmIHRoZSBmaWxlIGV4aXN0cywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgYXN5bmMgZXhpc3RzKCkgeyByZXR1cm4gYXdhaXQgdGhpcy5jaGF0cy5leGlzdHModGhpcy5maWxlX3BhdGgpOyB9XG5cbiAgLyoqXG4gICAqIExvYWRzIHRoZSBjaGF0IHNlc3Npb24gZGF0YSBmcm9tIHRoZSBmaWxlIHN5c3RlbS5cbiAgICogXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IFRoZSBsb2FkZWQgZGF0YS5cbiAgICovXG4gIGFzeW5jIGxvYWQoKSB7XG4gICAgaWYoIWF3YWl0IHRoaXMuZXhpc3RzKCkpIHJldHVybiB0aGlzLmRhdGEgPSAnJztcbiAgICByZXR1cm4gdGhpcy5kYXRhID0gYXdhaXQgdGhpcy5jaGF0cy5yZWFkKHRoaXMuZmlsZV9wYXRoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIENoYXRNTCBvYmplY3QgZnJvbSB0aGUgY3VycmVudCBzZXNzaW9uIGRhdGEuXG4gICAqIFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBUaGUgQ2hhdE1MIG9iamVjdC5cbiAgICovXG4gIGFzeW5jIGdldF9jaGF0X21sKCkge1xuICAgIGF3YWl0IHRoaXMubG9hZCgpO1xuICAgIGNvbnN0IGNoYXRfbWwgPSB0aGlzLnRvX2NoYXRtbCh0aGlzLmRhdGEpO1xuICAgIHJldHVybiBjaGF0X21sO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhbGwgbWVzc2FnZXMgZnJvbSB0aGUgQ2hhdE1MIG9iamVjdCBvZiB0aGUgY3VycmVudCBzZXNzaW9uLlxuICAgKiBcbiAgICogQHJldHVybnMge1Byb21pc2U8QXJyYXk+fSBBbiBhcnJheSBvZiBtZXNzYWdlIG9iamVjdHMuXG4gICAqL1xuICBhc3luYyBnZXRfbWVzc2FnZXMoKSB7IHJldHVybiAoYXdhaXQgdGhpcy5nZXRfY2hhdF9tbCgpKS5tZXNzYWdlczsgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzZXMgYSBuZXcgdXNlciBtZXNzYWdlLCB1cGRhdGVzIFVJL1VYLCBhbmQgYWRkcyBpdCB0byB0aGUgY2hhdCBzZXNzaW9uLlxuICAgKiBcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnQgLSBUaGUgY29udGVudCBvZiB0aGUgdXNlciBtZXNzYWdlLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIGFzeW5jIG5ld191c2VyX21lc3NhZ2UoY29udGVudCl7XG4gICAgY29udGVudCA9IGF3YWl0IHRoaXMucGFyc2VfdXNlcl9tZXNzYWdlKGNvbnRlbnQpO1xuICAgIGlmKHR5cGVvZiB0aGlzLmVudj8uY2hhdF91aT8ubmV3X3VzZXJfbWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJykgYXdhaXQgdGhpcy5lbnYuY2hhdF91aS5uZXdfdXNlcl9tZXNzYWdlKGNvbnRlbnQpOyAvLyBVSS9VWFxuICAgIGlmKHR5cGVvZiB0aGlzLmVudj8uYWN0aW9ucz8ubmV3X3VzZXJfbWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJykgYXdhaXQgdGhpcy5lbnYuYWN0aW9ucy5uZXdfdXNlcl9tZXNzYWdlKGNvbnRlbnQpOyAvLyBjb250ZXh0LXJldHJpZXZhbCAoYWRkcyBwcmVjZWRpbmcgc3lzdGVtIG1lc3NhZ2UgaWYgbmVjZXNzYXJ5KVxuICAgIGlmKHR5cGVvZiB0aGlzLmNoYXRzPy5uZXdfdXNlcl9tZXNzYWdlID09PSAnZnVuY3Rpb24nKSBhd2FpdCB0aGlzLmNoYXRzLm5ld191c2VyX21lc3NhZ2UoY29udGVudCk7IC8vIGFkZCBhZGRpdGlvbmFsIGxvZ2ljIGhlcmUgKGNoYXQtZm9ybWF0LWFnbm9zdGljKVxuICAgIGF3YWl0IHRoaXMuYWRkX21lc3NhZ2Uoe3JvbGU6ICd1c2VyJywgY29udGVudH0pO1xuICAgIGF3YWl0IHRoaXMuZW52LmNoYXRfbW9kZWwuY29tcGxldGUoe30pO1xuICB9XG5cbiAgLy8gT3ZlcnJpZGUgdGhlc2UgZm9yIGZpbGUtdHlwZSBzcGVjaWZpYyBwYXJzaW5nIGFuZCBmb3JtYXR0aW5nIGluIHN1YmNsYXNzZXNcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpbGUgdHlwZSBmb3IgdGhlIGNoYXQgc2Vzc2lvbiwgdXNlZCBpbiBmaWxlIG9wZXJhdGlvbnMuXG4gICAqIFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZmlsZSB0eXBlLCBkZWZhdWx0IGlzICdqc29uJy5cbiAgICovXG4gIGdldCBmaWxlX3R5cGUoKSB7IHJldHVybiAnanNvbic7IH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhlIHByb3ZpZGVkIGRhdGEgaW50byBhIENoYXRNTCBvYmplY3QuIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBvdmVycmlkZGVuIGluIHN1YmNsYXNzZXMuXG4gICAqIFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YSAtIFRoZSBkYXRhIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBDaGF0TUwgb2JqZWN0LlxuICAgKi9cbiAgdG9fY2hhdG1sKGRhdGEpIHsgcmV0dXJuIGRhdGE7IH1cblxuICAvKipcbiAgICogQ29udmVydHMgYSBDaGF0TUwgb2JqZWN0IGJhY2sgaW50byBhIHN0cmluZyBvciBzdWl0YWJsZSBmb3JtYXQgZm9yIHN0b3JhZ2UuIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBvdmVycmlkZGVuIGluIHN1YmNsYXNzZXMuXG4gICAqIFxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIFRoZSBDaGF0TUwgb2JqZWN0IHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBzdHJpbmcgb3IgZm9ybWF0dGVkIGRhdGEuXG4gICAqL1xuICBmcm9tX2NoYXRtbChkYXRhKSB7IHJldHVybiBkYXRhOyB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyB0aGUgdXNlciBtZXNzYWdlIGNvbnRlbnQgYmVmb3JlIGFkZGluZyBpdCB0byB0aGUgY2hhdC4gVGhpcyBtZXRob2QgY2FuIGJlIG92ZXJyaWRkZW4gdG8gaW5jbHVkZSBjdXN0b20gcGFyc2luZyBsb2dpYy5cbiAgICogXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50IC0gVGhlIGNvbnRlbnQgdG8gcGFyc2UuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IFRoZSBwYXJzZWQgY29udGVudC5cbiAgICovXG4gIGFzeW5jIHBhcnNlX3VzZXJfbWVzc2FnZShjb250ZW50KSB7IHJldHVybiBjb250ZW50OyB9XG59XG5mdW5jdGlvbiBnZXRfZmlsZV9kYXRlX3N0cmluZygpIHsgcmV0dXJuIG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5yZXBsYWNlKC8oVHw6fFxcLi4qKS9nLCBcIiBcIikudHJpbSgpOyB9XG5leHBvcnRzLlNtYXJ0Q2hhdCA9IFNtYXJ0Q2hhdDsiLCAiY29uc3QgeyBtZXNzYWdlX2NvbnRlbnRfYXJyYXlfdG9fbWFya2Rvd24gfSA9IHJlcXVpcmUoXCIuL21lc3NhZ2VfY29udGVudF9hcnJheV90b19tYXJrZG93blwiKTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgQ2hhdE1MIG9iamVjdCB0byBhIG1hcmtkb3duIHN0cmluZ1xuICogQHBhcmFtIHtPYmplY3R9IGNoYXRfbWwgLSBUaGUgQ2hhdE1MIG9iamVjdFxuICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gY29udmVydHMgYSBDaGF0TUwgb2JqZWN0IHRvIGEgbWFya2Rvd24gc3RyaW5nLiBJdCBjb252ZXJ0cyB0b29sIGNhbGxzIHRvIG1hcmtkb3duIGNvZGUgYmxvY2tzLlxuICogQHJldHVybnMge3N0cmluZ30gLSBUaGUgbWFya2Rvd24gc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGNoYXRfbWxfdG9fbWFya2Rvd24oY2hhdF9tbCkge1xuICBjb25zb2xlLmxvZygnY2hhdF9tbCcpO1xuICBjb25zb2xlLmxvZyhjaGF0X21sKTtcbiAgbGV0IG1hcmtkb3duID0gJyc7XG4gIGxldCBoYXNfbWQgPSBmYWxzZTtcbiAgY2hhdF9tbC5tZXNzYWdlcy5mb3JFYWNoKG1zZyA9PiB7XG4gICAgaWYgKG1zZy5yb2xlICYmIG1zZy5jb250ZW50KSB7XG4gICAgICBpZihtYXJrZG93bi5sZW5ndGggPiAwKSBtYXJrZG93biArPSAnXFxuXFxuJztcbiAgICAgIG1hcmtkb3duICs9IGAjIyMjIyAke21zZy5yb2xlfVxcbmA7XG4gICAgICBpZiAobXNnLnJvbGUgPT09ICd0b29sJykge1xuICAgICAgICBjb25zb2xlLmxvZyhtc2cpO1xuICAgICAgICBtYXJrZG93biArPSBcImBgYFwiO1xuICAgICAgICBpZiAobXNnLnRvb2xfY2FsbF9pZCkgbWFya2Rvd24gKz0gYCR7bXNnLnRvb2xfY2FsbF9pZH1cXG5gO1xuICAgICAgICBpZiAobXNnLmNvbnRlbnQpIG1hcmtkb3duICs9IGAke21zZy5jb250ZW50fVxcbmA7XG4gICAgICAgIG1hcmtkb3duICs9IFwiYGBgXCI7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobXNnLmNvbnRlbnQpKSB7XG4gICAgICAgIG1hcmtkb3duICs9IG1lc3NhZ2VfY29udGVudF9hcnJheV90b19tYXJrZG93bihtc2cuY29udGVudCk7XG4gICAgICB9IGVsc2UgaWYgKG1zZy5jb250ZW50LmluZGV4T2YoJy0tLUJFR0lOIE5PVEUnKSA+IC0xKSB7XG4gICAgICAgIC8vIERPOiBpcyB0aGlzIG5vIGxvbmdlciBuZWNlc3Nhcnkgc2luY2Ugc2NfYWN0aW9ucy5wYXJzZV90b29sX291dHB1dCBpcyB1c2VkPyBcbiAgICAgICAgbWFya2Rvd24gKz0gXCJgYGBzYy1jb250ZXh0XCI7XG4gICAgICAgIC8vIHBhcnNlIGxpbmtzIGZyb20gbGluZXMgdGhhdCBzdGFydCB3aXRoIC0tLUJFR0lOIE5PVEVcbiAgICAgICAgY29uc3QgbGluZXMgPSBtc2cuY29udGVudC5zcGxpdCgnXFxuJykuZmlsdGVyKGxpbmUgPT4gbGluZS50cmltKCkubGVuZ3RoICYmIGxpbmUuc3RhcnRzV2l0aCgnLS0tQkVHSU4gTk9URScpICYmIGxpbmUuaW5kZXhPZignW1snKSA+IC0xKTtcbiAgICAgICAgbGluZXMuZm9yRWFjaCgobGluZSwgaSkgPT4ge1xuICAgICAgICAgIC8vIGJldHdlZW4gW1sgYW5kIF1dXG4gICAgICAgICAgY29uc3QgbGluayA9IGxpbmUuc3Vic3RyaW5nKGxpbmUuaW5kZXhPZignW1snKSArIDIsIGxpbmUuaW5kZXhPZignXV0nKSk7XG4gICAgICAgICAgaWYgKGkgPiAwKSBtYXJrZG93biArPSAnXFxuJztcbiAgICAgICAgICBpZiAobGluaykgbWFya2Rvd24gKz0gYCR7bGlua31gO1xuICAgICAgICB9KTtcbiAgICAgICAgbWFya2Rvd24gKz0gXCJcXG5gYGBcIjtcbiAgICAgIH0gZWxzZSBpZiAobXNnLmNvbnRlbnQuaW5kZXhPZignIycpID09PSAwIHx8IG1zZy5jb250ZW50LmluZGV4T2YoJ1xcbiMnKSA+IC0xKSB7IC8vIGNvbnRlbnQgaGFzIG1hcmtkb3duXG4gICAgICAgIG1hcmtkb3duICs9IFwiYGBgbWRcIjtcbiAgICAgICAgY29uc3QgY29udGVudCA9IG1zZy5jb250ZW50LnJlcGxhY2UoL1xcbltgXXszfS9nLCAnXFxuXFxcXGBgYCcpO1xuICAgICAgICBtYXJrZG93biArPSBgXFxuJHtjb250ZW50fWA7XG4gICAgICAgIG1hcmtkb3duICs9IFwiXFxuYGBgXCI7XG4gICAgICB9IGVsc2UgbWFya2Rvd24gKz0gYCR7bXNnLmNvbnRlbnR9YDtcbiAgICB9XG4gICAgaWYgKG1zZy50b29sX2NhbGxzKSB7XG4gICAgICBtc2cudG9vbF9jYWxscy5mb3JFYWNoKHRvb2xfY2FsbCA9PiB7XG4gICAgICAgIGlmKG1hcmtkb3duLmxlbmd0aCA+IDApIG1hcmtkb3duICs9ICdcXG5cXG4nO1xuICAgICAgICBtYXJrZG93biArPSBgIyMjIyMgYXNzaXN0YW50XFxuYDtcbiAgICAgICAgbWFya2Rvd24gKz0gYFxcYFxcYFxcYCR7dG9vbF9jYWxsPy5mdW5jdGlvbj8ubmFtZX1gO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG1hcmtkb3duICs9IGBcXG4ke0pTT04uc3RyaW5naWZ5KEpTT04ucGFyc2UodG9vbF9jYWxsPy5mdW5jdGlvbj8uYXJndW1lbnRzKSl9YDtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgbWFya2Rvd24gKz0gYFxcbiR7dG9vbF9jYWxsPy5mdW5jdGlvbj8uYXJndW1lbnRzfWA7XG4gICAgICAgIH1cbiAgICAgICAgbWFya2Rvd24gKz0gXCJcXG5gYGBcIjtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBtYXJrZG93bi50cmltKCk7XG59XG5leHBvcnRzLmNoYXRfbWxfdG9fbWFya2Rvd24gPSBjaGF0X21sX3RvX21hcmtkb3duOyIsICJmdW5jdGlvbiBhZGRfY29udGVudF90b19tZXNzYWdlKGN1cnJfbXNnLCBjb250ZW50KSB7XG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBjb250ZW50LnRyaW0oKTtcbiAgZWxzZSBjb250ZW50ID0gY29udGVudC5tYXAoYyA9PiBjLnR5cGUgPT09ICd0ZXh0JyA/IHsgdHlwZTogJ3RleHQnLCB0ZXh0OiBjLnRleHQudHJpbSgpIH0gOiBjKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY29udGVudCkpIHtcbiAgICBpZiAodHlwZW9mIGN1cnJfbXNnLmNvbnRlbnQgPT09ICdzdHJpbmcnKSBjdXJyX21zZy5jb250ZW50ID0gW3sgdHlwZTogJ3RleHQnLCB0ZXh0OiBjdXJyX21zZy5jb250ZW50IH1dO1xuICAgIGVsc2UgaWYgKHR5cGVvZiBjdXJyX21zZy5jb250ZW50ID09PSAndW5kZWZpbmVkJykgY3Vycl9tc2cuY29udGVudCA9IFtdO1xuICAgIGN1cnJfbXNnLmNvbnRlbnQucHVzaCguLi5jb250ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJyX21zZy5jb250ZW50KSkge1xuICAgICAgLy8gaWYgbGFzdCBjb250ZW50IGlzIHRleHQsIGFkZCB0aGUgY29udGVudCB0byB0aGUgZW5kIG9mIHRoZSB0ZXh0XG4gICAgICBpZiAoY3Vycl9tc2cuY29udGVudFtjdXJyX21zZy5jb250ZW50Lmxlbmd0aCAtIDFdLnR5cGUgPT09ICd0ZXh0JykgY3Vycl9tc2cuY29udGVudFtjdXJyX21zZy5jb250ZW50Lmxlbmd0aCAtIDFdLnRleHQgKz0gJ1xcbicgKyBjb250ZW50O1xuICAgICAgZWxzZSBjdXJyX21zZy5jb250ZW50LnB1c2goeyB0eXBlOiAndGV4dCcsIHRleHQ6IGNvbnRlbnQgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghY3Vycl9tc2cuY29udGVudCkgY3Vycl9tc2cuY29udGVudCA9ICcnO1xuICAgICAgZWxzZSBjdXJyX21zZy5jb250ZW50ICs9ICdcXG4nO1xuICAgICAgaWYgKGNvbnRlbnQuc3RhcnRzV2l0aCgnXFxcXGBgYCcpKSBjb250ZW50ID0gY29udGVudC5zdWJzdHJpbmcoMSk7XG4gICAgICBjdXJyX21zZy5jb250ZW50ICs9IGNvbnRlbnQ7XG4gICAgfVxuICB9XG59XG5leHBvcnRzLmFkZF9jb250ZW50X3RvX21lc3NhZ2UgPSBhZGRfY29udGVudF90b19tZXNzYWdlO1xuIiwgImNvbnN0IHsgYWRkX2NvbnRlbnRfdG9fbWVzc2FnZSB9ID0gcmVxdWlyZShcIi4vYWRkX2NvbnRlbnRfdG9fbWVzc2FnZVwiKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIG1hcmtkb3duIHN0cmluZyB0byBhIENoYXRNTCBvYmplY3QuIEl0IGNvbnZlcnRzIG1hcmtkb3duIGNvZGUgYmxvY2tzIHRvIHRvb2wgY2FsbHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya2Rvd24gLSBUaGUgbWFya2Rvd24gc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgQ2hhdE1MIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIG1hcmtkb3duLlxuICovXG5mdW5jdGlvbiBtYXJrZG93bl90b19jaGF0X21sKG1hcmtkb3duKSB7XG4gIGNvbnN0IGxpbmVzID0gbWFya2Rvd24uc3BsaXQoJ1xcbicpO1xuICBjb25zdCBjaGF0X21sID0geyBtZXNzYWdlczogW10gfTtcbiAgbGV0IGN1cnJlbnRfcm9sZSA9ICcnO1xuICBsZXQgdG9vbF9uYW1lID0gbnVsbDtcbiAgbGV0IGN1cnJfbXNnID0gbnVsbDtcbiAgbGV0IGlzX2NvZGVfYmxvY2sgPSBmYWxzZTtcbiAgbGluZXMuZm9yRWFjaChsaW5lID0+IHtcbiAgICBpZiAodG9vbF9uYW1lICYmIGN1cnJfbXNnLnJvbGUgPT09IFwidG9vbFwiKSBjdXJyX21zZy50b29sX2NhbGxfaWQgPSB0b29sX25hbWU7XG4gICAgaWYgKGxpbmUuc3RhcnRzV2l0aCgnIyMjIyMgJykgJiYgIWlzX2NvZGVfYmxvY2spIHtcbiAgICAgIHRvb2xfbmFtZSA9IG51bGw7XG4gICAgICBpZiAoY3Vycl9tc2cpIGNoYXRfbWwubWVzc2FnZXMucHVzaCh7IC4uLmN1cnJfbXNnIH0pO1xuICAgICAgY3VycmVudF9yb2xlID0gbGluZS5zdWJzdHJpbmcoNikudHJpbSgpO1xuICAgICAgY3Vycl9tc2cgPSB7XG4gICAgICAgIHJvbGU6IGN1cnJlbnRfcm9sZSxcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChsaW5lLnN0YXJ0c1dpdGgoJ2BgYCcpKSB7XG4gICAgICBpc19jb2RlX2Jsb2NrID0gIWlzX2NvZGVfYmxvY2s7XG4gICAgICBpZiAobGluZS50cmltKCkubGVuZ3RoID4gNSAmJiBsaW5lLnRyaW0oKS5pbmRleE9mKCcgJykgPCAwKSB7XG4gICAgICAgIHRvb2xfbmFtZSA9IGxpbmUuc3Vic3RyaW5nKDMpLnRyaW0oKTtcbiAgICAgICAgLy8gcmV0dXJuIGVhcmx5IGlmIHRvb2xfbmFtZSBpcyBub3QgYSB2YWxpZCB0b29sXG4gICAgICAgIGlmICh0b29sX25hbWUgPT09ICdtZCcpIHJldHVybjtcbiAgICAgICAgaWYgKFsnanMnLCAnamF2YXNjcmlwdCcsICdkYXRhdmlldyddLmluY2x1ZGVzKHRvb2xfbmFtZSkpIHJldHVybiBhZGRfY29udGVudF90b19tZXNzYWdlKGN1cnJfbXNnLCBsaW5lKTtcbiAgICAgICAgaWYgKFsnc2MtY29udGV4dCcsICdzYy1zeXN0ZW0nXS5pbmNsdWRlcyh0b29sX25hbWUpKSByZXR1cm4gYWRkX2NvbnRlbnRfdG9fbWVzc2FnZShjdXJyX21zZywgbGluZSk7XG4gICAgICAgIGlmIChjdXJyX21zZy5yb2xlID09PSAndG9vbCcpIHJldHVybjtcbiAgICAgICAgLy8gYWRkIHRvb2wgY2FsbCB0byBjdXJyZW50IG1lc3NhZ2VcbiAgICAgICAgaWYgKCFjdXJyX21zZy50b29sX2NhbGxzKSBjdXJyX21zZy50b29sX2NhbGxzID0gW107XG4gICAgICAgIGN1cnJfbXNnLnRvb2xfY2FsbHMucHVzaCh7XG4gICAgICAgICAgaWQ6IHRvb2xfbmFtZSxcbiAgICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgICAgICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgICAgICBuYW1lOiB0b29sX25hbWUsXG4gICAgICAgICAgICBhcmd1bWVudHM6ICcnXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoWydzYy1jb250ZXh0JywgJ3NjLXN5c3RlbScsICdtZCcsICdqYXZhc2NyaXB0JywgJ2pzJywgJ2RhdGF2aWV3J10uaW5jbHVkZXModG9vbF9uYW1lKSkge1xuICAgICAgICBhZGRfY29udGVudF90b19tZXNzYWdlKGN1cnJfbXNnLCBsaW5lKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKChsaW5lLnRyaW0oKSAhPT0gJycpICYmIGN1cnJfbXNnKSB7XG4gICAgICBpZiAodG9vbF9uYW1lICYmIGN1cnJfbXNnLnRvb2xfY2FsbHMpIGN1cnJfbXNnLnRvb2xfY2FsbHNbY3Vycl9tc2cudG9vbF9jYWxscy5sZW5ndGggLSAxXS5mdW5jdGlvbi5hcmd1bWVudHMgKz0gbGluZTtcbiAgICAgIGVsc2UgaWYgKGxpbmUubWF0Y2goLyFcXFsuKj9cXF1cXCgoLio/KVxcKS8pKSB7XG4gICAgICAgIC8vIEV4dHJhY3QgaW1hZ2UgVVJMcyBhbmQgZGVzY3JpcHRpb25zIGZyb20gbWFya2Rvd24gaW1hZ2Ugc3ludGF4XG4gICAgICAgIGNvbnN0IGltYWdlX21hdGNoZXMgPSBsaW5lLm1hdGNoQWxsKC9eIVxcWyg/PGNhcHRpb24+W15cXF1dKj8pXFxdXFwoKD88aW1hZ2VVcmw+W15cXCldKj8pXFwpL2cpO1xuICAgICAgICBjb25zdCBjb250ZW50ID0gW107XG4gICAgICAgIGZvciAoY29uc3QgbWF0Y2ggb2YgaW1hZ2VfbWF0Y2hlcykge1xuICAgICAgICAgIGNvbnN0IGNhcHRpb24gPSBtYXRjaC5ncm91cHMuY2FwdGlvbiB8fCBtYXRjaC5ncm91cHMub2JzaWRpYW5DYXB0aW9uO1xuICAgICAgICAgIGNvbnN0IGltYWdlVXJsID0gbWF0Y2guZ3JvdXBzLmltYWdlVXJsIHx8IG1hdGNoLmdyb3Vwcy5vYnNpZGlhbkxpbms7XG4gICAgICAgICAgY29udGVudC5wdXNoKHsgdHlwZTogJ2ltYWdlX3VybCcsIGltYWdlX3VybDogeyB1cmw6IGltYWdlVXJsIH0gfSk7XG4gICAgICAgICAgaWYgKGNhcHRpb24pIGNvbnRlbnQucHVzaCh7IHR5cGU6ICd0ZXh0JywgdGV4dDogYEltYWdlIGNhcHRpb246ICR7Y2FwdGlvbn1gIH0pO1xuICAgICAgICB9XG4gICAgICAgIGFkZF9jb250ZW50X3RvX21lc3NhZ2UoY3Vycl9tc2csIGNvbnRlbnQpO1xuICAgICAgfVxuICAgICAgZWxzZSBhZGRfY29udGVudF90b19tZXNzYWdlKGN1cnJfbXNnLCBsaW5lKTtcbiAgICB9XG4gIH0pO1xuICBpZiAoY3Vycl9tc2cpIGNoYXRfbWwubWVzc2FnZXMucHVzaCh7IC4uLmN1cnJfbXNnIH0pO1xuICByZXR1cm4gY2hhdF9tbDtcbn1cbmV4cG9ydHMubWFya2Rvd25fdG9fY2hhdF9tbCA9IG1hcmtkb3duX3RvX2NoYXRfbWw7IiwgImNvbnN0IHsgU21hcnRDaGF0IH0gPSByZXF1aXJlKFwiLi9zbWFydF9jaGF0XCIpO1xuY29uc3QgeyBjaGF0X21sX3RvX21hcmtkb3duIH0gPSByZXF1aXJlKFwiLi91dGlscy9jaGF0X21sX3RvX21hcmtkb3duXCIpO1xuY29uc3QgeyBtYXJrZG93bl90b19jaGF0X21sIH0gPSByZXF1aXJlKFwiLi91dGlscy9tYXJrZG93bl90b19jaGF0X21sXCIpO1xuXG4vKipcbiAqIEV4dGVuZHMgU21hcnRDaGF0IHRvIGhhbmRsZSBtYXJrZG93bi1zcGVjaWZpYyBmdW5jdGlvbmFsaXRpZXMuXG4gKi9cbmNsYXNzIFNtYXJ0Q2hhdE1EIGV4dGVuZHMgU21hcnRDaGF0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpbGUgdHlwZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBjbGFzcy5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGZpbGUgdHlwZSwgd2hpY2ggaXMgJ21kJyBmb3IgbWFya2Rvd24uXG4gICAqL1xuICBnZXQgZmlsZV90eXBlKCkgeyByZXR1cm4gJ21kJzsgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBpbnRlcm5hbCBkYXRhIHdpdGggdGhlIHByb3ZpZGVkIENoYXRNTCBhbmQgc2F2ZXMgaXQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjaGF0X21sIC0gVGhlIENoYXRNTCBvYmplY3QgdG8gdXBkYXRlIHRoZSBkYXRhIHdpdGguXG4gICAqL1xuICBhc3luYyB1cGRhdGUoY2hhdF9tbCl7XG4gICAgdGhpcy5kYXRhID0gdGhpcy5mcm9tX2NoYXRtbChjaGF0X21sKTtcbiAgICBhd2FpdCB0aGlzLnNhdmUoKTtcbiAgfVxuXG4gIC8vIGZpbGUtdHlwZSBzcGVjaWZpYyBwYXJzaW5nIGFuZCBmb3JtYXR0aW5nIG92ZXJyaWRlc1xuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBDaGF0TUwgcmVwcmVzZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgZGF0YS5cbiAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gVGhlIENoYXRNTCBvYmplY3QuXG4gICAqL1xuICBhc3luYyBnZXRfY2hhdF9tbCgpIHtcbiAgICBhd2FpdCB0aGlzLmxvYWQoKTtcbiAgICBjb25zdCBjaGF0X21sID0gdGhpcy50b19jaGF0bWwodGhpcy5kYXRhKTtcbiAgICByZXR1cm4gY2hhdF9tbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBtYXJrZG93biB0ZXh0IHRvIGEgQ2hhdE1MIG9iamVjdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmtkb3duIC0gVGhlIG1hcmtkb3duIHN0cmluZyB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgY29udmVydGVkIENoYXRNTCBvYmplY3QuXG4gICAqL1xuICB0b19jaGF0bWwobWFya2Rvd24pIHsgcmV0dXJuIG1hcmtkb3duX3RvX2NoYXRfbWwobWFya2Rvd24pOyB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgQ2hhdE1MIG9iamVjdCB0byBtYXJrZG93biB0ZXh0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gY2hhdG1sIC0gVGhlIENoYXRNTCBvYmplY3QgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbnZlcnRlZCBtYXJrZG93biBzdHJpbmcuXG4gICAqL1xuICBmcm9tX2NoYXRtbChjaGF0bWwpIHsgcmV0dXJuIGNoYXRfbWxfdG9fbWFya2Rvd24oY2hhdG1sKTsgfVxuXG59XG5cbmV4cG9ydHMuU21hcnRDaGF0TUQgPSBTbWFydENoYXRNRDtcbmV4cG9ydHMuY2hhdF9tbF90b19tYXJrZG93biA9IGNoYXRfbWxfdG9fbWFya2Rvd247XG5leHBvcnRzLm1hcmtkb3duX3RvX2NoYXRfbWwgPSBtYXJrZG93bl90b19jaGF0X21sOyIsICIvLyBDb3B5cmlnaHQgKGMpIEJyaWFuIEpvc2VwaCBQZXRyb1xuXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbi8vIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbi8vIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xuLy8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuLy8gaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4vLyBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4vLyBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFXG4vLyBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OXG4vLyBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cbi8vIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5jb25zdCB7IFNtYXJ0Q2hhdE1EIH0gPSByZXF1aXJlKFwiLi9zbWFydF9jaGF0X21kXCIpO1xuY29uc3QgeyBTbWFydENoYXQgfSA9IHJlcXVpcmUoXCIuL3NtYXJ0X2NoYXRcIik7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgbWFuYWdlciBmb3Igc21hcnQgY2hhdCBjb252ZXJzYXRpb25zLlxuICogSXQgaGFuZGxlcyB0aGUgY3JlYXRpb24sIGxvYWRpbmcsIHNhdmluZywgYW5kIG1hbmFnZW1lbnQgb2YgY2hhdCBjb252ZXJzYXRpb25zIGluIHZhcmlvdXMgZm9ybWF0cy5cbiAqL1xuY2xhc3MgU21hcnRDaGF0cyB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFNtYXJ0Q2hhdHMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnYgLSBUaGUgZW52aXJvbm1lbnQgY29udGV4dCwgdXNlZCBhY3Jvc3MgdGhlIGNoYXQgc3lzdGVtLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHM9e31dIC0gT3B0aW9uYWwgcGFyYW1ldGVycyB0byBjb25maWd1cmUgdGhlIFNtYXJ0Q2hhdHMgaW5zdGFuY2UuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbnYsIG9wdHM9e30pIHtcbiAgICB0aGlzLmVudiA9IGVudjtcbiAgICB0aGlzLmZvbGRlciA9ICdzbWFydC1jaGF0cyc7XG4gICAgdGhpcy5pdGVtcyA9IHt9O1xuICAgIHRoaXMuZm9ybWF0cyA9IHtcbiAgICAgIG1kOiBTbWFydENoYXRNRCxcbiAgICAgIGpzb246IFNtYXJ0Q2hhdCxcbiAgICB9O1xuICAgIHRoaXMuZGVmYXVsdF9maWxlX3R5cGUgPSAnbWQnO1xuICAgIC8vIG1lcmdlIG9wdHMgaW50byB0aGlzXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGNoYXQgaW5zdGFuY2UgYW5kIGluaXRpYWxpemVzIHRoZSBjaGF0IFVJLlxuICAgKi9cbiAgYXN5bmMgbmV3KCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnQpIHtcbiAgICAgIGF3YWl0IHRoaXMuY3VycmVudC5zYXZlKCk7XG4gICAgICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLmZpbGVfZm9ybWF0LmNyZWF0ZSh0aGlzLmVudik7XG4gICAgY29uc29sZS5sb2codGhpcy5jdXJyZW50KTtcbiAgICBhd2FpdCB0aGlzLmVudi5jaGF0X3VpLmluaXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkcyBhbGwgY29udmVyc2F0aW9ucyBmcm9tIHRoZSBmaWxlc3lzdGVtIGFuZCBpbml0aWFsaXplcyB0aGVtLlxuICAgKi9cbiAgYXN5bmMgbG9hZF9hbGwoKSB7XG4gICAgaWYoIWF3YWl0IHRoaXMuZXhpc3RzKHRoaXMuZm9sZGVyKSkgYXdhaXQgdGhpcy5jcmVhdGVfZm9sZGVyKHRoaXMuZm9sZGVyKTtcbiAgICAvLyBsb2FkIGFsbCBjb252ZXJzYXRpb25zIGZyb20gZmlsZSBzeXN0ZW1cbiAgICBjb25zdCBjb252b3MgPSBhd2FpdCB0aGlzLmdldF9jb252ZXJzYXRpb25faWRzX2FuZF9maWxlX3R5cGVzKCk7XG4gICAgLy8gaW5pdGlhdGUgZWFjaCBhcyBzbWFydF9jb252ZXJzYXRpb24gaW5zdGFuY2VcbiAgICBjb252b3MuZm9yRWFjaCgoW2NvbnZlcnNhdGlvbl9pZCwgZmlsZV90eXBlXSkgPT4ge1xuICAgICAgaWYoIXRoaXMuZm9ybWF0c1tmaWxlX3R5cGVdKSBjb25zb2xlLmxvZygnVW5zdXBwb3J0ZWQgZmlsZSB0eXBlJywgW2NvbnZlcnNhdGlvbl9pZCwgZmlsZV90eXBlXSk7XG4gICAgICB0aGlzLml0ZW1zW2NvbnZlcnNhdGlvbl9pZF0gPSB0aGlzLmZvcm1hdHNbZmlsZV90eXBlXS5jcmVhdGUodGhpcy5lbnYsIGNvbnZlcnNhdGlvbl9pZCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2F2ZXMgYSBjaGF0IGNvbnZlcnNhdGlvbiBieSBpdHMga2V5LlxuICAgKiBJZiB0aGUgY2hhdCBkb2VzIG5vdCBleGlzdCwgaXQgY3JlYXRlcyBhIG5ldyBvbmUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IGlkZW50aWZpZXIgZm9yIHRoZSBjaGF0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhdF9tbCAtIFRoZSBjaGF0IGNvbnRlbnQgaW4gbWFya3VwIGxhbmd1YWdlLlxuICAgKi9cbiAgYXN5bmMgc2F2ZShrZXksIGNoYXRfbWwpIHtcbiAgICBsZXQgY2hhdCA9IHRoaXMuaXRlbXNba2V5XTtcbiAgICBpZighY2hhdCl7XG4gICAgICBjb25zb2xlLmxvZygnQ3JlYXRpbmcgbmV3IGNvbnZlcnNhdGlvbicpO1xuICAgICAgY2hhdCA9IHRoaXMuZmlsZV9mb3JtYXQuY3JlYXRlKHRoaXMuZW52LCBrZXksIGNoYXRfbWwpO1xuICAgIH1cbiAgICBhd2FpdCBjaGF0LnNhdmUoY2hhdF9tbCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgZmlsZSBmb3JtYXQgYmFzZWQgb24gdGhlIGRlZmF1bHQgZmlsZSB0eXBlLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgY2hhdCBmb3JtYXQgY2xhc3MuXG4gICAqL1xuICBnZXQgZmlsZV9mb3JtYXQoKSB7IHJldHVybiB0aGlzLmZvcm1hdHNbdGhpcy5kZWZhdWx0X2ZpbGVfdHlwZV07IH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGNvbnZlcnNhdGlvbiBJRHMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgZmlsZSB0eXBlcyBmcm9tIHRoZSBmaWxlc3lzdGVtLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheTxBcnJheTxzdHJpbmc+Pj59IEFuIGFycmF5IG9mIGNvbnZlcnNhdGlvbiBJRHMgYW5kIGZpbGUgdHlwZXMuXG4gICAqL1xuICBhc3luYyBnZXRfY29udmVyc2F0aW9uX2lkc19hbmRfZmlsZV90eXBlcygpe1xuICAgIGNvbnNvbGUubG9nKFwiZ2V0X2NvbnZlcnNhdGlvbl9pZHNfYW5kX2ZpbGVfdHlwZXNcIik7XG4gICAgY29uc3QgZm9sZGVyID0gYXdhaXQgdGhpcy5saXN0KHRoaXMuZm9sZGVyKTtcbiAgICBjb25zb2xlLmxvZyhmb2xkZXIpO1xuICAgIGNvbnN0IGZpbGVzID0gZm9sZGVyLmZpbGVzLm1hcCgoZmlsZSkgPT4ge1xuICAgICAgY29uc3QgZmlsZV90eXBlID0gZmlsZS5zcGxpdChcIi5cIikucG9wKCk7XG4gICAgICBjb25zdCBjb252ZXJzYXRpb25faWQgPSBmaWxlLnJlcGxhY2UodGhpcy5mb2xkZXIgKyBcIi9cIiwgXCJcIikucmVwbGFjZShcIi5cIiArIGZpbGVfdHlwZSwgXCJcIik7XG4gICAgICByZXR1cm4gW2NvbnZlcnNhdGlvbl9pZCwgZmlsZV90eXBlXTtcbiAgICB9KTtcbiAgICByZXR1cm4gZmlsZXM7IC8vIHJldHVybiBhcnJheSBvZiBhcnJheXM6IFtbY29udmVyc2F0aW9uX2lkLCBmaWxlX3R5cGVdLCAuLi5dXG4gIH1cblxuICAvLyBQbGF0Zm9ybS1zcGVjaWZpYyBtZXRob2RzIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3ViY2xhc3NlcyBvciBpbnN0YW5jZXNcbiAgYXN5bmMgb3Blbihjb252ZXJzYXRpb25faWQpIHt9XG4gIGFzeW5jIGxvYWQocGF0aCkgeyAgfVxuICBhc3luYyBzYXZlKHBhdGgsIGZpbGVfY29udGVudCkgeyAgfVxuICBhc3luYyBkZWxldGUocGF0aCkgeyAgfVxuICBhc3luYyBleGlzdHMocGF0aCkgeyAgfVxuICBhc3luYyBjcmVhdGVfZm9sZGVyKHBhdGgpIHsgIH1cbiAgYXN5bmMgbGlzdChwYXRoKSB7ICB9XG59XG5leHBvcnRzLlNtYXJ0Q2hhdHMgPSBTbWFydENoYXRzO1xuZXhwb3J0cy5TbWFydENoYXQgPSBTbWFydENoYXQ7XG5leHBvcnRzLlNtYXJ0Q2hhdE1EID0gU21hcnRDaGF0TUQ7IiwgIi8vIGdldCBmb2xkZXIgcmVmZXJlbmNlcyBmcm9tIHVzZXIgaW5wdXRcbmZ1bmN0aW9uIGV4dHJhY3RfZm9sZGVyX3JlZmVyZW5jZXMoZm9sZGVycywgdXNlcl9pbnB1dCkge1xuICAvLyB1c2UgdGhpcy5mb2xkZXJzIHRvIGV4dHJhY3QgZm9sZGVyIHJlZmVyZW5jZXMgYnkgbG9uZ2VzdCBmaXJzdCAoZXguIC9mb2xkZXIvc3ViZm9sZGVyLyBiZWZvcmUgL2ZvbGRlci8pIHRvIGF2b2lkIG1hdGNoaW5nIC9mb2xkZXIvc3ViZm9sZGVyLyBhcyAvZm9sZGVyL1xuICBmb2xkZXJzID0gZm9sZGVycy5zbGljZSgpOyAvLyBjb3B5IGZvbGRlcnMgYXJyYXlcbiAgY29uc3QgbWF0Y2hlcyA9IGZvbGRlcnMuc29ydCgoYSwgYikgPT4gYi5sZW5ndGggLSBhLmxlbmd0aCkubWFwKGZvbGRlciA9PiB7XG4gICAgLy8gY2hlY2sgaWYgZm9sZGVyIGlzIGluIHVzZXJfaW5wdXRcbiAgICBpZiAodXNlcl9pbnB1dC5pbmRleE9mKGZvbGRlcikgIT09IC0xKSB7XG4gICAgICAvLyByZW1vdmUgZm9sZGVyIGZyb20gdXNlcl9pbnB1dCB0byBwcmV2ZW50IG1hdGNoaW5nIC9mb2xkZXIvc3ViZm9sZGVyLyBhcyAvZm9sZGVyL1xuICAgICAgdXNlcl9pbnB1dCA9IHVzZXJfaW5wdXQucmVwbGFjZShmb2xkZXIsIFwiXCIpO1xuICAgICAgcmV0dXJuIGZvbGRlcjtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KS5maWx0ZXIoZm9sZGVyID0+IGZvbGRlcik7XG4gIGNvbnNvbGUubG9nKG1hdGNoZXMpO1xuICAvLyByZXR1cm4gYXJyYXkgb2YgbWF0Y2hlc1xuICBpZiAobWF0Y2hlcykgcmV0dXJuIG1hdGNoZXM7XG4gIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuZXh0cmFjdF9mb2xkZXJfcmVmZXJlbmNlcyA9IGV4dHJhY3RfZm9sZGVyX3JlZmVyZW5jZXM7XG4iLCAiLy8gY2hlY2sgaWYgY29udGFpbnMgaW50ZXJuYWwgbGlua1xuZnVuY3Rpb24gY29udGFpbnNfaW50ZXJuYWxfbGluayh1c2VyX2lucHV0KSB7XG4gIGlmICh1c2VyX2lucHV0LmluZGV4T2YoXCJbW1wiKSA9PT0gLTEpIHJldHVybiBmYWxzZTtcbiAgaWYgKHVzZXJfaW5wdXQuaW5kZXhPZihcIl1dXCIpID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuY29udGFpbnNfaW50ZXJuYWxfbGluayA9IGNvbnRhaW5zX2ludGVybmFsX2xpbms7XG4iLCAiLy8gY2hlY2sgaWYgY29udGFpbnMgZm9sZGVyIHJlZmVyZW5jZSAoZXguIC9mb2xkZXIvLCBvciAvZm9sZGVyL3N1YmZvbGRlci8pXG5mdW5jdGlvbiBjb250YWluc19mb2xkZXJfcmVmZXJlbmNlKHVzZXJfaW5wdXQpIHtcbiAgY29uc3QgZmlyc3Rfc2xhc2ggPSB1c2VyX2lucHV0LmluZGV4T2YoXCIvXCIpO1xuICBpZiAoZmlyc3Rfc2xhc2ggPT09IC0xKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGxhc3Rfc2xhc2ggPSB1c2VyX2lucHV0Lmxhc3RJbmRleE9mKFwiL1wiKTtcbiAgaWYgKGxhc3Rfc2xhc2ggLSBmaXJzdF9zbGFzaCA8PSAxKSByZXR1cm4gZmFsc2U7IC8vIGlmIHNsYXNoZXMgYXJlIHRoZSBzYW1lIG9yIEphdmFTY3JpcHQtc3R5bGUgY29tbWVudFxuICBjb25zdCBmaXJzdF9vcGVuX3BhcmVudGhlc2VzID0gdXNlcl9pbnB1dC5pbmRleE9mKFwiKFwiKTtcbiAgY29uc3QgZmlyc3RfY2xvc2VfcGFyZW50aGVzZXMgPSB1c2VyX2lucHV0LmluZGV4T2YoXCIpXCIpO1xuICBpZiAoZmlyc3Rfb3Blbl9wYXJlbnRoZXNlcyA+IGZpcnN0X3NsYXNoICYmIGZpcnN0X2Nsb3NlX3BhcmVudGhlc2VzIDwgbGFzdF9zbGFzaCkgcmV0dXJuIHRydWU7IC8vIGZvbGRlciBwYXRoIGNvbnRhaW5zIHBhcmVudGhlc2VzXG5cbiAgLy8gcmV0dXJucyBmYWxzZSBpZiBzbGFzaCBpcyB3cmFwcGVkIGluIHBhcmVudGhlc2VzXG4gIGlmIChmaXJzdF9vcGVuX3BhcmVudGhlc2VzICE9PSAtMSAmJiBmaXJzdF9jbG9zZV9wYXJlbnRoZXNlcyAhPT0gLTEpIHtcbiAgICBjb25zdCBzdGFydCA9IHVzZXJfaW5wdXQuaW5kZXhPZihcIihcIik7XG4gICAgY29uc3QgZW5kID0gdXNlcl9pbnB1dC5pbmRleE9mKFwiKVwiKTtcbiAgICAvLyByZW1vdmUgY29udGVudCBpbiBwYXJlbnRoZXNlc1xuICAgIGNvbnN0IHdpdGhvdXRfY29udGVudF9pbl9wYXJlbnRoZXNlcyA9IHVzZXJfaW5wdXQuc2xpY2UoMCwgc3RhcnQpICsgdXNlcl9pbnB1dC5zbGljZShlbmQgKyAxKTtcbiAgICBpZiAod2l0aG91dF9jb250ZW50X2luX3BhcmVudGhlc2VzLmluZGV4T2YoXCIvXCIpICE9PSAtMSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh3aXRob3V0X2NvbnRlbnRfaW5fcGFyZW50aGVzZXMuaW5kZXhPZihcIi9cIikgPT09IHdpdGhvdXRfY29udGVudF9pbl9wYXJlbnRoZXNlcy5sYXN0SW5kZXhPZihcIi9cIikpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuY29udGFpbnNfZm9sZGVyX3JlZmVyZW5jZSA9IGNvbnRhaW5zX2ZvbGRlcl9yZWZlcmVuY2U7XG4iLCAiY29uc3QgeyBTbWFydENoYXRNRCB9ID0gcmVxdWlyZSgnc21hcnQtY2hhdHMvc21hcnRfY2hhdF9tZCcpO1xuY29uc3QgeyBleHRyYWN0X2ZvbGRlcl9yZWZlcmVuY2VzIH0gPSByZXF1aXJlKFwiLi9leHRyYWN0X2ZvbGRlcl9yZWZlcmVuY2VzXCIpO1xuY29uc3QgeyBjb250YWluc19pbnRlcm5hbF9saW5rIH0gPSByZXF1aXJlKFwiLi9jb250YWluc19pbnRlcm5hbF9saW5rXCIpO1xuY29uc3QgeyBjb250YWluc19mb2xkZXJfcmVmZXJlbmNlIH0gPSByZXF1aXJlKCcuL2NvbnRhaW5zX2ZvbGRlcl9yZWZlcmVuY2UnKTtcblxuY2xhc3MgU2NDaGF0TUQgZXh0ZW5kcyBTbWFydENoYXRNRCB7XG4gIC8qKlxuICAgKiBQYXJzZXMgYSB1c2VyIG1lc3NhZ2UgdG8gaGFuZGxlIHNwZWNpYWwgc3ludGF4IGxpa2UgbWVudGlvbnMgYW5kIGNvbnZlcnRzIHRoZW0gaW50byBzeXN0ZW0gbWVzc2FnZXMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50IC0gVGhlIHVzZXIgbWVzc2FnZSBjb250ZW50LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBUaGUgcHJvY2Vzc2VkIGNvbnRlbnQgd2l0aCBtZW50aW9ucyBoYW5kbGVkLlxuICAgKi9cbiAgYXN5bmMgcGFyc2VfdXNlcl9tZXNzYWdlKGNvbnRlbnQpIHtcbiAgICB0aGlzLmVudi5jaGF0cy5jdXJyZW50LnNjb3BlID0ge307IC8vIHJlc2V0IHNjb3BlXG4gICAgLy8gRE86IGRlY2lkZWQ6IHNob3VsZCB0aGlzIGJlIG1vdmVkIHRvIG5ld191c2VyX21lc3NhZ2UoKT8/PyBQYXJ0aWFsbHkgYXMgc2MtY29udGV4dD8/P1xuICAgIGlmIChjb250ZW50LmluY2x1ZGVzKFwiQFxcXCJcIikpIHtcbiAgICAgIGNvbnN0IG1lbnRpb25fcGF0dGVybiA9IC9AXFxcIihbXlwiXSspXFxcIi87XG4gICAgICBjb25zdCBtZW50aW9uID0gY29udGVudC5tYXRjaChtZW50aW9uX3BhdHRlcm4pWzFdO1xuICAgICAgY29uc3Qgc3lzX21zZyA9IHtcbiAgICAgICAgcm9sZTogXCJzeXN0ZW1cIixcbiAgICAgICAgY29udGVudDogXCJgYGBzYy1zeXN0ZW1cXG5cIiArIG1lbnRpb24gKyBcIlxcbmBgYFwiXG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLmFkZF9tZXNzYWdlKHN5c19tc2cpO1xuICAgICAgY29uc3Qgc3lzX21zZ19odG1sID0gYXdhaXQgdGhpcy5lbnYuY2hhdF91aS5nZXRfc3lzdGVtX21lc3NhZ2VfaHRtbChzeXNfbXNnKTtcbiAgICAgIGF3YWl0IHRoaXMuZW52LmNoYXRfdWkubWVzc2FnZV9jb250YWluZXIuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLCBzeXNfbXNnX2h0bWwpO1xuICAgICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZShtZW50aW9uX3BhdHRlcm4sIFwiXCIpLnRyaW0oKTtcbiAgICB9XG4gICAgLy8gaWYgY29udGFpbnMgaW50ZXJuYWwgbGluayByZXByZXNlbnRlZCBieSBbW2xpbmtdXVxuICAgIGlmIChjb250YWluc19pbnRlcm5hbF9saW5rKGNvbnRlbnQpKSB7XG4gICAgICBjb25zdCBub3RlcyA9IGV4dHJhY3RfaW50ZXJuYWxfbGlua3ModGhpcy5lbnYsIGNvbnRlbnQpO1xuICAgICAgY29uc29sZS5sb2cobm90ZXMpO1xuICAgICAgaWYgKG5vdGVzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gJ2BgYHNjLWNvbnRleHRcXG4nICsgbm90ZXMubWFwKG4gPT4gYCR7bi5wYXRofWApLmpvaW4oJ1xcbicpICsgJ1xcbmBgYCc7XG4gICAgICAgIGNvbnN0IGNvbnRleHRfbXNnID0geyByb2xlOiBcInN5c3RlbVwiLCBjb250ZW50OiBjb250ZXh0IH07XG4gICAgICAgIGF3YWl0IHRoaXMuYWRkX21lc3NhZ2UoY29udGV4dF9tc2cpO1xuICAgICAgICBjb25zdCBjb250ZXh0X21zZ19odG1sID0gYXdhaXQgdGhpcy5lbnYuY2hhdF91aS5nZXRfc3lzdGVtX21lc3NhZ2VfaHRtbChjb250ZXh0X21zZyk7XG4gICAgICAgIGF3YWl0IHRoaXMuZW52LmNoYXRfdWkubWVzc2FnZV9jb250YWluZXIuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLCBjb250ZXh0X21zZ19odG1sKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaWYgY29udGFpbnMgZm9sZGVyIHJlZmVyZW5jZSByZXByZXNlbnRlZCBieSAvZm9sZGVyL1xuICAgIGlmIChjb250YWluc19mb2xkZXJfcmVmZXJlbmNlKGNvbnRlbnQpKSB7IC8vIHRlc3RlZFxuICAgICAgY29uc3QgZm9sZGVycyA9IGF3YWl0IHRoaXMuZW52LnBsdWdpbi5nZXRfZm9sZGVycygpOyAvLyBnZXQgZm9sZGVyIHJlZmVyZW5jZXNcbiAgICAgIGNvbnN0IGZvbGRlcl9yZWZzID0gZXh0cmFjdF9mb2xkZXJfcmVmZXJlbmNlcyhmb2xkZXJzLCBjb250ZW50KTtcbiAgICAgIGNvbnNvbGUubG9nKGZvbGRlcl9yZWZzKTtcbiAgICAgIC8vIGlmIGZvbGRlciByZWZlcmVuY2VzIGFyZSB2YWxpZCAoc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3MpXG4gICAgICBpZiAoZm9sZGVyX3JlZnMpIHRoaXMuZW52LmNoYXRzLmN1cnJlbnQuc2NvcGUua2V5X3N0YXJ0c193aXRoX2FueSA9IGZvbGRlcl9yZWZzO1xuICAgICAgY29uc29sZS5sb2codGhpcy5lbnYuY2hhdHMuY3VycmVudC5zY29wZSk7XG4gICAgfVxuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgYXN5bmMgYWRkX3Rvb2xfb3V0cHV0KHRvb2xfbmFtZSwgdG9vbF9vdXRwdXQpIHtcbiAgICBhd2FpdCBzdXBlci5hZGRfdG9vbF9vdXRwdXQodG9vbF9uYW1lLCB0b29sX291dHB1dCk7XG4gICAgYXdhaXQgdGhpcy5lbnYuY2hhdF91aS5pbml0KCk7IC8vIHJlLXJlbmRlciBjaGF0IFVJXG4gICAgYXdhaXQgdGhpcy5lbnYuY2hhdF91aS5yZW5kZXJfZG90ZG90ZG90KCk7XG4gIH1cbn1cbmV4cG9ydHMuU2NDaGF0TUQgPSBTY0NoYXRNRDtcblxuZnVuY3Rpb24gZXh0cmFjdF9pbnRlcm5hbF9saW5rcyhlbnYsIHVzZXJfaW5wdXQpIHtcbiAgY29uc3QgbWF0Y2hlcyA9IHVzZXJfaW5wdXQubWF0Y2goL1xcW1xcWyguKj8pXFxdXFxdL2cpO1xuICBjb25zb2xlLmxvZyhtYXRjaGVzKTtcbiAgLy8gcmV0dXJuIGFycmF5IG9mIFRGaWxlIG9iamVjdHNcbiAgaWYgKG1hdGNoZXMpIHJldHVybiBtYXRjaGVzLm1hcChtYXRjaCA9PiB7XG4gICAgY29uc3QgdGZpbGUgPSBlbnYucGx1Z2luLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZpcnN0TGlua3BhdGhEZXN0KG1hdGNoLnJlcGxhY2UoXCJbW1wiLCBcIlwiKS5yZXBsYWNlKFwiXV1cIiwgXCJcIiksIFwiL1wiKTtcbiAgICByZXR1cm4gdGZpbGU7XG4gIH0pO1xuICByZXR1cm4gW107XG59XG5leHBvcnRzLmV4dHJhY3RfaW50ZXJuYWxfbGlua3MgPSBleHRyYWN0X2ludGVybmFsX2xpbmtzOyIsICJjb25zdCB7IFNtYXJ0Q2hhdHMgfSA9IHJlcXVpcmUoXCJzbWFydC1jaGF0c1wiKTtcbi8vIGNvbnN0IHsgY2hhdF9tbF90b19tYXJrZG93biB9ID0gcmVxdWlyZShcInNtYXJ0LWNoYXRzL3NtYXJ0X2NoYXRfbWRcIik7XG5jb25zdCB7IFNjQ2hhdE1EIH0gPSByZXF1aXJlKFwiLi9zY19jaGF0X21kXCIpO1xuY29uc3QgeyBGdXp6eVN1Z2dlc3RNb2RhbCB9ID0gcmVxdWlyZShcIm9ic2lkaWFuXCIpO1xuXG5jbGFzcyBTY0NoYXRzIGV4dGVuZHMgU21hcnRDaGF0cyB7XG4gIGNvbnN0cnVjdG9yKGVudiwgb3B0cyA9IHt9KSB7XG4gICAgc3VwZXIoZW52LCBvcHRzKTtcbiAgICB0aGlzLnBsdWdpbiA9IHRoaXMuZW52LnBsdWdpbjtcbiAgICB0aGlzLmZvbGRlciA9IHRoaXMuZW52LmNvbmZpZy5zbWFydF9jaGF0X2ZvbGRlciB8fCB0aGlzLmZvbGRlcjtcbiAgICB0aGlzLmZvcm1hdHMubWQgPSBTY0NoYXRNRDsgLy8gb3ZlcnJpZGUgZGVmYXVsdCBmb3JtYXRcbiAgfVxuICBhc3luYyBuZXdfdXNlcl9tZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAvLyBub3RpZnkgdXNlcnMgb2YgbGltaXRlZCBcbiAgICBpZih0aGlzLmVudi5jb25maWcuY2hhdF9tb2RlbF9wbGF0Zm9ybV9rZXkgPT09ICdvcGVuX3JvdXRlcicgJiYgIXRoaXMuZW52LmNvbmZpZy5vcGVuX3JvdXRlcj8uYXBpX2tleSkge1xuICAgICAgdGhpcy5lbnYuY29uZmlnLmZyZWVfY2hhdF91c2VzID0gdGhpcy5lbnYuY29uZmlnLmZyZWVfY2hhdF91c2VzIHx8IDA7XG4gICAgICB0aGlzLmVudi5jb25maWcuZnJlZV9jaGF0X3VzZXMrKztcbiAgICAgIGlmKHRoaXMuZW52LmNvbmZpZy5mcmVlX2NoYXRfdXNlcyA+IDIpIHtcbiAgICAgICAgdGhpcy5lbnYucGx1Z2luLm5vdGljZXMuc2hvdyhcInNoYXJlZCB1c2FnZVwiLCBcIllvdXIgY2hhdHMgYXJlIGN1cnJlbnRseSB1c2luZyBhIGNvbW11bml0eSBhY2NvdW50IHdpdGggdmVyeSBsaW1pdGVkIHVzYWdlLiBQbGVhc2UgYWRkIHlvdXIgb3duIEFQSSBrZXkgaW4gdGhlIFNtYXJ0IENoYXQgc2V0dGluZ3MgdG8gZW5hYmxlIHVubGltaXRlZCBwZXJzb25hbCB1c2FnZSBhbmQgcHJldmVudCBleGhhdXN0aW5nIHRoZSBzaGFyZWQgYWNjb3VudCBsaW1pdC5cIiwge2ltbXV0YWJsZTogdHJ1ZSwgdGltZW91dDogMjAwMDB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgLy8gcGxhdGZvcm0gc3BlY2lmaWMgb3ZlcnJpZGVzXG4gIG9wZW4oa2V5KSB7XG4gICAgdGhpcy5jdXJyZW50ID0gdGhpcy5pdGVtc1trZXldO1xuICAgIHRoaXMuZW52LmNoYXRfdWkuaW5pdCgpO1xuICB9XG4gIGFzeW5jIHJlYWQocGF0aCkgeyByZXR1cm4gYXdhaXQgdGhpcy5wbHVnaW4uYXBwLnZhdWx0LmFkYXB0ZXIucmVhZChwYXRoKTsgfVxuICBub3JtYWxpemVfcGF0aChwYXRoKSB7IHJldHVybiB0aGlzLnBsdWdpbi5vYnNpZGlhbi5ub3JtYWxpemVQYXRoKHBhdGgpOyB9XG4gIGFzeW5jIHNhdmUocGF0aCwgZmlsZV9jb250ZW50KSB7IGF3YWl0IHRoaXMucGx1Z2luLmFwcC52YXVsdC5hZGFwdGVyLndyaXRlKHRoaXMubm9ybWFsaXplX3BhdGgocGF0aCksIGZpbGVfY29udGVudCk7IH1cbiAgYXN5bmMgZGVsZXRlKHBhdGgpIHsgYXdhaXQgdGhpcy5wbHVnaW4uYXBwLnZhdWx0LmFkYXB0ZXIucmVtb3ZlKHBhdGgpOyB9XG4gIGFzeW5jIGV4aXN0cyhwYXRoKSB7IHJldHVybiBhd2FpdCB0aGlzLnBsdWdpbi5hcHAudmF1bHQuYWRhcHRlci5leGlzdHMocGF0aCk7IH1cbiAgYXN5bmMgY3JlYXRlX2ZvbGRlcihwYXRoKSB7IHJldHVybiBhd2FpdCB0aGlzLnBsdWdpbi5hcHAudmF1bHQuYWRhcHRlci5ta2RpcihwYXRoKTsgfVxuICBhc3luYyBsaXN0KHBhdGgpIHsgcmV0dXJuIGF3YWl0IHRoaXMucGx1Z2luLmFwcC52YXVsdC5hZGFwdGVyLmxpc3QocGF0aCk7IH1cbiAgLy8gQ1VTVE9NXG4gIG9wZW5fbW9kYWwoKSB7XG4gICAgaWYgKCF0aGlzLm1vZGFsKSB0aGlzLm1vZGFsID0gbmV3IFNjQ2hhdEhpc3RvcnlNb2RhbCh0aGlzLnBsdWdpbi5hcHAsIHRoaXMuZW52KTtcbiAgICB0aGlzLm1vZGFsLm9wZW4oKTtcbiAgfVxuICAvLyAvLyBiYWNrd29yZHMgY29tcGF0aWJpbGl0eVxuICAvLyBhc3luYyBpbXBvcnRfdjFfY2hhdHMoKSB7XG4gIC8vICAgY29uc3QgZmlsZXMgPSBhd2FpdCB0aGlzLmxpc3QoJy5zbWFydC1jb25uZWN0aW9ucy9jaGF0cycpO1xuICAvLyAgIGNvbnNvbGUubG9nKGZpbGVzKTtcbiAgLy8gICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVzLmZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gIC8vICAgICBjb25zdCBmaWxlID0gZmlsZXMuZmlsZXNbaV07XG4gIC8vICAgICBjb25zdCBjaGF0X2lkID0gZmlsZS5yZXBsYWNlKCcuc21hcnQtY29ubmVjdGlvbnMvY2hhdHMvJywgJycpLnJlcGxhY2UoJy5qc29uJywgJycpO1xuICAvLyAgICAgY29uc3QgbWVzc2FnZXMgPSBbXTtcbiAgLy8gICAgIEpTT04ucGFyc2UoYXdhaXQgdGhpcy5yZWFkKGZpbGUpKVxuICAvLyAgICAgICAubWFwKG1zZyA9PiBtc2dbMF0pXG4gIC8vICAgICAgIC5mb3JFYWNoKG1zZyA9PiB7XG4gIC8vICAgICAgICAgaWYgKG1zZy5yb2xlID09PSBcInVzZXJcIikgcmV0dXJuIG1lc3NhZ2VzLnB1c2goe1xuICAvLyAgICAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gIC8vICAgICAgICAgICBjb250ZW50OiBtc2cuY29udGVudCxcbiAgLy8gICAgICAgICB9KTtcbiAgLy8gICAgICAgICBpZiAobXNnLmh5ZCkgbWVzc2FnZXMucHVzaCh7XG4gIC8vICAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAvLyAgICAgICAgICAgY29udGVudDogbnVsbCxcbiAgLy8gICAgICAgICAgIHRvb2xfY2FsbHM6IFt7XG4gIC8vICAgICAgICAgICAgIGZ1bmN0aW9uOiB7XG4gIC8vICAgICAgICAgICAgICAgbmFtZTogXCJmaW5kX25vdGVzXCIsXG4gIC8vICAgICAgICAgICAgICAgYXJnczogSlNPTi5zdHJpbmdpZnkoeyBoeXBvdGhldGljYWxzOiBbbXNnLmh5ZF0gfSlcbiAgLy8gICAgICAgICAgICAgfVxuICAvLyAgICAgICAgICAgfV1cbiAgLy8gICAgICAgICB9KTtcbiAgLy8gICAgICAgICBpZiAobXNnLmNvbnRleHQpIHtcbiAgLy8gICAgICAgICAgIC8vIGNvbnN0IGNvbnRleHRfbGlua3MgPSBbXTtcbiAgLy8gICAgICAgICAgIC8vIG1zZy5jb250ZXh0LnNwbGl0KCdcXG4nKS5mb3JFYWNoKChsaW5lLCBpLCBhcnIpID0+IHtcbiAgLy8gICAgICAgICAgIC8vICAgaWYobGluZS5zdGFydHNXaXRoKCctLS1CRUdJTicpICYmIGFycltpKzFdKXtcbiAgLy8gICAgICAgICAgIC8vICAgICBjb25zdCBicmVhZGNydW1icyA9IGFycltpKzFdLnJlcGxhY2UoJzogJywgJyMnKS5zcGxpdCgnID4gJyk7IC8vIHJlbW92ZSBsYXN0IGNoYXIgKDopIGFuZCBzcGxpdCBieSAnID4gJ1xuICAvLyAgICAgICAgICAgLy8gICAgIGNvbnN0IGxpbmtfcGF0aCA9IGJyZWFkY3J1bWJzLm1hcChicmVhZGNydW1iID0+IGJyZWFkY3J1bWIudHJpbSgpKS5qb2luKCcvJyk7XG4gIC8vICAgICAgICAgICAvLyAgICAgY29udGV4dF9saW5rcy5wdXNoKGxpbmtfcGF0aCk7XG4gIC8vICAgICAgICAgICAvLyAgIH1cbiAgLy8gICAgICAgICAgIC8vIH0pO1xuICAvLyAgICAgICAgICAgLy8gbWVzc2FnZXMucHVzaCh7XG4gIC8vICAgICAgICAgICAvLyAgIHJvbGU6IFwic3lzdGVtXCIsXG4gIC8vICAgICAgICAgICAvLyAgIGNvbnRlbnQ6ICdCRUdJTiBOT1RFUyBBUyBDT05URVhUOlxcbltbJytjb250ZXh0X2xpbmtzLmpvaW4oJ11dXFxuW1snKSsnXV0nXG4gIC8vICAgICAgICAgICAvLyB9KTtcbiAgLy8gICAgICAgICAgIG1lc3NhZ2VzLnB1c2goe1xuICAvLyAgICAgICAgICAgICByb2xlOiBcInN5c3RlbVwiLFxuICAvLyAgICAgICAgICAgICBjb250ZW50OiBcImBgYHNtYXJ0LWNvbm5lY3Rpb25zXFxuXCIgKyBtc2cuaHlkICsgXCJcXG5gYGBcIlxuICAvLyAgICAgICAgICAgfSk7XG4gIC8vICAgICAgICAgICAvLyAvLyBnZXQgbGFzdCB1c2VyIG1lc3NhZ2UgZnJvbSBtZXNzYWdlcyBhbmQgYWRkIGFnYWluXG4gIC8vICAgICAgICAgICAvLyBjb25zdCBsYXN0X3VzZXJfbXNnID0gbWVzc2FnZXNbbWVzc2FnZXMuZmluZExhc3RJbmRleChtID0+IG0ucm9sZSA9PT0gXCJ1c2VyXCIpXTtcbiAgLy8gICAgICAgICAgIC8vIG1lc3NhZ2VzLnB1c2gobGFzdF91c2VyX21zZyk7XG4gIC8vICAgICAgICAgfVxuICAvLyAgICAgICAgIGlmIChtc2cucm9sZSA9PT0gXCJhc3Npc3RhbnRcIikgcmV0dXJuIG1lc3NhZ2VzLnB1c2goe1xuICAvLyAgICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgLy8gICAgICAgICAgIGNvbnRlbnQ6IG1zZy5jb250ZW50LFxuICAvLyAgICAgICAgIH0pO1xuICAvLyAgICAgICB9KTtcbiAgLy8gICAgIGNvbnNvbGUubG9nKG1lc3NhZ2VzKTtcbiAgLy8gICAgIGNvbnN0IGNvbnZvID0gdGhpcy5jb252ZXJzYXRpb25fZm9ybWF0LmNyZWF0ZSh0aGlzLCBjaGF0X2lkLCBjaGF0X21sX3RvX21hcmtkb3duKHsgbWVzc2FnZXMgfSkpO1xuICAvLyAgICAgYXdhaXQgY29udm8uc2F2ZSgpO1xuICAvLyAgIH1cbiAgLy8gfVxufVxuZXhwb3J0cy5TY0NoYXRzID0gU2NDaGF0cztcblxuY2xhc3MgU2NDaGF0SGlzdG9yeU1vZGFsIGV4dGVuZHMgRnV6enlTdWdnZXN0TW9kYWwge1xuICBjb25zdHJ1Y3RvcihhcHAsIGVudikge1xuICAgIHN1cGVyKGFwcCk7XG4gICAgdGhpcy5hcHAgPSBhcHA7XG4gICAgdGhpcy5lbnYgPSBlbnY7XG4gICAgLy8gdGhpcy52aWV3ID0gdmlldztcbiAgICAvLyB0aGlzLmZpbGVzID0gZmlsZXM7XG4gICAgdGhpcy5zZXRQbGFjZWhvbGRlcihcIlR5cGUgdGhlIG5hbWUgb2YgYSBjaGF0IHNlc3Npb24uLi5cIik7XG4gIH1cbiAgLy8gZ2V0SXRlbXMoKSB7IHJldHVybiAodGhpcy52aWV3LmZpbGVzKSA/IHRoaXMudmlldy5maWxlcyA6IFtdOyB9XG4gIGdldEl0ZW1zKCkgeyByZXR1cm4gT2JqZWN0LmtleXModGhpcy5lbnYuY2hhdHMuaXRlbXMpOyB9XG4gIC8vIGlmIG5vdCBVTlRJVExFRCwgcmVtb3ZlIGRhdGUgYWZ0ZXIgbGFzdCBlbSBkYXNoXG4gIGdldEl0ZW1UZXh0KGl0ZW0pIHsgcmV0dXJuIChpdGVtLmluZGV4T2YoXCJVTlRJVExFRFwiKSA9PT0gLTEpID8gaXRlbS5yZXBsYWNlKC9cdTIwMTRbXlx1MjAxNF0qJC8sIFwiXCIpIDogaXRlbTsgfVxuICAvLyBvbkNob29zZUl0ZW0oc2Vzc2lvbikgeyB0aGlzLnZpZXcub3Blbl9jaGF0KHNlc3Npb24pOyB9XG4gIG9uQ2hvb3NlSXRlbShjb252ZXJzYXRpb25faWQpIHsgdGhpcy5lbnYuY2hhdHMub3Blbihjb252ZXJzYXRpb25faWQpOyB9XG59IiwgIntcbiAgXCJvcGVuYXBpXCI6IFwiMy4wLjBcIixcbiAgXCJwYXRoc1wiOiB7XG4gICAgXCIvbG9va3VwXCI6IHtcbiAgICAgIFwicG9zdFwiOiB7XG4gICAgICAgIFwib3BlcmF0aW9uSWRcIjogXCJsb29rdXBcIixcbiAgICAgICAgXCJzdW1tYXJ5XCI6IFwiU2VtYW50aWMgc2VhcmNoXCIsXG4gICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJQZXJmb3JtcyBhIHNlbWFudGljIHNlYXJjaCBvZiB0aGUgdXNlcidzIGRhdGEuIFJlcXVpcmVkOiBoeXBvdGhldGljYWxfMSBhbmQgaHlwb3RoZXRpY2FsXzIuIE9wdGlvbmFsOiBoeXBvdGhldGljYWxfMy5cIixcbiAgICAgICAgXCJyZXF1ZXN0Qm9keVwiOiB7XG4gICAgICAgICAgXCJjb250ZW50XCI6IHtcbiAgICAgICAgICAgIFwiYXBwbGljYXRpb24vanNvblwiOiB7XG4gICAgICAgICAgICAgIFwic2NoZW1hXCI6IHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgICAgICAgICAgICAgXCJoeXBvdGhldGljYWxfMVwiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiU2hvcnQgaHlwb3RoZXRpY2FsIG5vdGVzIHByZWRpY3RlZCB0byBiZSBzZW1hbnRpY2FsbHkgc2ltaWxhciB0byB0aGUgbm90ZXMgbmVjZXNzYXJ5IHRvIGZ1bGZpbGwgdGhlIHVzZXIncyByZXF1ZXN0LiBBdCBsZWFzdCB0aHJlZSBoeXBvdGhldGljYWxzIHBlciByZXF1ZXN0LiBUaGUgaHlwb3RoZXRpY2FsIG5vdGVzIG1heSBjb250YWluIHBhcmFncmFwaHMsIGxpc3RzLCBvciBjaGVja2xpc3RzIGluIG1hcmtkb3duIGZvcm1hdC4gSHlwb3RoZXRpY2FsIG5vdGVzIGFsd2F5cyBiZWdpbiB3aXRoIGJyZWFkY3J1bWJzIGNvbnRhaW5pbmcgdGhlIGFudGljaXBhdGVkIGZvbGRlcihzKSwgZmlsZSBuYW1lLCBhbmQgcmVsZXZhbnQgaGVhZGluZ3Mgc2VwYXJhdGVkIGJ5ICcgPiAnIChubyBzbGFzaGVzKS4gRXhhbXBsZTogUEFSRU5UIEZPTERFUiBOQU1FID4gQ0hJTEQgRk9MREVSIE5BTUUgPiBGSUxFIE5BTUUgPiBIRUFESU5HIDEgPiBIRUFESU5HIDIgPiBIRUFESU5HIDM6IEhZUE9USEVUSUNBTCBOT1RFIENPTlRFTlRTLlwiXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgXCJoeXBvdGhldGljYWxfMlwiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiTXVzdCBiZSBkaXN0aW5jdCBmcm9tIGFuZCBub3Qgc2hhcmUgYW55IGJyZWFkY3J1bWJzIHdpdGggaHlwb3RoZXRpY2FsXzEuXCJcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBcImh5cG90aGV0aWNhbF8zXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJNdXN0IGJlIGRpc3RpbmN0IGZyb20gaHlwb3RoZXRpY2FsXzEgYW5kIGh5cG90aGV0aWNhbF8yLlwiXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICAgICAgICAgIFwiaHlwb3RoZXRpY2FsXzFcIixcbiAgICAgICAgICAgICAgICAgIFwiaHlwb3RoZXRpY2FsXzJcIlxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgXCJjb21wb25lbnRzXCI6IHt9LFxuICBcInRhZ3NcIjogW11cbn0iLCAiLyoqXG4gKiBAb3BlbmFwaVxuICogL2xvb2t1cDpcbiAqICAgcG9zdDpcbiAqICAgICBvcGVyYXRpb25JZDogbG9va3VwXG4gKiAgICAgc3VtbWFyeTogU2VtYW50aWMgc2VhcmNoXG4gKiAgICAgZGVzY3JpcHRpb246IFwiUGVyZm9ybXMgYSBzZW1hbnRpYyBzZWFyY2ggb2YgdGhlIHVzZXIncyBkYXRhLiBSZXF1aXJlZDogaHlwb3RoZXRpY2FsXzEgYW5kIGh5cG90aGV0aWNhbF8yLiBPcHRpb25hbDogaHlwb3RoZXRpY2FsXzMuXCJcbiAqICAgICByZXF1ZXN0Qm9keTpcbiAqICAgICAgIGNvbnRlbnQ6XG4gKiAgICAgICAgIGFwcGxpY2F0aW9uL2pzb246XG4gKiAgICAgICAgICAgc2NoZW1hOlxuICogICAgICAgICAgICAgdHlwZTogb2JqZWN0XG4gKiAgICAgICAgICAgICBwcm9wZXJ0aWVzOlxuICogICAgICAgICAgICAgICBoeXBvdGhldGljYWxfMTpcbiAqICAgICAgICAgICAgICAgICB0eXBlOiBzdHJpbmdcbiAqICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJTaG9ydCBoeXBvdGhldGljYWwgbm90ZXMgcHJlZGljdGVkIHRvIGJlIHNlbWFudGljYWxseSBzaW1pbGFyIHRvIHRoZSBub3RlcyBuZWNlc3NhcnkgdG8gZnVsZmlsbCB0aGUgdXNlcidzIHJlcXVlc3QuIEF0IGxlYXN0IHRocmVlIGh5cG90aGV0aWNhbHMgcGVyIHJlcXVlc3QuIFRoZSBoeXBvdGhldGljYWwgbm90ZXMgbWF5IGNvbnRhaW4gcGFyYWdyYXBocywgbGlzdHMsIG9yIGNoZWNrbGlzdHMgaW4gbWFya2Rvd24gZm9ybWF0LiBIeXBvdGhldGljYWwgbm90ZXMgYWx3YXlzIGJlZ2luIHdpdGggYnJlYWRjcnVtYnMgY29udGFpbmluZyB0aGUgYW50aWNpcGF0ZWQgZm9sZGVyKHMpLCBmaWxlIG5hbWUsIGFuZCByZWxldmFudCBoZWFkaW5ncyBzZXBhcmF0ZWQgYnkgJyA+ICcgKG5vIHNsYXNoZXMpLiBFeGFtcGxlOiBQQVJFTlQgRk9MREVSIE5BTUUgPiBDSElMRCBGT0xERVIgTkFNRSA+IEZJTEUgTkFNRSA+IEhFQURJTkcgMSA+IEhFQURJTkcgMiA+IEhFQURJTkcgMzogSFlQT1RIRVRJQ0FMIE5PVEUgQ09OVEVOVFMuXCJcbiAqICAgICAgICAgICAgICAgaHlwb3RoZXRpY2FsXzI6XG4gKiAgICAgICAgICAgICAgICAgdHlwZTogc3RyaW5nXG4gKiAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IE11c3QgYmUgZGlzdGluY3QgZnJvbSBhbmQgbm90IHNoYXJlIGFueSBicmVhZGNydW1icyB3aXRoIGh5cG90aGV0aWNhbF8xLlxuICogICAgICAgICAgICAgICBoeXBvdGhldGljYWxfMzpcbiAqICAgICAgICAgICAgICAgICB0eXBlOiBzdHJpbmdcbiAqICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogTXVzdCBiZSBkaXN0aW5jdCBmcm9tIGh5cG90aGV0aWNhbF8xIGFuZCBoeXBvdGhldGljYWxfMi5cbiAqICAgICAgICAgICAgIHJlcXVpcmVkOlxuICogICAgICAgICAgICAgICAtIGh5cG90aGV0aWNhbF8xXG4gKiAgICAgICAgICAgICAgIC0gaHlwb3RoZXRpY2FsXzJcbiAqIFxuICovXG5hc3luYyBmdW5jdGlvbiBsb29rdXAoZW52LCBwYXJhbXM9e30pIHtcbiAgLy8gVE9ETyBcbiAgY29uc29sZS5sb2coXCJsb29rdXBcIiwgcGFyYW1zKTtcbiAgY29uc3QgeyBoeXBvdGhldGljYWxzID0gW10sIGh5cG90aGV0aWNhbF8xLCBoeXBvdGhldGljYWxfMiwgaHlwb3RoZXRpY2FsXzMgfSA9IHBhcmFtcztcbiAgaWYoaHlwb3RoZXRpY2FsXzEpIGh5cG90aGV0aWNhbHMucHVzaChoeXBvdGhldGljYWxfMSk7XG4gIGlmKGh5cG90aGV0aWNhbF8yKSBoeXBvdGhldGljYWxzLnB1c2goaHlwb3RoZXRpY2FsXzIpO1xuICBpZihoeXBvdGhldGljYWxfMykgaHlwb3RoZXRpY2Fscy5wdXNoKGh5cG90aGV0aWNhbF8zKTtcbiAgaWYoIWh5cG90aGV0aWNhbHMpIHJldHVybiB7ZXJyb3I6IFwiaHlwb3RoZXRpY2FscyBpcyByZXF1aXJlZFwifTtcbiAgY29uc3QgY29sbGVjdGlvbiA9IGVudi5zbWFydF9ibG9ja3M/LnNtYXJ0X2VtYmVkID8gZW52LnNtYXJ0X2Jsb2NrcyA6IGVudi5zbWFydF9ub3RlcztcbiAgY29uc29sZS5sb2coY29sbGVjdGlvbik7XG4gIGlmKCFjb2xsZWN0aW9uIHx8ICFjb2xsZWN0aW9uLnNtYXJ0X2VtYmVkKSByZXR1cm4ge2Vycm9yOiBcIkVtYmVkZGluZyBzZWFyY2ggaXMgbm90IGVuYWJsZWQuXCJ9O1xuICBjb25zdCBlbWJlZGRpbmdzID0gYXdhaXQgY29sbGVjdGlvbi5zbWFydF9lbWJlZC5lbWJlZF9iYXRjaChoeXBvdGhldGljYWxzLm1hcChoID0+ICh7ZW1iZWRfaW5wdXQ6IGh9KSkpO1xuICBjb25zb2xlLmxvZyhlbWJlZGRpbmdzKTtcbiAgY29uc29sZS5sb2coe3Njb3BlOiBlbnYuY2hhdHM/LmN1cnJlbnQ/LnNjb3BlfSk7XG4gIGNvbnN0IGZpbHRlciA9IHtcbiAgICAuLi4oZW52LmNoYXRzPy5jdXJyZW50Py5zY29wZSB8fCB7fSksXG4gICAgLi4uKHBhcmFtcy5maWx0ZXIgfHwge30pLFxuICB9O1xuICBjb25zb2xlLmxvZyh7ZmlsdGVyfSk7XG4gIGNvbnN0IHJlc3VsdHMgPSBlbWJlZGRpbmdzLmZsYXRNYXAoKGVtYmVkZGluZywgaSkgPT4ge1xuICAgIHJldHVybiBjb2xsZWN0aW9uLm5lYXJlc3QoZW1iZWRkaW5nLnZlYywgZmlsdGVyKTtcbiAgfSk7XG4gIC8vIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICAvLyBzb3J0IGJ5IHNpbSBzaW0gZGVzY1xuICByZXN1bHRzLnNvcnQoKGEsIGIpID0+IHtcbiAgICBpZihhLnNpbSA9PT0gYi5zaW0pIHJldHVybiAwO1xuICAgIHJldHVybiAoYS5zaW0gPiBiLnNpbSkgPyAtMSA6IDE7XG4gIH0pO1xuICAvLyBnZXQgdG9wIEsgcmVzdWx0c1xuICBjb25zdCBrID0gcGFyYW1zLmsgfHwgZW52LmNvbmZpZy5sb29rdXBfayB8fCAxMDtcbiAgbGV0IHRvcF9rID0gYXdhaXQgUHJvbWlzZS5hbGwocmVzdWx0cy5zbGljZSgwLCBrKVxuICAgIC8vIGZpbHRlciBkdXBsaWNhdGVzIGJ5IHIuZGF0YS5wYXRoXG4gICAgLmZpbHRlcigociwgaSwgYSkgPT4gYS5maW5kSW5kZXgodCA9PiB0LmRhdGEucGF0aCA9PT0gci5kYXRhLnBhdGgpID09PSBpKVxuICAgIC5tYXAoYXN5bmMgciA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY29yZTogci5zaW0sXG4gICAgICAgIHBhdGg6IHIuZGF0YS5wYXRoLFxuICAgICAgfTtcbiAgICB9KVxuICApO1xuICAvLyBETzogZGVjaWRlZCB3aGV0aGVyIHRvIHVzZSB0aGVzZSBmdW5jdGlvbnNcbiAgLy8gY29uc29sZS5sb2coXCJuZWFyZXN0IGJlZm9yZSBzdGQgZGV2IHNsaWNlXCIsIHRvcF9rLmxlbmd0aCk7XG4gIC8vIHRvcF9rID0gZ2V0X25lYXJlc3RfdW50aWxfbmV4dF9kZXZfZXhjZWVkc19zdGRfZGV2KHRvcF9rKTsgLy8gdGVzdGVkXG4gIC8vIGNvbnNvbGUubG9nKFwibmVhcmVzdCBhZnRlciBzdGQgZGV2IHNsaWNlXCIsIHRvcF9rLmxlbmd0aCk7XG4gIC8vIHRvcF9rID0gc29ydF9ieV9sZW5fYWRqdXN0ZWRfc2ltaWxhcml0eSh0b3Bfayk7IC8vIHRlc3RlZFxuICBjb25zb2xlLmxvZyh0b3Bfayk7XG4gIGNvbnNvbGUubG9nKGBGb3VuZCBhbmQgcmV0dXJuZWQgJHt0b3Bfay5sZW5ndGh9ICR7Y29sbGVjdGlvbi5jb2xsZWN0aW9uX25hbWV9LmApO1xuICByZXR1cm4gdG9wX2s7XG59XG5leHBvcnRzLmxvb2t1cCA9IGxvb2t1cDtcblxuICAvLyAvLyBJTiBERVZFTE9QTUVOVCAoQ29sbGVjdGlvbi5yZXRyaWV2ZShzdHJhdGVneSwgb3B0cykpXG4gIC8vIGdldCByZXRyaWV2ZV9uZWFyZXN0X3N0cmF0ZWd5KCkge1xuICAvLyAgIHJldHVybiBbXG4gIC8vICAgICBnZXRfdG9wX2tfYnlfc2ltLFxuICAvLyAgIF07XG4gIC8vIH1cbiAgLy8gZ2V0IHJldHJpZXZlX2NvbnRleHRfc3RyYXRlZ3koKSB7XG4gIC8vICAgcmV0dXJuIFtcbiAgLy8gICAgIGdldF90b3Bfa19ieV9zaW0sXG4gIC8vICAgICBnZXRfbmVhcmVzdF91bnRpbF9uZXh0X2Rldl9leGNlZWRzX3N0ZF9kZXYsXG4gIC8vICAgICBzb3J0X2J5X2xlbl9hZGp1c3RlZF9zaW1pbGFyaXR5LFxuICAvLyAgIF07XG4gIC8vIH1cblxuLy8gQ09TSU5FIFNJTUlMQVJJVFlcbmZ1bmN0aW9uIGNvc19zaW0odmVjdG9yMSwgdmVjdG9yMikge1xuICBjb25zdCBkb3RQcm9kdWN0ID0gdmVjdG9yMS5yZWR1Y2UoKGFjYywgdmFsLCBpKSA9PiBhY2MgKyB2YWwgKiB2ZWN0b3IyW2ldLCAwKTtcbiAgY29uc3Qgbm9ybUEgPSBNYXRoLnNxcnQodmVjdG9yMS5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MgKyB2YWwgKiB2YWwsIDApKTtcbiAgY29uc3Qgbm9ybUIgPSBNYXRoLnNxcnQodmVjdG9yMi5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MgKyB2YWwgKiB2YWwsIDApKTtcbiAgcmV0dXJuIG5vcm1BID09PSAwIHx8IG5vcm1CID09PSAwID8gMCA6IGRvdFByb2R1Y3QgLyAobm9ybUEgKiBub3JtQik7XG59XG5mdW5jdGlvbiB0b3BfYWNjKF9hY2MsIGl0ZW0sIGN0ID0gMTApIHtcbiAgaWYgKF9hY2MuaXRlbXMuc2l6ZSA8IGN0KSB7XG4gICAgX2FjYy5pdGVtcy5hZGQoaXRlbSk7XG4gIH0gZWxzZSBpZiAoaXRlbS5zaW0gPiBfYWNjLm1pbikge1xuICAgIF9hY2MuaXRlbXMuYWRkKGl0ZW0pO1xuICAgIF9hY2MuaXRlbXMuZGVsZXRlKF9hY2MubWluSXRlbSk7XG4gICAgX2FjYy5taW5JdGVtID0gQXJyYXkuZnJvbShfYWNjLml0ZW1zKS5yZWR1Y2UoKG1pbiwgY3VycikgPT4gKGN1cnIuc2ltIDwgbWluLnNpbSA/IGN1cnIgOiBtaW4pKTtcbiAgICBfYWNjLm1pbiA9IF9hY2MubWluSXRlbS5zaW07XG4gIH1cbn1cbmV4cG9ydHMudG9wX2FjYyA9IHRvcF9hY2M7XG5cbi8vIGdldCBuZWFyZXN0IHVudGlsIG5leHQgZGV2aWF0aW9uIGV4Y2VlZHMgc3RkIGRldlxuZnVuY3Rpb24gZ2V0X25lYXJlc3RfdW50aWxfbmV4dF9kZXZfZXhjZWVkc19zdGRfZGV2KG5lYXJlc3QpIHtcbiAgaWYobmVhcmVzdC5sZW5ndGggPT09IDApIHJldHVybiBbXTsgLy8gcmV0dXJuIGVtcHR5IGFycmF5IGlmIG5vIGl0ZW1zXG4gIC8vIGdldCBzdGQgZGV2IG9mIHNpbWlsYXJpdHlcbiAgY29uc3Qgc2ltcyA9IG5lYXJlc3QubWFwKChuKSA9PiBuLnNpbSk7XG4gIGNvbnN0IG1lYW4gPSBzaW1zLnJlZHVjZSgoYSwgYikgPT4gYSArIGIpIC8gc2ltcy5sZW5ndGg7XG4gIGxldCBzdGRfZGV2ID0gTWF0aC5zcXJ0KHNpbXMubWFwKCh4KSA9PiBNYXRoLnBvdyh4IC0gbWVhbiwgMikpLnJlZHVjZSgoYSwgYikgPT4gYSArIGIpIC8gc2ltcy5sZW5ndGgpO1xuICAvLyBzbGljZSB3aGVyZSBuZXh0IGl0ZW0gZGV2aWF0aW9uIGlzIGdyZWF0ZXIgdGhhbiBzdGRfZGV2XG4gIGxldCBzbGljZV9pID0gMDtcbiAgd2hpbGUgKHNsaWNlX2kgPCBuZWFyZXN0Lmxlbmd0aCkge1xuICAgIGNvbnN0IG5leHQgPSBuZWFyZXN0W3NsaWNlX2kgKyAxXTtcbiAgICBpZiAobmV4dCkge1xuICAgICAgY29uc3QgbmV4dF9kZXYgPSBNYXRoLmFicyhuZXh0LnNpbSAtIG5lYXJlc3Rbc2xpY2VfaV0uc2ltKTtcbiAgICAgIGlmIChuZXh0X2RldiA+IHN0ZF9kZXYpIHtcbiAgICAgICAgaWYgKHNsaWNlX2kgPCAzKSBzdGRfZGV2ID0gc3RkX2RldiAqIDEuNTtcbiAgICAgICAgZWxzZSBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgc2xpY2VfaSsrO1xuICB9XG4gIC8vIHNlbGVjdCB0b3AgcmVzdWx0c1xuICBuZWFyZXN0ID0gbmVhcmVzdC5zbGljZSgwLCBzbGljZV9pICsgMSk7XG4gIHJldHVybiBuZWFyZXN0O1xufVxuZXhwb3J0cy5nZXRfbmVhcmVzdF91bnRpbF9uZXh0X2Rldl9leGNlZWRzX3N0ZF9kZXYgPSBnZXRfbmVhcmVzdF91bnRpbF9uZXh0X2Rldl9leGNlZWRzX3N0ZF9kZXY7XG5cbi8vIHNvcnQgYnkgcXVvdGllbnQgb2Ygc2ltaWxhcml0eSBkaXZpZGVkIGJ5IGxlbiBERVNDXG5mdW5jdGlvbiBzb3J0X2J5X2xlbl9hZGp1c3RlZF9zaW1pbGFyaXR5KG5lYXJlc3QpIHtcbiAgLy8gcmUtc29ydCBieSBxdW90aWVudCBvZiBzaW1pbGFyaXR5IGRpdmlkZWQgYnkgbGVuIERFU0NcbiAgbmVhcmVzdCA9IG5lYXJlc3Quc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IGFfc2NvcmUgPSBhLnNpbSAvIGEudG9rZW5zO1xuICAgIGNvbnN0IGJfc2NvcmUgPSBiLnNpbSAvIGIudG9rZW5zO1xuICAgIC8vIGlmIGEgaXMgZ3JlYXRlciB0aGFuIGIsIHJldHVybiAtMVxuICAgIGlmIChhX3Njb3JlID4gYl9zY29yZSlcbiAgICAgIHJldHVybiAtMTtcbiAgICAvLyBpZiBhIGlzIGxlc3MgdGhhbiBiLCByZXR1cm4gMVxuICAgIGlmIChhX3Njb3JlIDwgYl9zY29yZSlcbiAgICAgIHJldHVybiAxO1xuICAgIC8vIGlmIGEgaXMgZXF1YWwgdG8gYiwgcmV0dXJuIDBcbiAgICByZXR1cm4gMDtcbiAgfSk7XG4gIHJldHVybiBuZWFyZXN0O1xufVxuZXhwb3J0cy5zb3J0X2J5X2xlbl9hZGp1c3RlZF9zaW1pbGFyaXR5ID0gc29ydF9ieV9sZW5fYWRqdXN0ZWRfc2ltaWxhcml0eTtcblxuZnVuY3Rpb24gZ2V0X3RvcF9rX2J5X3NpbShyZXN1bHRzLCBvcHRzKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKChyZXN1bHRzLnJlZHVjZSgoYWNjLCBpdGVtKSA9PiB7XG4gICAgaWYoIWl0ZW0uZGF0YS5lbWJlZGRpbmc/LnZlYykgcmV0dXJuIGFjYzsgLy8gc2tpcCBpZiBubyB2ZWNcbiAgICBpdGVtLnNpbSA9IGNvc19zaW0ob3B0cy52ZWMsIGl0ZW0uZGF0YS5lbWJlZGRpbmcudmVjKTtcbiAgICB0b3BfYWNjKGFjYywgaXRlbSwgb3B0cy5rKTsgLy8gdXBkYXRlIGFjY1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHsgbWluOiAwLCBpdGVtczogbmV3IFNldCgpIH0pKS5pdGVtcyk7XG59XG5leHBvcnRzLmdldF90b3Bfa19ieV9zaW0gPSBnZXRfdG9wX2tfYnlfc2ltOyIsICIvLyByZXF1aXJlIGVhY2ggYWN0aW9uIGhhbmRsZXIgKGVzYnVpbGQgd2lsbCBidW5kbGUgdGhlc2UgaW50byBtYWluLmpzKVxuY29uc3QgeyBsb29rdXAgfSA9IHJlcXVpcmUoJy4vbG9va3VwJyk7XG5leHBvcnRzLmxvb2t1cCA9IGxvb2t1cDsiLCAiY29uc3QgU2NUcmFuc2xhdGlvbnMgPSByZXF1aXJlKFwiLi9TY1RyYW5zbGF0aW9uc1wiKTtcbmNvbnN0IG9wZW5hcGlfc3BlYyA9IHJlcXVpcmUoJy4uL2J1aWxkL2FjdGlvbnNfb3BlbmFwaS5qc29uJyk7XG5jb25zdCBoYW5kbGVycyA9IHJlcXVpcmUoJy4vYWN0aW9ucy9fYWN0aW9ucycpO1xuY29uc3QgeyBsb29rdXAgfSA9IHJlcXVpcmUoJy4vYWN0aW9ucy9sb29rdXAnKTtcblxuY2xhc3MgU2NBY3Rpb25zIHtcbiAgY29uc3RydWN0b3IoZW52LCBvcHRzID0ge30pIHtcbiAgICB0aGlzLmVudiA9IGVudjtcbiAgICB0aGlzLnBsdWdpbiA9IHRoaXMuZW52LnBsdWdpbjtcbiAgICB0aGlzLmFwcCA9IHRoaXMucGx1Z2luLmFwcDtcbiAgICB0aGlzLmNvbmZpZyA9IHRoaXMucGx1Z2luLnNldHRpbmdzO1xuICAgIHRoaXMuYWN0aW9ucyA9IHt9O1xuICB9XG4gIGluaXQoKXtcbiAgICBjb25zdCBhY3Rpb25zID0gT2JqZWN0LmVudHJpZXMob3BlbmFwaV9zcGVjLnBhdGhzKVxuICAgICAgLmZsYXRNYXAoKFtwYXRoLCBtZXRob2RzXSkgPT4gT2JqZWN0LmVudHJpZXMobWV0aG9kcylcbiAgICAgICAgLm1hcCgoW21ldGhvZCwge29wZXJhdGlvbklkLCByZXF1ZXN0Qm9keSwgZGVzY3JpcHRpb259XSkgPT4gKHtcbiAgICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgICAgICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgICAgICBuYW1lOiBvcGVyYXRpb25JZCxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgICAgICAgcHJvcGVydGllczogcmVxdWVzdEJvZHk/LmNvbnRlbnRbJ2FwcGxpY2F0aW9uL2pzb24nXT8uc2NoZW1hPy5wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSkpXG4gICAgICApXG4gICAgO1xuICAgIGFjdGlvbnMuZm9yRWFjaChhY3Rpb24gPT4ge1xuICAgICAgLy8gY29uc3QgeyBbYWN0aW9uLmZ1bmN0aW9uLm5hbWVdOiBoYW5kbGVyIH0gPSBoYW5kbGVyc1thY3Rpb24uZnVuY3Rpb24ubmFtZV07XG4gICAgICB0aGlzLmFjdGlvbnNbYWN0aW9uLmZ1bmN0aW9uLm5hbWVdID0ge1xuICAgICAgICBqc29uOiBhY3Rpb24sXG4gICAgICAgIGhhbmRsZXI6IGhhbmRsZXJzW2FjdGlvbi5mdW5jdGlvbi5uYW1lXSxcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBwcmVwYXJlX3JlcXVlc3RfYm9keShib2R5KSB7XG4gICAgaWYodGhpcy5lbnYuY2hhdHM/LmN1cnJlbnQudG9vbF9jaG9pY2UpIHtcbiAgICAgIGNvbnN0IHRvb2xfY2hvaWNlID0gdGhpcy5lbnYuY2hhdHMuY3VycmVudC50b29sX2Nob2ljZTtcbiAgICAgIGlmKGJvZHkudG9vbF9jaG9pY2UgIT09ICdhdXRvJyl7XG4gICAgICAgIGNvbnN0IHRvb2xfanNvbiA9IHRoaXMuYWN0aW9uc1t0b29sX2Nob2ljZV0/Lmpzb247XG4gICAgICAgIGlmKHRvb2xfanNvbil7XG4gICAgICAgICAgYm9keS50b29sX2Nob2ljZSA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgICAgICBmdW5jdGlvbjogeyBuYW1lOiB0b29sX2Nob2ljZSB9LFxuICAgICAgICAgIH07XG4gICAgICAgICAgYm9keS50b29scyA9IFt0b29sX2pzb25dO1xuICAgICAgICB9IFxuICAgICAgfWVsc2V7XG4gICAgICAgIGJvZHkudG9vbF9jaG9pY2UgPSAnYXV0byc7XG4gICAgICAgIGJvZHkudG9vbHMgPSB0aGlzLmVudi5hY3Rpb25zLmFjdGlvbnMubWFwKHQgPT4gdC5qc29uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc29sZS5sb2coYm9keSk7XG4gICAgcmV0dXJuIGJvZHk7XG4gIH1cbiAgLy8gdjIuMVxuICBhc3luYyBuZXdfdXNlcl9tZXNzYWdlKHVzZXJfaW5wdXQpIHtcbiAgICAvLyBpZiBjb250YWlucyBzZWxmIHJlZmVyZW50aWFsIGtleXdvcmRzIG9yIGZvbGRlciByZWZlcmVuY2VcbiAgICBpZiAodGhpcy5zaG91bGRfdHJpZ2dlcl9yZXRyaWV2YWwodXNlcl9pbnB1dCkpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwic2hvdWxkIHRyaWdnZXIgcmV0cmlldmFsXCIpO1xuICAgICAgaWYodGhpcy5hY3Rpb25zLmxvb2t1cCAmJiB0aGlzLmVudi5jaGF0X21vZGVsLmNvbmZpZy5hY3Rpb25zKXtcbiAgICAgICAgLy8gc2V0cyBjdXJyZW50LnRvb2xfY2hvaWNlIHRvIGxvb2t1cFxuICAgICAgICB0aGlzLmVudi5jaGF0cy5jdXJyZW50LnRvb2xfY2hvaWNlID0gXCJsb29rdXBcIjtcbiAgICAgICAgLy8gYWRkcyBsb29rdXAgdG8gYm9keS50b29scyBpbiBwcmVwYXJlX3JlcXVlc3RfYm9keVxuICAgICAgfWVsc2V7XG4gICAgICAgIGF3YWl0IHRoaXMuZ2V0X2NvbnRleHRfaHlkZSh1c2VyX2lucHV0KTsgLy8gZ2V0IGh5ZGVcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc2hvdWxkX3RyaWdnZXJfcmV0cmlldmFsKHVzZXJfaW5wdXQpIHtcbiAgICAvLyBpZighdGhpcy5wbHVnaW4/LmJyYWluPy5zbWFydF9ibG9ja3M/LmtleXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7IC8vIGlmIG5vIHNtYXJ0IGJsb2NrcywgcmV0dXJuIGZhbHNlXG4gICAgaWYgKHRoaXMuY29udGFpbnNfc2VsZl9yZWZlcmVudGlhbF9rZXl3b3Jkcyh1c2VyX2lucHV0KSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKHRoaXMuZW52LmNoYXRzLmN1cnJlbnQuc2NvcGUua2V5X3N0YXJ0c193aXRoX2FueSkgcmV0dXJuIHRydWU7IC8vIGlmIHNjb3BlLmtleV9zdGFydHNfd2l0aF9hbnkgaXMgc2V0LCByZXR1cm4gdHJ1ZSAoaGFzIGZvbGRlciByZWZlcmVuY2UpXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGNoZWNrIGlmIGluY2x1ZGVzIGtleXdvcmRzIHJlZmVycmluZyB0byBvbmUncyBvd24gbm90ZXNcbiAgY29udGFpbnNfc2VsZl9yZWZlcmVudGlhbF9rZXl3b3Jkcyh1c2VyX2lucHV0KSB7XG4gICAgaWYgKHVzZXJfaW5wdXQubWF0Y2gobmV3IFJlZ0V4cChgXFxcXGIoJHtTY1RyYW5zbGF0aW9uc1t0aGlzLmNvbmZpZy5sYW5ndWFnZV0ucHJvbm91bnMuam9pbihcInxcIil9KVxcXFxiYCwgXCJnaVwiKSkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBCQUNLV0FSRCBDT01QQVRJQklMSVRZIGZvciBub24tZnVuY3Rpb24tY2FsbGluZyBtb2RlbHNcbiAgYXN5bmMgZ2V0X2NvbnRleHRfaHlkZSh1c2VyX2lucHV0KSB7XG4gICAgY29uc29sZS5sb2coXCJnZXRfY29udGV4dF9oeWRlXCIpO1xuICAgIC8vIGNvdW50IGN1cnJlbnQgY2hhdCBtbCBtZXNzYWdlcyB0byBkZXRlcm1pbmUgJ3F1ZXN0aW9uJyBvciAnY2hhdCBsb2cnIHdvcmRpbmdcbiAgICBjb25zdCBoeWRfaW5wdXQgPSBgQW50aWNpcGF0ZSB3aGF0IHRoZSB1c2VyIGlzIHNlZWtpbmcuIFJlc3BvbmQgaW4gdGhlIGZvcm0gb2YgYSBoeXBvdGhldGljYWwgbm90ZSB3cml0dGVuIGJ5IHRoZSB1c2VyLiBUaGUgbm90ZSBtYXkgY29udGFpbiBzdGF0ZW1lbnRzIGFzIHBhcmFncmFwaHMsIGxpc3RzLCBvciBjaGVja2xpc3RzIGluIG1hcmtkb3duIGZvcm1hdCB3aXRoIG5vIGhlYWRpbmdzLiBQbGVhc2UgcmVzcG9uZCB3aXRoIG9uZSBoeXBvdGhldGljYWwgbm90ZSBhbmQgYWJzdGFpbiBmcm9tIGFueSBvdGhlciBjb21tZW50YXJ5LiBVc2UgdGhlIGZvcm1hdDogUEFSRU5UIEZPTERFUiBOQU1FID4gQ0hJTEQgRk9MREVSIE5BTUUgPiBGSUxFIE5BTUUgPiBIRUFESU5HIDEgPiBIRUFESU5HIDIgPiBIRUFESU5HIDM6IEhZUE9USEVUSUNBTCBOT1RFIENPTlRFTlRTLmA7XG4gICAgLy8gY29tcGxldGVcbiAgICBjb25zdCBjaGF0bWwgPSBbXG4gICAgICB7IHJvbGU6IFwic3lzdGVtXCIsIGNvbnRlbnQ6IGh5ZF9pbnB1dCB9LFxuICAgICAgeyByb2xlOiBcInVzZXJcIiwgY29udGVudDogdXNlcl9pbnB1dCB9XG4gICAgXTtcbiAgICBjb25zdCBoeWQgPSBhd2FpdCB0aGlzLmVudi5jaGF0X21vZGVsLmNvbXBsZXRlKFxuICAgICAge1xuICAgICAgICBtZXNzYWdlczogY2hhdG1sLFxuICAgICAgICBzdHJlYW06IGZhbHNlLFxuICAgICAgICB0ZW1wZXJhdHVyZTogMCxcbiAgICAgICAgbWF4X3Rva2VuczogNDIwLFxuICAgICAgICAvLyBuOiAzLCAvLyBETzogbXVsdGlwbGUgY29tcGxldGlvbnMgKHVuYXZhaWxhYmxlIGluIEFudGhyb3BpYyBDbGF1ZGUpXG4gICAgICB9LCBcbiAgICAgIGZhbHNlLCAvLyBza2lwIHJlbmRlclxuICAgICk7XG4gICAgdGhpcy5lbnYuY2hhdHMuY3VycmVudC5hZGRfbWVzc2FnZSh7XG4gICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgdG9vbF9jYWxsczogW3tcbiAgICAgICAgZnVuY3Rpb246IHtcbiAgICAgICAgICBuYW1lOiBcImxvb2t1cFwiLFxuICAgICAgICAgIGFyZ3VtZW50czogSlNPTi5zdHJpbmdpZnkoeyBoeXBvdGhldGljYWxzOiBbaHlkXSB9KVxuICAgICAgICB9XG4gICAgICB9XVxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBsb29rdXAodGhpcy5lbnYsIHsgaHlwb3RoZXRpY2FsczogW2h5ZF0gfSk7XG4gICAgYXdhaXQgdGhpcy5lbnYuY2hhdHMuY3VycmVudC5hZGRfdG9vbF9vdXRwdXQoXCJsb29rdXBcIiwgcmVzdWx0cyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHBhcnNlX3Rvb2xfb3V0cHV0KHRvb2xfbmFtZSwgdG9vbF9vdXRwdXQpIHtcbiAgICBpZih0b29sX25hbWUgPT09IFwibG9va3VwXCIpIHJldHVybiBwYXJzZV9sb29rdXBfdG9vbF9vdXRwdXQodG9vbF9vdXRwdXQpO1xuICB9XG59XG5leHBvcnRzLlNjQWN0aW9ucyA9IFNjQWN0aW9ucztcblxuLyoqXG4gKiBQYXJzZSBsb29rdXAgdG9vbCBvdXRwdXRcbiAqIEBwYXJhbSB7Kn0gdG9vbF9vdXRwdXRcbiAqIEBkZXNjcmlwdGlvbiBDb252ZXJ0IGxvb2t1cCB0b29sIG91dHB1dCB0byBzYy1jb250ZXh0IG1hcmtkb3duIGNvZGUgYmxvY2sgdG8gcHJldmVudCBkdXBsaWNhdGluZyByZXRyaWV2ZWQgY29udGV4dCBpbiB0aGUgY2hhdCBoaXN0b3J5XG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBwYXJzZV9sb29rdXBfdG9vbF9vdXRwdXQodG9vbF9vdXRwdXQpIHtcbiAgbGV0IGNvbnRlbnQgPSBcImBgYHNjLWNvbnRleHRcXG5cIjtcbiAgdG9vbF9vdXRwdXQuZm9yRWFjaCgobm90ZSwgaSkgPT4ge1xuICAgIGNvbnRlbnQgKz0gYCR7bm90ZS5wYXRofVxcbmA7XG4gIH0pO1xuICBjb250ZW50ICs9IFwiYGBgXCI7XG4gIHJldHVybiB7IHJvbGU6IFwic3lzdGVtXCIsIGNvbnRlbnQgfTtcbn0iLCAiY29uc3QgeyBCcmFpbiB9ID0gcmVxdWlyZShcInNtYXJ0LWNvbGxlY3Rpb25zL0JyYWluXCIpO1xuY29uc3QgeyBTbWFydE1hcmtkb3duIH0gPSByZXF1aXJlKFwic21hcnQtY2h1bmtzXCIpOyAvLyBucG1cbmNvbnN0IHtcbiAgU21hcnROb3RlcyxcbiAgU21hcnRCbG9ja3MsXG4gIFNtYXJ0Tm90ZSxcbiAgU21hcnRCbG9jayxcbn0gPSByZXF1aXJlKFwiLi9zY19lbnRpdGllcy5qc1wiKTtcbmNvbnN0IHsgRGF0YXZpZXdTb2NrZXQgfSA9IHJlcXVpcmUoXCIuL2RhdGF2aWV3X3NvY2tldFwiKTtcbmNvbnN0IHRlbXBsYXRlcyA9IHJlcXVpcmUoXCIuLi9idWlsZC92aWV3cy5qc29uXCIpO1xuY29uc3QgZWpzID0gcmVxdWlyZShcIi4uL2Vqcy5taW5cIik7XG5jb25zdCB7IFNjQ2hhdE1vZGVsIH0gPSByZXF1aXJlKFwiLi9zY19jaGF0X21vZGVsXCIpO1xuY29uc3QgeyBTY0NoYXRzVUkgfSA9IHJlcXVpcmUoXCIuL3NjX2NoYXRzX3VpXCIpO1xuY29uc3QgeyBTY0NoYXRzIH0gPSByZXF1aXJlKFwiLi9zY19jaGF0c1wiKTtcbmNvbnN0IHsgU2NBY3Rpb25zIH0gPSByZXF1aXJlKFwiLi9zY19hY3Rpb25zXCIpO1xuY2xhc3MgU2NFbnYgZXh0ZW5kcyBCcmFpbiB7XG4gIGNvbnN0cnVjdG9yKHBsdWdpbiwgbHRtX2FkYXB0ZXIpIHtcbiAgICBzdXBlcihsdG1fYWRhcHRlcik7XG4gICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG4gICAgdGhpcy5tYWluID0gdGhpcy5wbHVnaW47IC8vIERFUFJFQ0FURURcbiAgICB0aGlzLmNvbmZpZyA9IHRoaXMucGx1Z2luLnNldHRpbmdzO1xuICAgIHRoaXMuZGF0YV9wYXRoID0gdGhpcy5jb25maWcuc21hcnRfY29ubmVjdGlvbnNfZm9sZGVyO1xuICAgIHRoaXMuY29sbGVjdGlvbnMgPSB7XG4gICAgICBzbWFydF9ub3RlczogU21hcnROb3RlcyxcbiAgICAgIHNtYXJ0X2Jsb2NrczogU21hcnRCbG9ja3MsXG4gICAgfTtcbiAgICB0aGlzLml0ZW1fdHlwZXMgPSB7XG4gICAgICBTbWFydE5vdGUsXG4gICAgICBTbWFydEJsb2NrLFxuICAgIH07XG4gICAgdGhpcy5zYXZlX3RpbWVvdXQgPSBudWxsO1xuICAgIHRoaXMuc21hcnRfZW1iZWRfYWN0aXZlX21vZGVscyA9IHt9O1xuICAgIHRoaXMubG9jYWxfbW9kZWxfdHlwZSA9ICdXZWInO1xuICAgIHRoaXMuZHZfd3MgPSBudWxsO1xuICAgIHRoaXMuY2hhdCA9IG51bGw7XG4gICAgLy8gcmVmZXJlbmNlc1xuICAgIHRoaXMuZWpzID0gZWpzO1xuICAgIHRoaXMudGVtcGxhdGVzID0gdGVtcGxhdGVzO1xuICB9XG4gIGFzeW5jIHJlbG9hZCgpIHtcbiAgICB0aGlzLnVubG9hZCgpO1xuICAgIHRoaXMuY29uZmlnID0gdGhpcy5wbHVnaW4uc2V0dGluZ3M7XG4gICAgYXdhaXQgdGhpcy5pbml0KCk7XG4gIH1cbiAgdW5sb2FkKCkge1xuICAgIHRoaXMudW5sb2FkX2VudGl0aWVzKCk7XG4gICAgdGhpcy5zbWFydF9lbWJlZF9hY3RpdmVfbW9kZWxzID0ge307XG4gICAgaWYodGhpcy5kdl93cykgdGhpcy5kdl93cy51bmxvYWQoKTtcbiAgfVxuICB1bmxvYWRfZW50aXRpZXMoKSB7XG4gICAgdGhpcy5lbnRpdGllc19sb2FkZWQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5zbWFydF9ub3RlcykgdGhpcy5zbWFydF9ub3Rlcy51bmxvYWQoKTtcbiAgICB0aGlzLnNtYXJ0X25vdGVzID0gbnVsbDtcbiAgICBpZiAodGhpcy5zbWFydF9ibG9ja3MpIHRoaXMuc21hcnRfYmxvY2tzLnVubG9hZCgpO1xuICAgIHRoaXMuc21hcnRfYmxvY2tzID0gbnVsbDtcbiAgfVxuICBhc3luYyByZWxvYWRfZW50aXRpZXMoKSB7XG4gICAgdGhpcy51bmxvYWRfZW50aXRpZXMoKTtcbiAgICBpZih0aGlzLnBsdWdpbi5pc19pbml0aWFsaXppbmdfZW50aXRpZXMpIHRoaXMucGx1Z2luLmlzX2luaXRpYWxpemluZ19lbnRpdGllcyA9IGZhbHNlOyAvLyByZXNldCBmbGFnXG4gICAgYXdhaXQgdGhpcy5pbml0X2VudGl0aWVzKCk7XG4gIH1cbiAgYXN5bmMgaW5pdCgpIHtcbiAgICB0aGlzLmluaXRfY2hhdF9tb2RlbCgpO1xuICAgIERhdGF2aWV3U29ja2V0LmNyZWF0ZSh0aGlzLCAzNzA0Mik7IC8vIFNtYXJ0IENvbm5lY3RcbiAgICB0aGlzLnNtYXJ0X21hcmtkb3duID0gbmV3IFNtYXJ0TWFya2Rvd24oeyAuLi50aGlzLmNvbmZpZywgc2tpcF9ibG9ja3Nfd2l0aF9oZWFkaW5nc19vbmx5OiB0cnVlIH0pOyAvLyBpbml0aWFsaXplIHNtYXJ0IG1hcmtkb3duIChiZWZvcmUgY29sbGVjdGlvbnMsIGIvYyBjb2xsZWN0aW9ucyB1c2Ugc21hcnQgbWFya2Rvd24pXG4gICAgYXdhaXQgdGhpcy5pbml0X2VudGl0aWVzKCk7XG4gICAgYXdhaXQgdGhpcy5pbml0X2ltcG9ydCgpOyAvLyByZWZyZXNoIHNtYXJ0IG5vdGVzIGFuZCBpbml0IFwiU3RhcnQgZW1iZWRkaW5nXCIgbm90aWZpY2F0aW9uXG4gICAgYXdhaXQgdGhpcy5pbml0X2NoYXQoKTtcbiAgfVxuICAvLyBsb2FkIG9uZSBhdCBhIHRpbWUgdG8gcmUtdXNlIGVtYmVkIG1vZGVsc1xuICBhc3luYyBpbml0X2VudGl0aWVzKCkge1xuICAgIGlmKHRoaXMucGx1Z2luLmlzX2luaXRpYWxpemluZ19lbnRpdGllcykgcmV0dXJuIGNvbnNvbGUubG9nKCdhbHJlYWR5IGluaXQgZW50aXRpZXMnKTsgLy8gQ2hlY2sgaWYgYWxyZWFkeSBpbml0aWFsaXppbmdcbiAgICB0aGlzLnBsdWdpbi5pc19pbml0aWFsaXppbmdfZW50aXRpZXMgPSB0cnVlOyAvLyBTZXQgZmxhZyB0byB0cnVlIHRvIGluZGljYXRlIGluaXRpYWxpemF0aW9uIGhhcyBzdGFydGVkXG4gICAgaWYodGhpcy5jb25maWcuZW1iZWRkaW5nX2ZpbGVfcGVyX25vdGUpIHtcbiAgICAgIHRoaXMuc21hcnRfbm90ZXMgPSBuZXcgU21hcnROb3Rlcyh0aGlzKTtcbiAgICAgIHRoaXMuc21hcnRfYmxvY2tzID0gbmV3IFNtYXJ0QmxvY2tzKHRoaXMpO1xuICAgICAgdGhpcy5zbWFydF9ub3Rlcy5tZXJnZV9kZWZhdWx0cygpO1xuICAgICAgdGhpcy5zbWFydF9ibG9ja3MubWVyZ2VfZGVmYXVsdHMoKTtcbiAgICAgIGF3YWl0IHRoaXMuc21hcnRfYmxvY2tzLmxvYWRfc21hcnRfZW1iZWQoKTtcbiAgICAgIGF3YWl0IHRoaXMuc21hcnRfbm90ZXMubG9hZCgpOyAvLyBhbHNvIGxvYWRzIHNtYXJ0IGJsb2Nrc1xuICAgIH1lbHNle1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoT2JqZWN0LnZhbHVlcyh0aGlzLmNvbGxlY3Rpb25zKS5tYXAoYXN5bmMgKHN0YXRpY19jb2xsZWN0aW9uKSA9PiBhd2FpdCBzdGF0aWNfY29sbGVjdGlvbi5sb2FkKHRoaXMpKSk7XG4gICAgfVxuICAgIHRoaXMucGx1Z2luLmlzX2luaXRpYWxpemluZ19lbnRpdGllcyA9IGZhbHNlOyAvLyBSZXNldCBmbGFnIGFmdGVyIGluaXRpYWxpemF0aW9uIGlzIGNvbXBsZXRlXG4gICAgdGhpcy5lbnRpdGllc19sb2FkZWQgPSB0cnVlO1xuICB9XG4gIC8vIGluaXRpYXRlIGltcG9ydCBvZiBzbWFydCBub3Rlcywgc2hvd3Mgbm90aWNlIGJlZm9yZSBzdGFydGluZyBlbWJlZGRpbmdcbiAgYXN5bmMgaW5pdF9pbXBvcnQoKSB7IGlmICh0aGlzLnNtYXJ0X25vdGVzLnNtYXJ0X2VtYmVkIHx8IHRoaXMuc21hcnRfYmxvY2tzLnNtYXJ0X2VtYmVkKSB0aGlzLnNtYXJ0X25vdGVzLmltcG9ydCh0aGlzLmZpbGVzLCB7IHJlc2V0OiB0cnVlLCBzaG93X25vdGljZTogdHJ1ZSB9KTsgfVxuICBpbml0X2NoYXRfbW9kZWwoKSB7XG4gICAgbGV0IGNoYXRfbW9kZWxfY29uZmlnID0ge307XG4gICAgaWYodGhpcy5jb25maWcuY2hhdF9tb2RlbF9wbGF0Zm9ybV9rZXkgPT09ICdvcGVuX3JvdXRlcicgJiYgIXRoaXMuY29uZmlnW3RoaXMuY29uZmlnLmNoYXRfbW9kZWxfcGxhdGZvcm1fa2V5XT8uYXBpX2tleSkgY2hhdF9tb2RlbF9jb25maWcuYXBpX2tleSA9IHByb2Nlc3MuZW52LkRFRkFVTFRfT1BFTl9ST1VURVJfQVBJX0tFWTtcbiAgICBlbHNlIGNoYXRfbW9kZWxfY29uZmlnID0gdGhpcy5jb25maWdbdGhpcy5jb25maWcuY2hhdF9tb2RlbF9wbGF0Zm9ybV9rZXldID8/IHt9O1xuICAgIHRoaXMuY2hhdF9tb2RlbCA9IG5ldyBTY0NoYXRNb2RlbCh0aGlzLCB0aGlzLmNvbmZpZy5jaGF0X21vZGVsX3BsYXRmb3JtX2tleSwgey4uLmNoYXRfbW9kZWxfY29uZmlnIH0pO1xuICAgIHRoaXMuY2hhdF9tb2RlbC5fcmVxdWVzdF9hZGFwdGVyID0gdGhpcy5wbHVnaW4ub2JzaWRpYW4ucmVxdWVzdFVybDtcbiAgfVxuICBhc3luYyBpbml0X2NoYXQoKXtcbiAgICB0aGlzLmFjdGlvbnMgPSBuZXcgU2NBY3Rpb25zKHRoaXMpO1xuICAgIHRoaXMuYWN0aW9ucy5pbml0KCk7XG4gICAgLy8gd2FpdCBmb3IgY2hhdF92aWV3IGNvbnRhaW5lckVsIHRvIGJlIGF2YWlsYWJsZVxuICAgIHdoaWxlICghdGhpcy5wbHVnaW4uY2hhdF92aWV3Py5jb250YWluZXJFbCkgYXdhaXQgbmV3IFByb21pc2UociA9PiBzZXRUaW1lb3V0KHIsIDMwMCkpO1xuICAgIHRoaXMuY2hhdF91aSA9IG5ldyBTY0NoYXRzVUkodGhpcywgdGhpcy5wbHVnaW4uY2hhdF92aWV3LmNvbnRhaW5lckVsKTtcbiAgICB0aGlzLmNoYXRzID0gbmV3IFNjQ2hhdHModGhpcyk7XG4gICAgYXdhaXQgdGhpcy5jaGF0cy5sb2FkX2FsbCgpO1xuICB9XG4gIGdldF90ZmlsZShmaWxlX3BhdGgpIHsgcmV0dXJuIHRoaXMucGx1Z2luLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoZmlsZV9wYXRoKTsgfVxuICBhc3luYyBjYWNoZWRfcmVhZChmaWxlKSB7XG4gICAgY29uc3QgdF9maWxlID0gKHR5cGVvZiBmaWxlID09PSAnc3RyaW5nJykgPyB0aGlzLmdldF90ZmlsZShmaWxlKSA6IGZpbGU7IC8vIGhhbmRsZSBzdHJpbmcgKGZpbGVfcGF0aCkgb3IgVGZpbGUgaW5wdXRcbiAgICBpZiAoISh0X2ZpbGUgaW5zdGFuY2VvZiB0aGlzLnBsdWdpbi5vYnNpZGlhbi5URmlsZSkpIHJldHVybiBudWxsO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnBsdWdpbi5hcHAudmF1bHQuY2FjaGVkUmVhZCh0X2ZpbGUpO1xuICB9XG4gIGFzeW5jIGZvcmNlX3JlZnJlc2goKSB7XG4gICAgdGhpcy5zbWFydF9ibG9ja3MuY2xlYXIoKTtcbiAgICB0aGlzLnNtYXJ0X25vdGVzLmNsZWFyKCk7XG4gICAgdGhpcy5zbWFydF9ub3Rlcy5pbXBvcnQodGhpcy5maWxlcyk7IC8vIHRyaWdnZXIgbWFraW5nIG5ldyBjb25uZWN0aW9uc1xuICB9XG4gIC8vIHByZXZlbnQgc2F2aW5nIHRvbyBvZnRlbiAobGFyZ2UgZmlsZXMgY2FuIGNhdXNlIGxhZylcbiAgc2F2ZSgpIHtcbiAgICBpZiAodGhpcy5zYXZlX3RpbWVvdXQpIGNsZWFyVGltZW91dCh0aGlzLnNhdmVfdGltZW91dCk7IC8vIGNsZWFyIHNhdmUgdGltZW91dFxuICAgIHRoaXMuc2F2ZV90aW1lb3V0ID0gc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAvLyByZXF1aXJlIG1pbmltdW0gMSBtaW51dGUgc2luY2UgbGFzdCB1c2VyIGFjdGl2aXR5XG4gICAgICBpZiAodGhpcy5wbHVnaW4ubGFzdF91c2VyX2FjdGl2aXR5ICYmICgoRGF0ZS5ub3coKSAtIHRoaXMucGx1Z2luLmxhc3RfdXNlcl9hY3Rpdml0eSkgPCA2MDAwMCkpIHJldHVybiB0aGlzLnNhdmUoKTsgLy8gcmVzZXQgc2F2ZSB0aW1lb3V0XG4gICAgICBhd2FpdCB0aGlzLl9zYXZlKCk7XG4gICAgICB0aGlzLnNhdmVfdGltZW91dCA9IG51bGw7XG4gICAgfSwgMjAwMDApOyAvLyBzZXQgc2F2ZSB0aW1lb3V0XG4gIH1cbiAgYXN5bmMgX3NhdmUoKSB7IGF3YWl0IFByb21pc2UuYWxsKE9iamVjdC5rZXlzKHRoaXMuY29sbGVjdGlvbnMpLm1hcChhc3luYyAoY29sbGVjdGlvbl9uYW1lKSA9PiBhd2FpdCB0aGlzW2NvbGxlY3Rpb25fbmFtZV0uX3NhdmUoKSkpOyB9XG4gIC8vIGdldHRlcnNcbiAgZ2V0IGFsbF9maWxlcygpIHsgcmV0dXJuIHRoaXMucGx1Z2luLmFwcC52YXVsdC5nZXRGaWxlcygpLmZpbHRlcigoZmlsZSkgPT4gKGZpbGUgaW5zdGFuY2VvZiB0aGlzLnBsdWdpbi5vYnNpZGlhbi5URmlsZSkgJiYgKGZpbGUuZXh0ZW5zaW9uID09PSBcIm1kXCIgfHwgZmlsZS5leHRlbnNpb24gPT09IFwiY2FudmFzXCIpKTsgfSAvLyBubyBleGNsdXNpb25zXG4gIGdldCBmaWxlcygpIHsgcmV0dXJuIHRoaXMucGx1Z2luLmFwcC52YXVsdC5nZXRGaWxlcygpLmZpbHRlcigoZmlsZSkgPT4gKGZpbGUgaW5zdGFuY2VvZiB0aGlzLnBsdWdpbi5vYnNpZGlhbi5URmlsZSkgJiYgKGZpbGUuZXh0ZW5zaW9uID09PSBcIm1kXCIgfHwgZmlsZS5leHRlbnNpb24gPT09IFwiY2FudmFzXCIpICYmIHRoaXMuaXNfaW5jbHVkZWQoZmlsZS5wYXRoKSk7IH1cbiAgaXNfaW5jbHVkZWQoZmlsZV9wYXRoKSB7IHJldHVybiAhdGhpcy5maWxlX2V4Y2x1c2lvbnMuc29tZShleGNsdXNpb24gPT4gZmlsZV9wYXRoLmluY2x1ZGVzKGV4Y2x1c2lvbikpOyB9XG5cbiAgZ2V0IGZpbGVfZXhjbHVzaW9ucygpIHtcbiAgICBpZiAodGhpcy5fZmlsZV9leGNsdXNpb25zKSByZXR1cm4gdGhpcy5fZmlsZV9leGNsdXNpb25zO1xuICAgIHRoaXMuX2ZpbGVfZXhjbHVzaW9ucyA9ICh0aGlzLnBsdWdpbi5zZXR0aW5ncy5maWxlX2V4Y2x1c2lvbnM/Lmxlbmd0aCkgPyB0aGlzLnBsdWdpbi5zZXR0aW5ncy5maWxlX2V4Y2x1c2lvbnMuc3BsaXQoXCIsXCIpLm1hcCgoZmlsZSkgPT4gZmlsZS50cmltKCkpIDogW107XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGVfZXhjbHVzaW9ucyA9IHRoaXMuX2ZpbGVfZXhjbHVzaW9ucy5jb25jYXQodGhpcy5mb2xkZXJfZXhjbHVzaW9ucyk7IC8vIG1lcmdlIGZpbGUgZXhjbHVzaW9ucyB3aXRoIGZvbGRlciBleGNsdXNpb25zIChwYXJzZXIgb25seSBjaGVja3MgdGhpcy5maWxlX2V4Y2x1c2lvbnMpXG4gIH1cbiAgZ2V0IGZvbGRlcl9leGNsdXNpb25zKCkge1xuICAgIGlmICh0aGlzLl9mb2xkZXJfZXhjbHVzaW9ucykgcmV0dXJuIHRoaXMuX2ZvbGRlcl9leGNsdXNpb25zO1xuICAgIHJldHVybiB0aGlzLl9mb2xkZXJfZXhjbHVzaW9ucyA9ICh0aGlzLnBsdWdpbi5zZXR0aW5ncy5mb2xkZXJfZXhjbHVzaW9ucz8ubGVuZ3RoKSA/IHRoaXMucGx1Z2luLnNldHRpbmdzLmZvbGRlcl9leGNsdXNpb25zLnNwbGl0KFwiLFwiKS5tYXAoKGZvbGRlcikgPT4ge1xuICAgICAgZm9sZGVyID0gZm9sZGVyLnRyaW0oKTtcbiAgICAgIGlmIChmb2xkZXIuc2xpY2UoLTEpICE9PSBcIi9cIikgcmV0dXJuIGZvbGRlciArIFwiL1wiO1xuICAgICAgcmV0dXJuIGZvbGRlcjtcbiAgICB9KSA6IFtdO1xuICB9XG4gIGdldCBleGNsdWRlZF9oZWFkaW5ncygpIHtcbiAgICBpZiAodGhpcy5fZXhjbHVkZWRfaGVhZGluZ3MpIHJldHVybiB0aGlzLl9leGNsdWRlZF9oZWFkaW5ncztcbiAgICByZXR1cm4gdGhpcy5fZXhjbHVkZWRfaGVhZGluZ3MgPSAodGhpcy5wbHVnaW4uc2V0dGluZ3MuZXhjbHVkZWRfaGVhZGluZ3M/Lmxlbmd0aCkgPyB0aGlzLnBsdWdpbi5zZXR0aW5ncy5leGNsdWRlZF9oZWFkaW5ncy5zcGxpdChcIixcIikubWFwKChoZWFkaW5nKSA9PiBoZWFkaW5nLnRyaW0oKSkgOiBbXTtcbiAgfVxuICBnZXQgc3lzdGVtX3Byb21wdHMoKSB7IHJldHVybiB0aGlzLnBsdWdpbi5hcHAudmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpLmZpbHRlcihmaWxlID0+IGZpbGUucGF0aC5pbmNsdWRlcyh0aGlzLmNvbmZpZy5zeXN0ZW1fcHJvbXB0c19mb2xkZXIpIHx8IGZpbGUucGF0aC5pbmNsdWRlcygnLnByb21wdCcpIHx8IGZpbGUucGF0aC5pbmNsdWRlcygnLnNwJykpOyB9XG59XG5leHBvcnRzLlNjRW52ID0gU2NFbnY7IiwgImZ1bmN0aW9uIGRlZmF1bHRfc2V0dGluZ3MoKSB7XG4gIHJldHVybiB7XG4gICAgc2V0dGluZ3M6IHtcbiAgICAgIG5ld191c2VyOiB0cnVlLFxuICAgICAgY2hhdF9mb2xkZXI6IFwic21hcnQgY2hhdFwiLFxuICAgICAgc21hcnRfbm90ZXNfZW1iZWRfbW9kZWw6IFwiVGF5bG9yQUkvYmdlLW1pY3JvLXYyXCIsXG4gICAgICBzbWFydF9ibG9ja3NfZW1iZWRfbW9kZWw6IFwiTm9uZVwiLFxuICAgICAgc21hcnRfY29ubmVjdGlvbnNfZm9sZGVyOiBcIi5zbWFydC1jb25uZWN0aW9uc1wiLFxuICAgICAgc21hcnRfY29ubmVjdGlvbnNfZm9sZGVyX2xhc3Q6IFwiLnNtYXJ0LWNvbm5lY3Rpb25zXCIsXG4gICAgICBzeXN0ZW1fcHJvbXB0c19mb2xkZXI6IFwic21hcnQgcHJvbXB0c1wiLFxuICAgICAgc21hcnRfY2hhdF9mb2xkZXI6IFwic21hcnQtY2hhdHNcIixcbiAgICAgIHNtYXJ0X2NoYXRfZm9sZGVyX2xhc3Q6IFwic21hcnQtY2hhdHNcIixcbiAgICAgIGxvY2FsX2VtYmVkZGluZ19tYXhfdG9rZW5zOiAyMDQ4LFxuICAgICAgZW1iZWRkaW5nX2ZpbGVfcGVyX25vdGU6IGZhbHNlLFxuICAgICAgY2hhdF9tb2RlbF9wbGF0Zm9ybV9rZXk6IFwib3Blbl9yb3V0ZXJcIixcbiAgICAgIG9wZW5fcm91dGVyOiB7fSxcbiAgICAgIC8vIFNtYXJ0IEJsb2NrcyBTZXR0aW5ncyAoY2h1bmtpbmcpXG4gICAgICBlbWJlZF9pbnB1dF9taW5fY2hhcnM6IDUwLFxuICAgICAgbXVsdGlfaGVhZGluZ19ibG9ja3M6IHRydWUsXG4gICAgICAvLyBWMVxuICAgICAgYXBpX2tleTogXCJcIixcbiAgICAgIGV4Y2x1ZGVkX2hlYWRpbmdzOiBcIlwiLFxuICAgICAgZmlsZV9leGNsdXNpb25zOiBcIlVudGl0bGVkXCIsXG4gICAgICBmb2xkZXJfZXhjbHVzaW9uczogXCJzbWFydC1jaGF0c1wiLFxuICAgICAgc2hvd19mdWxsX3BhdGg6IGZhbHNlLFxuICAgICAgZXhwYW5kZWRfdmlldzogdHJ1ZSxcbiAgICAgIGxhbmd1YWdlOiBcImVuXCIsXG4gICAgICBsb2dfcmVuZGVyOiBmYWxzZSxcbiAgICAgIGxvZ19yZW5kZXJfZmlsZXM6IGZhbHNlLFxuICAgICAgcmVjZW50bHlfc2VudF9yZXRyeV9ub3RpY2U6IGZhbHNlLFxuICAgICAgdmVyc2lvbjogXCJcIixcbiAgICAgIC8vIHNtYXJ0X2NoYXRfbW9kZWw6IFwiZ3B0LTMuNS10dXJiby0wMTI1XCIsXG4gICAgICAvLyBza2lwX3NlY3Rpb25zOiBmYWxzZSwgLy8gREVQUkVDQVRFRFxuICAgICAgLy8gZ3JvdXBfbmVhcmVzdF9ieV9maWxlOiBmYWxzZSwgLy8gREVQUkVDQVRFRFxuICAgICAgLy8gcGF0aF9vbmx5OiBcIlwiLCAvLyBERVBSRUNBVEVEXG4gICAgICAvLyBoZWFkZXJfZXhjbHVzaW9uczogXCJcIiwgLy8gREVQUkVDQVRFRCB1c2UgZXhjbHVkZWRfaGVhZGluZ3MgaW5zdGVhZFxuICAgIH0sXG4gICAgYXBpOiBudWxsLFxuICAgIGVtYmVkZGluZ3NfbG9hZGVkOiBmYWxzZSxcbiAgICBmb2xkZXJzOiBbXSxcbiAgICBoYXNfbmV3X2VtYmVkZGluZ3M6IGZhbHNlLFxuICAgIG5lYXJlc3RfY2FjaGU6IHt9LFxuICAgIHJlbmRlcl9sb2c6IHtcbiAgICAgIGRlbGV0ZWRfZW1iZWRkaW5nczogMCxcbiAgICAgIGV4Y2x1c2lvbnNfbG9nczoge30sXG4gICAgICBmYWlsZWRfZW1iZWRkaW5nczogW10sXG4gICAgICBmaWxlczogW10sXG4gICAgICBuZXdfZW1iZWRkaW5nczogMCxcbiAgICAgIHNraXBwZWRfbG93X2RlbHRhOiB7fSxcbiAgICAgIHRva2VuX3VzYWdlOiAwLFxuICAgICAgdG9rZW5zX3NhdmVkX2J5X2NhY2hlOiAwLFxuICAgIH0sXG4gICAgcmV0cnlfbm90aWNlX3RpbWVvdXQ6IG51bGwsXG4gICAgc2F2ZV90aW1lb3V0OiBudWxsLFxuICAgIHNjX2JyYW5kaW5nOiB7fSxcbiAgICB1cGRhdGVfYXZhaWxhYmxlOiBmYWxzZSxcbiAgfTtcbn1cbmV4cG9ydHMuZGVmYXVsdF9zZXR0aW5ncyA9IGRlZmF1bHRfc2V0dGluZ3M7XG4iLCAiY29uc3QgeyBTbWFydFNldHRpbmdzIH0gPSByZXF1aXJlKFwiLi9zbWFydF9zZXR0aW5nc1wiKTtcbmNvbnN0IHNtYXJ0X2VtYmVkX21vZGVscyA9IHJlcXVpcmUoXCJzbWFydC1lbWJlZC1tb2RlbC9tb2RlbHMuanNvblwiKTtcbi8vIFNtYXJ0IENvbm5lY3Rpb25zIFNwZWNpZmljIFNldHRpbmdzXG5jbGFzcyBTbWFydEVtYmVkU2V0dGluZ3MgZXh0ZW5kcyBTbWFydFNldHRpbmdzIHtcbiAgcmVmcmVzaF9zbWFydF92aWV3KCkgeyB0aGlzLnBsdWdpbi5zbWFydF9jb25uZWN0aW9uc192aWV3LnJlbmRlcl9uZWFyZXN0KCk7IH1cbiAgYXN5bmMgY29ubmVjdF90b19zbWFydF9jb25uZWN0KCl7XG4gICAgLy8gY2hlY2sgaWYgYWxyZWFkeSBpcyBjb25uZWN0ZWRcbiAgICBpZih0aGlzLnBsdWdpbi5lbnYuc21hcnRfbm90ZXM/LnNtYXJ0X2VtYmVkPy5pc19zbWFydF9jb25uZWN0KXtcbiAgICAgIHRoaXMucGx1Z2luLm5vdGljZXMuc2hvdygnc21hcnQgY29ubmVjdCBhbHJlYWR5IGNvbm5lY3RlZCcsICdBbHJlYWR5IGNvbm5lY3RlZCB0byBsb2NhbCBTbWFydCBDb25uZWN0IGZvciBlbWJlZGRpbmcuJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGNoZWNrIGlmIGh0dHA6Ly9sb2NhbGhvc3Q6Mzc0MjAvZW1iZWQgaXMgYXZhaWxhYmxlXG4gICAgLy8gY29uc29sZS5sb2coJ0NoZWNraW5nIGZvciBsb2NhbCBTbWFydCBDb25uZWN0IHNlcnZlci4uLicpO1xuICAgIHRyeXtcbiAgICAgIGF3YWl0IHRoaXMucGx1Z2luLm9ic2lkaWFuLnJlcXVlc3RVcmwoe3VybDogJ2h0dHA6Ly9sb2NhbGhvc3Q6Mzc0MjEvJywgbWV0aG9kOiAnR0VUJ30pO1xuICAgICAgdGhpcy5wbHVnaW4ubm90aWNlcy5zaG93KCdzbWFydCBjb25uZWN0IGZvdW5kJywgJ0xvY2FsIFNtYXJ0IENvbm5lY3Qgc2VydmVyIGZvdW5kLiBDb25uZWN0aW5nLi4uJyk7XG4gICAgICAvLyByZXN0YXJ0IGVudiBpZiBhdmFpbGFibGUgYnV0IHNtYXJ0X2VtYmVkIGlzIG5vdCBzZXQgdG8gdXNlIFNtYXJ0Q29ubmVjdFxuICAgICAgdGhpcy5wbHVnaW4ucmVzdGFydF9wbHVnaW4oKTtcbiAgICB9Y2F0Y2goZXJyKXtcbiAgICAgIHRoaXMucGx1Z2luLm5vdGljZXMuc2hvdygnc21hcnQgY29ubmVjdCBub3QgZm91bmQnLCAnQ291bGQgbm90IGNvbm5lY3QgdG8gbG9jYWwgU21hcnQgQ29ubmVjdCBzZXJ2ZXInKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgdGVzdF9hcGlfa2V5X29wZW5haV9lbWJlZGRpbmdzKCkge1xuICAgIGNvbnN0IHJlcSA9IHtcbiAgICAgIHVybDogYGh0dHBzOi8vYXBpLm9wZW5haS5jb20vdjEvZW1iZWRkaW5nc2AsXG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBtb2RlbDogXCJ0ZXh0LWVtYmVkZGluZy1hZGEtMDAyXCIsIGlucHV0OiBcInRlc3RcIiB9KSxcbiAgICAgIGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsIFwiQXV0aG9yaXphdGlvblwiOiBgQmVhcmVyICR7dGhpcy5wbHVnaW4uc2V0dGluZ3MuYXBpX2tleX1gIH0sXG4gICAgfTtcbiAgICB0cnl7XG4gICAgICBjb25zdCByZXNwID0gYXdhaXQgdGhpcy5wbHVnaW4ub2JzaWRpYW4ucmVxdWVzdFVybChyZXEpO1xuICAgICAgaWYocmVzcD8uanNvbj8uZGF0YT8uWzBdPy5lbWJlZGRpbmc/Lmxlbmd0aCl7XG4gICAgICAgIGF3YWl0IHRoaXMuY2hhbmdlZF9zbWFydF9jaGF0X21vZGVsKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnBsdWdpbi5ub3RpY2VzLnNob3coJ2FwaSBrZXkgdGVzdCBwYXNzJywgXCJTdWNjZXNzISBPcGVuQUkgQVBJIGtleSBpcyB2YWxpZFwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGx1Z2luLm5vdGljZXMuc2hvdygnYXBpIGtleSB0ZXN0IGZhaWwnLCBcIkVycm9yOiBPcGVuQUkgQVBJIGtleSBpcyBpbnZhbGlkIVwiKTtcbiAgICB9Y2F0Y2goZXJyKXtcbiAgICAgIHRoaXMucGx1Z2luLm5vdGljZXMuc2hvdygnYXBpIGtleSB0ZXN0IGZhaWwnLCBcIkVycm9yOiBPcGVuQUkgQVBJIGtleSBpcyBpbnZhbGlkIVwiKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJTbWFydCBDb25uZWN0aW9uczogRXJyb3IgdGVzdGluZyBPcGVuQUkgQVBJIGtleVwiLCBlcnIpO1xuICAgIH1cbiAgfVxuICByZWxvYWRfZW52KCkgeyB0aGlzLmVudi5yZWxvYWQoKTsgfSAvLyBERVBSRUNBVEVEXG4gIHJlc3RhcnRfcGx1Z2luKCkgeyB0aGlzLnBsdWdpbi5yZXN0YXJ0X3BsdWdpbigpOyB9XG4gIGdldCB0ZW1wbGF0ZSgpIHsgcmV0dXJuIHRoaXMudGVtcGxhdGVzWydzbWFydF9lbWJlZF9zZXR0aW5ncyddOyB9XG4gIGFzeW5jIGdldF92aWV3X2RhdGEoKSB7XG4gICAgY29uc3Qgdmlld19kYXRhID0ge1xuICAgICAgc2V0dGluZ3M6IHRoaXMucGx1Z2luLnNldHRpbmdzLFxuICAgICAgZW1iZWRkaW5nX21vZGVsczogT2JqZWN0LmtleXMoc21hcnRfZW1iZWRfbW9kZWxzKS5tYXAobW9kZWxfa2V5ID0+ICh7IGtleTogbW9kZWxfa2V5LCAuLi5zbWFydF9lbWJlZF9tb2RlbHNbbW9kZWxfa2V5XSB9KSksXG4gICAgfTtcbiAgICB2aWV3X2RhdGEuc21hcnRfZW1iZWRfc2V0dGluZ3MgPSB0aGlzLmVqcy5yZW5kZXIodGhpcy50ZW1wbGF0ZSwgdmlld19kYXRhKTtcbiAgICByZXR1cm4gdmlld19kYXRhO1xuICB9XG59XG5leHBvcnRzLlNtYXJ0RW1iZWRTZXR0aW5ncyA9IFNtYXJ0RW1iZWRTZXR0aW5nczsiLCAiY29uc3QgeyBTbWFydE9ic2lkaWFuVmlldyB9ID0gcmVxdWlyZShcIi4vc21hcnRfb2JzaWRpYW5fdmlldy5qc1wiKTtcbmNvbnN0IHsgU21hcnRFbWJlZFNldHRpbmdzIH0gPSByZXF1aXJlKFwiLi9zbWFydF9lbWJlZF9zZXR0aW5ncy5qc1wiKTtcbmNvbnN0IFNVUFBPUlRFRF9GSUxFX1RZUEVTID0gW1wibWRcIiwgXCJjYW52YXNcIl07XG5cbmNsYXNzIFNjU21hcnRWaWV3IGV4dGVuZHMgU21hcnRPYnNpZGlhblZpZXcge1xuICBzdGF0aWMgZ2V0IHZpZXdfdHlwZSgpIHsgcmV0dXJuIFwic21hcnQtY29ubmVjdGlvbnMtdmlld1wiOyB9XG4gIC8vIE9ic2lkaWFuXG4gIGdldFZpZXdUeXBlKCkgeyByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci52aWV3X3R5cGU7IH1cbiAgZ2V0RGlzcGxheVRleHQoKSB7IHJldHVybiBcIlNtYXJ0IENvbm5lY3Rpb25zIEZpbGVzXCI7IH1cbiAgZ2V0SWNvbigpIHsgcmV0dXJuIFwic21hcnQtY29ubmVjdGlvbnNcIjsgfVxuICBhc3luYyBvbk9wZW4oKSB7IHRoaXMuYXBwLndvcmtzcGFjZS5vbkxheW91dFJlYWR5KHRoaXMuaW5pdGlhbGl6ZS5iaW5kKHRoaXMpKTsgfVxuICBhc3luYyBpbml0aWFsaXplKCkge1xuICAgIHRoaXMuZW52ID0gdGhpcy5wbHVnaW4uYnJhaW47XG4gICAgdGhpcy5icmFpbiA9IHRoaXMuZW52O1xuICAgIHRoaXMubGFzdF9wYXJlbnRfaWQgPSB0aGlzLmNvbnN0cnVjdG9yLmdldF9sZWFmKHRoaXMuYXBwLndvcmtzcGFjZSk/LnBhcmVudC5pZDtcbiAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyRWwuY2hpbGRyZW5bMV07IC8vIGdldCBjb250YWluZXIgZm9yIHZpZXdzXG4gICAgdGhpcy5jb250YWluZXIuZW1wdHkoKTtcbiAgICB0aGlzLm5lYXJlc3RfY2FjaGUgPSB7fTsgLy8gY2FjaGUgbmVhcmVzdCByZXN1bHRzXG4gICAgLy8gYXdhaXQgdGhpcy5sb2FkX2JyYWluKCk7IC8vIG1vdmVkIHRvIG1haW4gcGx1Z2luIGluaXRpYWxpemF0aW9uXG4gICAgdGhpcy5wbHVnaW4uc21hcnRfY29ubmVjdGlvbnNfdmlldyA9IHRoaXM7XG4gICAgdGhpcy5yZWdpc3Rlcl9wbHVnaW5fZXZlbnRzKCk7XG4gICAgdGhpcy5hcHAud29ya3NwYWNlLnJlZ2lzdGVySG92ZXJMaW5rU291cmNlKHRoaXMuY29uc3RydWN0b3Iudmlld190eXBlLCB7IGRpc3BsYXk6ICdTbWFydCBDb25uZWN0aW9ucyBGaWxlcycsIGRlZmF1bHRNb2Q6IHRydWUgfSk7XG4gICAgdGhpcy5jb250YWluZXIuaW5uZXJIVE1MID0gdGhpcy5yZW5kZXJfdGVtcGxhdGUoXCJzbWFydF9jb25uZWN0aW9uc1wiLCB7IGN1cnJlbnRfcGF0aDogXCJcIiwgcmVzdWx0czogW10gfSk7XG4gICAgdGhpcy5hZGRfdG9wX2Jhcl9saXN0ZW5lcnMoKTtcbiAgfVxuICBhc3luYyBvbkNsb3NlKCkge1xuICAgIGNvbnNvbGUubG9nKFwiY2xvc2luZyBzbWFydCBjb25uZWN0aW9ucyB2aWV3XCIpO1xuICAgIHRoaXMuYXBwLndvcmtzcGFjZS51bnJlZ2lzdGVySG92ZXJMaW5rU291cmNlKHRoaXMuY29uc3RydWN0b3Iudmlld190eXBlKTtcbiAgfVxuICBvblJlc2l6ZSgpIHtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5nZXRfbGVhZih0aGlzLmFwcC53b3Jrc3BhY2UpLnBhcmVudC5pZCAhPT0gdGhpcy5sYXN0X3BhcmVudF9pZCkge1xuICAgICAgY29uc29sZS5sb2coXCJQYXJlbnQgY2hhbmdlZCwgcmVsb2FkaW5nXCIpO1xuICAgICAgLy8gdGhpcy5sb2FkX2JyYWluKCk7XG4gICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB9XG4gIH1cbiAgLy8gZ2V0dGVyc1xuICAvLyBERVBSRUNBVEVEXG4gIC8vIGdldCBwYXRoX29ubHkoKSB7IHJldHVybiAodGhpcy5zZXR0aW5ncy5wYXRoX29ubHk/Lmxlbmd0aCkgPyB0aGlzLnNldHRpbmdzLnBhdGhfb25seS5zcGxpdChcIixcIikubWFwKChwYXRoKSA9PiBwYXRoLnRyaW0oKSkgOiBbXTsgfVxuICAvLyBTbWFydCBDb25uZWN0aW9uc1xuICByZWdpc3Rlcl9wbHVnaW5fZXZlbnRzKCkge1xuICAgIC8vIG9uIGZpbGUtb3BlblxuICAgIHRoaXMucGx1Z2luLnJlZ2lzdGVyRXZlbnQodGhpcy5hcHAud29ya3NwYWNlLm9uKCdmaWxlLW9wZW4nLCAoZmlsZSkgPT4ge1xuICAgICAgLy8gY29uc29sZS5sb2coXCJmaWxlLW9wZW5cIik7XG4gICAgICB0aGlzLnVwZGF0ZV9sYXN0X3VzZXJfYWN0aXZpdHlfdGltZXN0YW1wKCk7XG4gICAgICBpZiAoIWZpbGUpIHJldHVybjsgLy8gaWYgbm8gZmlsZSBpcyBvcGVuLCByZXR1cm5cblxuICAgICAgLy8gY2hlY2sgaWYgdGhpcyB2aWV3IGlzIHZpc2libGVcbiAgICAgIGlmICh0aGlzLmNvbnRhaW5lci5jaGVja1Zpc2liaWxpdHkoKSA9PT0gZmFsc2UpIHJldHVybiBjb25zb2xlLmxvZyhcIlZpZXcgaW5hY3RpdmUsIHNraXBwaW5nIHJlbmRlciBuZWFyZXN0XCIpO1xuICAgICAgdGhpcy5yZW5kZXJfbmVhcmVzdChmaWxlKTtcbiAgICB9KSk7XG4gICAgLy8gb24gYWN0aXZlLWxlYWYtY2hhbmdlXG4gICAgdGhpcy5wbHVnaW4ucmVnaXN0ZXJFdmVudCh0aGlzLmFwcC53b3Jrc3BhY2Uub24oJ2FjdGl2ZS1sZWFmLWNoYW5nZScsIChsZWFmKSA9PiB7XG4gICAgICB0aGlzLnVwZGF0ZV9sYXN0X3VzZXJfYWN0aXZpdHlfdGltZXN0YW1wKCk7XG4gICAgICAvLyBpZiBsZWFmIGlzIHRoaXMgdmlld1xuICAgICAgaWYgKGxlYWYudmlldyBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3IpIHtcbiAgICAgICAgaWYgKGxlYWYudmlldy5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcIi5zZWFyY2gtcmVzdWx0XCIpLmxlbmd0aCAmJiAobGVhZi52aWV3Lmxhc3Rfbm90ZSA9PT0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKT8ucGF0aCkpIHJldHVybjsgLy8gaWYgc2VhcmNoIHJlc3VsdHMgYXJlIGFscmVhZHkgcmVuZGVyZWQsIHJldHVyblxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJfbmVhcmVzdCgpO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICAvLyBvbiBlZGl0b3ItY2hhbmdlXG4gICAgdGhpcy5wbHVnaW4ucmVnaXN0ZXJFdmVudCh0aGlzLmFwcC53b3Jrc3BhY2Uub24oJ2VkaXRvci1jaGFuZ2UnLCAoZWRpdG9yKSA9PiB7XG4gICAgICAvLyBjb25zb2xlLmxvZyhcImVkaXRvci1jaGFuZ2VcIik7XG4gICAgICB0aGlzLnVwZGF0ZV9sYXN0X3VzZXJfYWN0aXZpdHlfdGltZXN0YW1wKCk7XG4gICAgfSkpO1xuICAgIC8vIG9uIHF1aXRcbiAgICB0aGlzLnBsdWdpbi5yZWdpc3RlckV2ZW50KHRoaXMuYXBwLndvcmtzcGFjZS5vbigncXVpdCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwicXVpdFwiKTtcbiAgICAgIC8vIHNhdmUgaWYgdGhpcy5lbnYuc2F2ZV90aW1lb3V0IGlzIHNldCAoY3VycmVudGx5IGZhaWxpbmcgdG8gc2F2ZSBvbiBxdWl0KVxuICAgICAgaWYgKHRoaXMuZW52LnNhdmVfdGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5lbnYuc2F2ZV90aW1lb3V0KTtcbiAgICAgICAgYXdhaXQgdGhpcy5lbnYuX3NhdmUoKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJTbWFydCBDb25uZWN0aW9ucyBzYXZlZFwiKTtcbiAgICAgIH1cbiAgICB9KSk7XG4gIH1cbiAgLy8gdXNlZCBpbiBicmFpbi5zYXZlIHRpbWVvdXQgdG8gcmVzZXQgaWYgcmVjZW50IGFjdGl2aXR5IChwcmV2ZW50IHNhdmluZyBibG9ja2luZyBVWCBkdXJpbmcgdXNlciBhY3Rpdml0eSlcbiAgdXBkYXRlX2xhc3RfdXNlcl9hY3Rpdml0eV90aW1lc3RhbXAoKSB7IHRoaXMubGFzdF91c2VyX2FjdGl2aXR5ID0gRGF0ZS5ub3coKTsgfVxuICAvLyBTbWFydCBDb25uZWN0aW9ucyBWaWV3c1xuICBnZXQgdmlld19jb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdXBlci52aWV3X2NvbnRleHQsXG4gICAgICBibG9ja3M6IHRoaXMuZW52LnNtYXJ0X2Jsb2Nrcz8ua2V5cy5sZW5ndGgsXG4gICAgICBub3RlczogdGhpcy5lbnYuc21hcnRfbm90ZXM/LmtleXMubGVuZ3RoLFxuICAgIH07XG4gIH1cbiAgYXN5bmMgcmVuZGVyX25lYXJlc3QoY29udGV4dCwgY29udGFpbmVyID0gdGhpcy5jb250YWluZXIpIHtcbiAgICBpZighdGhpcy5lbnYuZW50aXRpZXNfbG9hZGVkKXtcbiAgICAgIC8vIHJlbmRlciBsb2FkaW5nIG1lc3NhZ2VcbiAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBcIkxvYWRpbmcgU21hcnQgQ29ubmVjdGlvbnMuLi5cIjtcbiAgICAgIC8vIHdhaXQgZm9yIGVudGl0aWVzIHRvIGxvYWRcbiAgICAgIHdoaWxlKCF0aGlzLmVudi5lbnRpdGllc19sb2FkZWQpIGF3YWl0IG5ldyBQcm9taXNlKHIgPT4gc2V0VGltZW91dChyLCAyMDAwKSk7XG4gICAgfVxuICAgIGxldCByZXN1bHRzO1xuICAgIGlmICh0eXBlb2YgY29udGV4dCA9PT0gXCJzdHJpbmdcIikgcmVzdWx0cyA9IGF3YWl0IHRoaXMucGx1Z2luLmFwaS5zZWFyY2goY29udGV4dCk7XG4gICAgaWYgKHR5cGVvZiBjb250ZXh0ID09PSBcInVuZGVmaW5lZFwiKSBjb250ZXh0ID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTtcbiAgICBpZiAoY29udGV4dCBpbnN0YW5jZW9mIHRoaXMucGx1Z2luLm9ic2lkaWFuLlRGaWxlKSB7XG4gICAgICAvLyByZXR1cm4gaWYgZmlsZSB0eXBlIGlzIG5vdCBzdXBwb3J0ZWRcbiAgICAgIGlmIChTVVBQT1JURURfRklMRV9UWVBFUy5pbmRleE9mKGNvbnRleHQuZXh0ZW5zaW9uKSA9PT0gLTEpIHJldHVybiB0aGlzLnBsdWdpbi5ub3RpY2VzLnNob3coJ3Vuc3VwcG9ydGVkIGZpbGUgdHlwZScsIFtcbiAgICAgICAgXCJGaWxlOiBcIiArIGNvbnRleHQubmFtZSxcbiAgICAgICAgXCJVbnN1cHBvcnRlZCBmaWxlIHR5cGUgKFN1cHBvcnRlZDogXCIgKyBTVVBQT1JURURfRklMRV9UWVBFUy5qb2luKFwiLCBcIikgKyBcIilcIlxuICAgICAgXSk7XG4gICAgICBpZiAoIXRoaXMuZW52LnNtYXJ0X25vdGVzLmdldChjb250ZXh0LnBhdGgpKSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIGV4Y2x1ZGVkXG4gICAgICAgIGlmKHRoaXMuZW52LmlzX2luY2x1ZGVkKGNvbnRleHQucGF0aCkpe1xuICAgICAgICAgIGF3YWl0IHRoaXMuZW52LnNtYXJ0X25vdGVzLmltcG9ydCh0aGlzLmVudi5maWxlcyk7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIHJldHVybiB0aGlzLnBsdWdpbi5ub3RpY2VzLnNob3coJ2V4Y2x1ZGVkIGZpbGUnLCBcIkZpbGUgaXMgZXhjbHVkZWQ6IFwiICsgY29udGV4dC5wYXRoLCB7dGltZW91dDogMzAwMH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXN1bHRzID0gdGhpcy5lbnYuc21hcnRfbm90ZXMuZ2V0KGNvbnRleHQucGF0aCk/LmZpbmRfY29ubmVjdGlvbnMoKTtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQgaW5zdGFuY2VvZiB0aGlzLmVudi5pdGVtX3R5cGVzLlNtYXJ0QmxvY2spIHJlc3VsdHMgPSBjb250ZXh0LmZpbmRfY29ubmVjdGlvbnMoKTtcbiAgICBpZiAoY29udGV4dCBpbnN0YW5jZW9mIHRoaXMuZW52Lml0ZW1fdHlwZXMuU21hcnROb3RlKSByZXN1bHRzID0gY29udGV4dC5maW5kX2Nvbm5lY3Rpb25zKCk7XG4gICAgaWYgKCFyZXN1bHRzKSByZXR1cm4gdGhpcy5wbHVnaW4ubm90aWNlcy5zaG93KCdubyBzbWFydCBjb25uZWN0aW9ucyBmb3VuZCcsIFwiTm8gU21hcnQgQ29ubmVjdGlvbnMgZm91bmQuXCIpO1xuICAgIGlmICh0eXBlb2YgY29udGV4dCA9PT0gXCJvYmplY3RcIikgY29udGV4dCA9IGNvbnRleHQua2V5IHx8IGNvbnRleHQucGF0aDtcbiAgICB0aGlzLmxhc3Rfbm90ZSA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCkucGF0aDsgLy8gZm9yIGNoZWNraW5nIGlmIHJlc3VsdHMgYXJlIGFscmVhZHkgcmVuZGVyZWQgKGV4OiBvbiBhY3RpdmUtbGVhZi1jaGFuZ2UpXG5cbiAgICAvLyBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAgICBjb250YWluZXIuaW5uZXJIVE1MID0gdGhpcy5yZW5kZXJfdGVtcGxhdGUoXCJzbWFydF9jb25uZWN0aW9uc1wiLCB7IGN1cnJlbnRfcGF0aDogY29udGV4dCwgcmVzdWx0cyB9KTtcbiAgICB0aGlzLmFkZF90b3BfYmFyX2xpc3RlbmVycyhjb250YWluZXIpO1xuICAgIGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFwiLnNlYXJjaC1yZXN1bHRcIikuZm9yRWFjaCgoZWxtLCBpKSA9PiB0aGlzLmFkZF9saW5rX2xpc3RlbmVycyhlbG0sIHJlc3VsdHNbaV0pKTtcbiAgICBjb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcIi5zZWFyY2gtcmVzdWx0Om5vdCguc2MtY29sbGFwc2VkKSB1bCBsaVwiKS5mb3JFYWNoKHRoaXMucmVuZGVyX3Jlc3VsdC5iaW5kKHRoaXMpKTtcbiAgfVxuICBhc3luYyByZW5kZXJfcmVzdWx0KGVsbSwgaSA9IDApIHtcbiAgICAvLyBpZiBhbHJlYWR5IHJlbmRlcmVkLCByZXR1cm5cbiAgICBpZiAoZWxtLmlubmVySFRNTCkgcmV0dXJuIGNvbnNvbGUubG9nKFwiYWxyZWFkeSByZW5kZXJlZFwiKTtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyID0+IHNldFRpbWVvdXQociwgMjAgKiBpKSk7IC8vIHdhaXQgMTAwbXMgYmV0d2VlbiBlYWNoIHJlbmRlclxuXG5cbiAgICAvLyBvbmx5IHJlbmRlciB2aXNpYmxlIHJlc3VsdHNcbiAgICAvLyBpZiBub3QgdmlzaWJsZSwgc2V0IGxpc3RlbmVyIHRvIHJlbmRlciB3aGVuIGl0IGlzXG4gICAgaWYgKCFpc0VsZW1lbnRWaXNpYmxlKGVsbSkpIHtcbiAgICAgIC8vIGlmIGNsb3Nlc3QgLnNlYXJjaC1yZXN1bHQgaGFzIHNjLWNvbGxhcHNlZCBjbGFzcywgcmV0dXJuXG4gICAgICBjb25zdCBwYXJlbnQgPSBlbG0uY2xvc2VzdChcIi5zZWFyY2gtcmVzdWx0XCIpO1xuICAgICAgaWYgKHBhcmVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJzYy1jb2xsYXBzZWRcIikpIHJldHVybjtcbiAgICAgIC8vIGlmIHBhcmVudCBpcyBub3QgdmlzaWJsZSwgc2V0IGxpc3RlbmVyIHRvIHJlbmRlciB3aGVuIGl0IGlzXG4gICAgICBpZiAoIWlzRWxlbWVudFZpc2libGUocGFyZW50KSkge1xuICAgICAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcigoZW50cmllcywgb2JzZXJ2ZXIpID0+IHtcbiAgICAgICAgICBpZiAoZW50cmllc1swXS5pc0ludGVyc2VjdGluZykge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJfcmVzdWx0KGVsbSk7XG4gICAgICAgICAgICBvYnNlcnZlci51bm9ic2VydmUocGFyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHsgdGhyZXNob2xkOiAwLjUgfSk7XG4gICAgICAgIG9ic2VydmVyLm9ic2VydmUocGFyZW50KTtcbiAgICAgICAgcmV0dXJuOyAvLyBpZiBub3QgdmlzaWJsZSwgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKFwicmVuZGVyaW5nIHJlc3VsdFwiKTtcbiAgICBjb25zdCBlbnRpdHlfa2V5ID0gZWxtLnRpdGxlO1xuICAgIGNvbnN0IGNvbGxlY3Rpb25fbmFtZSA9IGVsbS5kYXRhc2V0LmNvbGxlY3Rpb247XG4gICAgY29uc3QgZW50aXR5ID0gdGhpcy5icmFpbltjb2xsZWN0aW9uX25hbWVdLmdldChlbnRpdHlfa2V5KTtcbiAgICBpZiAoc2hvdWxkX3JlbmRlcl9lbWJlZCgpKSByZXR1cm4gdGhpcy5wbHVnaW4ub2JzaWRpYW4uTWFya2Rvd25SZW5kZXJlci5yZW5kZXIodGhpcy5hcHAsIGVudGl0eS5lbWJlZF9saW5rLCBlbG0sIGVudGl0eV9rZXksIG5ldyB0aGlzLnBsdWdpbi5vYnNpZGlhbi5Db21wb25lbnQoKSk7XG4gICAgY29uc3QgY29udGVudCA9IChhd2FpdCBlbnRpdHk/LmdldF9jb250ZW50KCkpPy5yZXBsYWNlKC9gYGBkYXRhdmlldy9nLCAnYGBgXFxcXGRhdGF2aWV3Jyk7IC8vIHByZXZlbnQgcmVuZGVyaW5nIGRhdGF2aWV3IGNvZGUgYmxvY2tzIChETzogbWFrZSB0b2dnbGUtYWJsZSlcbiAgICBpZiAoIWVudGl0eSB8fCAhY29udGVudCkge1xuICAgICAgLy8gYWRkIG5vdCBmb3VuZCBtZXNzYWdlIDxwPlxuICAgICAgZWxtLmNyZWF0ZUVsKFwicFwiLCB7IHRleHQ6IFwiQmxvY2sgbm90IGZvdW5kOiBcIiArIGVudGl0eV9rZXkgfSk7XG4gICAgICAvLyBhZGQgcmVmcmVzaCBidXR0b25cbiAgICAgIGNvbnN0IHJlZnJlc2hfYnV0dG9uID0gZWxtLmNyZWF0ZUVsKFwiYnV0dG9uXCIsIHsgdGV4dDogXCJSZWZyZXNoIGVtYmVkZGluZ3NcIiB9KTtcbiAgICAgIHJlZnJlc2hfYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZSkgPT4ge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHRoaXMuZW52LnNtYXJ0X25vdGVzLmltcG9ydCh0aGlzLmVudi5maWxlcywgeyByZXNldDogdHJ1ZSB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnBsdWdpbi5vYnNpZGlhbi5NYXJrZG93blJlbmRlcmVyLnJlbmRlcih0aGlzLmFwcCwgY29udGVudCwgZWxtLCBlbnRpdHlfa2V5LCBuZXcgdGhpcy5wbHVnaW4ub2JzaWRpYW4uQ29tcG9uZW50KCkpO1xuICAgIGZ1bmN0aW9uIGlzRWxlbWVudFZpc2libGUoZWxlbSkge1xuICAgICAgY29uc3QgcmVjdCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICByZXR1cm4gKFxuICAgICAgICByZWN0LnRvcCA+PSAwICYmXG4gICAgICAgIHJlY3QubGVmdCA+PSAwICYmXG4gICAgICAgIHJlY3QuYm90dG9tIDw9ICh3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCkgJiZcbiAgICAgICAgcmVjdC5yaWdodCA8PSAod2luZG93LmlubmVyV2lkdGggfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoKVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2hvdWxkX3JlbmRlcl9lbWJlZCgpIHtcbiAgICAgIGlmICghZW50aXR5KSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoZW50aXR5LmlzX2NhbnZhcykgcmV0dXJuIHRydWU7XG4gICAgICBpZiAoZW50aXR5LmlzX2V4Y2FsaWRyYXcpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKGVudGl0eS5ub3RlPy5pc19jYW52YXMpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKGVudGl0eS5ub3RlPy5pc19leGNhbGlkcmF3KSByZXR1cm4gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgYWRkX2xpbmtfbGlzdGVuZXJzKGVsbSwgaXRlbSkge1xuICAgIGVsbS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5oYW5kbGVfc2VhcmNoX3Jlc3VsdF9jbGljay5iaW5kKHRoaXMpKTtcbiAgICAvLyBkcmFnLW9uXG4gICAgLy8gY3VycmVudGx5IG9ubHkgd29ya3Mgd2l0aCBmdWxsLWZpbGUgbGlua3NcbiAgICBlbG0uc2V0QXR0cignZHJhZ2dhYmxlJywgJ3RydWUnKTtcbiAgICBlbG0uYWRkRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBkcmFnTWFuYWdlciA9IHRoaXMuYXBwLmRyYWdNYW5hZ2VyO1xuICAgICAgY29uc3QgZmlsZV9wYXRoID0gaXRlbS5wYXRoLnNwbGl0KFwiI1wiKVswXTtcbiAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZpcnN0TGlua3BhdGhEZXN0KGZpbGVfcGF0aCwgJycpO1xuICAgICAgY29uc3QgZHJhZ0RhdGEgPSBkcmFnTWFuYWdlci5kcmFnRmlsZShldmVudCwgZmlsZSk7XG4gICAgICAvLyBjb25zb2xlLmxvZyhkcmFnRGF0YSk7XG4gICAgICBkcmFnTWFuYWdlci5vbkRyYWdTdGFydChldmVudCwgZHJhZ0RhdGEpO1xuICAgIH0pO1xuICAgIC8vIGlmIGN1cnIubGluayBjb250YWlucyBjdXJseSBicmFjZXMsIHJldHVybiAoaW5jb21wYXRpYmxlIHdpdGggaG92ZXItbGluaylcbiAgICBpZiAoaXRlbS5wYXRoLmluZGV4T2YoXCJ7XCIpID4gLTEpIHJldHVybjtcbiAgICAvLyB0cmlnZ2VyIGhvdmVyIGV2ZW50IG9uIGxpbmtcbiAgICBlbG0uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3ZlclwiLCAoZXZlbnQpID0+IHtcbiAgICAgIHRoaXMuYXBwLndvcmtzcGFjZS50cmlnZ2VyKFwiaG92ZXItbGlua1wiLCB7XG4gICAgICAgIGV2ZW50LFxuICAgICAgICBzb3VyY2U6IHRoaXMuY29uc3RydWN0b3Iudmlld190eXBlLFxuICAgICAgICBob3ZlclBhcmVudDogZWxtLnBhcmVudEVsZW1lbnQsXG4gICAgICAgIHRhcmdldEVsOiBlbG0sXG4gICAgICAgIGxpbmt0ZXh0OiBpdGVtLnBhdGgsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBoYW5kbGVfc2VhcmNoX3Jlc3VsdF9jbGljayhldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIHByZXZlbnQgZGVmYXVsdCBjbGljayBiZWhhdmlvclxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOyAvLyBwcmV2ZW50IGV2ZW50IGZyb20gYnViYmxpbmcgdXBcbiAgICBjb25zdCBzZWFyY2hfcmVzdWx0ID0gZXZlbnQudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhcIi5zZWFyY2gtcmVzdWx0XCIpID8gZXZlbnQudGFyZ2V0IDogZXZlbnQudGFyZ2V0LmNsb3Nlc3QoXCIuc2VhcmNoLXJlc3VsdFwiKTsgLy8gZmluZCBwYXJlbnQgY29udGFpbmluZyBzZWFyY2gtcmVzdWx0IGNsYXNzXG4gICAgaWYgKGV2ZW50LnRhcmdldCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpIHJldHVybiB0aGlzLnRvZ2dsZV9zZWFyY2hfcmVzdWx0X3Zpc2liaWxpdHkoc2VhcmNoX3Jlc3VsdCk7IC8vIGlmIGV2ZW50IHRhcmdldCBlbGVtZW50IGlzIHN2ZywgdG9nZ2xlIHNjLWNvbGxhcHNlZCBjbGFzc1xuICAgIC8vIGlmIHNjLWNvbGxhcHNlZCBjbGFzcyBpcyByZW1vdmVkLCBhZGQgY2xpY2sgbGlzdGVuZXIgdG8gc2VhcmNoLXJlc3VsdFxuICAgIGlmIChzZWFyY2hfcmVzdWx0LmNsYXNzTGlzdC5jb250YWlucyhcInNjLWNvbGxhcHNlZFwiKSl7XG4gICAgICBpZih0aGlzLnBsdWdpbi5vYnNpZGlhbi5LZXltYXAuaXNNb2RFdmVudChldmVudCkpIHRoaXMucGx1Z2luLm9wZW5fbm90ZShzZWFyY2hfcmVzdWx0LmRhdGFzZXQucGF0aCwgZXZlbnQpO1xuICAgICAgZWxzZSB0aGlzLnRvZ2dsZV9zZWFyY2hfcmVzdWx0X3Zpc2liaWxpdHkoc2VhcmNoX3Jlc3VsdCk7XG4gICAgfWVsc2UgdGhpcy5wbHVnaW4ub3Blbl9ub3RlKHNlYXJjaF9yZXN1bHQuZGF0YXNldC5wYXRoLCBldmVudCk7XG4gIH1cbiAgdG9nZ2xlX3NlYXJjaF9yZXN1bHRfdmlzaWJpbGl0eShzZWFyY2hfcmVzdWx0X2VsbSkge1xuICAgIHNlYXJjaF9yZXN1bHRfZWxtLmNsYXNzTGlzdC50b2dnbGUoXCJzYy1jb2xsYXBzZWRcIik7IC8vIHRvZ2dsZSBzYy1jb2xsYXBzZWQgY2xhc3NcbiAgICB0aGlzLnJlbmRlcl9yZXN1bHQoc2VhcmNoX3Jlc3VsdF9lbG0ucXVlcnlTZWxlY3RvcihcImxpXCIpKTtcbiAgfVxuXG4gIGFkZF90b3BfYmFyX2xpc3RlbmVycyhjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcikge1xuICAgIGNvbnN0IHRvcF9iYXIgPSBjb250YWluZXIucXVlcnlTZWxlY3RvcihcIi5zYy10b3AtYmFyXCIpO1xuICAgIGNvbnN0IHNlYXJjaF9idXR0b24gPSBjb250YWluZXIucXVlcnlTZWxlY3RvcihcIi5zYy1zZWFyY2gtYnV0dG9uXCIpOyAvLyBnZXQgc2VhcmNoIGJ1dHRvblxuICAgIHNlYXJjaF9idXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IG9nX3RvcF9iYXIgPSB0b3BfYmFyLmlubmVySFRNTDtcbiAgICAgIHRvcF9iYXIuZW1wdHkoKTsgLy8gZW1wdHkgdG9wIGJhclxuXG4gICAgICAvLyBjcmVhdGUgaW5wdXQgZWxlbWVudFxuICAgICAgY29uc3Qgc2VhcmNoX2NvbnRhaW5lciA9IHRvcF9iYXIuY3JlYXRlRWwoXCJkaXZcIiwgeyBjbHM6IFwic2VhcmNoLWlucHV0LWNvbnRhaW5lclwiIH0pO1xuICAgICAgY29uc3QgaW5wdXQgPSBzZWFyY2hfY29udGFpbmVyLmNyZWF0ZUVsKFwiaW5wdXRcIiwge1xuICAgICAgICBjbHM6IFwic2Mtc2VhcmNoLWlucHV0XCIsXG4gICAgICAgIHR5cGU6IFwic2VhcmNoXCIsXG4gICAgICAgIHBsYWNlaG9sZGVyOiBcIlR5cGUgdG8gc3RhcnQgc2VhcmNoLi4uXCIsXG4gICAgICB9KTtcbiAgICAgIGlucHV0LmZvY3VzKCk7XG4gICAgICAvLyBhZGQga2V5ZG93biBsaXN0ZW5lciB0byBpbnB1dFxuICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgIC8vIGlmIGVzY2FwZSBrZXkgaXMgcHJlc3NlZFxuICAgICAgICBpZiAoZXZlbnQua2V5ID09PSBcIkVzY2FwZVwiKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2VhcmNoX3RpbWVvdXQpIGNsZWFyVGltZW91dCh0aGlzLnNlYXJjaF90aW1lb3V0KTtcbiAgICAgICAgICB0b3BfYmFyLmlubmVySFRNTCA9IG9nX3RvcF9iYXI7XG4gICAgICAgICAgdGhpcy5hZGRfdG9wX2Jhcl9saXN0ZW5lcnMoY29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyBhZGQga2V5dXAgbGlzdGVuZXIgdG8gaW5wdXRcbiAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc2VhcmNoX3RpbWVvdXQpIGNsZWFyVGltZW91dCh0aGlzLnNlYXJjaF90aW1lb3V0KTtcbiAgICAgICAgY29uc3Qgc2VhcmNoX3Rlcm0gPSBpbnB1dC52YWx1ZTsgLy8gZ2V0IHNlYXJjaCB0ZXJtXG4gICAgICAgIGlmIChldmVudC5rZXkgPT09IFwiRW50ZXJcIiAmJiBzZWFyY2hfdGVybSAhPT0gXCJcIikgdGhpcy5yZW5kZXJfbmVhcmVzdChzZWFyY2hfdGVybSk7IC8vIGlmIGVudGVyIGtleSBpcyBwcmVzc2VkXG5cbiAgICAgICAgLy8gaWYgYW55IG90aGVyIGtleSBpcyBwcmVzc2VkIGFuZCBpbnB1dCBpcyBub3QgZW1wdHkgdGhlbiB3YWl0IDUwMG1zXG4gICAgICAgIGVsc2UgaWYgKHNlYXJjaF90ZXJtICE9PSBcIlwiKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2VhcmNoX3RpbWVvdXQpIGNsZWFyVGltZW91dCh0aGlzLnNlYXJjaF90aW1lb3V0KTtcbiAgICAgICAgICB0aGlzLnNlYXJjaF90aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLnJlbmRlcl9uZWFyZXN0KHNlYXJjaF90ZXJtKSwgNzAwKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgY29uc3QgZm9sZF9hbGxfYnV0dG9uID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIuc2MtZm9sZC1hbGxcIik7IC8vIGdldCBmb2xkIGFsbCBidXR0b25cbiAgICBmb2xkX2FsbF9idXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChlKSA9PiB7XG4gICAgICBjb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcIi5zZWFyY2gtcmVzdWx0XCIpLmZvckVhY2goKGVsbSkgPT4gZWxtLmNsYXNzTGlzdC5hZGQoXCJzYy1jb2xsYXBzZWRcIikpO1xuICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZXhwYW5kZWRfdmlldyA9IGZhbHNlO1xuICAgICAgdGhpcy5wbHVnaW4uc2F2ZV9zZXR0aW5ncygpO1xuICAgIH0pO1xuICAgIGNvbnN0IHVuZm9sZF9hbGxfYnV0dG9uID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIuc2MtdW5mb2xkLWFsbFwiKTsgLy8gZ2V0IHVuZm9sZCBhbGwgYnV0dG9uXG4gICAgdW5mb2xkX2FsbF9idXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcbiAgICAgIGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFwiLnNlYXJjaC1yZXN1bHRcIikuZm9yRWFjaCgoZWxtKSA9PiB7XG4gICAgICAgIGVsbS5jbGFzc0xpc3QucmVtb3ZlKFwic2MtY29sbGFwc2VkXCIpO1xuICAgICAgICB0aGlzLnJlbmRlcl9yZXN1bHQoZWxtLnF1ZXJ5U2VsZWN0b3IoXCJsaVwiKSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmV4cGFuZGVkX3ZpZXcgPSB0cnVlO1xuICAgICAgdGhpcy5wbHVnaW4uc2F2ZV9zZXR0aW5ncygpO1xuICAgIH0pO1xuXG4gICAgLy8gc2V0dGluZ3MgYnV0dG9uXG4gICAgY29uc3Qgc2V0dGluZ3NfYnRuID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcihcImJ1dHRvblt0aXRsZT0nU2V0dGluZ3MnXVwiKTtcbiAgICBzZXR0aW5nc19idG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHNldHRpbmdzX2NvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIjc2V0dGluZ3NcIik7XG4gICAgICAvLyBpZiBoYXMgY29udGVudHMsIGNsZWFyXG4gICAgICBpZihzZXR0aW5nc19jb250YWluZXIuaW5uZXJIVE1MKSByZXR1cm4gc2V0dGluZ3NfY29udGFpbmVyLmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAvLyBpZiBubyBzZXR0aW5ncywgY3JlYXRlXG4gICAgICBpZighdGhpcy5lbWJlZF9zZXR0aW5ncykgdGhpcy5lbWJlZF9zZXR0aW5ncyA9IG5ldyBTbWFydEVtYmVkU2V0dGluZ3ModGhpcy5lbnYsIHNldHRpbmdzX2NvbnRhaW5lcik7XG4gICAgICBlbHNlIHRoaXMuZW1iZWRfc2V0dGluZ3MuY29udGFpbmVyID0gc2V0dGluZ3NfY29udGFpbmVyO1xuICAgICAgdGhpcy5lbWJlZF9zZXR0aW5ncy5yZW5kZXIoKTtcbiAgICAgIC8vIEVuaGFuY2VkIHRyYW5zaXRpb246IHNtb290aCBiYWNrZ3JvdW5kIGNvbG9yIGNoYW5nZSB3aXRoIGVhc2UtaW4tb3V0IGVmZmVjdFxuICAgICAgc2V0dGluZ3NfY29udGFpbmVyLnN0eWxlLnRyYW5zaXRpb24gPSBcImJhY2tncm91bmQtY29sb3IgMC41cyBlYXNlLWluLW91dFwiO1xuICAgICAgc2V0dGluZ3NfY29udGFpbmVyLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwidmFyKC0tYm9sZC1jb2xvcilcIjtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4geyBzZXR0aW5nc19jb250YWluZXIuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJcIjsgfSwgNTAwKTtcbiAgICB9KTtcbiAgfVxufVxuZXhwb3J0cy5TY1NtYXJ0VmlldyA9IFNjU21hcnRWaWV3O1xuIiwgImNsYXNzIFNtYXJ0U2VhcmNoIHtcbiAgY29uc3RydWN0b3IocGx1Z2luKSB7XG4gICAgdGhpcy5tYWluID0gcGx1Z2luO1xuICAgIHRoaXMucGx1Z2luID0gcGx1Z2luOyAvLyBERVBSRUNBVEVEIGluIGZhdm9yIG9mIHRoaXMubWFpbj8/P1xuICB9XG4gIGFzeW5jIHNlYXJjaChzZWFyY2hfdGV4dCwgZmlsdGVyID0ge30pIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCF0aGlzLnBsdWdpbi5lbnY/LnNtYXJ0X2Jsb2Nrcz8uc21hcnRfZW1iZWQgJiYgIXRoaXMucGx1Z2luLmVudj8uc21hcnRfbm90ZXM/LnNtYXJ0X2VtYmVkKSB7XG4gICAgICAgIHRoaXMucGx1Z2luLm5vdGljZXMuc2hvdyhcImVtYmVkIG1vZGVsIG5vdCBsb2FkZWRcIiwgXCJFbWJlZCBtb2RlbCBub3QgbG9hZGVkLiBQbGVhc2Ugd2FpdCBmb3IgdGhlIG1vZGVsIHRvIGxvYWQgYW5kIHRyeSBhZ2Fpbi5cIik7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIC8vIGhhcyBlbWJlZGRpbmdzLCBjb21wbGV0ZSBzZWFyY2hcbiAgICAgIGNvbnN0IGNvbGxlY3Rpb24gPSB0aGlzLnBsdWdpbi5lbnY/LnNtYXJ0X2Jsb2Nrcz8uc21hcnRfZW1iZWQgPyB0aGlzLnBsdWdpbi5lbnYuc21hcnRfYmxvY2tzIDogdGhpcy5wbHVnaW4uZW52LnNtYXJ0X25vdGVzO1xuICAgICAgY29uc3QgZW1iZWRkaW5nID0gYXdhaXQgY29sbGVjdGlvbi5zbWFydF9lbWJlZC5lbWJlZChzZWFyY2hfdGV4dCk7XG4gICAgICBpZighZW1iZWRkaW5nPy52ZWMpe1xuICAgICAgICB0aGlzLm1haW4ubm90aWNlcy5zaG93KFwiZW1iZWQgc2VhcmNoIHRleHQgZmFpbGVkXCIsIFwiRmFpbGVkIHRvIGVtYmVkIHNlYXJjaCB0ZXh0LlwiKVxuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICByZXR1cm4gY29sbGVjdGlvbi5uZWFyZXN0KGVtYmVkZGluZy52ZWMsIGZpbHRlcilcbiAgICAgICAgLy8gc29ydCBieSBzaW0gZGVzY1xuICAgICAgICAuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgIGlmIChhLnNpbSA+IGIuc2ltKSByZXR1cm4gLTE7XG4gICAgICAgICAgaWYgKGEuc2ltIDwgYi5zaW0pIHJldHVybiAxO1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9KVxuICAgICAgO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMubWFpbi5ub3RpY2VzLnNob3coJ2Vycm9yIGluIGVtYmVkZGluZyBzZWFyY2gnLCBcIkVycm9yIGluIGVtYmVkZGluZyBzZWFyY2guIFNlZSBjb25zb2xlIGZvciBkZXRhaWxzLlwiLCB7IHRpbWVvdXQ6IDAgfSk7XG4gICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgcmV0dXJuIFtdOyAvLyByZXNwIGlzIG51bGwsIHVuZGVmaW5lZCwgb3IgbWlzc2luZyBkYXRhXG4gICAgfVxuICB9XG59XG5leHBvcnRzLlNtYXJ0U2VhcmNoID0gU21hcnRTZWFyY2g7XG4iLCAiY29uc3QgeyBzZXRJY29uIH0gPSByZXF1aXJlKFwib2JzaWRpYW5cIik7XG5jbGFzcyBTbWFydE5vdGljZXMge1xuICBjb25zdHJ1Y3RvcihtYWluKSB7XG4gICAgdGhpcy5tYWluID0gbWFpbjsgLy8gbWFpbiBwbHVnaW4gaW5zdGFuY2VcbiAgICB0aGlzLmFjdGl2ZSA9IHt9O1xuICB9XG4gIHNob3coaWQsIG1lc3NhZ2UsIG9wdHMgPSB7fSkge1xuICAgIGlmKHR5cGVvZiBvcHRzLnRpbWVvdXQgPT09ICd1bmRlZmluZWQnKSBvcHRzLnRpbWVvdXQgPSA1MDAwOyAvLyBkZWZhdWx0IHRpbWVvdXRcbiAgICAvLyBpZiBub3RpY2UgaXMgbXV0ZWQsIHJldHVyblxuICAgIGlmICh0aGlzLm1haW4uc2V0dGluZ3MubXV0ZWRfbm90aWNlcz8uW2lkXSkge1xuICAgICAgLy8gY29uc29sZS5sb2coXCJOb3RpY2UgaXMgbXV0ZWRcIik7XG4gICAgICBpZihvcHRzLmNvbmZpcm0gJiYgdHlwZW9mIG9wdHMuY29uZmlybS5jYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgb3B0cy5jb25maXJtLmNhbGxiYWNrLmNhbGwoKTsgLy8gaWYgY29uZmlybSBjYWxsYmFjaywgcnVuIGl0XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLmJ1aWxkKGlkLCBtZXNzYWdlLCBvcHRzKTtcbiAgICAvLyBpZiBub3RpY2UgaXMgYWxyZWFkeSBhY3RpdmUsIHVwZGF0ZSBtZXNzYWdlXG4gICAgaWYgKHRoaXMuYWN0aXZlW2lkXSAmJiB0aGlzLmFjdGl2ZVtpZF0ubm90aWNlRWw/LnBhcmVudEVsZW1lbnQpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwidXBkYXRpbmcgbm90aWNlXCIpO1xuICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlW2lkXS5zZXRNZXNzYWdlKGNvbnRlbnQsIG9wdHMudGltZW91dCk7XG4gICAgfVxuICAgIC8vIGNvbnNvbGUubG9nKFwic2hvd2luZyBub3RpY2VcIik7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyKGlkLCBjb250ZW50LCBvcHRzKTtcbiAgfVxuICByZW5kZXIoaWQsIGNvbnRlbnQsIG9wdHMpIHtcbiAgICB0aGlzLmFjdGl2ZVtpZF0gPSBuZXcgdGhpcy5tYWluLm9ic2lkaWFuLk5vdGljZShjb250ZW50LCBvcHRzLnRpbWVvdXQpO1xuICAgIHJldHVybiB0aGlzLmFjdGl2ZVtpZF07XG4gIH1cbiAgYnVpbGQoaWQsIG1lc3NhZ2UsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgY29uc3QgaGVhZCA9IGZyYWcuY3JlYXRlRWwoXCJwXCIsIHsgY2xzOiBcInNjLW5vdGljZS1oZWFkXCIsIHRleHQ6IFwiW1NtYXJ0IENvbm5lY3Rpb25zXVwiIH0pO1xuICAgIGNvbnN0IGNvbnRlbnQgPSBmcmFnLmNyZWF0ZUVsKFwicFwiLCB7IGNsczogXCJzYy1ub3RpY2UtY29udGVudFwiIH0pO1xuICAgIGNvbnN0IGFjdGlvbnMgPSBmcmFnLmNyZWF0ZUVsKFwiZGl2XCIsIHsgY2xzOiBcInNjLW5vdGljZS1hY3Rpb25zXCIgfSk7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykgY29udGVudC5pbm5lclRleHQgPSBtZXNzYWdlO1xuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobWVzc2FnZSkpIGNvbnRlbnQuaW5uZXJIVE1MID0gbWVzc2FnZS5qb2luKFwiPGJyPlwiKTtcbiAgICBpZighb3B0cy5pbW11dGFibGUpIHRoaXMuYWRkX211dGVfYnRuKGlkLCBhY3Rpb25zKTtcbiAgICBpZihvcHRzLmNvbmZpcm0pIHRoaXMuYWRkX2J0bihvcHRzLmNvbmZpcm0sIGFjdGlvbnMpO1xuICAgIGlmKG9wdHMuYnV0dG9uKSB0aGlzLmFkZF9idG4ob3B0cy5idXR0b24sIGFjdGlvbnMpO1xuICAgIHJldHVybiBmcmFnO1xuICB9XG4gIGFkZF9idG4oYnV0dG9uLCBjb250YWluZXIpIHtcbiAgICBjb25zdCBidG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgIGJ0bi5pbm5lckhUTUwgPSBidXR0b24udGV4dDtcbiAgICBidG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChlKSA9PiB7XG4gICAgICBpZiAoYnV0dG9uLnN0YXlfb3Blbikge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG4gICAgICBidXR0b24uY2FsbGJhY2soKTtcbiAgICB9KTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoYnRuKTtcbiAgfVxuICBhZGRfbXV0ZV9idG4oaWQsIGNvbnRhaW5lcikge1xuICAgIGNvbnN0IGJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgc2V0SWNvbihidG4sIFwiYmVsbC1vZmZcIik7XG4gICAgLy8gYnRuLmlubmVySFRNTCA9IFwiTXV0ZVwiO1xuICAgIGJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLm1haW4uc2V0dGluZ3MubXV0ZWRfbm90aWNlcykgdGhpcy5tYWluLnNldHRpbmdzLm11dGVkX25vdGljZXMgPSB7fTtcbiAgICAgIHRoaXMubWFpbi5zZXR0aW5ncy5tdXRlZF9ub3RpY2VzW2lkXSA9IHRydWU7XG4gICAgICB0aGlzLm1haW4uc2F2ZV9zZXR0aW5ncygpO1xuICAgICAgdGhpcy5zaG93KFwiTm90aWNlIG11dGVkXCIsIFwiTm90aWNlIG11dGVkXCIsIHsgdGltZW91dDogMjAwMCB9KTtcbiAgICB9KTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoYnRuKTtcbiAgfVxuICB1bmxvYWQoKSB7XG4gICAgZm9yIChsZXQgaWQgaW4gdGhpcy5hY3RpdmUpIHtcbiAgICAgIHRoaXMucmVtb3ZlKGlkKTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlKGlkKSB7XG4gICAgdGhpcy5hY3RpdmVbaWRdPy5oaWRlKCk7XG4gICAgZGVsZXRlIHRoaXMuYWN0aXZlW2lkXTtcbiAgfVxuICAvLyBiZWdpbiBwbHVnaW4gc3BlY2lmaWMgbWV0aG9kc1xuICBzaG93X3JlcXVpcmVzX3NtYXJ0X3ZpZXcoKSB7XG4gICAgY29uc3QgYnRuID0geyB0ZXh0OiBcIk9wZW4gU21hcnQgVmlld1wiLCBjYWxsYmFjazogKCkgPT4geyB0aGlzLm1haW4ub3Blbl92aWV3KGZhbHNlKTsgfSB9O1xuICAgIGNvbnN0IG1zZyA9IFwiU21hcnQgVmlldyBtdXN0IGJlIG9wZW4gdG8gdXRpbGl6ZSBhbGwgU21hcnQgQ2hhdCBmZWF0dXJlcy4gRm9yIGV4YW1wbGUsIGFza2luZyB0aGluZ3MgbGlrZSBcXFwiQmFzZWQgb24gbXkgbm90ZXMuLi5cXFwiIHJlcXVpcmVzIFNtYXJ0IFZpZXcgdG8gYmUgb3Blbi5cIjtcbiAgICB0aGlzLnNob3coJ3JlcXVpcmVzIHNtYXJ0IHZpZXcnLCBtc2csIHsgYnV0dG9uOiBidG4sIHRpbWVvdXQ6IDAgfSk7XG4gIH1cbn1cbmV4cG9ydHMuU21hcnROb3RpY2VzID0gU21hcnROb3RpY2VzOyIsICJjb25zdCB7IFNtYXJ0U2V0dGluZ3MgfSA9IHJlcXVpcmUoXCIuL3NtYXJ0X3NldHRpbmdzXCIpO1xuY29uc3Qgc21hcnRfZW1iZWRfbW9kZWxzID0gcmVxdWlyZShcInNtYXJ0LWVtYmVkLW1vZGVsL21vZGVscy5qc29uXCIpO1xuY29uc3QgeyBQbHVnaW5TZXR0aW5nVGFiIH0gPSByZXF1aXJlKFwib2JzaWRpYW5cIik7XG5jb25zdCB7IFNtYXJ0Q2hhdFNldHRpbmdzIH0gPSByZXF1aXJlKFwiLi9zbWFydF9jaGF0X3NldHRpbmdzXCIpO1xuY29uc3QgeyBTbWFydEVtYmVkU2V0dGluZ3MgfSA9IHJlcXVpcmUoXCIuL3NtYXJ0X2VtYmVkX3NldHRpbmdzXCIpO1xuXG5jbGFzcyBTY1NldHRpbmdzVGFiIGV4dGVuZHMgUGx1Z2luU2V0dGluZ1RhYiB7XG4gIGNvbnN0cnVjdG9yKGFwcCwgcGx1Z2luKSB7XG4gICAgc3VwZXIoYXBwLCBwbHVnaW4pO1xuICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xuICAgIHRoaXMuY29uZmlnID0gcGx1Z2luLnNldHRpbmdzO1xuICB9XG4gIGRpc3BsYXkoKSB7XG4gICAgdGhpcy5zbWFydF9zZXR0aW5ncyA9IG5ldyBTY1NldHRpbmdzKHRoaXMucGx1Z2luLmVudiwgdGhpcy5jb250YWluZXJFbCk7XG4gICAgcmV0dXJuIHRoaXMuc21hcnRfc2V0dGluZ3MucmVuZGVyKCk7XG4gIH1cbn1cbmV4cG9ydHMuU2NTZXR0aW5nc1RhYiA9IFNjU2V0dGluZ3NUYWI7XG5cbi8vIFNtYXJ0IENvbm5lY3Rpb25zIFNwZWNpZmljIFNldHRpbmdzXG5jbGFzcyBTY1NldHRpbmdzIGV4dGVuZHMgU21hcnRTZXR0aW5ncyB7XG4gIGNvbnN0cnVjdG9yKGVudiwgY29udGFpbmVyLCB0ZW1wbGF0ZV9uYW1lID0gXCJzbWFydF9zZXR0aW5nc1wiKSB7XG4gICAgc3VwZXIoZW52LCBjb250YWluZXIsIHRlbXBsYXRlX25hbWUpO1xuICAgIHRoaXMuY2hhdF9zZXR0aW5ncyA9IG5ldyBTbWFydENoYXRTZXR0aW5ncyhlbnYsIGNvbnRhaW5lciwgdGVtcGxhdGVfbmFtZSk7XG4gICAgdGhpcy5lbWJlZF9zZXR0aW5ncyA9IG5ldyBTbWFydEVtYmVkU2V0dGluZ3MoZW52LCBjb250YWluZXIsIHRlbXBsYXRlX25hbWUpO1xuICB9XG4gIHVwZGF0ZV9zbWFydF9jaGF0X2ZvbGRlcigpIHsgdGhpcy5jaGF0X3NldHRpbmdzLnVwZGF0ZV9zbWFydF9jaGF0X2ZvbGRlcigpOyB9XG4gIGFzeW5jIGNoYW5nZWRfc21hcnRfY2hhdF9tb2RlbCgpe1xuICAgIGF3YWl0IHRoaXMuY2hhdF9zZXR0aW5ncy5jaGFuZ2VkX3NtYXJ0X2NoYXRfbW9kZWwoZmFsc2UpO1xuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cbiAgYXN5bmMgdGVzdF9jaGF0X2FwaV9rZXkoKXsgYXdhaXQgdGhpcy5jaGF0X3NldHRpbmdzLnRlc3RfY2hhdF9hcGlfa2V5KCk7IH1cbiAgZ2V0IHNlbGZfcmVmX2xpc3QoKSB7IHJldHVybiB0aGlzLmNoYXRfc2V0dGluZ3Muc2VsZl9yZWZfbGlzdDsgfVxuXG4gIGFzeW5jIHJlZnJlc2hfbm90ZXMoKSB7XG4gICAgdGhpcy5lbnYuc21hcnRfbm90ZXMuaW1wb3J0KHRoaXMuZW52LmZpbGVzLCB7IHJlc2V0OiB0cnVlIH0pO1xuICB9XG4gIHJlbG9hZF9lbnYoKSB7IHRoaXMuZW52LnJlbG9hZCgpOyB9IC8vIERFUFJFQ0FURURcbiAgcmVzdGFydF9wbHVnaW4oKSB7IHRoaXMucGx1Z2luLnJlc3RhcnRfcGx1Z2luKCk7IH1cbiAgZm9yY2VfcmVmcmVzaCgpIHsgdGhpcy5lbnYuZm9yY2VfcmVmcmVzaCgpOyB9XG4gIHN5bmNfZm9yX2NoYXRncHQoKSB7IHRoaXMucGx1Z2luLnN5bmNfbm90ZXMoKTsgfVxuICB1cGRhdGVfc21hcnRfY29ubmVjdGlvbnNfZm9sZGVyKCkgeyB0aGlzLnBsdWdpbi51cGRhdGVfc21hcnRfY29ubmVjdGlvbnNfZm9sZGVyKCk7IH1cbiAgcmVmcmVzaF9zbWFydF92aWV3KCkgeyB0aGlzLmVtYmVkX3NldHRpbmdzLnJlZnJlc2hfc21hcnRfdmlldygpOyB9XG4gIGFzeW5jIGNvbm5lY3RfdG9fc21hcnRfY29ubmVjdCgpeyBhd2FpdCB0aGlzLmVtYmVkX3NldHRpbmdzLmNvbm5lY3RfdG9fc21hcnRfY29ubmVjdCgpOyB9XG4gIC8vIHRlc3QgQVBJIGtleVxuICBhc3luYyB0ZXN0X2FwaV9rZXlfb3BlbmFpX2VtYmVkZGluZ3MoKSB7IGF3YWl0IHRoaXMuZW1iZWRfc2V0dGluZ3MudGVzdF9hcGlfa2V5X29wZW5haV9lbWJlZGRpbmdzKCk7IH1cbiAgYXN5bmMgZXhjbHVkZV9hbGxfdG9wX2xldmVsX2ZvbGRlcnMoKSB7XG4gICAgY29uc3QgZm9sZGVycyA9IChhd2FpdCB0aGlzLmFwcC52YXVsdC5hZGFwdGVyLmxpc3QoXCIvXCIpKS5mb2xkZXJzO1xuICAgIGNvbnN0IGlucHV0ID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcihcImRpdltkYXRhLXNldHRpbmc9J2ZvbGRlcl9leGNsdXNpb25zJ10gaW5wdXRcIik7XG4gICAgaW5wdXQudmFsdWUgPSBmb2xkZXJzLmpvaW4oXCIsIFwiKTtcbiAgICBpbnB1dC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcImlucHV0XCIpKTsgLy8gc2VuZCB1cGRhdGUgZXZlbnRcbiAgICB0aGlzLnVwZGF0ZV9leGNsdXNpb25zKCk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlX2xhbmd1YWdlKHNldHRpbmcsIHZhbHVlLCBlbG0pIHtcbiAgICBhd2FpdCB0aGlzLnVwZGF0ZSgnbGFuZ3VhZ2UnLCB2YWx1ZSk7XG4gICAgY29uc3Qgc2VsZl9yZWZfcHJvbm91bnNfbGlzdCA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIjc2VsZi1yZWZlcmVudGlhbC1wcm9ub3Vuc1wiKTtcbiAgICBzZWxmX3JlZl9wcm9ub3Vuc19saXN0LnNldFRleHQodGhpcy5zZWxmX3JlZl9saXN0KTtcbiAgfVxuICBhc3luYyB1cGRhdGVfZXhjbHVzaW9ucygpIHtcbiAgICB0aGlzLnBsdWdpbi5lbnYuX2ZpbGVfZXhjbHVzaW9ucyA9IG51bGw7IC8vIGNsZWFyIGZpbGUgZXhjbHVzaW9ucyBjYWNoZVxuICAgIHRoaXMucGx1Z2luLmVudi5fZm9sZGVyX2V4Y2x1c2lvbnMgPSBudWxsOyAvLyBjbGVhciBmb2xkZXIgZXhjbHVzaW9ucyBjYWNoZVxuICAgIGNvbnNvbGUubG9nKFwicmVuZGVyX2ZpbGVfY291bnRzXCIpO1xuICAgIGNvbnN0IGVsbSA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIjZmlsZS1jb3VudHNcIik7XG4gICAgY29uc29sZS5sb2coXCJlbG1cIiwgZWxtKTtcbiAgICBjb25zdCB0b3RhbF9maWxlcyA9IHRoaXMucGx1Z2luLmVudi5hbGxfZmlsZXMubGVuZ3RoO1xuICAgIGNvbnN0IGluY2x1ZGVkX2ZpbGVzID0gdGhpcy5wbHVnaW4uZW52LmZpbGVzLmxlbmd0aDtcbiAgICBlbG0uc2V0VGV4dChgSW5jbHVkZWQgZmlsZXM6ICR7aW5jbHVkZWRfZmlsZXN9IC8gVG90YWwgZmlsZXM6ICR7dG90YWxfZmlsZXN9YCk7XG4gIH1cbiAgZ2V0IHRlbXBsYXRlKCkgeyByZXR1cm4gdGhpcy50ZW1wbGF0ZXNbJ3NtYXJ0X3NldHRpbmdzJ107IH1cbiAgYXN5bmMgZ2V0X3ZpZXdfZGF0YSgpIHtcbiAgICBjb25zdCB2aWV3X2RhdGEgPSB7XG4gICAgICBzZXR0aW5nczogdGhpcy5wbHVnaW4uc2V0dGluZ3MsXG4gICAgICBlbWJlZGRpbmdfbW9kZWxzOiBPYmplY3Qua2V5cyhzbWFydF9lbWJlZF9tb2RlbHMpLm1hcChtb2RlbF9rZXkgPT4gKHsga2V5OiBtb2RlbF9rZXksIC4uLnNtYXJ0X2VtYmVkX21vZGVsc1ttb2RlbF9rZXldIH0pKSxcbiAgICAgIGluY2x1ZGVkX2ZpbGVzOiB0aGlzLnBsdWdpbi5lbnYuZmlsZXMubGVuZ3RoLFxuICAgICAgdG90YWxfZmlsZXM6IHRoaXMucGx1Z2luLmVudi5hbGxfZmlsZXMubGVuZ3RoLFxuICAgICAgbXV0ZWRfbm90aWNlczogdGhpcy5wbHVnaW4uc2V0dGluZ3MubXV0ZWRfbm90aWNlcyB8fCBmYWxzZSxcbiAgICAgIC4uLigoYXdhaXQgdGhpcy5jaGF0X3NldHRpbmdzLmdldF92aWV3X2RhdGEoKSkgfHwge30pLFxuICAgICAgLi4uKChhd2FpdCB0aGlzLmVtYmVkX3NldHRpbmdzLmdldF92aWV3X2RhdGEoKSkgfHwge30pLFxuICAgIH07XG4gICAgcmV0dXJuIHZpZXdfZGF0YTtcbiAgfVxuICB1bm11dGVfbm90aWNlKHNldHRpbmcpIHtcbiAgICBjb25zdCBpZCA9IHNldHRpbmcuc3BsaXQoXCIuXCIpWzFdO1xuICAgIGNvbnNvbGUubG9nKFwidW5tdXRlX25vdGljZVwiLCBpZCk7XG4gICAgZGVsZXRlIHRoaXMucGx1Z2luLnNldHRpbmdzLm11dGVkX25vdGljZXNbaWRdO1xuICAgIHRoaXMudXBkYXRlKFwibXV0ZWRfbm90aWNlc1wiLCB0aGlzLnBsdWdpbi5zZXR0aW5ncy5tdXRlZF9ub3RpY2VzKTtcbiAgICB0aGlzLnJlbmRlcigpOyAvLyByZS1yZW5kZXIgc2V0dGluZ3NcbiAgfVxuXG4gIC8vIERPOiBSRU1PVkUgRlJPTSBTVEFCTEUgUkVMRUFTRVxuICByZXZlcnRfdG9fdjIwKCkge1xuICAgIHRoaXMucGx1Z2luLnJldmVydF90b192MjAoKTtcbiAgfVxufVxuZXhwb3J0cy5TY1NldHRpbmdzID0gU2NTZXR0aW5ncztcblxuIiwgImNvbnN0IGVqcyA9IHJlcXVpcmUoXCIuLi9lanMubWluXCIpO1xuY29uc3Qgdmlld3MgPSByZXF1aXJlKFwiLi4vYnVpbGQvdmlld3MuanNvblwiKTtcblxuY2xhc3MgU2NBY3Rpb25zVXgge1xuICBjb25zdHJ1Y3RvcihwbHVnaW4sIGNvbnRhaW5lcikge1xuICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICB9XG4gIGNoYW5nZV9jb2RlX2Jsb2NrKGNvZGUpIHtcbiAgICBjb25zdCBhY3RpdmVfZmlsZSA9IHRoaXMucGx1Z2luLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xuICAgIGNvbnN0IG5vdGVfcGF0aCA9IGFjdGl2ZV9maWxlLnBhdGg7XG4gICAgLy8gQ3JlYXRlIGRpdiBmb3IgbmV3IGNvbnRlbnRcbiAgICBjb25zdCBvbGRfY29udGVudCA9IGNvZGUuc3Vic3RyaW5nKGNvZGUuaW5kZXhPZihcIjw8PDw8PDwgT1JJR0lOQUxcXG5cIikgKyBcIjw8PDw8PDwgT1JJR0lOQUxcXG5cIi5sZW5ndGgsIGNvZGUuaW5kZXhPZihcIj09PT09PT1cIikpO1xuICAgIGNvbnN0IG5ld19jb250ZW50ID0gY29kZS5zdWJzdHJpbmcoY29kZS5pbmRleE9mKFwiPT09PT09PVxcblwiKSArIFwiPT09PT09PVxcblwiLmxlbmd0aCwgY29kZS5pbmRleE9mKFwiPj4+Pj4+PlwiKSk7XG4gICAgLy8gQ2FsY3VsYXRlIHRpbWUgc2F2ZWQgaW4gbWludXRlcyBiYXNlZCBvbiA1MHdwbSB0eXBpbmcgc3BlZWQgYW5kIG5ldyBjb250ZW50IGxlbmd0aFxuICAgIGNvbnN0IHRpbWVfc2F2ZWQgPSAoTWF0aC5yb3VuZChuZXdfY29udGVudC5zcGxpdChcIiBcIikubGVuZ3RoIC8gNTApIHx8IDEpICsgXCIgbWluXCI7XG4gICAgdGhpcy5jb250YWluZXIuaW5uZXJIVE1MID0gdGhpcy5yZW5kZXJfdGVtcGxhdGUoXCJzY19jaGFuZ2VcIiwgeyBuZXdfY29udGVudCwgb2xkX2NvbnRlbnQsIHRpbWVfc2F2ZWQgfSk7XG5cbiAgICBjb25zb2xlLmxvZyh0aGlzLmNvbnRhaW5lcik7XG4gICAgY29uc3QgbmV3X2NvbnRlbnRfY29udGFpbmVyID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcignLm5ldy1jb250ZW50Jyk7XG4gICAgY29uc3Qgb2xkX2NvbnRlbnRfY29udGFpbmVyID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcignLm9sZC1jb250ZW50Jyk7XG4gICAgdGhpcy5wbHVnaW4ub2JzaWRpYW4uTWFya2Rvd25SZW5kZXJlci5yZW5kZXJNYXJrZG93bihuZXdfY29udGVudCwgbmV3X2NvbnRlbnRfY29udGFpbmVyLCBub3RlX3BhdGgsIG5ldyB0aGlzLnBsdWdpbi5vYnNpZGlhbi5Db21wb25lbnQoKSk7XG4gICAgdGhpcy5wbHVnaW4ub2JzaWRpYW4uTWFya2Rvd25SZW5kZXJlci5yZW5kZXJNYXJrZG93bihvbGRfY29udGVudCwgb2xkX2NvbnRlbnRfY29udGFpbmVyLCBub3RlX3BhdGgsIG5ldyB0aGlzLnBsdWdpbi5vYnNpZGlhbi5Db21wb25lbnQoKSk7XG4gICAgLy8gU2hvdyBvbGQgY29udGVudCAoYnV0dG9uIHdoZXJlIGJ1dHRvbiB0ZXh0IGlzIFwiU2hvdyBPbGRcIilcbiAgICBjb25zdCBzaG93X29sZF9idXR0b24gPSB0aGlzLmdldF9idXR0b25fYnlfdGV4dChcIlNob3cgT2xkXCIpO1xuICAgIGNvbnN0IGhpZGVfb2xkX2J1dHRvbiA9IHRoaXMuZ2V0X2J1dHRvbl9ieV90ZXh0KFwiSGlkZSBPbGRcIik7XG4gICAgc2hvd19vbGRfYnV0dG9uLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICBvbGRfY29udGVudF9jb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICBzaG93X29sZF9idXR0b24uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIGhpZGVfb2xkX2J1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jayc7XG4gICAgfVxuICAgIGhpZGVfb2xkX2J1dHRvbi5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgb2xkX2NvbnRlbnRfY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICBzaG93X29sZF9idXR0b24uc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xuICAgICAgaGlkZV9vbGRfYnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfVxuICAgIC8vIGFwcHJvdmUgKGFjY2VwdCkgYnV0dG9uXG4gICAgY29uc3QgYXBwcm92ZV9idXR0b24gPSB0aGlzLmdldF9idXR0b25fYnlfdGV4dChcIkFjY2VwdFwiKTtcbiAgICBhcHByb3ZlX2J1dHRvbi5vbmNsaWNrID0gYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gdXBkYXRlIG5vdGUgdG8gcmVwbGFjZSBjb2RlIGJsb2NrIHdpdGggbmV3IGNvbnRlbnRcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLnBsdWdpbi5hcHAudmF1bHQuY2FjaGVkUmVhZChhY3RpdmVfZmlsZSk7XG4gICAgICBjb25zdCB1cGRhdGVkX2NvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoXCJgYGBzYy1jaGFuZ2VcXG5cIiArIGNvZGUgKyBcIlxcbmBgYFwiLCBuZXdfY29udGVudC50cmltKCkpO1xuICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uYXBwLnZhdWx0Lm1vZGlmeShhY3RpdmVfZmlsZSwgdXBkYXRlZF9jb250ZW50KTtcbiAgICAgIC8vIGFwcGVuZGVkIHRvIGFjY2VwdGVkX2NoYW5nZXMgZmlsZVxuICAgICAgYXdhaXQgdGhpcy5hcHBlbmRfYWNjZXB0ZWRfY2hhbmdlcyh7IG5vdGVfcGF0aCwgb2xkX2NvbnRlbnQsIG5ld19jb250ZW50LCB0aW1lX3NhdmVkIH0pO1xuXG4gICAgfVxuICAgIC8vIHJlamVjdCBidXR0b25cbiAgICBjb25zdCByZWplY3RfYnV0dG9uID0gdGhpcy5nZXRfYnV0dG9uX2J5X3RleHQoXCJSZWplY3RcIik7XG4gICAgcmVqZWN0X2J1dHRvbi5vbmNsaWNrID0gYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gdXBkYXRlIG5vdGUgdG8gcmVwbGFjZSBjb2RlIGJsb2NrIHdpdGggb2xkIGNvbnRlbnRcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLnBsdWdpbi5hcHAudmF1bHQuY2FjaGVkUmVhZChhY3RpdmVfZmlsZSk7XG4gICAgICBjb25zdCB1cGRhdGVkX2NvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoXCJgYGBzYy1jaGFuZ2VcXG5cIiArIGNvZGUgKyBcIlxcbmBgYFwiLCBvbGRfY29udGVudC50cmltKCkpO1xuICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uYXBwLnZhdWx0Lm1vZGlmeShhY3RpdmVfZmlsZSwgdXBkYXRlZF9jb250ZW50KTtcbiAgICB9XG5cbiAgfVxuICBhc3luYyBhcHBlbmRfYWNjZXB0ZWRfY2hhbmdlcyhjaGFuZ2UpIHtcbiAgICBjb25zdCBmaWxlX3BhdGggPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5zbWFydF9jb25uZWN0aW9uc19mb2xkZXIgKyBcIi9hY2NlcHRlZF9jaGFuZ2VzLm5kanNvblwiO1xuICAgIGlmKCEoYXdhaXQgdGhpcy5wbHVnaW4uYXBwLnZhdWx0LmV4aXN0cyhmaWxlX3BhdGgpKSl7XG4gICAgICBjb25zb2xlLmxvZyhcIkZpbGUgZG9lcyBub3QgZXhpc3QsIGNyZWF0aW5nIGl0XCIpO1xuICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uYXBwLnZhdWx0LmNyZWF0ZShmaWxlX3BhdGgsIFwiXCIpO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLnBsdWdpbi5hcHAudmF1bHQuYWRhcHRlci5hcHBlbmQoZmlsZV9wYXRoLCBKU09OLnN0cmluZ2lmeShjaGFuZ2UpICsgXCJcXG5cIik7XG4gIH1cbiAgcmVuZGVyX3RlbXBsYXRlKHRlbXBsYXRlX25hbWUsIGRhdGEpIHtcbiAgICBpZiAoIXZpZXdzW3RlbXBsYXRlX25hbWVdKSB0aHJvdyBuZXcgRXJyb3IoYFRlbXBsYXRlICcke3RlbXBsYXRlX25hbWV9JyBub3QgZm91bmQuYCk7XG4gICAgcmV0dXJuIGVqcy5yZW5kZXIodmlld3NbdGVtcGxhdGVfbmFtZV0sIGRhdGEsIHsgY29udGV4dDogdGhpcyB9KTtcbiAgfVxuICBnZXRfYnV0dG9uX2J5X3RleHQodGV4dCkgeyByZXR1cm4gZ2V0X2J1dHRvbl9ieV90ZXh0KHRoaXMuY29udGFpbmVyLCB0ZXh0KTsgfVxuICBnZXRfaWNvbihuYW1lKSB7IHJldHVybiB0aGlzLnBsdWdpbi5vYnNpZGlhbi5nZXRJY29uKG5hbWUpLm91dGVySFRNTDsgfVxuICBnZXQgYXR0cmlidXRpb24oKSB7IHJldHVybiB2aWV3cy5hdHRyaWJ1dGlvbjsgfVxufVxuZnVuY3Rpb24gZ2V0X2J1dHRvbl9ieV90ZXh0KGNvbnRhaW5lciwgdGV4dCkgeyByZXR1cm4gQXJyYXkuZnJvbShjb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnYnV0dG9uJykpLmZpbmQoYnV0dG9uID0+IGJ1dHRvbi50ZXh0Q29udGVudCA9PT0gdGV4dCk7IH1cbmV4cG9ydHMuU2NBY3Rpb25zVXggPSBTY0FjdGlvbnNVeDtcblxuIiwgImFzeW5jIGZ1bmN0aW9uIG9wZW5fbm90ZShwbHVnaW4sIHRhcmdldF9wYXRoLCBldmVudD1udWxsKSB7XG4gIGxldCB0YXJnZXRGaWxlO1xuICBsZXQgaGVhZGluZztcbiAgLy8gaWYgaGFzICMgYW5kIGlzIGxhc3QgY2hhcmFjdGVyLCByZW1vdmUgaXRcbiAgaWYgKHRhcmdldF9wYXRoW3RhcmdldF9wYXRoLmxlbmd0aCAtIDFdID09PSBcIiNcIikgdGFyZ2V0X3BhdGggPSB0YXJnZXRfcGF0aC5zbGljZSgwLCAtMSk7XG4gIGlmICh0YXJnZXRfcGF0aC5pbmRleE9mKFwiI1wiKSA+IC0xKSB7XG4gICAgdGFyZ2V0RmlsZSA9IHBsdWdpbi5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaXJzdExpbmtwYXRoRGVzdCh0YXJnZXRfcGF0aC5zcGxpdChcIiNcIilbMF0sIFwiXCIpOyAvLyByZW1vdmUgYWZ0ZXIgIyBmcm9tIGxpbmtcbiAgICAvLyBjb25zb2xlLmxvZyh0YXJnZXRGaWxlKTtcbiAgICBjb25zdCB0YXJnZXRfZmlsZV9jYWNoZSA9IHBsdWdpbi5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUodGFyZ2V0RmlsZSk7XG4gICAgLy8gY29uc29sZS5sb2codGFyZ2V0X2ZpbGVfY2FjaGUpO1xuICAgIGxldCBoZWFkaW5nX3RleHQgPSB0YXJnZXRfcGF0aC5zcGxpdChcIiNcIikucG9wKCk7IC8vIGdldCBoZWFkaW5nXG4gICAgLy8gaWYgaGVhZGluZyB0ZXh0IGNvbnRhaW5zIGEgY3VybHkgYnJhY2UsIGdldCB0aGUgbnVtYmVyIGluc2lkZSB0aGUgY3VybHkgYnJhY2VzIGFzIG9jY3VyZW5jZVxuICAgIGxldCBvY2N1cmVuY2UgPSAwO1xuICAgIGlmIChoZWFkaW5nX3RleHQuaW5kZXhPZihcIntcIikgPiAtMSkge1xuICAgICAgLy8gZ2V0IG9jY3VyZW5jZVxuICAgICAgb2NjdXJlbmNlID0gcGFyc2VJbnQoaGVhZGluZ190ZXh0LnNwbGl0KFwie1wiKVsxXS5zcGxpdChcIn1cIilbMF0pO1xuICAgICAgLy8gcmVtb3ZlIG9jY3VyZW5jZSBmcm9tIGhlYWRpbmcgdGV4dFxuICAgICAgaGVhZGluZ190ZXh0ID0gaGVhZGluZ190ZXh0LnNwbGl0KFwie1wiKVswXTtcbiAgICB9XG4gICAgY29uc3QgaGVhZGluZ3MgPSB0YXJnZXRfZmlsZV9jYWNoZS5oZWFkaW5nczsgLy8gZ2V0IGhlYWRpbmdzIGZyb20gZmlsZSBjYWNoZVxuICAgIC8vIGdldCBoZWFkaW5ncyB3aXRoIHRoZSBzYW1lIGRlcHRoIGFuZCB0ZXh0IGFzIHRoZSBsaW5rXG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGhlYWRpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaGVhZGluZ3NbaV0uaGVhZGluZyA9PT0gaGVhZGluZ190ZXh0KSB7XG4gICAgICAgIC8vIGlmIG9jY3VyZW5jZSBpcyAwLCBzZXQgaGVhZGluZyBhbmQgYnJlYWtcbiAgICAgICAgaWYob2NjdXJlbmNlID09PSAwKSB7XG4gICAgICAgICAgaGVhZGluZyA9IGhlYWRpbmdzW2ldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG9jY3VyZW5jZS0tOyAvLyBkZWNyZW1lbnQgb2NjdXJlbmNlXG4gICAgICB9XG4gICAgfVxuICAgIC8vIGNvbnNvbGUubG9nKGhlYWRpbmcpO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldEZpbGUgPSBwbHVnaW4uYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0Rmlyc3RMaW5rcGF0aERlc3QodGFyZ2V0X3BhdGgsIFwiXCIpO1xuICB9XG4gIGxldCBsZWFmO1xuICBpZihldmVudCkge1xuICAgIGNvbnN0IG1vZCA9IHBsdWdpbi5vYnNpZGlhbi5LZXltYXAuaXNNb2RFdmVudChldmVudCk7IC8vIHByb3Blcmx5IGhhbmRsZSBpZiB0aGUgbWV0YS9jdHJsIGtleSBpcyBwcmVzc2VkXG4gICAgbGVhZiA9IHBsdWdpbi5hcHAud29ya3NwYWNlLmdldExlYWYobW9kKTsgLy8gZ2V0IG1vc3QgcmVjZW50IGxlYWZcbiAgfWVsc2V7XG4gICAgbGVhZiA9IHBsdWdpbi5hcHAud29ya3NwYWNlLmdldE1vc3RSZWNlbnRMZWFmKCk7IC8vIGdldCBtb3N0IHJlY2VudCBsZWFmXG4gIH1cbiAgYXdhaXQgbGVhZi5vcGVuRmlsZSh0YXJnZXRGaWxlKTtcbiAgaWYgKGhlYWRpbmcpIHtcbiAgICBsZXQgeyBlZGl0b3IgfSA9IGxlYWYudmlldztcbiAgICBjb25zdCBwb3MgPSB7IGxpbmU6IGhlYWRpbmcucG9zaXRpb24uc3RhcnQubGluZSwgY2g6IDAgfTtcbiAgICBlZGl0b3Iuc2V0Q3Vyc29yKHBvcyk7XG4gICAgZWRpdG9yLnNjcm9sbEludG9WaWV3KHsgdG86IHBvcywgZnJvbTogcG9zIH0sIHRydWUpO1xuICB9XG59XG5leHBvcnRzLm9wZW5fbm90ZSA9IG9wZW5fbm90ZTsiLCAiY29uc3Qge1xuICBhZGRJY29uLFxuICBLZXltYXAsXG4gIE1hcmtkb3duUmVuZGVyZXIsXG4gIE5vdGljZSxcbiAgUGx1Z2luLFxuICByZXF1ZXN0LFxuICByZXF1ZXN0VXJsLFxuICBUQWJzdHJhY3RGaWxlLFxuICBURmlsZSxcbn0gPSByZXF1aXJlKFwib2JzaWRpYW5cIik7XG5jb25zdCB7IE9ic0FKU09OIH0gPSByZXF1aXJlKFwic21hcnQtY29sbGVjdGlvbnMvT2JzQUpTT04uanNcIik7IC8vIExvY2FsXG5jb25zdCB7IE9ic011bHRpQUpTT04gfSA9IHJlcXVpcmUoXCJzbWFydC1jb2xsZWN0aW9ucy9PYnNNdWx0aUFKU09OLmpzXCIpOyAvLyBMb2NhbFxuY29uc3QgeyBTY0VudiB9ID0gcmVxdWlyZShcIi4vc2NfZW52XCIpO1xuY29uc3QgeyBkZWZhdWx0X3NldHRpbmdzIH0gPSByZXF1aXJlKFwiLi9kZWZhdWx0X3NldHRpbmdzXCIpO1xuLy8gcmVuYW1lIG1vZHVsZXNcbmNvbnN0IHsgU2NTbWFydFZpZXcgfSA9IHJlcXVpcmUoXCIuL3NjX3NtYXJ0X3ZpZXdcIik7IC8vIHJlbmFtZSB0byBzY192aWV3LmpzXG5jb25zdCB7IFNtYXJ0U2VhcmNoIH0gPSByZXF1aXJlKFwiLi9zbWFydF9zZWFyY2guanNcIik7IC8vIHJlbmFtZSB0byBzY19zZWFyY2guanNcbmNvbnN0IHsgU21hcnROb3RpY2VzIH0gPSByZXF1aXJlKFwiLi9zbWFydF9ub3RpY2VzLmpzXCIpOyAvLyByZW5hbWUgdG8gc2Nfbm90aWNlcy5qcyAoZXh0cmFjdCBzbWFydF9ub3RpY2VzLmpzIGFzIHN0YW5kYXJkIHN0cnVjdHVyZSBmaXJzdClcbi8vIHYyLjFcbmNvbnN0IHsgU2NDaGF0VmlldyB9ID0gcmVxdWlyZShcIi4vc2NfY2hhdF92aWV3LmpzXCIpO1xuY29uc3QgeyBTY1NldHRpbmdzVGFiIH0gPSByZXF1aXJlKFwiLi9zY19zZXR0aW5ncy5qc1wiKTtcbmNvbnN0IGVtYmVkX21vZGVscyA9IHJlcXVpcmUoJ3NtYXJ0LWVtYmVkLW1vZGVsL21vZGVscy5qc29uJyk7XG5jb25zdCB7IFNjQWN0aW9uc1V4IH0gPSByZXF1aXJlKFwiLi9zY19hY3Rpb25zX3V4LmpzXCIpO1xuY29uc3QgeyBvcGVuX25vdGUgfSA9IHJlcXVpcmUoXCIuL29wZW5fbm90ZS5qc1wiKTtcbmNsYXNzIFNtYXJ0Q29ubmVjdGlvbnNQbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRzKCkgeyByZXR1cm4gZGVmYXVsdF9zZXR0aW5ncygpIH1cbiAgZ2V0IGl0ZW1fdmlld3MoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFNjU21hcnRWaWV3LFxuICAgICAgU2NDaGF0VmlldyxcbiAgICB9XG4gIH1cbiAgYXN5bmMgb3Blbl9ub3RlKHRhcmdldF9wYXRoLCBldmVudD1udWxsKSB7IGF3YWl0IG9wZW5fbm90ZSh0aGlzLCB0YXJnZXRfcGF0aCwgZXZlbnQpOyB9XG4gIGFzeW5jIGxvYWRfc2V0dGluZ3MoKSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLnNldHRpbmdzLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xuICAgIHRoaXMuaGFuZGxlX2RlcHJlY2F0ZWRfc2V0dGluZ3MoKTsgLy8gSEFORExFIERFUFJFQ0FURUQgU0VUVElOR1NcbiAgfVxuICBhc3luYyBvbmxvYWQoKSB7IHRoaXMuYXBwLndvcmtzcGFjZS5vbkxheW91dFJlYWR5KHRoaXMuaW5pdGlhbGl6ZS5iaW5kKHRoaXMpKTsgfSAvLyBpbml0aWFsaXplIHdoZW4gbGF5b3V0IGlzIHJlYWR5XG4gIG9udW5sb2FkKCkge1xuICAgIGNvbnNvbGUubG9nKFwidW5sb2FkaW5nIHBsdWdpblwiKTtcbiAgICB0aGlzLmVudj8udW5sb2FkKCk7XG4gICAgdGhpcy5lbnYgPSBudWxsO1xuICAgIHRoaXMuYnJhaW4gPSBudWxsO1xuICAgIHRoaXMubm90aWNlcz8udW5sb2FkKCk7XG4gIH1cbiAgYXN5bmMgaW5pdGlhbGl6ZSgpIHtcbiAgICBjb25zb2xlLmxvZyhcIkxvYWRpbmcgU21hcnQgQ29ubmVjdGlvbnMgdjIuLi5cIik7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCB0aGlzLmNvbnN0cnVjdG9yLmRlZmF1bHRzKTtcbiAgICBhd2FpdCB0aGlzLmxvYWRfc2V0dGluZ3MoKTtcbiAgICB0aGlzLnNtYXJ0X2Nvbm5lY3Rpb25zX3ZpZXcgPSBudWxsO1xuICAgIHRoaXMuYWRkX2NvbW1hbmRzKCk7IC8vIGFkZCBjb21tYW5kc1xuICAgIHRoaXMucmVnaXN0ZXJfdmlld3MoKTsgLy8gcmVnaXN0ZXIgY2hhdCB2aWV3IHR5cGVcbiAgICB0aGlzLmFkZFNldHRpbmdUYWIobmV3IFNjU2V0dGluZ3NUYWIodGhpcy5hcHAsIHRoaXMsIFwic21hcnRfc2V0dGluZ3NfMjFcIikpOyAvLyBhZGQgc2V0dGluZ3MgdGFiXG4gICAgdGhpcy5jaGVja19mb3JfdXBkYXRlcygpO1xuICAgIHRoaXMuYWRkX3RvX2dpdGlnbm9yZShcIlxcblxcbiMgSWdub3JlIFNtYXJ0IENvbm5lY3Rpb25zIGZvbGRlclxcbi5zbWFydC1jb25uZWN0aW9uc1wiKTsgXG4gICAgdGhpcy5hcGkgPSBuZXcgU21hcnRTZWFyY2godGhpcyk7XG4gICAgKHdpbmRvd1tcIlNtYXJ0U2VhcmNoXCJdID0gdGhpcy5hcGkpICYmIHRoaXMucmVnaXN0ZXIoKCkgPT4gZGVsZXRlIHdpbmRvd1tcIlNtYXJ0U2VhcmNoXCJdKTsgLy8gcmVnaXN0ZXIgQVBJIHRvIGdsb2JhbCB3aW5kb3cgb2JqZWN0XG4gICAgYWRkSWNvbihcInNtYXJ0LWNvbm5lY3Rpb25zXCIsIGA8cGF0aCBkPVwiTTUwLDIwIEw4MCw0MCBMODAsNjAgTDUwLDEwMFwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjRcIiBmaWxsPVwibm9uZVwiLz5cbiAgICA8cGF0aCBkPVwiTTMwLDUwIEw1NSw3MFwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjVcIiBmaWxsPVwibm9uZVwiLz5cbiAgICA8Y2lyY2xlIGN4PVwiNTBcIiBjeT1cIjIwXCIgcj1cIjlcIiBmaWxsPVwiY3VycmVudENvbG9yXCIvPlxuICAgIDxjaXJjbGUgY3g9XCI4MFwiIGN5PVwiNDBcIiByPVwiOVwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIi8+XG4gICAgPGNpcmNsZSBjeD1cIjgwXCIgY3k9XCI3MFwiIHI9XCI5XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiLz5cbiAgICA8Y2lyY2xlIGN4PVwiNTBcIiBjeT1cIjEwMFwiIHI9XCI5XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiLz5cbiAgICA8Y2lyY2xlIGN4PVwiMzBcIiBjeT1cIjUwXCIgcj1cIjlcIiBmaWxsPVwiY3VycmVudENvbG9yXCIvPmApO1xuICAgIHRoaXMuYWRkUmliYm9uSWNvbihcInNtYXJ0LWNvbm5lY3Rpb25zXCIsIFwiT3BlbjogVmlldyBTbWFydCBDb25uZWN0aW9uc1wiLCAoKSA9PiB7IHRoaXMub3Blbl92aWV3KCk7IH0pO1xuICAgIHRoaXMuYWRkUmliYm9uSWNvbihcIm1lc3NhZ2Utc3F1YXJlXCIsIFwiT3BlbjogU21hcnQgQ2hhdCBDb252ZXJzYXRpb25cIiwgKCkgPT4geyB0aGlzLm9wZW5fY2hhdCgpOyB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyTWFya2Rvd25Db2RlQmxvY2tQcm9jZXNzb3IoXCJzbWFydC1jb25uZWN0aW9uc1wiLCB0aGlzLnJlbmRlcl9jb2RlX2Jsb2NrLmJpbmQodGhpcykpOyAvLyBjb2RlLWJsb2NrIHJlbmRlcmVyXG4gICAgdGhpcy5yZWdpc3Rlck1hcmtkb3duQ29kZUJsb2NrUHJvY2Vzc29yKFwic2MtY29udGV4dFwiLCB0aGlzLnJlbmRlcl9jb2RlX2Jsb2NrX2NvbnRleHQuYmluZCh0aGlzKSk7IC8vIGNvZGUtYmxvY2sgcmVuZGVyZXJcbiAgICAvLyBcIkFJIGNoYW5nZVwiIGR5bmFtaWMgY29kZSBibG9ja1xuICAgIHRoaXMucmVnaXN0ZXJNYXJrZG93bkNvZGVCbG9ja1Byb2Nlc3NvcihcInNjLWNoYW5nZVwiLCB0aGlzLmNoYW5nZV9jb2RlX2Jsb2NrLmJpbmQodGhpcykpO1xuICAgIHRoaXMubm90aWNlcyA9IG5ldyBTbWFydE5vdGljZXModGhpcyk7XG4gICAgdGhpcy5vYnNpZGlhbiA9IHJlcXVpcmUoXCJvYnNpZGlhblwiKTtcbiAgICB0aGlzLm5ld191c2VyKCk7XG4gICAgYXdhaXQgdGhpcy5sb2FkX2VudigpO1xuICAgIGNvbnNvbGUubG9nKFwiU21hcnQgQ29ubmVjdGlvbnMgdjIgbG9hZGVkXCIpO1xuICB9XG4gIGFzeW5jIGxvYWRfZW52KCkge1xuICAgIHRoaXMuZW52ID0gbmV3IFNjRW52KHRoaXMsICh0aGlzLnNldHRpbmdzLmVtYmVkZGluZ19maWxlX3Blcl9ub3RlID8gT2JzTXVsdGlBSlNPTiA6IE9ic0FKU09OKSk7XG4gICAgdGhpcy5icmFpbiA9IHRoaXMuZW52OyAvLyBERVBSRUNBVEVEICh1c2UgdGhpcy5lbnYgaW5zdGVhZClcbiAgICBhd2FpdCB0aGlzLmVudi5pbml0KCk7XG4gIH1cbiAgbmV3X3VzZXIoKSB7XG4gICAgaWYoIXRoaXMuc2V0dGluZ3MubmV3X3VzZXIpIHJldHVybjtcbiAgICB0aGlzLnNldHRpbmdzLm5ld191c2VyID0gZmFsc2U7XG4gICAgdGhpcy5zZXR0aW5ncy52ZXJzaW9uID0gdGhpcy5tYW5pZmVzdC52ZXJzaW9uO1xuICAgIHRoaXMub3Blbl92aWV3KCk7XG4gICAgdGhpcy5vcGVuX2NoYXQoKTtcbiAgICBpZih0aGlzLmFwcC53b3Jrc3BhY2UucmlnaHRTcGxpdC5jb2xsYXBzZWQpIHRoaXMuYXBwLndvcmtzcGFjZS5yaWdodFNwbGl0LnRvZ2dsZSgpO1xuICAgIHRoaXMuc2F2ZV9zZXR0aW5ncygpO1xuICB9XG4gIHJlZ2lzdGVyX3ZpZXdzKCkge1xuICAgIE9iamVjdC52YWx1ZXModGhpcy5pdGVtX3ZpZXdzKS5mb3JFYWNoKFZpZXcgPT4ge1xuICAgICAgdGhpcy5yZWdpc3RlclZpZXcoVmlldy52aWV3X3R5cGUsIChsZWFmKSA9PiAobmV3IFZpZXcobGVhZiwgdGhpcykpKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBjaGVja19mb3JfdXBkYXRlcygpIHtcbiAgICBpZih0aGlzLnNldHRpbmdzLnZlcnNpb24gIT09IHRoaXMubWFuaWZlc3QudmVyc2lvbil7XG4gICAgICB0aGlzLnNldHRpbmdzLnZlcnNpb24gPSB0aGlzLm1hbmlmZXN0LnZlcnNpb247IC8vIHVwZGF0ZSB2ZXJzaW9uXG4gICAgICBhd2FpdCB0aGlzLnNhdmVfc2V0dGluZ3MoKTsgLy8gc2F2ZSBzZXR0aW5nc1xuICAgIH1cbiAgICBzZXRUaW1lb3V0KHRoaXMuY2hlY2tfZm9yX3VwZGF0ZS5iaW5kKHRoaXMpLCAzMDAwKTsgLy8gcnVuIGFmdGVyIDMgc2Vjb25kc1xuICAgIHNldEludGVydmFsKHRoaXMuY2hlY2tfZm9yX3VwZGF0ZS5iaW5kKHRoaXMpLCAxMDgwMDAwMCk7IC8vIHJ1biBjaGVjayBmb3IgdXBkYXRlIGV2ZXJ5IDMgaG91cnNcbiAgfVxuICAvLyBjaGVjayBmb3IgdXBkYXRlXG4gIGFzeW5jIGNoZWNrX2Zvcl91cGRhdGUoKSB7XG4gICAgLy8gZmFpbCBzaWxlbnRseSwgZXguIGlmIG5vIGludGVybmV0IGNvbm5lY3Rpb25cbiAgICB0cnkge1xuICAgICAgLy8gZ2V0IGxhdGVzdCByZWxlYXNlIHZlcnNpb24gZnJvbSBnaXRodWJcbiAgICAgIGNvbnN0IHtqc29uOiByZXNwb25zZX0gPSBhd2FpdCByZXF1ZXN0VXJsKHtcbiAgICAgICAgdXJsOiBcImh0dHBzOi8vYXBpLmdpdGh1Yi5jb20vcmVwb3MvYnJpYW5wZXRyby9vYnNpZGlhbi1zbWFydC1jb25uZWN0aW9ucy9yZWxlYXNlcy9sYXRlc3RcIixcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIH0sXG4gICAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIH0pO1xuICAgICAgLy8gZ2V0IHZlcnNpb24gbnVtYmVyIGZyb20gcmVzcG9uc2VcbiAgICAgIGNvbnN0IGxhdGVzdF9yZWxlYXNlID0gcmVzcG9uc2UudGFnX25hbWU7XG4gICAgICAvLyBjb25zb2xlLmxvZyhgTGF0ZXN0IHJlbGVhc2U6ICR7bGF0ZXN0X3JlbGVhc2V9YCk7XG4gICAgICAvLyBpZiBsYXRlc3RfcmVsZWFzZSBpcyBuZXdlciB0aGFuIGN1cnJlbnQgdmVyc2lvbiwgc2hvdyBtZXNzYWdlXG4gICAgICBpZihsYXRlc3RfcmVsZWFzZSAhPT0gdGhpcy5tYW5pZmVzdC52ZXJzaW9uKSB7XG4gICAgICAgIG5ldyBOb3RpY2UoYFtTbWFydCBDb25uZWN0aW9uc10gQSBuZXcgdmVyc2lvbiBpcyBhdmFpbGFibGUhICh2JHtsYXRlc3RfcmVsZWFzZX0pYCk7XG4gICAgICAgIHRoaXMudXBkYXRlX2F2YWlsYWJsZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcmVzdGFydF9wbHVnaW4oKSB7XG4gICAgYXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTsgLy8gc2F2ZSBzZXR0aW5nc1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKHIgPT4gc2V0VGltZW91dChyLCAzMDAwKSk7XG4gICAgd2luZG93LnJlc3RhcnRfcGx1Z2luID0gYXN5bmMgKGlkKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhcInJlc3RhcnRpbmcgcGx1Z2luXCIsIGlkKTtcbiAgICAgIGF3YWl0IHdpbmRvdy5hcHAucGx1Z2lucy5kaXNhYmxlUGx1Z2luKGlkKTtcbiAgICAgIGF3YWl0IHdpbmRvdy5hcHAucGx1Z2lucy5lbmFibGVQbHVnaW4oaWQpO1xuICAgICAgY29uc29sZS5sb2coXCJwbHVnaW4gcmVzdGFydGVkXCIsIGlkKTtcbiAgICB9O1xuICAgIHdpbmRvdy5yZXN0YXJ0X3BsdWdpbih0aGlzLm1hbmlmZXN0LmlkKTtcbiAgfVxuXG4gIGFkZF9jb21tYW5kcygpIHtcbiAgICAvLyBtYWtlIGNvbm5lY3Rpb25zIGNvbW1hbmRcbiAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgaWQ6IFwic2MtZmluZC1ub3Rlc1wiLFxuICAgICAgbmFtZTogXCJGaW5kOiBNYWtlIFNtYXJ0IENvbm5lY3Rpb25zXCIsXG4gICAgICBpY29uOiBcInBlbmNpbF9pY29uXCIsXG4gICAgICBob3RrZXlzOiBbXSxcbiAgICAgIGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yKSA9PiB7XG4gICAgICAgIGlmKGVkaXRvci5zb21ldGhpbmdTZWxlY3RlZCgpKSB0aGlzLnZpZXcucmVuZGVyX25lYXJlc3QoZWRpdG9yLmdldFNlbGVjdGlvbigpKTtcbiAgICAgICAgZWxzZSBpZihlZGl0b3IuZ2V0Q3Vyc29yKCk/LmxpbmUpeyAvLyBpZiBjdXJzb3IgaXMgb24gYSBsaW5lIGdyZWF0ZXIgdGhhbiAwXG4gICAgICAgICAgY29uc3QgbGluZSA9IGVkaXRvci5nZXRDdXJzb3IoKS5saW5lO1xuICAgICAgICAgIGNvbnN0IGJsb2NrID0gdGhpcy5icmFpbi5zbWFydF9ub3Rlcy5jdXJyZW50X25vdGUuZ2V0X2Jsb2NrX2J5X2xpbmUobGluZSk7XG4gICAgICAgICAgY29uc29sZS5sb2coYmxvY2spO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGxpbmUpO1xuICAgICAgICAgIHRoaXMudmlldy5yZW5kZXJfbmVhcmVzdChibG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB0aGlzLnZpZXcucmVuZGVyX25lYXJlc3QoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBtYWtlIGNvbm5lY3Rpb25zIGNvbW1hbmRcbiAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgaWQ6IFwic2MtcmVmcmVzaC1jb25uZWN0aW9uc1wiLFxuICAgICAgbmFtZTogXCJSZWZyZXNoICYgTWFrZSBDb25uZWN0aW9uc1wiLFxuICAgICAgaWNvbjogXCJwZW5jaWxfaWNvblwiLFxuICAgICAgaG90a2V5czogW10sXG4gICAgICBlZGl0b3JDYWxsYmFjazogYXN5bmMgKGVkaXRvcikgPT4ge1xuICAgICAgICAvLyBnZXQgY3VycmVudCBub3RlXG4gICAgICAgIGNvbnN0IGN1cnJfZmlsZSA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7XG4gICAgICAgIC8vIGNvbnN0IGN1cnJfbm90ZSA9IHRoaXMuZW52Py5zbWFydF9ub3Rlcy5nZXQoY3Vycl9maWxlLnBhdGgpO1xuICAgICAgICAvLyBkZWxldGUgbm90ZSBlbnRpdHkgZnJvbSBjYWNoZVxuICAgICAgICBkZWxldGUgdGhpcy52aWV3Py5uZWFyZXN0X2NhY2hlW2N1cnJfZmlsZS5wYXRoXTtcbiAgICAgICAgLy8gZGVsdGUgbm90ZSBlbnRpdHkgZnJvbSBjb2xsZWN0aW9uXG4gICAgICAgIHRoaXMuZW52LnNtYXJ0X25vdGVzLmRlbGV0ZShjdXJyX2ZpbGUucGF0aCk7XG4gICAgICAgIC8vIGltcG9ydCBub3RlXG4gICAgICAgIGF3YWl0IHRoaXMuZW52LnNtYXJ0X25vdGVzLmltcG9ydChbY3Vycl9maWxlXSk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIC8vIHJlZnJlc2ggdmlld1xuICAgICAgICAgIHRoaXMudmlldy5yZW5kZXJfbmVhcmVzdCgpO1xuICAgICAgICB9LCAxMDAwKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBvcGVuIHZpZXcgY29tbWFuZFxuICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICBpZDogXCJzbWFydC1jb25uZWN0aW9ucy12aWV3XCIsXG4gICAgICBuYW1lOiBcIk9wZW46IFZpZXcgU21hcnQgQ29ubmVjdGlvbnNcIixcbiAgICAgIGNhbGxiYWNrOiAoKSA9PiB7IHRoaXMub3Blbl92aWV3KCk7IH1cbiAgICB9KTtcbiAgICAvLyBvcGVuIGNoYXQgY29tbWFuZFxuICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICBpZDogXCJzbWFydC1jb25uZWN0aW9ucy1jaGF0XCIsXG4gICAgICBuYW1lOiBcIk9wZW46IFNtYXJ0IENoYXQgQ29udmVyc2F0aW9uXCIsXG4gICAgICBjYWxsYmFjazogKCkgPT4geyB0aGlzLm9wZW5fY2hhdCgpOyB9XG4gICAgfSk7XG4gICAgLy8gb3BlbiByYW5kb20gbm90ZSBmcm9tIG5lYXJlc3QgY2FjaGVcbiAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgaWQ6IFwic21hcnQtY29ubmVjdGlvbnMtcmFuZG9tXCIsXG4gICAgICBuYW1lOiBcIk9wZW46IFJhbmRvbSBOb3RlIGZyb20gU21hcnQgQ29ubmVjdGlvbnNcIixcbiAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJfZmlsZSA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7XG4gICAgICAgIGNvbnN0IGN1cnJfbm90ZSA9IHRoaXMuYnJhaW4/LnNtYXJ0X25vdGVzLmdldChjdXJyX2ZpbGUucGF0aCk7XG4gICAgICAgIGNvbnN0IG5lYXJlc3QgPSBjdXJyX25vdGUuZmluZF9jb25uZWN0aW9ucygpO1xuICAgICAgICBjb25zdCByYW5kID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbmVhcmVzdC5sZW5ndGgvMik7IC8vIGRpdmlkZSBieSAyIHRvIGxpbWl0IHRvIHRvcCBoYWxmIG9mIHJlc3VsdHNcbiAgICAgICAgY29uc3QgcmFuZF9lbnRpdHkgPSBuZWFyZXN0W3JhbmRdOyAvLyBnZXQgcmFuZG9tIGZyb20gbmVhcmVzdCBjYWNoZVxuICAgICAgICAvLyByYW5kX2VudGl0eS5ub3RlID8gcmFuZF9lbnRpdHkubm90ZS5vcGVuKCkgOiByYW5kX2VudGl0eS5vcGVuKCk7IC8vIG9wZW4gcmFuZG9tIGZpbGVcbiAgICAgICAgdGhpcy5vcGVuX25vdGUocmFuZF9lbnRpdHkucGF0aCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgbWFrZV9jb25uZWN0aW9ucyhzZWxlY3RlZF90ZXh0PW51bGwpIHtcbiAgICBpZighdGhpcy52aWV3KSBhd2FpdCB0aGlzLm9wZW5fdmlldygpOyAvLyBvcGVuIHZpZXcgaWYgbm90IG9wZW5cbiAgICBhd2FpdCB0aGlzLnZpZXcucmVuZGVyX25lYXJlc3Qoc2VsZWN0ZWRfdGV4dCk7XG4gIH1cbiAgYXN5bmMgc2F2ZV9zZXR0aW5ncyhyZXJlbmRlcj1mYWxzZSkge1xuICAgIGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7IC8vIE9ic2lkaWFuIEFQSS0+c2F2ZURhdGFcbiAgICBhd2FpdCB0aGlzLmxvYWRfc2V0dGluZ3MoKTsgLy8gcmUtbG9hZCBzZXR0aW5ncyBpbnRvIG1lbW9yeVxuICAgIC8vIHJlLXJlbmRlciB2aWV3IGlmIHNldCB0byB0cnVlIChmb3IgZXhhbXBsZSwgYWZ0ZXIgYWRkaW5nIEFQSSBrZXkpXG4gICAgaWYocmVyZW5kZXIpIHtcbiAgICAgIHRoaXMubmVhcmVzdF9jYWNoZSA9IHt9O1xuICAgICAgY29uc29sZS5sb2coXCJyZXJlbmRlcmluZyB2aWV3XCIpO1xuICAgICAgYXdhaXQgdGhpcy5tYWtlX2Nvbm5lY3Rpb25zKCk7XG4gICAgfVxuICB9XG4gIC8vIHV0aWxzXG4gIGFzeW5jIGFkZF90b19naXRpZ25vcmUoaWdub3JlLCBtZXNzYWdlPW51bGwpIHtcbiAgICBpZighKGF3YWl0IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIuZXhpc3RzKFwiLmdpdGlnbm9yZVwiKSkpIHJldHVybjsgLy8gaWYgLmdpdGlnbm9yZSBza2lwXG4gICAgbGV0IGdpdGlnbm9yZV9maWxlID0gYXdhaXQgdGhpcy5hcHAudmF1bHQuYWRhcHRlci5yZWFkKFwiLmdpdGlnbm9yZVwiKTtcbiAgICBpZiAoZ2l0aWdub3JlX2ZpbGUuaW5kZXhPZihpZ25vcmUpIDwgMCkge1xuICAgICAgYXdhaXQgdGhpcy5hcHAudmF1bHQuYWRhcHRlci5hcHBlbmQoXCIuZ2l0aWdub3JlXCIsIGBcXG5cXG4ke21lc3NhZ2UgPyBcIiMgXCIgKyBtZXNzYWdlICsgXCJcXG5cIiA6IFwiXCJ9JHtpZ25vcmV9YCk7XG4gICAgICBjb25zb2xlLmxvZyhcIkFkZGVkIHRvIC5naXRpZ25vcmU6IFwiICsgaWdub3JlKTtcbiAgICB9XG4gIH1cbiAgc2hvd19ub3RpY2UobWVzc2FnZSwgb3B0cz17fSkge1xuICAgIGNvbnNvbGUubG9nKFwib2xkIHNob3dpbmcgbm90aWNlXCIpO1xuICAgIGNvbnN0IG5vdGljZV9pZCA9IHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJyA/IG1lc3NhZ2UgOiBtZXNzYWdlWzBdO1xuICAgIHJldHVybiB0aGlzLm5vdGljZXMuc2hvdyhub3RpY2VfaWQsIG1lc3NhZ2UsIG9wdHMpO1xuICB9XG4gIG9wZW5fdmlldyhhY3RpdmU9dHJ1ZSkgeyBTY1NtYXJ0Vmlldy5vcGVuKHRoaXMuYXBwLndvcmtzcGFjZSwgYWN0aXZlKTsgfVxuICBvcGVuX2NoYXQoKSB7IFNjQ2hhdFZpZXcub3Blbih0aGlzLmFwcC53b3Jrc3BhY2UpOyB9XG4gIGdldCB2aWV3KCkgeyByZXR1cm4gU2NTbWFydFZpZXcuZ2V0X3ZpZXcodGhpcy5hcHAud29ya3NwYWNlKTsgfSBcbiAgZ2V0IGNoYXRfdmlldygpIHsgcmV0dXJuIFNjQ2hhdFZpZXcuZ2V0X3ZpZXcodGhpcy5hcHAud29ya3NwYWNlKTsgfVxuICAvLyBnZXQgZm9sZGVycywgdHJhdmVyc2Ugbm9uLWhpZGRlbiBzdWItZm9sZGVyc1xuICBhc3luYyBnZXRfZm9sZGVycyhwYXRoID0gXCIvXCIpIHtcbiAgICBjb25zdCBmb2xkZXJzID0gKGF3YWl0IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIubGlzdChwYXRoKSkuZm9sZGVycztcbiAgICBsZXQgZm9sZGVyX2xpc3QgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZvbGRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChmb2xkZXJzW2ldLnN0YXJ0c1dpdGgoXCIuXCIpKSBjb250aW51ZTtcbiAgICAgIGZvbGRlcl9saXN0LnB1c2goZm9sZGVyc1tpXSk7XG4gICAgICBmb2xkZXJfbGlzdCA9IGZvbGRlcl9saXN0LmNvbmNhdChhd2FpdCB0aGlzLmdldF9mb2xkZXJzKGZvbGRlcnNbaV0gKyBcIi9cIikpO1xuICAgIH1cbiAgICByZXR1cm4gZm9sZGVyX2xpc3Q7XG4gIH1cbiAgLy8gU1VQUE9SVEVSU1xuICBhc3luYyBzeW5jX25vdGVzKCkge1xuICAgIC8vIGlmIGxpY2Vuc2Uga2V5IGlzIG5vdCBzZXQsIHJldHVyblxuICAgIGlmKCF0aGlzLnNldHRpbmdzLmxpY2Vuc2Vfa2V5KXtcbiAgICAgIG5ldyBOb3RpY2UoXCJTbWFydCBDb25uZWN0aW9uczogU3VwcG9ydGVyIGxpY2Vuc2Uga2V5IGlzIHJlcXVpcmVkIHRvIHN5bmMgbm90ZXMgdG8gdGhlIENoYXRHUFQgUGx1Z2luIHNlcnZlci5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKFwic3luY2luZyBub3Rlc1wiKTtcbiAgICBjb25zdCBmaWxlcyA9IHRoaXMuYnJhaW4uZmlsZXM7XG4gICAgY29uc3Qgbm90ZXMgPSBhd2FpdCB0aGlzLmJ1aWxkX25vdGVzX29iamVjdChmaWxlcyk7XG4gICAgLy8gUE9TVCBub3RlcyBvYmplY3QgdG8gc2VydmVyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0VXJsKHtcbiAgICAgIHVybDogXCJodHRwczovL3N5bmMuc21hcnRjb25uZWN0aW9ucy5hcHAvc3luY1wiLFxuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICB9LFxuICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBsaWNlbnNlX2tleTogdGhpcy5zZXR0aW5ncy5saWNlbnNlX2tleSxcbiAgICAgICAgbm90ZXM6IG5vdGVzXG4gICAgICB9KVxuICAgIH0pO1xuICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcbiAgfVxuICBhc3luYyBidWlsZF9ub3Rlc19vYmplY3QoZmlsZXMpIHtcbiAgICBsZXQgb3V0cHV0ID0ge307XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgZmlsZSA9IGZpbGVzW2ldO1xuICAgICAgbGV0IHBhcnRzID0gZmlsZS5wYXRoLnNwbGl0KFwiL1wiKTtcbiAgICAgIGxldCBjdXJyZW50ID0gb3V0cHV0O1xuICAgICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IHBhcnRzLmxlbmd0aDsgaWkrKykge1xuICAgICAgICBsZXQgcGFydCA9IHBhcnRzW2lpXTtcbiAgICAgICAgaWYgKGlpID09PSBwYXJ0cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBhIGZpbGVcbiAgICAgICAgICBjdXJyZW50W3BhcnRdID0gYXdhaXQgdGhpcy5hcHAudmF1bHQuY2FjaGVkUmVhZChmaWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGEgZGlyZWN0b3J5XG4gICAgICAgICAgaWYgKCFjdXJyZW50W3BhcnRdKSB7XG4gICAgICAgICAgICBjdXJyZW50W3BhcnRdID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50W3BhcnRdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cbiAgYXN5bmMgcmVuZGVyX2NvZGVfYmxvY2soY29udGVudHMsIGNvbnRhaW5lciwgY3R4KSB7XG4gICAgY29uc29sZS5sb2coY29udGFpbmVyKTtcbiAgICByZXR1cm4gdGhpcy52aWV3LnJlbmRlcl9uZWFyZXN0KChjb250ZW50cy50cmltKCkubGVuZ3RoPyBjb250ZW50cyA6IGN0eC5zb3VyY2VQYXRoKSwgY29udGFpbmVyKTtcbiAgfVxuICBhc3luYyByZW5kZXJfY29kZV9ibG9ja19jb250ZXh0KHJlc3VsdHMsIGNvbnRhaW5lciwgY3R4KSB7XG4gICAgcmVzdWx0cyA9IHRoaXMuZ2V0X2VudGl0aWVzX2Zyb21fY29udGV4dF9jb2RlYmxvY2socmVzdWx0cyk7XG4gICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gICAgY29udGFpbmVyLmlubmVySFRNTCA9IHRoaXMudmlldy5yZW5kZXJfdGVtcGxhdGUoXCJzbWFydF9jb25uZWN0aW9uc1wiLCB7IGN1cnJlbnRfcGF0aDogXCJjb250ZXh0XCIsIHJlc3VsdHMgfSk7XG4gICAgY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuc2VhcmNoLXJlc3VsdFwiKS5mb3JFYWNoKChlbG0sIGkpID0+IHRoaXMudmlldy5hZGRfbGlua19saXN0ZW5lcnMoZWxtLCByZXN1bHRzW2ldKSk7XG4gICAgY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuc2VhcmNoLXJlc3VsdDpub3QoLnNjLWNvbGxhcHNlZCkgdWwgbGlcIikuZm9yRWFjaCh0aGlzLnZpZXcucmVuZGVyX3Jlc3VsdC5iaW5kKHRoaXMudmlldykpO1xuICB9XG4gIGdldF9lbnRpdGllc19mcm9tX2NvbnRleHRfY29kZWJsb2NrKHJlc3VsdHMpIHtcbiAgICByZXR1cm4gcmVzdWx0cy5zcGxpdChcIlxcblwiKS5tYXAoa2V5ID0+IHtcbiAgICAgIC8vIGNvbnN0IGtleSA9IGxpbmUuc3Vic3RyaW5nKGxpbmUuaW5kZXhPZignW1snKSArIDIsIGxpbmUuaW5kZXhPZignXV0nKSk7XG4gICAgICBjb25zdCBlbnRpdHkgPSBrZXkuaW5jbHVkZXMoXCIjXCIpID8gdGhpcy5icmFpbi5zbWFydF9ibG9ja3MuZ2V0KGtleSkgOiB0aGlzLmJyYWluLnNtYXJ0X25vdGVzLmdldChrZXkpO1xuICAgICAgcmV0dXJuIGVudGl0eSA/IGVudGl0eSA6IHsgbmFtZTogXCJOb3QgZm91bmQ6IFwiICsga2V5IH07XG4gICAgfSk7XG4gIH1cbiAgLy8gY2hhbmdlIGNvZGUgYmxvY2tcbiAgYXN5bmMgY2hhbmdlX2NvZGVfYmxvY2soc291cmNlLCBlbCwgY3R4KSB7XG4gICAgY29uc29sZS5sb2coc291cmNlKTtcbiAgICBjb25zdCByZW5kZXJlciA9IG5ldyBTY0FjdGlvbnNVeCh0aGlzLCBlbCk7XG4gICAgcmVuZGVyZXIuY2hhbmdlX2NvZGVfYmxvY2soc291cmNlKTtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBzbWFydCBjb25uZWN0aW9ucyBmb2xkZXJcbiAgYXN5bmMgdXBkYXRlX3NtYXJ0X2Nvbm5lY3Rpb25zX2ZvbGRlcigpIHtcbiAgICBpZih0aGlzLnNldHRpbmdzLnNtYXJ0X2Nvbm5lY3Rpb25zX2ZvbGRlciA9PT0gdGhpcy5zZXR0aW5ncy5zbWFydF9jb25uZWN0aW9uc19mb2xkZXJfbGFzdCkgcmV0dXJuOyAvLyBpZiBmb2xkZXIgaXMgdGhlIHNhbWUgYXMgbGFzdCwgcmV0dXJuXG4gICAgaWYoIWNvbmZpcm0oXCJBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gdXBkYXRlIHRoZSBTbWFydCBDb25uZWN0aW9ucyBmb2xkZXI/IFRoaXMgd2lsbCBtb3ZlIGFsbCBTbWFydCBDb25uZWN0aW9ucyBmaWxlcyB0byB0aGUgbmV3IGZvbGRlciBhbmQgcmVzdGFydCB0aGUgcGx1Z2luLlwiKSl7XG4gICAgICB0aGlzLnNldHRpbmdzLnNtYXJ0X2Nvbm5lY3Rpb25zX2ZvbGRlciA9IHRoaXMuc2V0dGluZ3Muc21hcnRfY29ubmVjdGlvbnNfZm9sZGVyX2xhc3Q7IC8vIHJlc2V0IGZvbGRlciB0byBsYXN0IGZvbGRlciBpZiB1c2VyIGNhbmNlbHNcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5hcHAudmF1bHQuYWRhcHRlci5yZW5hbWUodGhpcy5zZXR0aW5ncy5zbWFydF9jb25uZWN0aW9uc19mb2xkZXJfbGFzdCwgdGhpcy5zZXR0aW5ncy5zbWFydF9jb25uZWN0aW9uc19mb2xkZXIpO1xuICAgIC8vIHVwZGF0ZSBsYXN0IGZvbGRlclxuICAgIHRoaXMuc2V0dGluZ3Muc21hcnRfY29ubmVjdGlvbnNfZm9sZGVyX2xhc3QgPSB0aGlzLnNldHRpbmdzLnNtYXJ0X2Nvbm5lY3Rpb25zX2ZvbGRlcjtcbiAgICAvLyBzYXZlIHNldHRpbmdzXG4gICAgYXdhaXQgdGhpcy5zYXZlX3NldHRpbmdzKCk7XG4gICAgLy8gcmVsb2FkIHBsdWdpblxuICAgIHRoaXMucmVzdGFydF9wbHVnaW4oKTtcbiAgfVxuICAvLyB1cGRhdGUgc21hcnQgY2hhdCBmb2xkZXJcbiAgYXN5bmMgdXBkYXRlX3NtYXJ0X2NoYXRfZm9sZGVyKCkge1xuICAgIGlmKHRoaXMuc2V0dGluZ3Muc21hcnRfY2hhdF9mb2xkZXIgPT09IHRoaXMuc2V0dGluZ3Muc21hcnRfY2hhdF9mb2xkZXJfbGFzdCkgcmV0dXJuOyAvLyBpZiBmb2xkZXIgaXMgdGhlIHNhbWUgYXMgbGFzdCwgcmV0dXJuXG4gICAgaWYoIWNvbmZpcm0oXCJBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gdXBkYXRlIHRoZSBTbWFydCBDaGF0cyBmb2xkZXI/IFRoaXMgd2lsbCBtb3ZlIGFsbCBTbWFydCBDaGF0IGZpbGVzIHRvIHRoZSBuZXcgZm9sZGVyLlwiKSl7XG4gICAgICB0aGlzLnNldHRpbmdzLnNtYXJ0X2NoYXRfZm9sZGVyID0gdGhpcy5zZXR0aW5ncy5zbWFydF9jaGF0X2ZvbGRlcl9sYXN0OyAvLyByZXNldCBmb2xkZXIgdG8gbGFzdCBmb2xkZXIgaWYgdXNlciBjYW5jZWxzXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGF3YWl0IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIucmVuYW1lKHRoaXMuc2V0dGluZ3Muc21hcnRfY2hhdF9mb2xkZXJfbGFzdCwgdGhpcy5zZXR0aW5ncy5zbWFydF9jaGF0X2ZvbGRlcik7XG4gICAgLy8gdXBkYXRlIGxhc3QgZm9sZGVyXG4gICAgdGhpcy5zZXR0aW5ncy5zbWFydF9jaGF0X2ZvbGRlcl9sYXN0ID0gdGhpcy5zZXR0aW5ncy5zbWFydF9jaGF0X2ZvbGRlcjtcbiAgICAvLyBzYXZlIHNldHRpbmdzXG4gICAgYXdhaXQgdGhpcy5zYXZlX3NldHRpbmdzKCk7XG4gICAgLy8gdXBkYXRlIGNoYXQgaGlzdG9yeSBjb252ZXJzYXRpb24gZm9sZGVyXG4gICAgdGhpcy5lbnYuY2hhdHMuZm9sZGVyID0gdGhpcy5zZXR0aW5ncy5zbWFydF9jaGF0X2ZvbGRlcjsgXG4gIH1cbiAgLy8gaXMgc21hcnQgdmlldyBvcGVuXG4gIC8vIGlzX3NtYXJ0X3ZpZXdfb3BlbigpIHsgcmV0dXJuIFNjU21hcnRWaWV3LmlzX29wZW4odGhpcy5hcHAud29ya3NwYWNlKTsgfVxuICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICBhc3luYyBoYW5kbGVfZGVwcmVjYXRlZF9zZXR0aW5ncygpIHtcbiAgICAvLyBtb3ZlIGFwaSBrZXlzIChhcGlfa2V5X1BMQVRGT1JNKSB0byBQTEFURk9STS5hcGlfa2V5XG4gICAgT2JqZWN0LmVudHJpZXModGhpcy5zZXR0aW5ncykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBpZihrZXkuaW5jbHVkZXMoJy0nKSkge1xuICAgICAgICAvLyByZXBsYWNlIHdpdGggdW5kZXJzY29yZVxuICAgICAgICBjb25zdCBuZXdfa2V5ID0ga2V5LnJlcGxhY2UoLy0vZywgXCJfXCIpO1xuICAgICAgICB0aGlzLnNldHRpbmdzW25ld19rZXldID0gdmFsdWU7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnNldHRpbmdzW2tleV07XG4gICAgICAgIHRoaXMuc2F2ZV9zZXR0aW5ncygpO1xuICAgICAgfVxuICAgICAgaWYoa2V5LnN0YXJ0c1dpdGgoXCJhcGlfa2V5X1wiKSl7XG4gICAgICAgIGNvbnN0IHBsYXRmb3JtID0ga2V5LnJlcGxhY2UoL15hcGlfa2V5Xy8sIFwiXCIpO1xuICAgICAgICBpZighdGhpcy5zZXR0aW5nc1twbGF0Zm9ybV0pIHRoaXMuc2V0dGluZ3NbcGxhdGZvcm1dID0ge307XG4gICAgICAgIGlmKCF0aGlzLnNldHRpbmdzW3BsYXRmb3JtXS5hcGlfa2V5KSB0aGlzLnNldHRpbmdzW3BsYXRmb3JtXS5hcGlfa2V5ID0gdmFsdWU7XG4gICAgICAgIGlmKHRoaXMuc2V0dGluZ3Muc21hcnRfY2hhdF9tb2RlbD8uc3RhcnRzV2l0aChwbGF0Zm9ybSkpe1xuICAgICAgICAgIGNvbnN0IG1vZGVsX25hbWUgPSB0aGlzLnNldHRpbmdzLnNtYXJ0X2NoYXRfbW9kZWwucmVwbGFjZShwbGF0Zm9ybStcIi1cIiwgXCJcIik7XG4gICAgICAgICAgaWYoIXRoaXMuc2V0dGluZ3NbcGxhdGZvcm1dLm1vZGVsX25hbWUpIHRoaXMuc2V0dGluZ3NbcGxhdGZvcm1dLm1vZGVsX25hbWUgPSBtb2RlbF9uYW1lO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnNldHRpbmdzLnNtYXJ0X2NoYXRfbW9kZWw7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMuc2V0dGluZ3Nba2V5XTtcbiAgICAgICAgdGhpcy5zYXZlX3NldHRpbmdzKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gaWYgZXhjbHVkZWQgZmlsZXMgZG9lcyBub3QgaW5jbHVkZSBVbnRpdGxlZCwgYWRkIGl0XG4gICAgaWYoIXRoaXMuc2V0dGluZ3MuZmlsZV9leGNsdXNpb25zLmluY2x1ZGVzKFwiVW50aXRsZWRcIikpIHtcbiAgICAgIC8vIGlmIG5vdCBlbXB0eSwgYWRkIGNvbW1hXG4gICAgICBpZih0aGlzLnNldHRpbmdzLmZpbGVfZXhjbHVzaW9ucy5sZW5ndGgpIHRoaXMuc2V0dGluZ3MuZmlsZV9leGNsdXNpb25zICs9IFwiLFwiO1xuICAgICAgdGhpcy5zZXR0aW5ncy5maWxlX2V4Y2x1c2lvbnMgKz0gXCJVbnRpdGxlZFwiO1xuICAgICAgdGhpcy5zYXZlX3NldHRpbmdzKCk7XG4gICAgfVxuICAgIC8vIGlmIG5vIHNtYXJ0IG5vdGVzIG1vZGVsLCBzZXQgdG8gZGVmYXVsdFxuICAgIGlmKHRoaXMuc2V0dGluZ3Muc21hcnRfbm90ZXNfZW1iZWRfbW9kZWwgPT09IFwiTm9uZVwiKXtcbiAgICAgIHRoaXMuc2V0dGluZ3Muc21hcnRfbm90ZXNfZW1iZWRfbW9kZWwgPSBcIlRheWxvckFJL2JnZS1taWNyby12MlwiO1xuICAgICAgdGhpcy5zYXZlX3NldHRpbmdzKCk7XG4gICAgfVxuICAgIC8vIGhhbmRsZSBkZXByZWNhdGVkIHNtYXJ0LWVtYmVkIG1vZGVsc1xuICAgIGlmKCFlbWJlZF9tb2RlbHNbdGhpcy5zZXR0aW5ncy5zbWFydF9ub3Rlc19lbWJlZF9tb2RlbF0pIHtcbiAgICAgIHRoaXMuc2V0dGluZ3Muc21hcnRfbm90ZXNfZW1iZWRfbW9kZWwgPSB0aGlzLmNvbnN0cnVjdG9yLmRlZmF1bHRzLnNtYXJ0X25vdGVzX2VtYmVkX21vZGVsO1xuICAgICAgdGhpcy5zYXZlX3NldHRpbmdzKCk7XG4gICAgfVxuICAgIGlmKCFlbWJlZF9tb2RlbHNbdGhpcy5zZXR0aW5ncy5zbWFydF9ibG9ja3NfZW1iZWRfbW9kZWxdICYmIHRoaXMuc2V0dGluZ3Muc21hcnRfYmxvY2tzX2VtYmVkX21vZGVsICE9PSBcIk5vbmVcIikge1xuICAgICAgdGhpcy5zZXR0aW5ncy5zbWFydF9ibG9ja3NfZW1iZWRfbW9kZWwgPSB0aGlzLmNvbnN0cnVjdG9yLmRlZmF1bHRzLnNtYXJ0X2Jsb2Nrc19lbWJlZF9tb2RlbDtcbiAgICAgIHRoaXMuc2F2ZV9zZXR0aW5ncygpO1xuICAgIH1cbiAgICAvLyBWMSByZWxpY3NcbiAgICBpZiAodGhpcy5zZXR0aW5ncy5oZWFkZXJfZXhjbHVzaW9ucykge1xuICAgICAgdGhpcy5zZXR0aW5ncy5leGNsdWRlZF9oZWFkaW5ncyA9IHRoaXMuc2V0dGluZ3MuaGVhZGVyX2V4Y2x1c2lvbnM7XG4gICAgICBkZWxldGUgdGhpcy5zZXR0aW5ncy5oZWFkZXJfZXhjbHVzaW9ucztcbiAgICB9XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gU21hcnRDb25uZWN0aW9uc1BsdWdpbjsiXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQSx1REFBQUEsVUFBQTtBQUdBLFFBQU0saUJBQU4sTUFBcUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS25CLFlBQVksWUFBWTtBQUN0QixhQUFLLE1BQU0sV0FBVztBQUN0QixhQUFLLFFBQVEsS0FBSztBQUNsQixhQUFLLGFBQWE7QUFDbEIsYUFBSyxlQUFlO0FBQUEsTUFDdEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLE9BQU8sUUFBUSxZQUFZLFNBQVM7QUFDbEMsY0FBTSxNQUFNLElBQUksUUFBUSxVQUFVO0FBQ2xDLGVBQU87QUFBQSxNQUNUO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1BLElBQUksa0JBQWtCO0FBQUUsZUFBTyxLQUFLLFdBQVc7QUFBQSxNQUFpQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNaEUsSUFBSSxZQUFZO0FBQUUsZUFBTyxLQUFLLFdBQVc7QUFBQSxNQUFXO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1wRCxJQUFJLFlBQVk7QUFBRSxlQUFPLEtBQUssSUFBSTtBQUFBLE1BQVc7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTTdDLElBQUksWUFBWTtBQUFFLGVBQU8sS0FBSyxXQUFXLGFBQWEsS0FBSyxXQUFXO0FBQUEsTUFBaUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTXZGLElBQUksWUFBWTtBQUFFLGVBQU8sS0FBSyxZQUFZLE1BQU0sS0FBSztBQUFBLE1BQVc7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTWhFLElBQUksUUFBUTtBQUFFLGVBQU8sS0FBSyxXQUFXO0FBQUEsTUFBTztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNNUMsSUFBSSxNQUFNLE9BQU87QUFBRSxhQUFLLFdBQVcsUUFBUTtBQUFBLE1BQU87QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTWxELElBQUksT0FBTztBQUFFLGVBQU8sS0FBSyxXQUFXO0FBQUEsTUFBTTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BSzFDLE1BQU0sT0FBTztBQUFBLE1BQUU7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUtmLE9BQU87QUFBRSxZQUFJLEtBQUssWUFBWSxTQUFTO0FBQWtCLGtCQUFRLElBQUksNkJBQTZCO0FBQUEsTUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS3JHLE1BQU0sUUFBUTtBQUFFLFlBQUksS0FBSyxZQUFZLFNBQVM7QUFBa0Isa0JBQVEsSUFBSSw2QkFBNkI7QUFBQSxNQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRNUcsUUFBUSxLQUFLLE9BQU87QUFBRSxlQUFPLEtBQUssV0FBVyxRQUFRLEtBQUssS0FBSztBQUFBLE1BQUc7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFsRSxTQUFTLEtBQUssT0FBTztBQUFFLGVBQU8sS0FBSyxXQUFXLFNBQVMsS0FBSyxLQUFLO0FBQUEsTUFBRztBQUFBLElBQ3RFO0FBR0EsSUFBQUEsU0FBUSxpQkFBaUI7QUFBQTtBQUFBOzs7QUMzR3pCO0FBQUEsK0NBQUFDLFVBQUE7QUFBQSxRQUFNLEVBQUUsZUFBZSxJQUFJO0FBTTNCLFFBQU1DLFlBQU4sY0FBdUIsZUFBZTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLcEMsWUFBWSxZQUFZO0FBQ3RCLGNBQU0sVUFBVTtBQUNoQixhQUFLLFVBQVUsS0FBSyxJQUFJLEtBQUssSUFBSSxNQUFNO0FBQUEsTUFDekM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxNQUFNLE9BQU87QUFDWCxnQkFBUSxJQUFJLGNBQWMsS0FBSyxTQUFTO0FBQ3hDLFlBQUk7QUFDRixXQUFDLE1BQU0sS0FBSyxRQUFRLEtBQUssS0FBSyxTQUFTLEdBQ3BDLE1BQU0sS0FBSyxFQUNYLE9BQU8sV0FBUyxLQUFLLEVBQ3JCLFFBQVEsQ0FBQyxPQUFPLE1BQU07QUFDckIsa0JBQU0sUUFBUSxLQUFLLE1BQU0sSUFBSSxRQUFRO0FBQ3JDLG1CQUFPLFFBQVEsS0FBSyxFQUFFLFFBQVEsQ0FBQyxDQUFDLEtBQUssS0FBSyxNQUFNO0FBQzlDLG1CQUFLLFdBQVcsTUFBTSxHQUFHLElBQUksSUFBSyxLQUFLLElBQUksV0FBVyxNQUFNLFVBQVUsRUFBRyxLQUFLLEtBQUssS0FBSztBQUFBLFlBQzFGLENBQUM7QUFBQSxVQUNILENBQUM7QUFFSCxrQkFBUSxJQUFJLGFBQWEsS0FBSyxTQUFTO0FBQUEsUUFDekMsU0FBUyxLQUFQO0FBQ0Esa0JBQVEsSUFBSSxvQkFBb0IsS0FBSyxTQUFTO0FBQzlDLGtCQUFRLElBQUksSUFBSSxLQUFLO0FBRXJCLGNBQUksSUFBSSxTQUFTLFVBQVU7QUFDekIsaUJBQUssUUFBUSxDQUFDO0FBRWQsZ0JBQUk7QUFDRixvQkFBTSxLQUFLLFFBQVEsTUFBTSxLQUFLLFNBQVM7QUFDdkMsb0JBQU0sS0FBSyxRQUFRLE1BQU0sS0FBSyxXQUFXLEVBQUU7QUFBQSxZQUM3QyxTQUFTLGFBQVA7QUFDQSxzQkFBUSxJQUFJLHFDQUFxQyxXQUFXO0FBQUEsWUFDOUQ7QUFBQSxVQUNGO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFBQTtBQUFBLE1BR0EsT0FBTztBQUNMLFlBQUcsS0FBSztBQUFjLHVCQUFhLEtBQUssWUFBWTtBQUNwRCxhQUFLLGVBQWUsV0FBVyxNQUFNO0FBQUUsZUFBSyxNQUFNO0FBQUEsUUFBRyxHQUFHLEdBQUs7QUFBQSxNQUMvRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNQSxNQUFNLE1BQU0sUUFBTSxPQUFPO0FBQ3ZCLFlBQUcsS0FBSztBQUFjLHVCQUFhLEtBQUssWUFBWTtBQUNwRCxhQUFLLGVBQWU7QUFDcEIsWUFBRyxLQUFLO0FBQVMsaUJBQU8sUUFBUSxJQUFJLHFCQUFxQixLQUFLLFNBQVM7QUFDdkUsYUFBSyxVQUFVO0FBQ2YsbUJBQVcsTUFBTTtBQUFFLGVBQUssVUFBVTtBQUFBLFFBQU8sR0FBRyxHQUFLO0FBQ2pELGNBQU0sUUFBUSxLQUFLLElBQUk7QUFDdkIsZ0JBQVEsSUFBSSxhQUFhLEtBQUssU0FBUztBQUV2QyxjQUFNLGlCQUFpQixLQUFLLFVBQVUsUUFBUSxVQUFVLGFBQWE7QUFDckUsWUFBRyxNQUFNLEtBQUssUUFBUSxPQUFPLGNBQWM7QUFBRyxnQkFBTSxLQUFLLFFBQVEsT0FBTyxjQUFjO0FBQ3RGLFlBQUk7QUFFRixnQkFBTSxLQUFLLFFBQVEsTUFBTSxnQkFBZ0IsRUFBRTtBQUMzQyxjQUFJLGVBQWUsQ0FBQztBQUNwQixnQkFBTSxRQUFRLE9BQU8sT0FBTyxLQUFLLEtBQUssRUFBRSxPQUFPLE9BQUssRUFBRSxHQUFHO0FBQ3pELGdCQUFNLFVBQVUsS0FBSyxLQUFLLE1BQU0sU0FBUyxHQUFJO0FBQzdDLG1CQUFRLElBQUksR0FBRyxJQUFJLFNBQVMsS0FBSztBQUMvQiwyQkFBZSxNQUFNLE1BQU0sSUFBSSxNQUFPLElBQUksS0FBSyxHQUFJLEVBQUUsSUFBSSxDQUFBQyxPQUFLQSxHQUFFLEtBQUs7QUFDckUsa0JBQU0sZ0JBQWdCLGFBQWEsS0FBSyxHQUFHO0FBQzNDLGtCQUFNLEtBQUssUUFBUSxPQUFPLGdCQUFnQixnQkFBZ0IsS0FBSztBQUFBLFVBQ2pFO0FBRUEsY0FBRyxNQUFNLFNBQVMsVUFBVSxLQUFNO0FBQ2hDLGtCQUFNLEtBQUssUUFBUSxPQUFPLGdCQUFnQixNQUFNLE1BQU0sVUFBVSxHQUFJLEVBQUUsSUFBSSxPQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssR0FBRyxJQUFJLEtBQUs7QUFBQSxVQUMzRztBQUNBLGdCQUFNLE1BQU0sS0FBSyxJQUFJO0FBQ3JCLGdCQUFNLE9BQU8sTUFBTTtBQUNuQixjQUFHLFNBQVMsTUFBTSxLQUFLLGNBQWMsZ0JBQWdCLEtBQUssU0FBUyxHQUFHO0FBQ3BFLGdCQUFHLE1BQU0sS0FBSyxRQUFRLE9BQU8sS0FBSyxTQUFTO0FBQUcsb0JBQU0sS0FBSyxRQUFRLE9BQU8sS0FBSyxTQUFTO0FBQ3RGLGtCQUFNLEtBQUssUUFBUSxPQUFPLGdCQUFnQixLQUFLLFNBQVM7QUFDeEQsb0JBQVEsSUFBSSxXQUFXLEtBQUssWUFBWSxTQUFTLE9BQU8sSUFBSTtBQUFBLFVBQzlELE9BQUs7QUFDSCxvQkFBUSxJQUFJLGdCQUFnQixLQUFLLFlBQVksZ0RBQWdEO0FBQUEsVUFDL0Y7QUFBQSxRQUNGLFNBQVMsS0FBUDtBQUNBLGtCQUFRLE1BQU0sbUJBQW1CLEtBQUssU0FBUztBQUMvQyxrQkFBUSxNQUFNLElBQUksS0FBSztBQUV2QixnQkFBTSxtQkFBbUIsZUFBZSxRQUFRLFVBQVUsYUFBYSxLQUFLLElBQUksSUFBSSxHQUFHO0FBQ3ZGLGdCQUFNLEtBQUssUUFBUSxPQUFPLGdCQUFnQixnQkFBZ0I7QUFBQSxRQUM1RDtBQUNBLGFBQUssVUFBVTtBQUVmLFlBQUcsTUFBTSxLQUFLLFFBQVEsT0FBTyxjQUFjLEtBQUssTUFBTSxLQUFLLFFBQVEsT0FBTyxLQUFLLFNBQVM7QUFBRyxnQkFBTSxLQUFLLFFBQVEsT0FBTyxjQUFjO0FBQUEsTUFDckk7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLE1BQU0sY0FBYyxlQUFlLGVBQWU7QUFuSHBEO0FBb0hJLGNBQU0saUJBQWlCLFdBQU0sS0FBSyxRQUFRLEtBQUssYUFBYSxNQUFyQyxtQkFBeUM7QUFDaEUsY0FBTSxpQkFBaUIsV0FBTSxLQUFLLFFBQVEsS0FBSyxhQUFhLE1BQXJDLG1CQUF5QztBQUNoRSxZQUFHLENBQUM7QUFBZSxpQkFBTztBQUMxQixnQkFBUSxJQUFJLG9CQUFvQixnQkFBZ0IsUUFBUTtBQUN4RCxnQkFBUSxJQUFJLG9CQUFvQixnQkFBZ0IsUUFBUTtBQUN4RCxlQUFPLGdCQUFpQixnQkFBZ0I7QUFBQSxNQUMxQztBQUFBLE1BRUEsSUFBSSxZQUFZO0FBQUUsZUFBTyxNQUFNLFlBQVk7QUFBQSxNQUFVO0FBQUEsSUFDdkQ7QUFFQSxJQUFBRixTQUFRLFdBQVdDO0FBQUE7QUFBQTs7O0FDL0huQjtBQUFBLG9EQUFBRSxVQUFBO0FBQUEsUUFBTSxFQUFFLGVBQWUsSUFBSTtBQU0zQixRQUFNQyxpQkFBTixjQUE0QixlQUFlO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUt6QyxZQUFZLFlBQVk7QUFDdEIsY0FBTSxVQUFVO0FBQ2hCLGFBQUssVUFBVSxLQUFLLElBQUksS0FBSyxJQUFJLE1BQU07QUFBQSxNQUN6QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNQSxNQUFNLE9BQU87QUFDWCxnQkFBUSxJQUFJLDBCQUEwQjtBQUN0QyxZQUFHLENBQUUsTUFBTSxLQUFLLFFBQVEsT0FBTyxLQUFLLFNBQVM7QUFBSSxnQkFBTSxLQUFLLFFBQVEsTUFBTSxLQUFLLFNBQVM7QUFDeEYsY0FBTSxTQUFTLE1BQU0sS0FBSyxRQUFRLEtBQUssS0FBSyxTQUFTLEdBQUc7QUFDeEQsbUJBQVcsYUFBYSxPQUFPO0FBQzdCLGNBQUk7QUFDRixnQkFBSSxVQUFVLFNBQVMsUUFBUSxHQUFHO0FBQ2hDLG9CQUFNLFVBQVUsTUFBTSxLQUFLLFFBQVEsS0FBSyxTQUFTO0FBRWpELG9CQUFNLE9BQU8sS0FBSyxNQUFNLElBQUksUUFBUSxTQUFTLEdBQUcsSUFBSSxRQUFRLE1BQU0sR0FBRyxFQUFFLElBQUksVUFBVTtBQUNyRixrQkFBSSxTQUFTO0FBQ2IscUJBQU8sUUFBUSxJQUFJLEVBQUUsUUFBUSxDQUFDLENBQUMsS0FBSyxLQUFLLE1BQU07QUFDN0Msc0JBQU0sU0FBUyxJQUFLLEtBQUssSUFBSSxXQUFXLE1BQU0sVUFBVSxFQUFHLEtBQUssS0FBSyxLQUFLO0FBQzFFLHFCQUFLLElBQUksT0FBTyxlQUFlLEVBQUUsTUFBTSxHQUFHLElBQUk7QUFDOUMsMEJBQVUsT0FBTyxRQUFRO0FBQUEsY0FDM0IsQ0FBQztBQUVELG9CQUFNLEtBQUssUUFBUSxNQUFNLFdBQVcsT0FBTyxLQUFLLENBQUM7QUFBQSxZQUNuRDtBQUFBLFVBQ0YsU0FBUyxLQUFQO0FBQ0Esb0JBQVEsSUFBSSx5QkFBeUIsU0FBUztBQUM5QyxvQkFBUSxJQUFJLElBQUksS0FBSztBQUFBLFVBQ3ZCO0FBQUEsUUFDRjtBQUNBLGdCQUFRLElBQUkseUJBQXlCO0FBQUEsTUFDdkM7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUtBLE9BQU87QUFDTCxZQUFHLEtBQUs7QUFBYyx1QkFBYSxLQUFLLFlBQVk7QUFDcEQsYUFBSyxlQUFlLFdBQVcsTUFBTTtBQUFFLGVBQUssTUFBTTtBQUFBLFFBQUcsR0FBRyxHQUFLO0FBQUEsTUFDL0Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTUEsTUFBTSxNQUFNLFFBQVEsT0FBTztBQUN6QixZQUFJLFdBQVc7QUFDZixZQUFHLEtBQUs7QUFBUyxpQkFBTyxRQUFRLElBQUksZ0JBQWdCO0FBQ3BELGFBQUssVUFBVTtBQUNmLG1CQUFXLE1BQU07QUFBRSxlQUFLLFVBQVU7QUFBQSxRQUFPLEdBQUcsR0FBSztBQUNqRCxjQUFNLFFBQVEsS0FBSyxJQUFJO0FBQ3ZCLGdCQUFRLElBQUkseUJBQXlCO0FBRXJDLFlBQUcsQ0FBRSxNQUFNLEtBQUssUUFBUSxPQUFPLEtBQUssU0FBUztBQUFJLGdCQUFNLEtBQUssUUFBUSxNQUFNLEtBQUssU0FBUztBQUN4RixjQUFNLFFBQVEsT0FBTyxPQUFPLEtBQUssS0FBSyxFQUFFLE9BQU8sT0FBSyxFQUFFLE9BQU8sRUFBRSxPQUFPO0FBQ3RFLFlBQUcsTUFBTSxXQUFXLEdBQUc7QUFDckIsZUFBSyxVQUFVO0FBQ2Ysa0JBQVEsSUFBSSxpQkFBaUI7QUFDN0I7QUFBQSxRQUNGO0FBQ0EsWUFBSTtBQUNGLHFCQUFXLFFBQVEsT0FBTztBQUN4QixrQkFBTSxpQkFBaUIsR0FBRyxLQUFLLGFBQWEsS0FBSztBQUNqRCxrQkFBTSxLQUFLLFFBQVEsT0FBTyxnQkFBZ0IsT0FBTyxLQUFLLFFBQVEsR0FBRztBQUNqRTtBQUFBLFVBQ0Y7QUFDQSxnQkFBTSxNQUFNLEtBQUssSUFBSTtBQUNyQixnQkFBTSxPQUFPLE1BQU07QUFDbkIsa0JBQVEsSUFBSSxTQUFTLGdDQUFnQyxRQUFRO0FBQUEsUUFDL0QsU0FBUyxLQUFQO0FBQ0Esa0JBQVEsTUFBTSwrQkFBK0I7QUFDN0Msa0JBQVEsTUFBTSxJQUFJLEtBQUs7QUFBQSxRQUN6QjtBQUNBLGFBQUssVUFBVTtBQUFBLE1BQ2pCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxNQUFNLGNBQWMsZUFBZSxlQUFlO0FBaEdwRDtBQWlHSSxjQUFNLGlCQUFpQixXQUFNLEtBQUssUUFBUSxLQUFLLGFBQWEsTUFBckMsbUJBQXlDO0FBQ2hFLGNBQU0saUJBQWlCLFdBQU0sS0FBSyxRQUFRLEtBQUssYUFBYSxNQUFyQyxtQkFBeUM7QUFDaEUsWUFBRyxDQUFDO0FBQWUsaUJBQU87QUFDMUIsZ0JBQVEsSUFBSSxvQkFBb0IsZ0JBQWdCLFFBQVE7QUFDeEQsZ0JBQVEsSUFBSSxvQkFBb0IsZ0JBQWdCLFFBQVE7QUFDeEQsZUFBTyxnQkFBaUIsZ0JBQWdCO0FBQUEsTUFDMUM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTUEsSUFBSSxZQUFZO0FBQUUsZUFBTyxNQUFNLFlBQVk7QUFBQSxNQUFVO0FBQUEsSUFDdkQ7QUFFQSxJQUFBRCxTQUFRLGdCQUFnQkM7QUFBQTtBQUFBOzs7QUNoSHhCO0FBQUEsMENBQUFDLFVBQUE7QUFBQSxRQUFNLEVBQUUsZ0JBQWdCLElBQUksSUFBSTtBQUVoQyxRQUFNLFdBQU4sTUFBZTtBQUFBLE1BQ2IsWUFBWSxjQUFjLEtBQUs7QUFDN0IsYUFBSyxTQUFTLENBQUM7QUFDZixhQUFLLGFBQWEsQ0FBQztBQUNuQixhQUFLLGNBQWMsQ0FBQztBQUNwQixhQUFLLGNBQWM7QUFDbkIsYUFBSyxZQUFZO0FBQUEsTUFDbkI7QUFBQSxNQUNBLE9BQU87QUFDTCxhQUFLLGlCQUFpQjtBQUFBLE1BQ3hCO0FBQUEsTUFDQSxtQkFBbUI7QUFDakIsZUFBTyxRQUFRLEtBQUssV0FBVyxFQUFFLElBQUksQ0FBQyxDQUFDLGlCQUFpQixVQUFVLE1BQU0sS0FBSyxlQUFlLElBQUksV0FBVyxLQUFLLElBQUksQ0FBQztBQUFBLE1BQ3ZIO0FBQUEsTUFDQSxRQUFRLEtBQUs7QUFBRSxlQUFPLEtBQUssSUFBSSxlQUFlLEVBQUUsSUFBSSxJQUFJLEdBQUc7QUFBQSxNQUFHO0FBQUEsSUFDaEU7QUFDQSxJQUFBQSxTQUFRLFdBQVc7QUFBQTtBQUFBOzs7QUNsQm5CO0FBQUEsNENBQUFDLFVBQUE7QUFBQSxRQUFNLEVBQUUsU0FBUyxJQUFJO0FBbUJyQixJQUFBQSxTQUFRLFFBQVE7QUFBQTtBQUFBOzs7QUNuQmhCO0FBQUEsK0NBQUFDLFVBQUE7QUFPQSxRQUFNLGdCQUFOLE1BQW9CO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUtsQixXQUFXLFdBQVc7QUFDcEIsZUFBTztBQUFBLFVBQ0wsbUJBQW1CO0FBQUE7QUFBQSxVQUNuQix1QkFBdUI7QUFBQTtBQUFBLFVBQ3ZCLHVCQUF1QjtBQUFBO0FBQUEsVUFDdkIsZ0NBQWdDO0FBQUE7QUFBQSxRQUNsQztBQUFBLE1BQ0Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0EsWUFBWSxRQUFRO0FBQ2xCLGFBQUssU0FBUyxFQUFDLEdBQUcsY0FBYyxVQUFVLEdBQUcsT0FBTTtBQUFBLE1BQ3JEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUtBLElBQUksb0JBQW9CO0FBL0IxQjtBQStCNEIsVUFBQyxVQUFLLE9BQU8sc0JBQVosbUJBQStCLFVBQVUsS0FBSyxPQUFPLGtCQUFrQixNQUFNLEdBQUcsRUFBRSxJQUFJLENBQUMsV0FBVyxPQUFPLEtBQUssQ0FBQyxJQUFJO0FBQUEsTUFBTTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT3BKLGtCQUFrQixTQUFTO0FBQ3pCLGVBQU8sUUFBUSxNQUFNLElBQUksRUFBRSxPQUFPLENBQUMsS0FBSyxNQUFNLFFBQVEsVUFBVTtBQUM5RCxjQUFJLENBQUMsS0FBSyxXQUFXLElBQUk7QUFBRyxtQkFBTztBQUNuQyxnQkFBTSwyQkFBMkIsTUFBTSxNQUFNLFNBQVMsQ0FBQyxFQUFFLFVBQVUsQ0FBQUMsVUFBUSxLQUFLLFdBQVdBLEtBQUksQ0FBQztBQUNoRyxnQkFBTSxnQkFBZ0IsS0FBSyxNQUFNLEdBQUcsRUFBRSxTQUFTO0FBQy9DLGdCQUFNLGVBQWUsS0FBSyxRQUFRLE1BQU0sRUFBRSxFQUFFLEtBQUs7QUFDakQsY0FBSSxPQUFPLEVBQUUsUUFBUSxlQUFlLGNBQWMseUJBQXlCO0FBQzNFLGlCQUFPO0FBQUEsUUFDVCxHQUFHLENBQUMsQ0FBQztBQUFBLE1BQ1A7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVdBLG9CQUFvQixZQUFZLFVBQVUsT0FBSyxDQUFDLEdBQUU7QUFFaEQsWUFBRyxXQUFXLFNBQVMsR0FBRyxLQUFLLFdBQVcsTUFBTSxHQUFHLEVBQUUsV0FBVztBQUFHLGlCQUFPLFNBQVMsTUFBTSxHQUFHLEVBQUUsQ0FBQztBQUMvRixZQUFHLENBQUMsS0FBSyxvQkFBb0IsVUFBVTtBQUFHLGlCQUFPO0FBQ2pELGNBQU07QUFBQSxVQUNKLGlCQUFpQjtBQUFBLFVBQ2pCLFlBQVksS0FBSyxPQUFPO0FBQUEsVUFDeEIsWUFBWSxLQUFLLE9BQU87QUFBQSxRQUMxQixJQUFJO0FBQ0osY0FBTSxRQUFRLENBQUM7QUFDZixjQUFNLGlCQUFpQixXQUFXLE1BQU0sR0FBRyxFQUFFLE1BQU0sQ0FBQztBQUNwRCxZQUFJLGlCQUFpQixDQUFDO0FBQ3RCLFlBQUksYUFBYTtBQUNqQixZQUFJLFVBQVU7QUFDZCxZQUFJLGFBQWE7QUFDakIsWUFBSSxxQkFBcUI7QUFDekIsWUFBSSxtQkFBbUI7QUFDdkIsWUFBRyxlQUFlLGVBQWUsU0FBTyxDQUFDLEVBQUUsUUFBUSxHQUFHLElBQUksSUFBSTtBQUM1RCwrQkFBcUIsU0FBUyxlQUFlLGVBQWUsU0FBTyxDQUFDLEVBQUUsTUFBTSxHQUFHLEVBQUUsQ0FBQyxFQUFFLFFBQVEsS0FBSyxFQUFFLENBQUM7QUFDcEcseUJBQWUsZUFBZSxTQUFPLENBQUMsSUFBSSxlQUFlLGVBQWUsU0FBTyxDQUFDLEVBQUUsTUFBTSxHQUFHLEVBQUUsQ0FBQztBQUFBLFFBQ2hHO0FBQ0EsY0FBTSxRQUFRLFNBQVMsTUFBTSxJQUFJO0FBQ2pDLFlBQUksc0JBQXNCO0FBRTFCLGlCQUFTLElBQUksR0FBRyxJQUFJLE1BQU0sUUFBUSxLQUFLO0FBQ3JDLGdCQUFNLE9BQU8sTUFBTSxDQUFDO0FBQ3BCLGNBQUcsS0FBSyxRQUFRLEtBQUssTUFBTTtBQUFHLHNCQUFVLENBQUM7QUFDekMsY0FBRztBQUFTO0FBQ1osY0FBRyxDQUFDLE1BQU0sUUFBUSxFQUFFLFFBQVEsSUFBSSxJQUFJO0FBQUk7QUFDeEMsY0FBSSxDQUFDLEtBQUssV0FBVyxJQUFJO0FBQUc7QUFDNUIsZ0NBQXNCLEtBQUssY0FBYyxJQUFJO0FBQzdDLGdCQUFNLGVBQWUsS0FBSyxRQUFRLE1BQU0sRUFBRSxFQUFFLEtBQUs7QUFDakQsZ0JBQU0sZ0JBQWdCLGVBQWUsUUFBUSxZQUFZO0FBQ3pELGNBQUksZ0JBQWdCO0FBQUc7QUFDdkIsY0FBSSxlQUFlLFdBQVc7QUFBZTtBQUM3Qyx5QkFBZSxLQUFLLFlBQVk7QUFDaEMsY0FBSSxlQUFlLFdBQVcsZUFBZSxRQUFRO0FBQ25ELGdCQUFHLHVCQUF1QixHQUFFO0FBQzFCLDJCQUFhLElBQUk7QUFDakI7QUFBQSxZQUNGO0FBQ0EsZ0JBQUcscUJBQXFCLG9CQUFtQjtBQUN6QywyQkFBYSxJQUFJO0FBQ2pCO0FBQUEsWUFDRjtBQUNBO0FBQ0EsMkJBQWUsSUFBSTtBQUNuQjtBQUFBLFVBQ0Y7QUFBQSxRQUNGO0FBRUEsWUFBSSxlQUFlO0FBQUcsaUJBQU87QUFDN0Isa0JBQVU7QUFDVixpQkFBUyxJQUFJLFlBQVksSUFBSSxNQUFNLFFBQVEsS0FBSztBQUM5QyxjQUFJLE9BQU8sTUFBTSxDQUFDO0FBRWxCLGNBQUcsS0FBSyxXQUFXLElBQUksS0FBTSxLQUFLLGNBQWMsSUFBSSxLQUFLO0FBQXNCO0FBRS9FLGNBQUksa0JBQW1CLEtBQUssU0FBUztBQUFpQixtQkFBTyxLQUFLLE1BQU0sR0FBRyxjQUFjLElBQUk7QUFDN0YsY0FBSSxLQUFLLFdBQVcsS0FBSztBQUFHLHNCQUFVLENBQUM7QUFDdkMsZ0JBQU0sS0FBSyxJQUFJO0FBQ2Ysd0JBQWMsS0FBSztBQUNuQixjQUFHLGFBQWMsYUFBYSxXQUFXO0FBQ3ZDLGtCQUFNLE9BQU8sYUFBYTtBQUMxQixrQkFBTSxNQUFNLFNBQU8sQ0FBQyxJQUFJLE1BQU0sTUFBTSxTQUFPLENBQUMsRUFBRSxNQUFNLEdBQUcsTUFBTSxNQUFNLFNBQU8sQ0FBQyxFQUFFLFNBQVMsSUFBSSxJQUFJO0FBQzlGO0FBQUEsVUFDRjtBQUNBLGNBQUcsYUFBYyxZQUFZLGFBQWE7QUFBSztBQUFBLFFBQ2pEO0FBQ0EsWUFBSTtBQUFTLGdCQUFNLEtBQUssS0FBSztBQUM3QixlQUFPLE1BQU0sS0FBSyxJQUFJLEVBQUUsS0FBSztBQUFBLE1BQy9CO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTUEsTUFBTSxFQUFFLFNBQVMsWUFBVSxHQUFHLEdBQUc7QUFDL0IsY0FBTSxtQkFBbUIsS0FBSyx5QkFBeUIsU0FBUyxJQUFJO0FBRXBFLFlBQUcsVUFBVSxTQUFTLGdCQUFnQixHQUFHO0FBQ3ZDLGdCQUFNLG1CQUFtQixLQUFLLG9CQUFvQixZQUFZLGtCQUFrQixPQUFPLEVBQUUsUUFBUSxRQUFRLEVBQUU7QUFDM0csaUJBQU87QUFBQSxZQUNMLFFBQVE7QUFBQSxjQUNOO0FBQUEsZ0JBQ0UsTUFBTTtBQUFBLGdCQUNOLE1BQU0sWUFBWTtBQUFBLGdCQUNsQixRQUFRLGlCQUFpQjtBQUFBLGdCQUN6QixTQUFTO0FBQUEsY0FDWDtBQUFBLFlBQ0Y7QUFBQSxZQUNBLEtBQUssQ0FBQztBQUFBLFVBQ1I7QUFBQSxRQUNGO0FBRUEsY0FBTSxTQUFTLFFBQVEsTUFBTSxJQUFJLEVBQzlCLE9BQU8sQ0FBQyxLQUFLLE1BQU0sR0FBRyxRQUFRO0FBRTdCLGNBQUcsS0FBSyxXQUFXLElBQUksTUFBTSxDQUFDLElBQUksY0FBYyxDQUFDLEtBQUssT0FBTyx3QkFBeUIsS0FBSyxjQUFjLElBQUksS0FBSyxJQUFJLGNBQWdCLElBQUksS0FBSyxTQUFTLEtBQUssT0FBTyx3QkFBd0I7QUFDMUwsaUJBQUssYUFBYSxHQUFHO0FBQ3JCLGdCQUFJLGFBQWEsS0FBSyxjQUFjLElBQUk7QUFDeEMsZ0JBQUksa0JBQWtCLElBQUksZ0JBQWdCLE9BQU8sWUFBVSxPQUFPLFFBQVEsSUFBSSxVQUFVO0FBQ3hGLGdCQUFJLGdCQUFnQixLQUFLLEVBQUUsUUFBUSxLQUFLLFFBQVEsTUFBTSxFQUFFLEVBQUUsS0FBSyxHQUFHLE9BQU8sSUFBSSxXQUFXLENBQUM7QUFDekYsZ0JBQUksYUFBYTtBQUNqQixnQkFBSSxPQUFPO0FBQ1gsZ0JBQUksUUFBUSxJQUFJLGdCQUFnQixJQUFJLFlBQVUsT0FBTyxNQUFNLEVBQUUsS0FBSyxLQUFLO0FBQ3ZFLGdCQUFJLGlCQUFpQixNQUFNLElBQUksZ0JBQWdCLElBQUksWUFBVSxPQUFPLE1BQU0sRUFBRSxLQUFLLEdBQUc7QUFDcEYsaUJBQUssMEJBQTBCLEdBQUc7QUFDbEMsZ0JBQUksb0JBQW9CLEtBQUssSUFBSSxjQUFjO0FBQy9DLGdCQUFJLGFBQWEsWUFBWSxJQUFJO0FBQ2pDLGdCQUFJLGVBQWUsS0FBSyxRQUFRLE1BQU0sRUFBRSxFQUFFLEtBQUs7QUFDL0MsbUJBQU87QUFBQSxVQUNUO0FBRUEsY0FBRyxLQUFLLGdCQUFnQixJQUFJLEdBQUU7QUFDNUIsZ0JBQUcsSUFBSSxLQUFLLFFBQVEsSUFBSSxNQUFNO0FBQUksa0JBQUksUUFBUTtBQUM5QyxnQkFBSSxRQUFRLE9BQU87QUFDbkIsZ0JBQUksWUFBWTtBQUFBLFVBQ2xCO0FBQ0EsY0FBSSxNQUFNLElBQUksU0FBUztBQUFHLGlCQUFLLGFBQWEsR0FBRztBQUMvQyxpQkFBTztBQUFBLFFBQ1QsR0FBRyxFQUFFLGdCQUFnQixJQUFJLHFCQUFxQixDQUFDLEdBQUcsWUFBWSxZQUFZLEtBQUssTUFBTSxrQkFBa0IsaUJBQWlCLENBQUMsR0FBRyxRQUFRLENBQUMsR0FBRyxLQUFLLENBQUMsR0FBRyxZQUFZLEdBQUcsV0FBVyxHQUFHLGNBQWMsS0FBSyxDQUFDO0FBRXBNLGVBQU87QUFBQSxVQUNMLEdBQUc7QUFBQSxVQUNIO0FBQUE7QUFBQSxVQUVBLGdCQUFnQjtBQUFBLFVBQ2hCLHFCQUFxQjtBQUFBLFVBQ3JCLFlBQVk7QUFBQSxVQUNaLE1BQU07QUFBQSxVQUNOLGlCQUFpQjtBQUFBLFFBQ25CO0FBQUEsTUFDRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1BLDBCQUEwQixLQUFLO0FBQzdCLFlBQUksQ0FBQyxJQUFJLG9CQUFvQixTQUFTLElBQUksY0FBYztBQUFHO0FBQzNELFlBQUksUUFBUTtBQUNaLGNBQU0saUJBQWlCLElBQUksSUFBSSxJQUFJLG1CQUFtQjtBQUN0RCxlQUFPLGVBQWUsSUFBSSxHQUFHLElBQUksa0JBQWtCLFFBQVEsR0FBRztBQUFFO0FBQUEsUUFBUztBQUN6RSxZQUFJLGlCQUFpQixHQUFHLElBQUksa0JBQWtCO0FBQUEsTUFDaEQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNQSxhQUFhLEtBQUs7QUFDaEIsY0FBTSxFQUFFLHVCQUF1QixzQkFBc0IsSUFBSSxLQUFLO0FBQzlELFlBQUcsSUFBSSxLQUFLLFFBQVEsSUFBSSxNQUFNO0FBQUksaUJBQU8sSUFBSSxJQUFJLEtBQUsseUJBQXlCLElBQUksTUFBTTtBQUN6RixZQUFHLENBQUMsS0FBSyxpQkFBaUIsSUFBSSxjQUFjO0FBQUcsaUJBQU8sSUFBSSxJQUFJLEtBQUssOEJBQThCLElBQUksZ0JBQWdCO0FBQ3JILFlBQUcsSUFBSSxLQUFLLFNBQVM7QUFBdUIsY0FBSSxPQUFPLElBQUksS0FBSyxVQUFVLEdBQUcscUJBQXFCO0FBQ2xHLGNBQU0scUJBQXFCLElBQUksS0FBSyxRQUFRLElBQUksSUFBSTtBQUNwRCxjQUFNLGVBQWUsSUFBSSxLQUFLLFNBQVM7QUFDdkMsWUFBRyxlQUFlO0FBQXVCLGlCQUFPLElBQUksSUFBSSxLQUFLLDJDQUEyQyxJQUFJLE1BQU07QUFDbEgsWUFBRyxLQUFLLE9BQU8sZ0NBQStCO0FBQzVDLGdCQUFNLGNBQWMsSUFBSSxLQUFLLE1BQU0sSUFBSTtBQUN2QyxnQkFBTSxpQkFBaUIsWUFBWSxNQUFNLENBQUMsRUFBRSxPQUFPLFVBQVEsS0FBSyxXQUFXLElBQUksQ0FBQztBQUNoRixjQUFHLGVBQWUsV0FBVyxZQUFZLFNBQVM7QUFBRyxtQkFBTyxJQUFJLElBQUksS0FBSyxzQ0FBc0MsSUFBSSxNQUFNO0FBQUEsUUFDM0g7QUFDQSxZQUFJLE9BQU8sS0FBSztBQUFBLFVBQ2QsTUFBTSxJQUFJLEtBQUssS0FBSztBQUFBLFVBQ3BCLE1BQU0sSUFBSTtBQUFBLFVBQ1YsUUFBUTtBQUFBLFVBQ1IsU0FBUyxJQUFJO0FBQUEsVUFDYixPQUFPLENBQUMsSUFBSSxZQUFZLElBQUksU0FBUztBQUFBLFFBQ3ZDLENBQUM7QUFBQSxNQUNIO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTUEsZ0JBQWdCLE1BQU07QUFFcEIsWUFBSSxDQUFDLE1BQU0sUUFBUSxFQUFFLFFBQVEsSUFBSSxJQUFJO0FBQUksaUJBQU87QUFDaEQsZUFBTztBQUFBLE1BQ1Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNQSx5QkFBeUIsV0FBVztBQUFFLGVBQU8sVUFBVSxRQUFRLE9BQU8sRUFBRSxFQUFFLE1BQU0sR0FBRyxFQUFFLElBQUksV0FBUyxNQUFNLEtBQUssQ0FBQyxFQUFFLE9BQU8sV0FBUyxVQUFVLEVBQUUsRUFBRSxLQUFLLEtBQUs7QUFBQSxNQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNM0osY0FBYyxNQUFNO0FBQUUsZUFBTyxLQUFLLE1BQU0sR0FBRyxFQUFFLFNBQVM7QUFBQSxNQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVF6RCxXQUFXLE1BQU07QUFBRSxlQUFPLEtBQUssV0FBVyxHQUFHLEtBQU0sQ0FBQyxLQUFLLEdBQUcsRUFBRSxRQUFRLEtBQUssQ0FBQyxDQUFDLElBQUk7QUFBQSxNQUFLO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNdEYsb0JBQW9CLFlBQVk7QUFBRSxlQUFPLFdBQVcsUUFBUSxHQUFHLElBQUk7QUFBQSxNQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNdkUsaUJBQWlCLFVBQVU7QUEvUTdCO0FBK1ErQixlQUFPLENBQUMsQ0FBQyxHQUFDLFVBQUssc0JBQUwsbUJBQXdCLEtBQUssZUFBYSxTQUFTLFFBQVEsU0FBUyxJQUFJO0FBQUEsTUFBSztBQUFBO0FBQUEsSUFFdEg7QUFDQSxJQUFBRCxTQUFRLGdCQUFnQjtBQUFBO0FBQUE7OztBQ2xSeEI7QUFBQSw4Q0FBQUUsVUFBQTtBQXFCQSxRQUFNLEVBQUUsY0FBYyxJQUFJO0FBQzFCLElBQUFBLFNBQVEsZ0JBQWdCO0FBQUE7QUFBQTs7O0FDdEJ4QjtBQUFBLDhDQUFBQyxVQUFBO0FBS0EsYUFBUyxXQUFXLE1BQU07QUFDeEIsWUFBTSxNQUFNLEtBQUssVUFBVSxJQUFJO0FBQy9CLFVBQUksT0FBTztBQUNYLFVBQUksSUFBSSxXQUFXO0FBQUcsZUFBTztBQUM3QixlQUFTLElBQUksR0FBRyxJQUFJLElBQUksUUFBUSxLQUFLO0FBQ25DLGNBQU0sT0FBTyxJQUFJLFdBQVcsQ0FBQztBQUM3QixnQkFBUyxRQUFRLEtBQUssT0FBUTtBQUM5QixlQUFPLE9BQU87QUFFZCxZQUFJLE9BQU87QUFBRyxpQkFBTyxPQUFPO0FBQUEsTUFDOUI7QUFDQSxhQUFPLEtBQUssU0FBUyxJQUFJLElBQUk7QUFBQSxJQUMvQjtBQUNBLElBQUFBLFNBQVEsYUFBYTtBQVFyQixhQUFTLFdBQVcsUUFBUSxRQUFRO0FBQ2xDLGlCQUFXLE9BQU8sUUFBUTtBQUN4QixZQUFJLE9BQU8sZUFBZSxHQUFHLEdBQUc7QUFFOUIsY0FBSSxPQUFPLE9BQU8sR0FBRyxDQUFDLEtBQUssT0FBTyxPQUFPLEdBQUcsQ0FBQztBQUFHLHVCQUFXLE9BQU8sR0FBRyxHQUFHLE9BQU8sR0FBRyxDQUFDO0FBQUE7QUFDOUUsbUJBQU8sR0FBRyxJQUFJLE9BQU8sR0FBRztBQUFBLFFBQy9CO0FBQUEsTUFDRjtBQUNBLGFBQU87QUFDUCxlQUFTLE9BQU8sTUFBTTtBQUFFLGVBQVEsUUFBUSxPQUFPLFNBQVMsWUFBWSxDQUFDLE1BQU0sUUFBUSxJQUFJO0FBQUEsTUFBSTtBQUFBLElBQzdGO0FBQ0EsSUFBQUEsU0FBUSxhQUFhO0FBT3JCLGFBQVMsOEJBQThCLFlBQVk7QUFDakQsYUFBTyxXQUNKLFFBQVEsbUJBQW1CLE9BQU8sRUFDbEMsWUFBWSxFQUNaLFFBQVEsTUFBTSxJQUFJLElBQ2pCO0FBQUEsSUFDTjtBQUNBLElBQUFBLFNBQVEsZ0NBQWdDO0FBUXhDLGFBQVMsUUFBUSxTQUFTLFNBQVM7QUFDakMsWUFBTSxhQUFhLFFBQVEsT0FBTyxDQUFDLEtBQUssS0FBSyxNQUFNLE1BQU0sTUFBTSxRQUFRLENBQUMsR0FBRyxDQUFDO0FBQzVFLFlBQU0sUUFBUSxLQUFLLEtBQUssUUFBUSxPQUFPLENBQUMsS0FBSyxRQUFRLE1BQU0sTUFBTSxLQUFLLENBQUMsQ0FBQztBQUN4RSxZQUFNLFFBQVEsS0FBSyxLQUFLLFFBQVEsT0FBTyxDQUFDLEtBQUssUUFBUSxNQUFNLE1BQU0sS0FBSyxDQUFDLENBQUM7QUFDeEUsYUFBTyxVQUFVLEtBQUssVUFBVSxJQUFJLElBQUksY0FBYyxRQUFRO0FBQUEsSUFDaEU7QUFDQSxJQUFBQSxTQUFRLFVBQVU7QUFRbEIsYUFBUyxRQUFRLE1BQU0sTUFBTSxLQUFLLElBQUk7QUFDcEMsVUFBSSxLQUFLLE1BQU0sT0FBTyxJQUFJO0FBQ3hCLGFBQUssTUFBTSxJQUFJLElBQUk7QUFBQSxNQUNyQixXQUFXLEtBQUssTUFBTSxLQUFLLEtBQUs7QUFDOUIsYUFBSyxNQUFNLElBQUksSUFBSTtBQUNuQixhQUFLLE1BQU0sT0FBTyxLQUFLLE9BQU87QUFDOUIsYUFBSyxVQUFVLE1BQU0sS0FBSyxLQUFLLEtBQUssRUFBRSxPQUFPLENBQUMsS0FBSyxTQUFVLEtBQUssTUFBTSxJQUFJLE1BQU0sT0FBTyxHQUFJO0FBQzdGLGFBQUssTUFBTSxLQUFLLFFBQVE7QUFBQSxNQUMxQjtBQUFBLElBQ0Y7QUFDQSxJQUFBQSxTQUFRLFVBQVU7QUFPbEIsYUFBUyxNQUFNLElBQUk7QUFBRSxhQUFPLElBQUksUUFBUSxhQUFXLFdBQVcsU0FBUyxFQUFFLENBQUM7QUFBQSxJQUFHO0FBQzdFLElBQUFBLFNBQVEsUUFBUTtBQUFBO0FBQUE7OztBQzNGaEI7QUFBQSxxREFBQUMsVUFBQTtBQUFBLFFBQU0sVUFBVTtBQUNoQixRQUFNO0FBQUEsTUFDSjtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsSUFDRixJQUFJO0FBS0osUUFBTSxpQkFBTixNQUFxQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLbkIsV0FBVyxXQUFXO0FBQ3BCLGVBQU87QUFBQSxVQUNMLE1BQU07QUFBQSxZQUNKLEtBQUs7QUFBQSxVQUNQO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxZQUFZLEtBQUssT0FBTyxNQUFNO0FBNUJoQztBQTZCSSxhQUFLLE1BQU07QUFDWCxhQUFLLFFBQVEsS0FBSztBQUNsQixhQUFLLFVBQVMsVUFBSyxRQUFMLG1CQUFVO0FBQ3hCLGFBQUssZUFBZTtBQUNwQixZQUFJO0FBQU0sZUFBSyxPQUFPO0FBQ3RCLFlBQUcsQ0FBQyxLQUFLLEtBQUs7QUFBWSxlQUFLLEtBQUssYUFBYSxLQUFLLFlBQVk7QUFBQSxNQUNwRTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0EsaUJBQWlCO0FBQ2YsWUFBSSxnQkFBZ0IsS0FBSztBQUN6QixlQUFPLGVBQWU7QUFDcEIsbUJBQVMsT0FBTyxjQUFjLFVBQVU7QUFDdEMsZ0JBQUksT0FBTyxjQUFjLFNBQVMsR0FBRyxNQUFNO0FBQVUsbUJBQUssR0FBRyxJQUFJLEVBQUUsR0FBRyxjQUFjLFNBQVMsR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEVBQUU7QUFBQTtBQUMzRyxtQkFBSyxHQUFHLElBQUksY0FBYyxTQUFTLEdBQUc7QUFBQSxVQUM3QztBQUNBLDBCQUFnQixPQUFPLGVBQWUsYUFBYTtBQUFBLFFBQ3JEO0FBQUEsTUFDRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNQSxVQUFVO0FBQ1IsZ0JBQVEsSUFBSSx3QkFBd0I7QUFDcEMsZUFBTyxXQUFXLEtBQUssSUFBSTtBQUFBLE1BQzdCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxZQUFZLE1BQU07QUFDaEIsZUFBTyxLQUFLLE1BQU0sS0FBSyxVQUFVLE1BQU0sS0FBSyxvQkFBb0IsQ0FBQztBQUNqRSxtQkFBVyxLQUFLLE1BQU0sSUFBSTtBQUMxQixlQUFPO0FBQUEsTUFDVDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEscUJBQXFCLEtBQUssT0FBTztBQUMvQixZQUFJLGlCQUFpQjtBQUFnQixpQkFBTyxNQUFNO0FBQ2xELFlBQUksTUFBTSxRQUFRLEtBQUs7QUFBRyxpQkFBTyxNQUFNLElBQUksQ0FBQyxRQUFTLGVBQWUsaUJBQWtCLElBQUksTUFBTSxHQUFHO0FBQ25HLGVBQU87QUFBQSxNQUNUO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTUEsT0FBTztBQUFFLGFBQUssS0FBSztBQUFBLE1BQUc7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS3RCLE9BQU87QUFDTCxZQUFJLENBQUMsS0FBSyxjQUFjLEdBQUc7QUFDekIsY0FBSSxLQUFLO0FBQUssaUJBQUssV0FBVyxPQUFPLEtBQUssR0FBRztBQUM3QyxpQkFBTyxRQUFRLE1BQU0sa0JBQWtCLEVBQUUsTUFBTSxLQUFLLE1BQU0sT0FBTyxJQUFJLE1BQU0sRUFBRSxNQUFNLENBQUM7QUFBQSxRQUN0RjtBQUNBLGFBQUssV0FBVyxJQUFJLElBQUk7QUFDeEIsYUFBSyxXQUFXLEtBQUs7QUFBQSxNQUN2QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNQSxnQkFBZ0I7QUFDZCxZQUFHLENBQUMsS0FBSztBQUFLLGlCQUFPO0FBQ3JCLFlBQUcsS0FBSyxRQUFRO0FBQUksaUJBQU87QUFDM0IsWUFBRyxLQUFLLFFBQVE7QUFBYSxpQkFBTztBQUNwQyxlQUFPO0FBQUEsTUFDVDtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0EsU0FBUztBQUFFLGFBQUssV0FBVyxPQUFPLEtBQUssR0FBRztBQUFBLE1BQUc7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVE3QyxPQUFPLE9BQU8sQ0FBQyxHQUFHO0FBQ2hCLGNBQU07QUFBQSxVQUNKO0FBQUEsVUFDQSxlQUFlLGNBQWMsQ0FBQyxXQUFXLElBQUksQ0FBQztBQUFBLFVBQzlDO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsUUFDRixJQUFJO0FBQ0osWUFBSSw2Q0FBYyxTQUFTLEtBQUs7QUFBTSxpQkFBTztBQUM3QyxZQUFJLDJCQUEyQixLQUFLLElBQUksV0FBVyx1QkFBdUI7QUFBRyxpQkFBTztBQUNwRixZQUFJLGlCQUFpQixDQUFDLEtBQUssSUFBSSxTQUFTLGFBQWE7QUFBRyxpQkFBTztBQUMvRCxZQUFJLG1CQUFtQixDQUFDLEtBQUssSUFBSSxXQUFXLGVBQWU7QUFBRyxpQkFBTztBQUNyRSxZQUFJLHVCQUF1QixDQUFDLG9CQUFvQixLQUFLLENBQUMsV0FBVyxLQUFLLElBQUksV0FBVyxNQUFNLENBQUM7QUFBRyxpQkFBTztBQUV0RyxlQUFPO0FBQUEsTUFDVDtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0EsUUFBUTtBQUFBLE1BQUU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTVYsV0FBVyxrQkFBa0I7QUFBRSxlQUFPLDhCQUE4QixLQUFLLElBQUk7QUFBQSxNQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1oRixJQUFJLGtCQUFrQjtBQUFFLGVBQU8sS0FBSyxLQUFLLGtCQUFrQixLQUFLLEtBQUssa0JBQWtCLDhCQUE4QixLQUFLLEtBQUssY0FBYyxLQUFLLFlBQVksSUFBSTtBQUFBLE1BQUc7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTXJLLElBQUksYUFBYTtBQUFFLGVBQU8sS0FBSyxJQUFJLEtBQUssZUFBZTtBQUFBLE1BQUc7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTTFELElBQUksTUFBTTtBQUFFLGVBQU8sS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLE9BQU8sS0FBSyxRQUFRO0FBQUEsTUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNcEUsSUFBSSxNQUFNO0FBQUUsZUFBTyxFQUFFLGlCQUFpQixLQUFLLGlCQUFpQixLQUFLLEtBQUssSUFBSTtBQUFBLE1BQUc7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTTdFLElBQUksVUFBVTtBQUFFLGVBQU8sS0FBSztBQUFBLE1BQUs7QUFBQTtBQUFBLElBQ25DO0FBQ0EsSUFBQUEsU0FBUSxpQkFBaUI7QUFBQTtBQUFBOzs7QUN0THpCO0FBQUEsaURBQUFDLFVBQUE7QUFBQSxRQUFNLEVBQUUsZUFBZSxJQUFJO0FBQzNCLFFBQU0sZ0JBQWdCLE9BQU8sZUFBZSxpQkFBZ0I7QUFBQSxJQUFDLENBQUMsRUFBRTtBQUNoRSxRQUFNLFVBQVU7QUFDaEIsUUFBTSxFQUFFLFdBQVksSUFBSTtBQUt4QixRQUFNLGFBQU4sTUFBaUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS2YsWUFBWSxLQUFLO0FBQ2YsYUFBSyxNQUFNO0FBQ1gsYUFBSyxRQUFRLEtBQUs7QUFDbEIsYUFBSyxTQUFTLEtBQUssSUFBSTtBQUN2QixhQUFLLFFBQVEsQ0FBQztBQUNkLGFBQUssTUFBTSxLQUFLLElBQUksWUFBWSxRQUFRLE1BQU0sS0FBSyxJQUFJLFdBQVc7QUFBQSxNQUNwRTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsT0FBTyxLQUFLLEtBQUssU0FBUyxDQUFDLEdBQUc7QUFDNUIsY0FBTSxFQUFFLHVCQUF1QixJQUFJO0FBQ25DLFlBQUksS0FBSyxlQUFlLElBQUksSUFBSSxLQUFLLEdBQUc7QUFDeEMsWUFBSSx3QkFBd0I7QUFDMUIsY0FBSSxLQUFLLGVBQWUsRUFBRSxrQkFBa0I7QUFDNUMsY0FBSSxZQUFZLHNCQUFzQixJQUFJLEtBQUs7QUFBQSxRQUNqRDtBQUNBLFlBQUksS0FBSyxlQUFlLEVBQUUsZUFBZTtBQUV6QyxZQUFJLElBQUksS0FBSyxlQUFlLEVBQUUsZ0JBQWdCO0FBQWUsaUJBQU8sSUFBSSxLQUFLLGVBQWUsRUFBRSxLQUFLLEVBQUUsS0FBSyxNQUFNLElBQUksS0FBSyxlQUFlLENBQUM7QUFBQTtBQUNwSSxjQUFJLEtBQUssZUFBZSxFQUFFLEtBQUs7QUFDcEMsZUFBTyxJQUFJLEtBQUssZUFBZTtBQUFBLE1BQ2pDO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFJQSxpQkFBaUI7QUEzQ25CO0FBNENJLFlBQUksZ0JBQWdCLEtBQUs7QUFDekIsZUFBTyxlQUFlO0FBQ3BCLGdCQUFNLFlBQVcsZ0JBQUssV0FBTCxtQkFBYSxnQkFBYixtQkFBMkIsY0FBYztBQUMxRCxpQkFBTyxRQUFTLE9BQU8sYUFBYSxXQUFZLFdBQVcsQ0FBQyxDQUFDLEVBQzFELFFBQVEsQ0FBQyxDQUFDLEtBQUssS0FBSyxNQUFNLEtBQUssR0FBRyxJQUFJLEtBQUs7QUFFOUMsMEJBQWdCLE9BQU8sZUFBZSxhQUFhO0FBQUEsUUFDckQ7QUFBQSxNQUVGO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLQSxPQUFPO0FBQUUsYUFBSyxJQUFJLEtBQUs7QUFBQSxNQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLMUIsT0FBTztBQUFFLGFBQUssSUFBSSxLQUFLO0FBQUEsTUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUTFCLFFBQVEsS0FBSyxPQUFPO0FBQ2xCLFlBQUksT0FBTyxVQUFVLFlBQVksVUFBVTtBQUFNLGlCQUFPO0FBQ3hELFlBQUksTUFBTTtBQUFZLGlCQUFPLElBQUssS0FBSyxJQUFJLFdBQVcsTUFBTSxVQUFVLEVBQUcsS0FBSyxLQUFLLEtBQUs7QUFDeEYsZUFBTztBQUFBLE1BQ1Q7QUFBQSxNQUNBLFNBQVMsS0FBSyxPQUFPO0FBQ25CLFlBQUksaUJBQWlCLEtBQUs7QUFBVyxpQkFBTyxNQUFNO0FBQ2xELFlBQUksaUJBQWlCO0FBQWdCLGlCQUFPLE1BQU07QUFDbEQsZUFBTztBQUFBLE1BQ1Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxpQkFBaUIsT0FBTyxDQUFDLEdBQUc7QUFDMUIsY0FBTSxXQUFXLEtBQUssUUFBUSxJQUFJO0FBQ2xDLGNBQU0sT0FBTyxXQUFXLFdBQVcsSUFBSSxLQUFLLFVBQVUsS0FBSyxHQUFHO0FBQzlELGFBQUssU0FBUyxDQUFDLENBQUMsQ0FBQztBQUNqQixjQUFNLFVBQVUsS0FBSyxZQUFZLElBQUk7QUFDckMsWUFBSSxZQUFZLENBQUM7QUFBUyxpQkFBTztBQUNqQyxZQUFJLEtBQUssY0FBYztBQUFHLGVBQUssSUFBSSxJQUFJO0FBR3ZDLFlBQUksS0FBSyxnQkFBZ0I7QUFBZSxpQkFBTyxJQUFJLFFBQVEsQ0FBQyxTQUFTLFdBQVc7QUFBRSxpQkFBSyxLQUFLLElBQUksRUFBRSxLQUFLLE1BQU0sUUFBUSxJQUFJLENBQUM7QUFBQSxVQUFHLENBQUM7QUFDOUgsYUFBSyxLQUFLLElBQUk7QUFDZCxlQUFPO0FBQUEsTUFDVDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLFFBQVEsTUFBTTtBQUNaLFlBQUcsS0FBSztBQUFLLGlCQUFPLEtBQUssSUFBSSxLQUFLLEdBQUc7QUFDckMsY0FBTSxPQUFPLElBQUksS0FBSyxVQUFVLEtBQUssR0FBRztBQUN4QyxjQUFNLFlBQVksS0FBSyxNQUFNLEtBQUssVUFBVSxNQUFNLEtBQUssb0JBQW9CLENBQUM7QUFDNUUsbUJBQVcsS0FBSyxNQUFNLFNBQVM7QUFDL0IsZUFBTyxLQUFLLE1BQU0sS0FBSyxJQUFJLEtBQUssR0FBRyxJQUFJO0FBQUEsTUFDekM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLE9BQU8sTUFBTTtBQUFFLGVBQU8sT0FBTyxRQUFRLEtBQUssS0FBSyxFQUFFLE9BQU8sQ0FBQyxDQUFDLEtBQUssSUFBSSxNQUFNLEtBQUssT0FBTyxJQUFJLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxLQUFLLElBQUksTUFBTSxJQUFJO0FBQUEsTUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFReEgsTUFBTSxTQUFTLFdBQVMsQ0FBQyxHQUFHLE9BQUssQ0FBQyxHQUFHO0FBQUUsZUFBTyxNQUFNLDJCQUEyQixPQUFPLEtBQUssT0FBTyxJQUFJLEdBQUcsSUFBSTtBQUFBLE1BQUc7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNaEgsSUFBSSxLQUFLO0FBQUUsZUFBTyxLQUFLLE1BQU0sR0FBRztBQUFBLE1BQUc7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNbkMsU0FBUyxPQUFPLENBQUMsR0FBRztBQUNsQixZQUFJLE1BQU0sUUFBUSxJQUFJO0FBQUcsaUJBQU8sS0FBSyxJQUFJLENBQUMsUUFBUSxLQUFLLElBQUksR0FBRyxDQUFDO0FBQy9ELGdCQUFRLE1BQU0seUNBQXlDLElBQUk7QUFBQSxNQUM3RDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1BLFNBQVMsT0FBTyxNQUFNO0FBQ3BCLFlBQUksTUFBTTtBQUNSLGdCQUFNLFdBQVcsS0FBSyxPQUFPLElBQUk7QUFDakMsaUJBQU8sU0FBUyxLQUFLLE1BQU0sS0FBSyxPQUFPLElBQUksU0FBUyxNQUFNLENBQUM7QUFBQSxRQUM3RDtBQUNBLGVBQU8sS0FBSyxNQUFNLEtBQUssS0FBSyxLQUFLLE1BQU0sS0FBSyxPQUFPLElBQUksS0FBSyxLQUFLLE1BQU0sQ0FBQyxDQUFDO0FBQUEsTUFDM0U7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNQSxJQUFJLE1BQU07QUFDUixZQUFJLENBQUMsS0FBSztBQUFLLGdCQUFNLElBQUksTUFBTSw2QkFBNkI7QUFDNUQsYUFBSyxNQUFNLEtBQUssR0FBRyxJQUFJO0FBQUEsTUFDekI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNQSxZQUFZLE9BQU8sQ0FBQyxHQUFHLE9BQU8sQ0FBQyxHQUFHO0FBQUUsYUFBSyxTQUFTLElBQUksRUFBRSxRQUFRLENBQUMsU0FBUyxLQUFLLFlBQVksSUFBSSxDQUFDO0FBQUEsTUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLbkcsUUFBUTtBQUNOLGFBQUssUUFBUSxDQUFDO0FBQUEsTUFDaEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0EsT0FBTyxLQUFLO0FBQ1YsZUFBTyxLQUFLLE1BQU0sR0FBRztBQUFBLE1BQ3ZCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUtBLFlBQVksT0FBTyxDQUFDLEdBQUc7QUFDckIsYUFBSyxRQUFRLENBQUMsUUFBUSxPQUFPLEtBQUssTUFBTSxHQUFHLENBQUM7QUFBQSxNQUM5QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1BLFdBQVcsa0JBQWtCO0FBQUUsZUFBTyxLQUFLLEtBQUssUUFBUSxtQkFBbUIsT0FBTyxFQUFFLFlBQVk7QUFBQSxNQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUtuRyxJQUFJLGtCQUFrQjtBQUFFLGVBQVEsS0FBSyxtQkFBb0IsS0FBSyxtQkFBbUIsS0FBSyxZQUFZO0FBQUEsTUFBaUI7QUFBQSxNQUNuSCxJQUFJLGdCQUFnQixNQUFNO0FBQUUsYUFBSyxtQkFBbUI7QUFBQSxNQUFNO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUsxRCxJQUFJLE9BQU87QUFBRSxlQUFPLE9BQU8sS0FBSyxLQUFLLEtBQUs7QUFBQSxNQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUs3QyxJQUFJLGtCQUFrQjtBQUFFLGVBQU8sS0FBSyxZQUFZLEtBQUssTUFBTSxHQUFHLEVBQUUsRUFBRSxRQUFRLFVBQVUsR0FBRztBQUFBLE1BQUc7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLMUYsSUFBSSxZQUFZO0FBQUUsZUFBTyxLQUFLLGdCQUFnQixRQUFRLG1CQUFtQixPQUFPLEVBQUUsWUFBWTtBQUFBLE1BQUc7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS2pHLElBQUksWUFBWTtBQUFFLGVBQU8sS0FBSyxJQUFJLFdBQVcsS0FBSyxlQUFlO0FBQUEsTUFBRztBQUFBLElBQ3RFO0FBQ0EsSUFBQUEsU0FBUSxhQUFhO0FBWXJCLG1CQUFlLDJCQUEyQkMsUUFBTyxlQUFlLE9BQU8sQ0FBQyxHQUFHO0FBQ3pFLFVBQUksUUFBUTtBQUNaLGlCQUFXLFFBQVFBLFFBQU87QUFFeEIsWUFBSSxPQUFPLFNBQVMsWUFBWTtBQUM5QixnQkFBTSxJQUFJLFVBQVUseURBQXlEO0FBQUEsUUFDL0U7QUFDQSxZQUFJO0FBQ0Ysa0JBQVEsTUFBTSxLQUFLLE9BQU8sSUFBSTtBQUFBLFFBQ2hDLFNBQVMsT0FBUDtBQUVBLGdCQUFNO0FBQUEsUUFDUjtBQUFBLE1BQ0Y7QUFFQSxhQUFPO0FBQUEsSUFDVDtBQUNBLElBQUFELFNBQVEsNkJBQTZCO0FBQUE7QUFBQTs7O0FDN1ByQztBQUFBLHVEQUFBRSxVQUFBO0FBR0EsUUFBTSxVQUFOLE1BQWM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS1osWUFBWSxNQUFNO0FBS2hCLGFBQUssT0FBTztBQUtaLGVBQU8sT0FBTyxNQUFNLEtBQUssTUFBTTtBQUFBLE1BQ2pDO0FBQUEsSUFDRjtBQUdBLElBQUFBLFNBQVEsVUFBVTtBQUFBO0FBQUE7OztBQ3ZCbEI7QUFBQSxtREFBQUMsVUFBQTtBQUFBLFFBQU0sRUFBRSxRQUFRLElBQUk7QUFTcEIsUUFBTSxhQUFOLGNBQXlCLFFBQVE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU8vQixNQUFNLGFBQWEsT0FBTztBQUFFLGVBQU8sS0FBSyxnQkFBZ0IsS0FBSztBQUFBLE1BQUc7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPaEUsZ0JBQWdCLE9BQU87QUF2QnpCO0FBd0JJLFlBQUcsU0FBTyxVQUFLLFlBQUwsbUJBQWMscUJBQW9CO0FBQVksaUJBQU8sS0FBSyxRQUFRLGdCQUFnQixLQUFLO0FBQ2pHLFlBQUcsT0FBTyxVQUFVO0FBQVUsa0JBQVEsS0FBSyxVQUFVLEtBQUs7QUFDMUQsZUFBTyxNQUFNLFNBQVM7QUFBQSxNQUN4QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNQSxJQUFJLFlBQVk7QUFBRSxlQUFRLEtBQUssYUFBYSxJQUFLO0FBQUEsTUFBSztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU90RCxNQUFNLE1BQU0sT0FBTztBQUNqQixZQUFHLEVBQUMsK0JBQU87QUFBUSxpQkFBTyxRQUFRLElBQUksZ0JBQWdCO0FBQ3RELGdCQUFRLEtBQUssb0JBQW9CLEtBQUs7QUFDdEMsY0FBTSxhQUFhLE1BQU0sS0FBSyxrQkFBa0IsS0FBSztBQUNyRCxlQUFPLFdBQVcsQ0FBQztBQUFBLE1BQ3JCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsTUFBTSxZQUFZLE9BQU87QUFDdkIsZ0JBQVEsTUFBTSxPQUFPLFVBQUs7QUFyRDlCO0FBcURpQyw2QkFBSyxnQkFBTCxtQkFBa0IsVUFBUztBQUFBLFNBQUM7QUFDekQsWUFBRyxNQUFNLFdBQVc7QUFBRyxpQkFBTyxRQUFRLElBQUksbURBQW1EO0FBQzdGLGNBQU0sZUFBZSxLQUFLLG9CQUFvQixLQUFLO0FBQ25ELFlBQUksYUFBYSxNQUFNLEtBQUssa0JBQWtCLFlBQVk7QUFDMUQsWUFBRyxDQUFDO0FBQVksaUJBQU8sUUFBUSxNQUFNLEtBQUs7QUFDMUMscUJBQWEsV0FBVyxJQUFJLENBQUMsV0FBVyxNQUFNLEtBQUssdUJBQXVCLGNBQWMsV0FBVyxDQUFDLENBQUM7QUFDckcsZUFBTyxNQUFNLElBQUksQ0FBQyxNQUFNLE1BQU07QUFDNUIsZUFBSyxNQUFNLFdBQVcsQ0FBQyxFQUFFO0FBQ3pCLGVBQUssU0FBUyxXQUFXLENBQUMsRUFBRTtBQUM1QixpQkFBTztBQUFBLFFBQ1QsQ0FBQztBQUFBLE1BQ0g7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BU0EsdUJBQXVCLGNBQWMsV0FBVyxHQUFHO0FBQ2pELGNBQU0sY0FBYyxLQUFLLHdCQUF3QixZQUFZO0FBQzdELGVBQU87QUFBQSxVQUNMLEtBQUssVUFBVTtBQUFBLFVBQ2YsUUFBUSxLQUFLLE1BQU8sYUFBYSxDQUFDLEVBQUUsU0FBUyxjQUFlLFVBQVUsTUFBTTtBQUFBLFFBQzlFO0FBQUEsTUFDRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLHdCQUF3QixjQUFjO0FBQUUsZUFBTyxhQUFhLE9BQU8sQ0FBQyxLQUFLLFNBQVMsTUFBTSxLQUFLLFFBQVEsQ0FBQztBQUFBLE1BQUc7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPekcsb0JBQW9CLE9BQU87QUFBRSxlQUFPLE1BQU0sSUFBSSxVQUFRLEtBQUssb0JBQW9CLEtBQUssV0FBVyxDQUFDO0FBQUEsTUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9uRyxvQkFBb0IsYUFBYTtBQUFFLGVBQVEsWUFBWSxTQUFTLEtBQUssWUFBYSxZQUFZLE1BQU0sR0FBRyxLQUFLLFNBQVMsSUFBSTtBQUFBLE1BQWE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPdEkscUJBQXFCLGFBQVk7QUFDL0IsY0FBTSxPQUFPO0FBQUEsVUFDWCxPQUFPLEtBQUs7QUFBQSxVQUNaLE9BQU87QUFBQSxRQUNUO0FBQ0EsWUFBSSxLQUFLLFdBQVcsV0FBVyxrQkFBa0IsR0FBRztBQUNsRCxlQUFLLGFBQWEsS0FBSztBQUFBLFFBQ3pCO0FBQ0EsZUFBTztBQUFBLE1BQ1Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTUEsMEJBQTBCO0FBQ3hCLFlBQUksVUFBVTtBQUFBLFVBQ1osZ0JBQWdCO0FBQUEsVUFDaEIsaUJBQWlCLFVBQVUsS0FBSztBQUFBLFFBQ2xDO0FBQ0EsWUFBSSxLQUFLO0FBQVMsb0JBQVUsRUFBRSxHQUFHLFNBQVMsR0FBRyxLQUFLLFFBQVE7QUFDMUQsZUFBTztBQUFBLE1BQ1Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxNQUFNLGtCQUFrQixhQUFhO0FBRW5DLFlBQUksWUFBWSxXQUFXLEdBQUc7QUFDNUIsa0JBQVEsSUFBSSxzQkFBc0I7QUFDbEMsaUJBQU87QUFBQSxRQUNUO0FBQ0EsY0FBTUMsV0FBVTtBQUFBLFVBQ2QsS0FBSyxLQUFLO0FBQUEsVUFDVixRQUFRO0FBQUEsVUFDUixNQUFNLEtBQUssVUFBVSxLQUFLLHFCQUFxQixXQUFXLENBQUM7QUFBQSxVQUMzRCxTQUFTLEtBQUssd0JBQXdCO0FBQUEsUUFDeEM7QUFDQSxjQUFNLE9BQU8sTUFBTSxLQUFLLFFBQVFBLFFBQU87QUFDdkMsZUFBTyxLQUFLLGVBQWUsSUFBSTtBQUFBLE1BQ2pDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsZUFBZSxNQUFNO0FBQ25CLGVBQU8sS0FBSyxLQUFLLElBQUksV0FBUztBQUFBLFVBQzVCLEtBQUssS0FBSztBQUFBLFVBQ1YsUUFBUSxLQUFLLE1BQU0sZUFBZSxLQUFLLEtBQUs7QUFBQSxRQUM5QyxFQUFFO0FBQUEsTUFDSjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLFNBQVMsV0FBVztBQUFFLGVBQU8sQ0FBQyxVQUFVLFFBQVEsQ0FBQyxVQUFVO0FBQUEsTUFBTztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9sRSxNQUFNLGNBQWMsTUFBTTtBQUFFLGVBQVEsT0FBTyxLQUFLLFNBQVMsYUFBYyxNQUFNLEtBQUssS0FBSyxJQUFJLE1BQU0sS0FBSztBQUFBLE1BQU07QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVE1RyxNQUFNLFFBQVEsS0FBSyxVQUFVLEdBQUU7QUFDN0IsWUFBSTtBQUNGLGNBQUksUUFBUTtBQUVaLGdCQUFNLE9BQU8sS0FBSyxrQkFBa0IsTUFBTSxLQUFLLGdCQUFnQixFQUFDLEtBQUssS0FBSyxVQUFVLEdBQUcsSUFBRyxDQUFDLElBQUksTUFBTSxNQUFNLEtBQUssVUFBVSxHQUFHO0FBQzdILGdCQUFNLFlBQVksTUFBTSxLQUFLLGNBQWMsSUFBSTtBQUUvQyxjQUFHLEtBQUssU0FBUyxTQUFTO0FBQUcsbUJBQU8sTUFBTSxLQUFLLG1CQUFtQixXQUFXLEtBQUssT0FBTztBQUN6RixpQkFBTztBQUFBLFFBQ1QsU0FBUyxPQUFQO0FBQ0EsaUJBQU8sTUFBTSxLQUFLLG1CQUFtQixPQUFPLEtBQUssT0FBTztBQUFBLFFBQzFEO0FBQUEsTUFDRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFTQSxNQUFNLG1CQUFtQixPQUFPLEtBQUssU0FBUztBQTdNaEQ7QUFpTkksZ0JBQVEsTUFBTTtBQUNkLGFBQUcsV0FBTSxZQUFOLG1CQUFlLFNBQVMsOEJBQThCO0FBQ3ZELGdCQUFNLFVBQVUsU0FBUyxNQUFNLFFBQVEsTUFBTSxZQUFZLEVBQUUsQ0FBQyxFQUFFLE1BQU0sUUFBUSxFQUFFLENBQUMsRUFBRSxLQUFLLENBQUM7QUFDdkYsZ0JBQU0sZ0JBQWdCLFNBQVMsTUFBTSxRQUFRLE1BQU0sV0FBVyxFQUFFLENBQUMsRUFBRSxNQUFNLFFBQVEsRUFBRSxDQUFDLEVBQUUsS0FBSyxDQUFDO0FBQzVGLGtCQUFRLElBQUksdUJBQXVCLHVCQUF1QixlQUFlO0FBQ3pFLGdCQUFNLE9BQU8sS0FBSyxNQUFNLElBQUksSUFBSTtBQUNoQyxnQkFBTSxjQUFjLEtBQUssSUFBSSxHQUFHLEtBQUssTUFBTSxJQUFJLFVBQVEsS0FBSyxNQUFNLENBQUM7QUFDbkUsZ0JBQU0sWUFBWSxLQUFLLE1BQU0sVUFBVSxPQUFLLEVBQUUsV0FBVyxXQUFXO0FBRXBFLGdCQUFNLGlCQUFpQixnQkFBZ0IsV0FBVztBQUVsRCxlQUFLLE1BQU0sU0FBUyxJQUFJLEtBQUssTUFBTSxTQUFTLEVBQUUsTUFBTSxHQUFHLEtBQUssTUFBTSxnQkFBZ0IsV0FBVyxJQUFLLE1BQU0sT0FBUTtBQUNoSCxrQkFBUSxJQUFJLG9CQUFvQixLQUFLLE1BQU0sU0FBUyxFQUFFLFFBQVE7QUFDOUQsY0FBSSxPQUFPLEtBQUssVUFBVSxJQUFJO0FBQzlCLGlCQUFPLE1BQU0sS0FBSyxRQUFRLEtBQUssVUFBVSxDQUFDO0FBQUEsUUFDNUM7QUFDQSxZQUFJLE1BQU0sV0FBVyxPQUFPLFVBQVUsR0FBRztBQUN2QyxnQkFBTSxVQUFVLEtBQUssSUFBSSxVQUFVLEdBQUcsQ0FBQztBQUN2QyxrQkFBUSxJQUFJLDZCQUE2QixvQkFBb0I7QUFDN0QsZ0JBQU0sSUFBSSxRQUFRLE9BQUssV0FBVyxHQUFHLE1BQU8sT0FBTyxDQUFDO0FBQ3BELGlCQUFPLE1BQU0sS0FBSyxRQUFRLEtBQUssVUFBVSxDQUFDO0FBQUEsUUFDNUM7QUFDQSxnQkFBUSxNQUFNLEtBQUs7QUFDbkIsZUFBTztBQUFBLE1BQ1Q7QUFBQSxJQUNGO0FBQ0EsSUFBQUQsU0FBUSxhQUFhO0FBQUE7QUFBQTs7O0FDM09yQjtBQUFBLHlEQUFBRSxVQUFBO0FBQUEsUUFBTSxFQUFFLFdBQVcsSUFBSTtBQUN2QixRQUFNLGtCQUFOLGNBQThCLFdBQVc7QUFBQSxNQUN2QyxNQUFNLE1BQU0sT0FBTztBQUNqQixjQUFNLE9BQU8sTUFBTSxLQUFLLFlBQVksQ0FBQztBQUFBLFVBQ25DLGFBQWE7QUFBQSxRQUNmLENBQUMsQ0FBQztBQUNGLGVBQU8sNkJBQU87QUFBQSxNQUNoQjtBQUFBLE1BQ0EsTUFBTSxPQUFPO0FBQ1gsYUFBSyxXQUFXLEtBQUs7QUFBQSxNQUN2QjtBQUFBLE1BQ0Esb0JBQW9CLE9BQU87QUFDekIsZUFBTyxNQUFNLElBQUksVUFBUTtBQUN2QixpQkFBTztBQUFBLFlBQ0wsYUFBYSxLQUFLLG9CQUFvQixLQUFLLFdBQVc7QUFBQSxVQUN4RDtBQUFBLFFBQ0YsQ0FBQztBQUFBLE1BQ0g7QUFBQSxNQUNBLHVCQUF1QixjQUFjLFdBQVcsR0FBRztBQUFFLGVBQU87QUFBQSxNQUFXO0FBQUEsTUFDdkUscUJBQXFCLE9BQU87QUFDMUIsZUFBTztBQUFBLFVBQ0wsY0FBYyxLQUFLLEtBQUs7QUFBQSxVQUN4QjtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQUEsTUFDQSwwQkFBMEI7QUFDeEIsZUFBTztBQUFBLFVBQ0wsZ0JBQWdCO0FBQUEsUUFDbEI7QUFBQSxNQUNGO0FBQUEsTUFDQSxTQUFTLE1BQU07QUFBRSxlQUFPLDZCQUFNO0FBQUEsTUFBTztBQUFBLE1BQ3JDLGVBQWUsTUFBTTtBQUFFLGVBQU87QUFBQSxNQUFNO0FBQUEsSUFDdEM7QUFDQSxJQUFBQSxTQUFRLGtCQUFrQjtBQUFBO0FBQUE7OztBQ2pDMUI7QUFBQSw0REFBQUMsVUFBQTtBQUFBLFFBQU0sRUFBRSxRQUFRLElBQUk7QUFFcEIsUUFBTSxzQkFBTixjQUFrQyxRQUFRO0FBQUEsTUFDeEMsTUFBTSxPQUFPO0FBQ1gsY0FBTSxFQUFFLEtBQUssVUFBVSxjQUFjLElBQUksTUFBTSxPQUFPLHNCQUFzQjtBQUM1RSxZQUFJLG1CQUFtQjtBQUN2QixhQUFLLFFBQVEsTUFBTSxTQUFTLHNCQUFzQixLQUFLLFlBQVksRUFBRSxXQUFXLE1BQU0sWUFBWSxLQUFLLFdBQVcsQ0FBQztBQUVuSCxhQUFLLFlBQVksTUFBTSxjQUFjLGdCQUFnQixLQUFLLFVBQVU7QUFBQSxNQUN0RTtBQUFBLE1BQ0EsTUFBTSxZQUFZLE9BQU87QUFDdkIsZ0JBQVEsTUFBTSxPQUFPLFVBQUs7QUFYOUI7QUFXaUMsNkJBQUssZ0JBQUwsbUJBQWtCLFVBQVM7QUFBQSxTQUFDO0FBQ3pELFlBQUcsRUFBQywrQkFBTztBQUFRLGlCQUFPLENBQUM7QUFDM0IsY0FBTSxTQUFTLE1BQU0sUUFBUSxJQUFJLE1BQU0sSUFBSSxVQUFRLEtBQUssYUFBYSxLQUFLLFdBQVcsQ0FBQyxDQUFDO0FBQ3ZGLGNBQU0sY0FBYyxNQUFNLFFBQVEsSUFBSSxNQUFNLElBQUksT0FBTyxNQUFNLE1BQU07QUFDakUsY0FBSSxPQUFPLENBQUMsSUFBSSxLQUFLO0FBQVksbUJBQU8sS0FBSztBQUM3QyxjQUFJLFdBQVcsT0FBTyxDQUFDO0FBQ3ZCLGNBQUksa0JBQWtCLEtBQUs7QUFDM0IsaUJBQU8sV0FBVyxLQUFLLFlBQVk7QUFDakMsa0JBQU0sTUFBTSxLQUFLLGFBQWE7QUFDOUIsa0JBQU0sWUFBWSxLQUFLLE1BQU0sZ0JBQWdCLFNBQVMsTUFBTSxHQUFJO0FBQ2hFLDhCQUFrQixnQkFBZ0IsVUFBVSxHQUFHLFNBQVMsSUFBSTtBQUM1RCx1QkFBVyxNQUFNLEtBQUssYUFBYSxlQUFlO0FBQUEsVUFDcEQ7QUFHQSxpQkFBTyxDQUFDLElBQUk7QUFDWixpQkFBTztBQUFBLFFBQ1QsQ0FBQyxDQUFDO0FBR0YsWUFBRztBQUNELGdCQUFNQyxRQUFPLE1BQU0sS0FBSyxNQUFNLGFBQWEsRUFBRSxTQUFTLFFBQVEsV0FBVyxLQUFLLENBQUM7QUFFL0UsaUJBQU8sTUFBTSxJQUFJLENBQUMsTUFBTSxNQUFNO0FBQzVCLGlCQUFLLE1BQU0sTUFBTSxLQUFLQSxNQUFLLENBQUMsRUFBRSxJQUFJO0FBQ2xDLGlCQUFLLFNBQVMsT0FBTyxDQUFDO0FBQ3RCLG1CQUFPO0FBQUEsVUFDVCxDQUFDO0FBQUEsUUFDSCxTQUFPLEtBQU47QUFDQyxrQkFBUSxJQUFJLEdBQUc7QUFDZixrQkFBUSxJQUFJLGdEQUFnRDtBQUFBLFFBQzlEO0FBQ0EsY0FBTSxPQUFPLE1BQU0sUUFBUSxJQUFJLE1BQU0sSUFBSSxPQUFNLFNBQVE7QUFDckQsZ0JBQU0sRUFBRSxLQUFLLFFBQUFDLFNBQVEsTUFBTSxJQUFJLE1BQU0sS0FBSyxNQUFNLEtBQUssV0FBVztBQUNoRSxjQUFHLE9BQU07QUFDUCxvQkFBUSxJQUFJLDBCQUEwQixLQUFLLEdBQUc7QUFDOUMsb0JBQVEsSUFBSSxLQUFLO0FBQ2pCLGlCQUFLLFFBQVE7QUFDYixtQkFBTztBQUFBLFVBQ1Q7QUFDQSxjQUFHLENBQUMsS0FBSTtBQUNOLG9CQUFRLElBQUksMEJBQTBCLEtBQUssR0FBRztBQUM5QyxvQkFBUSxJQUFJLFNBQVMsR0FBRztBQUN4QixvQkFBUSxJQUFJLFdBQVcsS0FBSztBQUM1QixvQkFBUSxJQUFJLFlBQVlBLE9BQU07QUFDOUIsb0JBQVEsSUFBSSxpQkFBaUI7QUFDN0IsaUJBQUssUUFBUTtBQUNiLG1CQUFPO0FBQUEsVUFDVDtBQUNBLGVBQUssTUFBTSxJQUFJLElBQUksU0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFTLElBQUksR0FBUztBQUNqRSxlQUFLLFNBQVNBO0FBQ2QsaUJBQU87QUFBQSxRQUNULENBQUMsQ0FBQztBQUNGLGVBQU87QUFBQSxNQUNUO0FBQUEsTUFDQSxNQUFNLE1BQU0sT0FBTztBQUNqQixjQUFNLFNBQVMsRUFBRSxhQUFhLE1BQU07QUFDcEMsWUFBSSxDQUFDO0FBQU8saUJBQU8sRUFBRSxHQUFHLFFBQVEsT0FBTyxpQkFBaUI7QUFDeEQsWUFBSSxDQUFDLEtBQUs7QUFBTyxnQkFBTSxLQUFLLEtBQUs7QUFDakMsWUFBSTtBQUNGLGlCQUFPLFNBQVMsTUFBTSxLQUFLLGFBQWEsS0FBSztBQUM3QyxjQUFJLE9BQU8sU0FBUztBQUFHLG1CQUFPLEVBQUUsR0FBRyxRQUFRLE9BQU8sbUJBQW1CO0FBQ3JFLGNBQUksT0FBTyxTQUFTLEtBQUssWUFBWTtBQUNuQyxrQkFBTSxZQUFZLE1BQU0sS0FBSyxNQUFNLE9BQU8sRUFBRSxTQUFTLFFBQVEsV0FBVyxLQUFLLENBQUM7QUFDOUUsbUJBQU8sTUFBTSxNQUFNLEtBQUssVUFBVSxJQUFJLEVBQUUsSUFBSSxTQUFPLEtBQUssTUFBTSxNQUFNLEdBQVMsSUFBSSxHQUFTO0FBQUEsVUFDNUYsT0FBTztBQUNMLGtCQUFNLE1BQU0sS0FBSyxhQUFhLE9BQU87QUFDckMsa0JBQU0sWUFBWSxLQUFLLE1BQU0sTUFBTSxTQUFTLE1BQU0sSUFBSTtBQUN0RCxvQkFBUSxNQUFNLFVBQVUsR0FBRyxTQUFTLElBQUk7QUFDeEMsbUJBQU8sWUFBWTtBQUNuQixvQkFBUSxJQUFJLGtDQUFrQyxNQUFNLFFBQVEsY0FBYztBQUMxRSxrQkFBTSxFQUFFLEtBQUssT0FBTyxJQUFJLE1BQU0sS0FBSyxNQUFNLEtBQUs7QUFDOUMsbUJBQU8sTUFBTTtBQUNiLG1CQUFPLFNBQVM7QUFBQSxVQUNsQjtBQUNBLGlCQUFPO0FBQUEsUUFDVCxTQUFTLEtBQVA7QUFDQSxrQkFBUSxJQUFJLEdBQUc7QUFDZixpQkFBTyxFQUFFLEdBQUcsUUFBUSxPQUFPLElBQUksUUFBUTtBQUFBLFFBQ3pDO0FBQUEsTUFDRjtBQUFBLE1BQ0EsTUFBTSxhQUFhLE1BQU07QUFDdkIsWUFBSSxDQUFDLEtBQUs7QUFBVyxnQkFBTSxLQUFLLEtBQUs7QUFDckMsY0FBTSxFQUFFLFVBQVUsSUFBSSxNQUFNLEtBQUssVUFBVSxJQUFJO0FBQy9DLGVBQU8sVUFBVSxLQUFLO0FBQUEsTUFDeEI7QUFBQSxJQUNGO0FBRUEsSUFBQUYsU0FBUSxzQkFBc0I7QUFBQTtBQUFBOzs7QUNuRzlCO0FBQUEsc0RBQUFHLFVBQUFDLFNBQUE7QUFBQSxJQUFBQSxRQUFBO0FBQUEsTUFDRSxRQUFVO0FBQUEsSUFDWjtBQUFBO0FBQUE7OztBQ0ZBO0FBQUEsc0RBQUFDLFVBQUE7QUFBQSxRQUFNLEVBQUUsUUFBUSxJQUFJO0FBQ3BCLFFBQU0sZ0JBQWdCO0FBRXRCLFFBQU0sZ0JBQU4sY0FBNEIsUUFBUTtBQUFBLE1BQ2xDLFlBQVksTUFBTTtBQUNoQixjQUFNLElBQUk7QUFDVixhQUFLLFFBQVE7QUFDYixhQUFLLFNBQVMsQ0FBQztBQUNmLGFBQUssb0JBQW9CLENBQUM7QUFDMUIsYUFBSyxhQUFhLGNBQWM7QUFBQSxNQUNsQztBQUFBLE1BQ0EsU0FBUztBQUNQLGdCQUFRLElBQUksNENBQTRDO0FBQ3hELGFBQUssYUFBYTtBQUNsQixhQUFLLFFBQVE7QUFDYixhQUFLLFNBQVMsQ0FBQztBQUNmLGFBQUssb0JBQW9CLENBQUM7QUFBQSxNQUM1QjtBQUFBLE1BQ0EsTUFBTSxPQUFPO0FBRVgsWUFBRyxDQUFDLEtBQUssT0FBTztBQUNkLGVBQUssUUFBUSxTQUFTLGNBQWMsUUFBUTtBQUM1QyxlQUFLLE1BQU0sTUFBTSxVQUFVO0FBQzNCLGVBQUssTUFBTSxNQUFNLFFBQVE7QUFDekIsZUFBSyxNQUFNLE1BQU0sU0FBUztBQUUxQixlQUFLLGVBQWUsSUFBSSxRQUFRLGFBQVcsS0FBSyxNQUFNLFNBQVMsT0FBTztBQUN0RSxnQkFBTSxlQUFlLElBQUksUUFBUSxhQUFXO0FBQzFDLG1CQUFPLGlCQUFpQixXQUFXLFdBQVM7QUFDMUMsa0JBQUksTUFBTSxLQUFLLFNBQVMsZ0JBQWU7QUFDckMsd0JBQVEsSUFBSSxtQkFBbUIsS0FBSyxVQUFVO0FBQzlDLHdCQUFRO0FBQUEsY0FDVjtBQUFBLFlBQ0YsR0FBRyxFQUFFLE1BQU0sTUFBTSxTQUFTLE1BQU0sQ0FBQztBQUFBLFVBQ25DLENBQUM7QUFDRCxlQUFLLE1BQU0sU0FBUyxLQUFLO0FBQ3pCLGVBQUssVUFBVSxZQUFZLEtBQUssS0FBSztBQUNyQyxnQkFBTSxLQUFLO0FBQ1gsZUFBSyxNQUFNLGNBQWMsWUFBWSxFQUFFLE1BQU0sUUFBUSxjQUFjLEVBQUMsR0FBRyxLQUFLLEtBQUssUUFBUSxXQUFXLEtBQUksRUFBRSxHQUFHLEdBQUc7QUFDaEgsZ0JBQU07QUFDTixlQUFLLE1BQU0sY0FBYyxpQkFBaUIsV0FBVyxLQUFLLHVCQUF1QixLQUFLLElBQUksR0FBRyxLQUFLO0FBQUEsUUFDcEc7QUFFQSxnQkFBUSxJQUFJLDRDQUE0QztBQUFBLE1BQzFEO0FBQUEsTUFDQSxrQkFBa0IsYUFBYSxVQUFVLEdBQUc7QUFDMUMsWUFBSSxFQUFDLDJDQUFhO0FBQVEsaUJBQU8sUUFBUSxJQUFJLHNCQUFzQjtBQUNuRSxjQUFNLGFBQWMsT0FBTyxnQkFBZ0IsV0FBWSxjQUFjLFdBQVcsV0FBVztBQUMzRixhQUFLLE1BQU0sY0FBYyxZQUFZLEVBQUUsTUFBTSxlQUFlLGFBQWEsV0FBVyxHQUFHLEdBQUc7QUFDMUYsZUFBTyxJQUFJLFFBQVEsQ0FBQyxTQUFTLFdBQVc7QUFDdEMsZUFBSyxrQkFBa0IsVUFBVSxJQUFJLENBQUMsRUFBRSxPQUFPLEtBQUssTUFBTTtBQUN4RCxnQkFBSSxPQUFPO0FBQ1Qsc0JBQVEsSUFBSSxLQUFLO0FBQ2pCLHFCQUFPLEtBQUs7QUFBQSxZQUNkLE9BQU87QUFDTCxzQkFBUSxJQUFJO0FBQUEsWUFDZDtBQUFBLFVBQ0Y7QUFDQSxxQkFBVyxNQUFNO0FBQ2YsZ0JBQUksS0FBSyxrQkFBa0IsVUFBVSxHQUFHO0FBQ3RDLHFCQUFPLElBQUksTUFBTSw4QkFBOEIsQ0FBQztBQUNoRCxxQkFBTyxLQUFLLGtCQUFrQixVQUFVO0FBQUEsWUFDMUM7QUFBQSxVQUNGLEdBQUcsR0FBSztBQUFBLFFBQ1YsQ0FBQztBQUFBLE1BQ0g7QUFBQSxNQUNBLE1BQU0sWUFBWSxPQUFPO0FBQ3ZCLGdCQUFRLE1BQU0sT0FBTyxVQUFLO0FBbkU5QjtBQW1FaUMsNkJBQUssZ0JBQUwsbUJBQWtCLFVBQVM7QUFBQSxTQUFDO0FBQ3pELFlBQUcsRUFBQywrQkFBTztBQUFRLGlCQUFPLENBQUM7QUFDM0IsY0FBTSxPQUFPLE1BQU0sS0FBSyxrQkFBa0IsTUFBTSxJQUFJLFdBQVMsRUFBRSxhQUFhLEtBQUssWUFBWSxFQUFFLENBQUM7QUFDaEcsZUFBTyxNQUFNLElBQUksQ0FBQyxNQUFNLE1BQU07QUFDNUIsZ0JBQU0sWUFBWSxLQUFLLEtBQUssQ0FBQztBQUM3QixlQUFLLE1BQU0sVUFBVTtBQUNyQixlQUFLLFNBQVMsVUFBVTtBQUN4QixpQkFBTztBQUFBLFFBQ1QsQ0FBQztBQUFBLE1BQ0g7QUFBQSxNQUNBLE1BQU0sT0FBTztBQUFFLGVBQU8sS0FBSyxrQkFBa0IsS0FBSztBQUFBLE1BQUc7QUFBQSxNQUNyRCxhQUFhLE9BQU8sVUFBVSxLQUFPO0FBQ25DLGFBQUssTUFBTSxjQUFjLFlBQVksRUFBRSxNQUFNLHdCQUF3QixhQUFhLE1BQU0sR0FBRyxHQUFHO0FBQzlGLGVBQU8sSUFBSSxRQUFRLENBQUMsU0FBUyxXQUFXO0FBQ3RDLGVBQUssa0JBQWtCLFdBQVcsS0FBSyxJQUFJLENBQUMsRUFBRSxPQUFPLEtBQUssTUFBTTtBQUM5RCxnQkFBSSxPQUFPO0FBQ1Qsc0JBQVEsSUFBSSxLQUFLO0FBQ2pCLHFCQUFPLEtBQUs7QUFBQSxZQUNkLE9BQU87QUFDTCxzQkFBUSxJQUFJO0FBQUEsWUFDZDtBQUFBLFVBQ0Y7QUFDQSxxQkFBVyxNQUFNO0FBQ2YsZ0JBQUksS0FBSyxrQkFBa0IsV0FBVyxLQUFLLEdBQUc7QUFDNUMscUJBQU8sSUFBSSxNQUFNLDhCQUE4QixDQUFDO0FBQ2hELHFCQUFPLEtBQUssa0JBQWtCLFdBQVcsS0FBSztBQUFBLFlBQ2hEO0FBQUEsVUFDRixHQUFHLE9BQU87QUFBQSxRQUNaLENBQUM7QUFBQSxNQUNIO0FBQUEsTUFDQSxJQUFJLGdCQUFnQjtBQUFFLGVBQU8seUJBQXlCLEtBQUs7QUFBQSxNQUF1QjtBQUFBLE1BQ2xGLElBQUksZUFBZTtBQUFFLGVBQU8sT0FBTyxLQUFLLEtBQUssaUJBQWlCLEVBQUUsU0FBUztBQUFBLE1BQUc7QUFBQSxNQUM1RSxJQUFJLGVBQWU7QUFBRSxlQUFPLE9BQU8sS0FBSyxLQUFLLGlCQUFpQixFQUFFO0FBQUEsTUFBUTtBQUFBLE1BQ3hFLElBQUksZUFBZTtBQUFFLGVBQU8sS0FBSyxXQUFXLFFBQVEsZUFBZSxHQUFHLEVBQUUsWUFBWTtBQUFBLE1BQUc7QUFBQSxNQUN2RixlQUFlO0FBQ2IsWUFBSSxLQUFLO0FBQU8sZUFBSyxNQUFNLE9BQU87QUFDbEMsY0FBTSxjQUFjLEtBQUssVUFBVSxjQUFjLE1BQU0sS0FBSyxZQUFZO0FBQ3hFLFlBQUk7QUFBYSxzQkFBWSxPQUFPO0FBQ3BDLGdCQUFRLElBQUksK0NBQStDO0FBQUEsTUFDN0Q7QUFBQSxNQUNBLHVCQUF1QixPQUFPO0FBQzVCLFlBQUksTUFBTSxLQUFLLFNBQVMsc0JBQXNCLE1BQU0sS0FBSyxTQUFTLHdCQUF3QjtBQUN4RixnQkFBTSxVQUFVLEtBQUssa0JBQWtCLE1BQU0sS0FBSyxjQUFjLE1BQU0sS0FBSyxJQUFJO0FBQy9FLGNBQUksU0FBUztBQUNYLG9CQUFRLEVBQUUsT0FBTyxNQUFNLE1BQU0sTUFBTSxLQUFLLENBQUM7QUFDekMsbUJBQU8sS0FBSyxrQkFBa0IsTUFBTSxLQUFLLGNBQWMsTUFBTSxLQUFLLElBQUk7QUFBQSxVQUN4RTtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUNBLElBQUFBLFNBQVEsZ0JBQWdCO0FBRXhCLGFBQVMsV0FBVyxNQUFNO0FBQ3hCLFlBQU0sTUFBTSxLQUFLLFVBQVUsSUFBSTtBQUMvQixVQUFJLE9BQU87QUFDWCxVQUFJLElBQUksV0FBVztBQUFHLGVBQU87QUFDN0IsZUFBUyxJQUFJLEdBQUcsSUFBSSxJQUFJLFFBQVEsS0FBSztBQUNuQyxjQUFNLE9BQU8sSUFBSSxXQUFXLENBQUM7QUFDN0IsZ0JBQVMsUUFBUSxLQUFLLE9BQVE7QUFDOUIsZUFBTyxPQUFPO0FBRWQsWUFBSSxPQUFPO0FBQUcsaUJBQU8sT0FBTztBQUFBLE1BQzlCO0FBQ0EsYUFBTyxLQUFLLFNBQVMsSUFBSSxJQUFJO0FBQUEsSUFDL0I7QUFBQTtBQUFBOzs7QUNuSUE7QUFBQSwrQ0FBQUMsVUFBQTtBQUFBLFFBQU0sRUFBRSxXQUFXLElBQUk7QUFDdkIsSUFBQUEsU0FBUSxNQUFNO0FBQ2QsUUFBTSxFQUFFLGdCQUFnQixJQUFJO0FBQzVCLElBQUFBLFNBQVEsWUFBWTtBQUNwQixRQUFNLEVBQUUsb0JBQW9CLElBQUk7QUFDaEMsSUFBQUEsU0FBUSxlQUFlO0FBQ3ZCLFFBQU0sRUFBRSxjQUFjLElBQUk7QUFDMUIsSUFBQUEsU0FBUSxTQUFTO0FBQUE7QUFBQTs7O0FDUGpCO0FBQUEsK0NBQUFDLFVBQUFDLFNBQUE7QUFBQSxJQUFBQSxRQUFBO0FBQUEsTUFDRSx5QkFBeUI7QUFBQSxRQUN2QixZQUFjO0FBQUEsUUFDZCxZQUFjO0FBQUEsUUFDZCxNQUFRO0FBQUEsUUFDUixZQUFjO0FBQUEsUUFDZCxNQUFRO0FBQUEsUUFDUixhQUFlO0FBQUEsUUFDZixNQUFRO0FBQUEsTUFDVjtBQUFBLE1BQ0EsaUNBQWlDO0FBQUEsUUFDL0IsWUFBYztBQUFBLFFBQ2QsWUFBYztBQUFBLFFBQ2QsTUFBUTtBQUFBLFFBQ1IsWUFBYztBQUFBLFFBQ2QsTUFBUTtBQUFBLFFBQ1IsYUFBZTtBQUFBLFFBQ2YsTUFBUTtBQUFBLE1BQ1Y7QUFBQSxNQUNBLDBDQUEwQztBQUFBLFFBQ3hDLFlBQWM7QUFBQSxRQUNkLFlBQWM7QUFBQSxRQUNkLE1BQVE7QUFBQSxRQUNSLFlBQWM7QUFBQSxRQUNkLE1BQVE7QUFBQSxRQUNSLGFBQWU7QUFBQSxRQUNmLE1BQVE7QUFBQSxNQUNWO0FBQUEsTUFDQSwwQkFBMEI7QUFBQSxRQUN4QixZQUFjO0FBQUEsUUFDZCxZQUFjO0FBQUEsUUFDZCxNQUFRO0FBQUEsUUFDUixZQUFjO0FBQUEsUUFDZCxNQUFRO0FBQUEsUUFDUixhQUFlO0FBQUEsUUFDZixVQUFZO0FBQUEsUUFDWixNQUFRO0FBQUEsTUFDVjtBQUFBLE1BQ0EsMEJBQTBCO0FBQUEsUUFDeEIsWUFBYztBQUFBLFFBQ2QsWUFBYztBQUFBLFFBQ2QsTUFBUTtBQUFBLFFBQ1IsWUFBYztBQUFBLFFBQ2QsTUFBUTtBQUFBLFFBQ1IsYUFBZTtBQUFBLFFBQ2YsVUFBWTtBQUFBLFFBQ1osTUFBUTtBQUFBLE1BQ1Y7QUFBQSxNQUNBLDhCQUE4QjtBQUFBLFFBQzVCLFlBQWM7QUFBQSxRQUNkLFlBQWM7QUFBQSxRQUNkLE1BQVE7QUFBQSxRQUNSLFlBQWM7QUFBQSxRQUNkLE1BQVE7QUFBQSxRQUNSLGFBQWU7QUFBQSxRQUNmLFVBQVk7QUFBQSxRQUNaLE1BQVE7QUFBQSxNQUNWO0FBQUEsTUFDQSw4QkFBOEI7QUFBQSxRQUM1QixZQUFjO0FBQUEsUUFDZCxZQUFjO0FBQUEsUUFDZCxNQUFRO0FBQUEsUUFDUixZQUFjO0FBQUEsUUFDZCxNQUFRO0FBQUEsUUFDUixhQUFlO0FBQUEsUUFDZixVQUFZO0FBQUEsUUFDWixNQUFRO0FBQUEsTUFDVjtBQUFBLE1BQ0EsMEJBQTBCO0FBQUEsUUFDeEIsWUFBYztBQUFBLFFBQ2QsWUFBYztBQUFBLFFBQ2QsTUFBUTtBQUFBLFFBQ1IsWUFBYztBQUFBLFFBQ2QsTUFBUTtBQUFBLFFBQ1IsYUFBZTtBQUFBLFFBQ2YsVUFBWTtBQUFBLFFBQ1osTUFBUTtBQUFBLE1BQ1Y7QUFBQSxNQUNBLHNDQUFzQztBQUFBLFFBQ3BDLFlBQWM7QUFBQSxRQUNkLFlBQWM7QUFBQSxRQUNkLE1BQVE7QUFBQSxRQUNSLFlBQWM7QUFBQSxRQUNkLE1BQVE7QUFBQSxRQUNSLGFBQWU7QUFBQSxRQUNmLE1BQVE7QUFBQSxNQUNWO0FBQUEsTUFDQSxzQ0FBc0M7QUFBQSxRQUNwQyxZQUFjO0FBQUEsUUFDZCxZQUFjO0FBQUEsUUFDZCxNQUFRO0FBQUEsUUFDUixZQUFjO0FBQUEsUUFDZCxNQUFRO0FBQUEsUUFDUixhQUFlO0FBQUEsUUFDZixNQUFRO0FBQUEsTUFDVjtBQUFBLE1BQ0EsNEJBQTRCO0FBQUEsUUFDMUIsWUFBYztBQUFBLFFBQ2QsWUFBYztBQUFBLFFBQ2QsTUFBUTtBQUFBLFFBQ1IsWUFBYztBQUFBLFFBQ2QsTUFBUTtBQUFBLFFBQ1IsYUFBZTtBQUFBLFFBQ2YsTUFBUTtBQUFBLE1BQ1Y7QUFBQSxNQUNBLGdDQUFnQztBQUFBLFFBQzlCLFlBQWM7QUFBQSxRQUNkLFlBQWM7QUFBQSxRQUNkLE1BQVE7QUFBQSxRQUNSLFlBQWM7QUFBQSxRQUNkLE1BQVE7QUFBQSxRQUNSLGFBQWU7QUFBQSxRQUNmLE1BQVE7QUFBQSxNQUNWO0FBQUEsSUFDRjtBQUFBO0FBQUE7OztBQ2xIQTtBQUFBLHdEQUFBQyxVQUFBO0FBcUJBLFFBQU0sV0FBVztBQUNqQixRQUFNQyxnQkFBZTtBQUtyQixRQUFNLGtCQUFOLE1BQXNCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPcEIsWUFBWSxLQUFLLFFBQVE7QUFDdkIsYUFBSyxNQUFNO0FBQ1gsWUFBRyxPQUFPO0FBQVcsZUFBSyxTQUFTLEVBQUMsR0FBR0EsY0FBYSxPQUFPLFNBQVMsR0FBRyxHQUFHLE9BQU07QUFBQTtBQUMzRSxlQUFLLFNBQVMsRUFBRSxHQUFHLE9BQU87QUFFL0IsYUFBSyxXQUFXO0FBQ2hCLGFBQUssWUFBWTtBQUNqQixhQUFLLFNBQVM7QUFFZCxZQUFHLEtBQUssT0FBTztBQUFTLGVBQUssVUFBVSxJQUFJLFNBQVMsS0FBSyxPQUFPLE9BQU8sRUFBRSxJQUFJO0FBQUE7QUFDeEUsZUFBSyxVQUFVLElBQUksU0FBUyxLQUFLLEVBQUUsSUFBSTtBQUFBLE1BQzlDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxhQUFhLE9BQU8sS0FBSyxjQUFjO0FBQ3JDLGNBQU0sUUFBUSxJQUFJLEtBQUssS0FBSyxZQUFZO0FBRXhDLFlBQUksTUFBTSxXQUFXLE9BQU8sTUFBTSxRQUFRLFNBQVM7QUFBWSxnQkFBTSxNQUFNLFFBQVEsS0FBSztBQUN4RixlQUFPO0FBQUEsTUFDVDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLE1BQU0sYUFBYSxPQUFPO0FBQ3hCLFlBQUksS0FBSyxXQUFXLE9BQU8sS0FBSyxRQUFRLGlCQUFpQixZQUFZO0FBQ25FLGlCQUFPLE1BQU0sS0FBSyxRQUFRLGFBQWEsS0FBSztBQUFBLFFBQzlDO0FBQUEsTUFFRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLE1BQU0sTUFBTSxPQUFPO0FBQ2pCLFlBQUksS0FBSyxXQUFXLE9BQU8sS0FBSyxRQUFRLFVBQVUsWUFBWTtBQUM1RCxpQkFBTyxNQUFNLEtBQUssUUFBUSxNQUFNLEtBQUs7QUFBQSxRQUN2QztBQUFBLE1BRUY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxNQUFNLFlBQVksT0FBTztBQUN2QixZQUFJLEtBQUssV0FBVyxPQUFPLEtBQUssUUFBUSxnQkFBZ0IsWUFBWTtBQUNsRSxpQkFBTyxNQUFNLEtBQUssUUFBUSxZQUFZLEtBQUs7QUFBQSxRQUM3QztBQUFBLE1BRUY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTUEsSUFBSSxhQUFhO0FBQUUsZUFBTyxLQUFLLE9BQU87QUFBQSxNQUFZO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1sRCxJQUFJLE9BQU87QUFBRSxlQUFPLEtBQUssT0FBTztBQUFBLE1BQU07QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTXRDLElBQUksYUFBYTtBQUFFLGVBQU8sS0FBSyxPQUFPO0FBQUEsTUFBWTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNbEQsSUFBSSxhQUFhO0FBQUUsZUFBTyxLQUFLLE9BQU87QUFBQSxNQUFZO0FBQUEsSUFDcEQ7QUFFQSxJQUFBRCxTQUFRLGtCQUFrQjtBQUFBO0FBQUE7OztBQ3pIMUI7QUFBQSxrREFBQUUsVUFBQTtBQXFCQSxRQUFNLEVBQUUsV0FBVyxJQUFJO0FBQ3ZCLFFBQU0sRUFBRSxlQUFlLElBQUk7QUFDM0IsUUFBTSxFQUFFLGdCQUFnQixJQUFJO0FBQzVCLFFBQU0sZ0JBQU4sY0FBNEIsV0FBVztBQUFBLE1BQ3JDLFlBQVksS0FBSztBQUNmLGNBQU0sR0FBRztBQUNULGFBQUssTUFBTTtBQUNYLGFBQUssb0JBQW9CO0FBQUEsTUFDM0I7QUFBQSxNQUNBLE1BQU0sUUFBUTtBQUFFLGNBQU0sS0FBSyxJQUFJLE1BQU07QUFBQSxNQUFHO0FBQUE7QUFBQSxNQUN4QyxTQUFTLEtBQUssT0FBTztBQUNuQixZQUFHLGlCQUFpQixLQUFLLFdBQVU7QUFDakMsY0FBRyxDQUFDLE1BQU0sY0FBYyxHQUFFO0FBQ3hCLG9CQUFRLElBQUksa0NBQWtDLE1BQU0sSUFBSTtBQUN4RCxtQkFBTztBQUFBLFVBQ1Q7QUFDQSxjQUFHLE1BQU0sS0FBSyxVQUFVLE9BQU8sTUFBTSxLQUFLO0FBQU0sa0JBQU0sS0FBSyxPQUFPO0FBQ2xFLGlCQUFPLE1BQU07QUFBQSxRQUNmO0FBQ0EsZUFBTyxNQUFNLFNBQVMsS0FBSyxLQUFLO0FBQUEsTUFDbEM7QUFBQSxNQUNBLFNBQVE7QUExQ1Y7QUEyQ0ksWUFBRyxTQUFPLFVBQUssZ0JBQUwsbUJBQWtCLFlBQVcsWUFBVztBQUNoRCxlQUFLLFlBQVksT0FBTztBQUN4QixpQkFBTyxLQUFLO0FBQUEsUUFDZDtBQUNBLFlBQUcsS0FBSyx1QkFBc0I7QUFDNUIsZ0JBQU0sU0FBUyxLQUFLLHNCQUFzQixjQUFjLFFBQVE7QUFDaEUsY0FBSSxDQUFDO0FBQVE7QUFFYixpQkFBTyxTQUFTO0FBQ2hCLGlCQUFPLFdBQVcsWUFBWSxNQUFNO0FBQ3BDLGVBQUssc0JBQXNCLE9BQU87QUFBQSxRQUNwQztBQUFBLE1BQ0Y7QUFBQSxNQUNBLE1BQU0sT0FBTztBQUNYLGNBQU0sS0FBSyxJQUFJLEtBQUs7QUFDcEIsZ0JBQVEsSUFBSSxJQUFJO0FBQ2hCLGdCQUFRLElBQUksS0FBSyxHQUFHO0FBQ3BCLGNBQU0sS0FBSyxpQkFBaUI7QUFBQSxNQUM5QjtBQUFBLE1BQ0EsTUFBTSxtQkFBbUI7QUE5RDNCO0FBZ0VJLFlBQUcsS0FBSyxzQkFBc0I7QUFBUTtBQUN0QyxZQUFHLEtBQUssSUFBSSwwQkFBMEIsS0FBSyxpQkFBaUIsYUFBYSxpQkFBZ0I7QUFDdkYsZUFBSyxjQUFjLEtBQUssSUFBSSwwQkFBMEIsS0FBSyxpQkFBaUI7QUFDNUUsa0JBQVEsSUFBSSxtQ0FBbUMsS0FBSyxrQkFBa0IsY0FBYyxLQUFLLGlCQUFpQjtBQUFBLFFBQzVHLE9BQUs7QUFDSCxnQkFBTSxRQUFRLEVBQUMsV0FBVyxLQUFLLGtCQUFpQjtBQUNoRCxjQUFHLEtBQUssa0JBQWtCLFNBQVMsR0FBRyxHQUFHO0FBQ3ZDLG9CQUFRLElBQUksS0FBSyxJQUFJLGdCQUFnQjtBQUNyQyxpQkFBSyxZQUFZLEtBQUs7QUFDdEIsa0JBQU0sWUFBWSxLQUFLLElBQUksT0FBTztBQUNsQyxnQkFBRyxZQUFZLE1BQU07QUFBWSxvQkFBTSxhQUFhO0FBRXBELG9CQUFRLElBQUksNENBQTRDO0FBQ3hELGdCQUFHO0FBQ0Qsb0JBQU0sb0JBQWtCLFVBQUssSUFBSSxLQUFLLGFBQWQsbUJBQXdCLGVBQWM7QUFDOUQsb0JBQU0sV0FBVyxDQUFDLGtCQUFrQixNQUFNLE1BQU0seUJBQXlCLElBQUksTUFBTSxnQkFBZ0IsRUFBQyxLQUFLLDJCQUEyQixRQUFRLE1BQUssQ0FBQztBQUVsSixrQkFBRyxTQUFTLFdBQVcsS0FBSztBQUMxQix3QkFBUSxJQUFJLGtDQUFrQztBQUM5QyxxQkFBSyxjQUFjLE1BQU0sZ0JBQWdCLE9BQU8sS0FBSyxLQUFLLEVBQUMsR0FBRyxPQUFPLGlCQUFrQyxTQUFTLGFBQWEsZ0JBQWdCLHFDQUFvQyxDQUFDO0FBQ2xMO0FBQUEsY0FDRjtBQUFBLFlBQ0YsU0FBTyxLQUFOO0FBQ0Msc0JBQVEsSUFBSSxpREFBaUQ7QUFBQSxZQUMvRDtBQUNBLGdCQUFHLEtBQUssSUFBSSxxQkFBcUIsT0FBTTtBQUNyQyxtQkFBSyxhQUFhO0FBQ2xCLGtCQUFHLEtBQUs7QUFBYSx3QkFBUSxJQUFJLDJCQUEyQixLQUFLLDBCQUEwQixLQUFLLG1CQUFtQjtBQUFBO0FBQzlHLHFCQUFLLGNBQWMsTUFBTSxnQkFBZ0IsT0FBTyxLQUFLLEtBQUssRUFBQyxHQUFHLE9BQU8sU0FBUyxVQUFVLFdBQVcsS0FBSyxzQkFBcUIsQ0FBQztBQUFBLFlBQ3JJLE9BQUs7QUFDSCxtQkFBSyxhQUFhO0FBQ2xCLGtCQUFHLEtBQUs7QUFBYSx3QkFBUSxJQUFJLDRCQUE0QixLQUFLLDBCQUEwQixLQUFLLG1CQUFtQjtBQUFBO0FBQy9HLHFCQUFLLGNBQWMsTUFBTSxnQkFBZ0IsT0FBTyxLQUFLLEtBQUssRUFBQyxHQUFHLE9BQU8sU0FBUyxlQUFjLENBQUM7QUFBQSxZQUNwRztBQUFBLFVBQ0YsT0FBTztBQUNMLGlCQUFLLGFBQWE7QUFDbEIsZ0JBQUcsS0FBSztBQUFhLHNCQUFRLElBQUksMkJBQTJCLEtBQUssMEJBQTBCLEtBQUssbUJBQW1CO0FBQUE7QUFDOUcsbUJBQUssY0FBYyxNQUFNLGdCQUFnQixPQUFPLEtBQUssS0FBSyxFQUFDLEdBQUcsT0FBTyxrQkFBaUIsVUFBSyxJQUFJLEtBQUssYUFBZCxtQkFBd0IsWUFBWSxTQUFTLEtBQUssT0FBTyxRQUFPLENBQUM7QUFBQSxVQUM5SjtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQUEsTUFDQSxJQUFJLHdCQUF3QjtBQUMxQixZQUFHLENBQUMsS0FBSztBQUFXLGlCQUFPLFFBQVEsSUFBSSxtQkFBbUI7QUFDMUQsY0FBTSxLQUFLLEtBQUssVUFBVSxRQUFRLGlCQUFpQixHQUFHO0FBQ3RELFlBQUcsQ0FBQyxPQUFPO0FBQVUsaUJBQU8sUUFBUSxJQUFJLCtCQUErQjtBQUN2RSxZQUFHLE9BQU8sU0FBUyxjQUFjLElBQUksSUFBSTtBQUFHLGlCQUFPLE9BQU8sU0FBUyxjQUFjLElBQUksSUFBSTtBQUN6RixjQUFNLFlBQVksT0FBTyxTQUFTLGNBQWMsS0FBSztBQUNyRCxrQkFBVSxLQUFLO0FBQ2YsZUFBTyxTQUFTLEtBQUssWUFBWSxTQUFTO0FBQzFDLGVBQU87QUFBQSxNQUNUO0FBQUEsTUFDQSxJQUFJLGNBQWM7QUFuSHBCO0FBbUhzQixnQkFBTyxVQUFLLElBQUksd0JBQVQsbUJBQStCLEtBQUs7QUFBQSxNQUFZO0FBQUEsTUFDM0UsSUFBSSxZQUFZLEtBQUs7QUFDbkIsWUFBRyxDQUFDLEtBQUs7QUFBVyxlQUFLLFlBQVksSUFBSSxhQUFhLE1BQU0sSUFBSSxZQUFZO0FBQzVFLFlBQUcsQ0FBQyxLQUFLLElBQUk7QUFBcUIsZUFBSyxJQUFJLHNCQUFzQixDQUFDO0FBQ2xFLGFBQUssSUFBSSxvQkFBb0IsS0FBSyxTQUFTLElBQUk7QUFBQSxNQUNqRDtBQUFBLE1BQ0Esa0JBQWtCO0FBQ2hCLGFBQUssb0JBQW9CO0FBQ3pCLGFBQUssSUFBSSxLQUFLLFFBQVEsT0FBTyxvQkFBb0I7QUFBQSxNQUNuRDtBQUFBLE1BQ0EsTUFBTSxrQkFBa0IsY0FBYyxNQUFNO0FBN0g5QztBQThISSxnQkFBUSxJQUFJLG1CQUFtQjtBQUMvQixZQUFHLENBQUMsS0FBSztBQUFhLGlCQUFPLFFBQVEsSUFBSSwrQkFBK0IsS0FBSyxlQUFlO0FBQzVGLGNBQU0sbUJBQW1CLEtBQUs7QUFDOUIsWUFBRyxpQkFBaUIsV0FBVztBQUFHLGlCQUFPO0FBQ3pDLGdCQUFRLElBQUksc0JBQXNCLGdCQUFnQjtBQUNsRCxjQUFNLHlCQUF5QjtBQUMvQixZQUFJLGdCQUFnQixTQUFXLGlCQUFpQixTQUFTLElBQUs7QUFDNUQsZ0JBQU0sWUFBWSxFQUFDLE1BQU0sbUJBQW1CLFVBQVUsTUFBTSxLQUFLLGtCQUFrQixLQUFLLEVBQUU7QUFDMUYsZUFBSyxJQUFJLEtBQUssUUFBUSxLQUFLLG1CQUFtQixDQUFDLG9DQUFvQyxpQkFBaUIsVUFBVSxLQUFLLG9CQUFvQixzQkFBc0IsR0FBRyxFQUFFLFNBQVMsR0FBRyxTQUFTLFVBQVMsQ0FBQztBQUNqTSxpQkFBTztBQUFBLFFBQ1Q7QUFDQSxZQUFHLEtBQUs7QUFBYyxpQkFBTyxRQUFRLElBQUksbUJBQW1CO0FBQzVELGFBQUssZUFBZTtBQUNwQixjQUFNLGFBQWEsS0FBSyxZQUFZO0FBQ3BDLGFBQUssSUFBSSxLQUFLLFFBQVEsT0FBTyxpQkFBaUI7QUFDOUMsWUFBSSxlQUFlO0FBQ25CLFlBQUksYUFBYSxLQUFLLElBQUk7QUFDMUIsWUFBSSxlQUFlO0FBQ25CLFlBQUksaUJBQWlCO0FBQ3JCLGlCQUFRLElBQUksR0FBRyxJQUFJLGlCQUFpQixRQUFRLEtBQUssWUFBWTtBQUUzRCxjQUFHLEtBQUssbUJBQW1CO0FBRXpCLGlCQUFLLG9CQUFvQjtBQUN6QixrQkFBTSxjQUFjLEVBQUMsTUFBTSxXQUFXLFVBQVUsTUFBTSxLQUFLLGtCQUFrQixFQUFFO0FBQy9FLGlCQUFLLElBQUksS0FBSyxRQUFRLEtBQUsscUJBQXFCLENBQUMsYUFBYSxLQUFLLHNCQUFzQixhQUFhLE9BQU8saUJBQWlCLFVBQVUsS0FBSyxtQkFBbUIsc0JBQXNCLEdBQUcsRUFBRSxTQUFTLEdBQUcsUUFBUSxZQUFXLENBQUM7QUFDM04saUJBQUssSUFBSSxNQUFNLElBQUk7QUFDbkIsaUJBQUssZUFBZTtBQUNwQjtBQUFBLFVBQ0Y7QUFDQSxjQUFHLElBQUksT0FBTyxHQUFFO0FBQ2Qsa0JBQU0sWUFBWSxFQUFDLE1BQU0sU0FBUyxVQUFVLE1BQU0sS0FBSyxnQkFBZ0IsR0FBRyxXQUFXLEtBQUk7QUFDekYsaUJBQUssSUFBSSxLQUFLLFFBQVEsS0FBSyxzQkFBc0IsQ0FBQyxhQUFhLEtBQUssc0JBQXNCLGFBQWEsT0FBTyxpQkFBaUIsVUFBVSxLQUFLLG1CQUFtQixHQUFHLDZCQUE2QixzQkFBc0IsR0FBRyxFQUFFLFNBQVMsR0FBRyxRQUFRLFdBQVcsV0FBVyxLQUFJLENBQUM7QUFBQSxVQUM3UTtBQUNBLGdCQUFNLFFBQVEsaUJBQWlCLE1BQU0sR0FBRyxJQUFJLFVBQVU7QUFDdEQsZ0JBQU0sUUFBUSxJQUFJLE1BQU0sSUFBSSxPQUFNLFNBQVEsTUFBTSxLQUFLLGdCQUFnQixDQUFDLENBQUM7QUFDdkUsZ0JBQU0sT0FBTyxNQUFNLEtBQUssWUFBWSxZQUFZLEtBQUs7QUFFckQsZ0JBQU0sUUFBUSxVQUFRO0FBQ3BCLGlCQUFLLGVBQWU7QUFDcEIsaUJBQUssVUFBVTtBQUFBLFVBQ2pCLENBQUM7QUFDRCwwQkFBZ0IsS0FBSyxPQUFPLENBQUMsS0FBSyxTQUFTLE1BQU0sS0FBSyxRQUFRLENBQUM7QUFDL0QseUJBQWUsS0FBSyxJQUFJLElBQUk7QUFDNUIsMkJBQWlCLEtBQUssTUFBTSxnQkFBZ0IsZUFBZSxJQUFLO0FBRWhFLGNBQUcsS0FBTSxJQUFJLFFBQVEsR0FBRztBQUV0QixrQkFBTSxLQUFLLElBQUksTUFBTTtBQUFBLFVBQ3ZCO0FBQUEsUUFFRjtBQUNBLGFBQUcsZ0JBQUssSUFBSSxLQUFLLFlBQWQsbUJBQXVCLGFBQXZCLG1CQUFpQztBQUFlLGVBQUssSUFBSSxLQUFLLFFBQVEsS0FBSztBQUM5RSxjQUFNLGNBQWMsaUJBQWlCLE9BQU8sT0FBSyxFQUFFLEdBQUcsRUFBRTtBQUV4RCxhQUFLLElBQUksS0FBSyxRQUFRLE9BQU8sb0JBQW9CO0FBQ2pELGFBQUssSUFBSSxLQUFLLFFBQVEsS0FBSyxrQkFBa0IsQ0FBQyxhQUFhLEtBQUssc0JBQXNCLGlCQUFpQix5QkFBeUIsR0FBRyxFQUFFLFNBQVMsSUFBTSxDQUFDO0FBQ3JKLFlBQUcsaUJBQWlCO0FBQVEsZUFBSyxJQUFJLE1BQU07QUFDM0MsYUFBSyxlQUFlO0FBQ3BCLGVBQU87QUFBQSxNQUNUO0FBQUEsTUFDQSxJQUFJLGlCQUFpQjtBQUFFLGVBQU8sS0FBSyxjQUFjLE9BQU8sT0FBTyxLQUFLLEtBQUssRUFBRSxPQUFPLE9BQUssRUFBRSxHQUFHLElBQUksT0FBTyxPQUFPLEtBQUssS0FBSztBQUFBLE1BQUc7QUFBQSxNQUMzSCxJQUFJLG1CQUFtQjtBQUFFLGVBQU8sS0FBSyxjQUFjLE9BQU8sT0FBTyxLQUFLLEtBQUssRUFBRSxPQUFPLFVBQVEsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO0FBQUEsTUFBRztBQUFBLE1BRTdHLFFBQVEsS0FBSyxTQUFPLENBQUMsR0FBRztBQUN0QixZQUFHLENBQUM7QUFBSyxpQkFBTyxRQUFRLElBQUksUUFBUTtBQUNwQyxjQUFNO0FBQUE7QUFBQSxVQUVKLGdCQUFnQjtBQUFBLFFBQ2xCLElBQUk7QUFDSixjQUFNLFVBQVUsS0FBSyxPQUFPLE1BQU0sRUFDL0IsT0FBTyxDQUFDLEtBQUssU0FBUztBQXJNN0I7QUFzTVEsY0FBRyxHQUFDLFVBQUssS0FBSyxjQUFWLG1CQUFxQjtBQUFLLG1CQUFPO0FBQ3JDLGVBQUssTUFBTSxRQUFRLEtBQUssS0FBSyxLQUFLLFVBQVUsR0FBRztBQUMvQyxrQkFBUSxLQUFLLE1BQU0sYUFBYTtBQUNoQyxpQkFBTztBQUFBLFFBQ1QsR0FBRyxFQUFFLEtBQUssR0FBRyxPQUFPLG9CQUFJLElBQUksRUFBRSxDQUFDO0FBRWpDLGVBQU8sTUFBTSxLQUFLLFFBQVEsS0FBSztBQUFBLE1BQ2pDO0FBQUEsTUFDQSxJQUFJLFlBQVk7QUFBRSxlQUFPLEtBQUssa0JBQWtCLE1BQU0sS0FBSyxrQkFBa0IsTUFBTSxHQUFHLEVBQUUsSUFBSTtBQUFBLE1BQUc7QUFBQSxNQUMvRixJQUFJLG9CQUFvQjtBQUFFLGVBQU8sS0FBSyxPQUFPLEtBQUssa0JBQWtCLGNBQWM7QUFBQSxNQUFHO0FBQUEsSUFDdkY7QUFDQSxRQUFNLGNBQU4sY0FBMEIsZUFBZTtBQUFBLE1BQ3ZDLFdBQVcsV0FBVztBQUNwQixlQUFPO0FBQUEsVUFDTCxNQUFNO0FBQUEsWUFDSixNQUFNO0FBQUEsWUFDTixXQUFXLENBQUM7QUFBQSxVQUNkO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFBQSxNQUNBLFVBQVU7QUFBRSxlQUFPLEtBQUssS0FBSztBQUFBLE1BQU07QUFBQTtBQUFBLE1BRW5DLE9BQU87QUFDTCxhQUFLLFdBQVcsSUFBSSxJQUFJO0FBQ3hCLGFBQUssSUFBSSxLQUFLO0FBQUEsTUFDaEI7QUFBQSxNQUNBLFlBQVksU0FBTyxDQUFDLEdBQUc7QUFBQSxNQUFhO0FBQUEsTUFDcEMsTUFBTSxlQUFlLFNBQVMsQ0FBQyxHQUFHO0FBQ2hDLGVBQU8sZ0JBQWdCLE9BQU8sSUFBSSxNQUFNLE9BQU8sSUFBSSxRQUFRLEtBQUs7QUFBQSxFQUFjLE1BQU0sS0FBSyxZQUFZO0FBQUEsYUFBaUIsT0FBTyxJQUFJLE1BQU0sT0FBTyxJQUFJO0FBQUEsTUFDcEo7QUFBQSxNQUNBLE1BQU0sY0FBYztBQUFBLE1BQUM7QUFBQTtBQUFBLE1BQ3JCLE1BQU0sa0JBQWtCO0FBQUEsTUFBQztBQUFBO0FBQUE7QUFBQSxNQUV6QixJQUFJLFFBQVE7QUFBRSxlQUFPLEdBQUcsS0FBSyxVQUFVLEtBQUssR0FBRyxNQUFNLEtBQUssVUFBVSxLQUFLLElBQUk7QUFBQSxNQUFLO0FBQUEsTUFDbEYsSUFBSSxhQUFhO0FBQUUsZUFBTyxNQUFNLEtBQUssS0FBSztBQUFBLE1BQVU7QUFBQSxNQUNwRCxJQUFJLHdCQUF3QjtBQUFFLGVBQVEsS0FBSyxLQUFLLE1BQU0sR0FBRyxFQUFFLE1BQU0sRUFBRyxRQUFRLGlCQUFpQixHQUFHLEVBQUUsUUFBUSxPQUFPLEVBQUU7QUFBQSxNQUFHO0FBQUEsTUFDdEgsSUFBSSxPQUFPO0FBQUUsZ0JBQVEsQ0FBQyxLQUFLLElBQUksS0FBSyxTQUFTLGlCQUFpQixLQUFLLEtBQUssTUFBTSxHQUFHLEVBQUUsSUFBSSxJQUFJLEtBQUssS0FBSyxNQUFNLEdBQUcsRUFBRSxLQUFLLEtBQUssR0FBRyxNQUFNLEdBQUcsRUFBRSxLQUFLLEtBQUssRUFBRSxRQUFRLE9BQU8sRUFBRTtBQUFBLE1BQUc7QUFBQSxNQUN4SyxJQUFJLE9BQU87QUFBRSxlQUFPLEtBQUssS0FBSztBQUFBLE1BQU07QUFBQSxNQUNwQyxJQUFJLFNBQVM7QUFBRSxlQUFPLEtBQUssS0FBSyxVQUFVO0FBQUEsTUFBUTtBQUFBLE1BQ2xELElBQUksTUFBTTtBQUFFLGVBQU8sS0FBSyxLQUFLLFVBQVU7QUFBQSxNQUFLO0FBQUE7QUFBQSxNQUU1QyxJQUFJLE1BQU0sT0FBTztBQUFFLGFBQUssS0FBSyxVQUFVLFFBQVE7QUFBQSxNQUFPO0FBQUEsTUFDdEQsSUFBSSxPQUFPLFFBQVE7QUFBRSxhQUFLLEtBQUssVUFBVSxTQUFTO0FBQUEsTUFBUTtBQUFBLE1BQzFELElBQUksSUFBSSxLQUFLO0FBQUUsYUFBSyxLQUFLLFVBQVUsTUFBTTtBQUFBLE1BQUs7QUFBQSxJQUNoRDtBQUVBLGFBQVMsUUFBUSxTQUFTLFNBQVM7QUFDakMsWUFBTSxhQUFhLFFBQVEsT0FBTyxDQUFDLEtBQUssS0FBSyxNQUFNLE1BQU0sTUFBTSxRQUFRLENBQUMsR0FBRyxDQUFDO0FBQzVFLFlBQU0sUUFBUSxLQUFLLEtBQUssUUFBUSxPQUFPLENBQUMsS0FBSyxRQUFRLE1BQU0sTUFBTSxLQUFLLENBQUMsQ0FBQztBQUN4RSxZQUFNLFFBQVEsS0FBSyxLQUFLLFFBQVEsT0FBTyxDQUFDLEtBQUssUUFBUSxNQUFNLE1BQU0sS0FBSyxDQUFDLENBQUM7QUFDeEUsYUFBTyxVQUFVLEtBQUssVUFBVSxJQUFJLElBQUksY0FBYyxRQUFRO0FBQUEsSUFDaEU7QUFDQSxhQUFTLFFBQVEsTUFBTSxNQUFNLEtBQUssSUFBSTtBQUNwQyxVQUFJLEtBQUssTUFBTSxPQUFPLElBQUk7QUFDeEIsYUFBSyxNQUFNLElBQUksSUFBSTtBQUFBLE1BQ3JCLFdBQVcsS0FBSyxNQUFNLEtBQUssS0FBSztBQUM5QixhQUFLLE1BQU0sSUFBSSxJQUFJO0FBQ25CLGFBQUssTUFBTSxPQUFPLEtBQUssT0FBTztBQUM5QixhQUFLLFVBQVUsTUFBTSxLQUFLLEtBQUssS0FBSyxFQUFFLE9BQU8sQ0FBQyxLQUFLLFNBQVUsS0FBSyxNQUFNLElBQUksTUFBTSxPQUFPLEdBQUk7QUFDN0YsYUFBSyxNQUFNLEtBQUssUUFBUTtBQUFBLE1BQzFCO0FBQUEsSUFDRjtBQUVBLElBQUFBLFNBQVEsY0FBYztBQUN0QixJQUFBQSxTQUFRLGdCQUFnQjtBQUN4QixJQUFBQSxTQUFRLFVBQVU7QUFHbEIsUUFBTSxhQUFOLGNBQXlCLGNBQWM7QUFBQSxNQUNyQyxNQUFNLE9BQU8sT0FBTyxPQUFNLENBQUMsR0FBRztBQUM1QixZQUFHO0FBQ0QsY0FBSSxRQUFRLENBQUM7QUFDYixtQkFBUSxJQUFJLEdBQUcsSUFBSSxNQUFNLFFBQVEsS0FBSTtBQUNuQyxnQkFBRyxNQUFNLFNBQVMsT0FBTyxHQUFFO0FBQ3pCLG1CQUFLLElBQUksS0FBSyxRQUFRLEtBQUsseUJBQXlCLENBQUMsK0JBQStCLGFBQWEsT0FBTyxNQUFNLGNBQWMsR0FBRyxFQUFFLFNBQVMsRUFBRSxDQUFDO0FBQzdJLG9CQUFNLFFBQVEsSUFBSSxLQUFLO0FBQ3ZCLHNCQUFRLENBQUM7QUFBQSxZQUNYO0FBQ0Esa0JBQU0sT0FBTyxLQUFLLElBQUksTUFBTSxDQUFDLEVBQUUsSUFBSTtBQUNuQyxnQkFBRyxDQUFDO0FBQU0sb0JBQU0sS0FBSyxLQUFLLGlCQUFpQixFQUFFLE1BQU0sTUFBTSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFDbkUsZ0JBQUcsUUFBUSxLQUFLLGNBQWE7QUFDM0IsbUJBQUssS0FBSyxZQUFZLENBQUM7QUFDdkIsb0JBQU0sS0FBSyxLQUFLLGlCQUFpQixFQUFFLE1BQU0sTUFBTSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFBQSxZQUMzRDtBQUFBLFVBQ0Y7QUFDQSxnQkFBTSxRQUFRLElBQUksS0FBSztBQUN2QixlQUFLLElBQUksS0FBSyxRQUFRLE9BQU8sdUJBQXVCO0FBQ3BELGVBQUssSUFBSSxLQUFLLFFBQVEsS0FBSyxxQkFBcUIsQ0FBQywrQkFBK0IsNkJBQTZCLEdBQUcsRUFBRSxTQUFTLElBQUssQ0FBQztBQUNqSSxlQUFLLGtCQUFrQjtBQUFBLFFBQ3pCLFNBQU8sR0FBTjtBQUNDLGtCQUFRLElBQUksd0JBQXdCO0FBQ3BDLGtCQUFRLElBQUksQ0FBQztBQUFBLFFBQ2Y7QUFBQSxNQUNGO0FBQUEsTUFDQSxNQUFNLGtCQUFrQixjQUFjLE9BQU87QUFwUy9DO0FBcVNJLGNBQU0sTUFBTSxrQkFBa0IsV0FBVztBQUN6QyxjQUFNLEtBQUssTUFBTSxJQUFJO0FBQ3JCLGFBQUcsVUFBSyxJQUFJLGlCQUFULG1CQUF1QixhQUFZO0FBQ3BDLGdCQUFNLEtBQUssSUFBSSxhQUFhLGtCQUFrQixFQUFDLFlBQVcsQ0FBQztBQUMzRCxnQkFBTSxLQUFLLElBQUksYUFBYSxNQUFNLElBQUk7QUFBQSxRQUN4QztBQUFBLE1BQ0Y7QUFBQSxNQUNBLE1BQU0sTUFBTSxXQUFXLE9BQU87QUE1U2hDO0FBNlNJLGNBQU0sU0FBUyxDQUFDO0FBQ2hCLGNBQU0sY0FBYyxPQUFPLFFBQVEsS0FBSyxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUMsS0FBSyxJQUFJLE1BQU0sS0FBSyxHQUFHO0FBQy9FLGNBQU0sb0JBQW9CLFlBQVk7QUFDdEMsY0FBTSxrQkFBa0IsS0FBSyxJQUFJLE1BQU0sT0FBTyxDQUFDLEtBQUssU0FBUztBQUMzRCxjQUFJLEtBQUssSUFBSSxJQUFJO0FBQ2pCLGlCQUFPO0FBQUEsUUFDVCxHQUFHLENBQUMsQ0FBQztBQUNMLFlBQUcsQ0FBQyxtQkFBa0I7QUFDcEIsZUFBSyxNQUFNO0FBQ1g7QUFBQSxRQUNGO0FBQ0EsbUJBQVUsQ0FBQyxLQUFLLElBQUksS0FBSyxhQUFZO0FBQ25DLGNBQUcsQ0FBQyxnQkFBZ0IsS0FBSyxLQUFLLElBQUksR0FBRTtBQUNsQyxtQkFBTyxLQUFLLEdBQUc7QUFDZjtBQUFBLFVBQ0Y7QUFDQSxjQUFHLEtBQUssU0FBUTtBQUNkLG1CQUFPLEtBQUssR0FBRztBQUNmO0FBQUEsVUFDRjtBQUNBLGNBQUcsS0FBSyxjQUFhO0FBQ25CLGtCQUFNLFVBQVUsTUFBTSxLQUFLLFlBQVk7QUFDdkMsa0JBQU0sT0FBTyxNQUFNLFlBQVksT0FBTztBQUN0QyxnQkFBRyxXQUFTLFVBQUssaUJBQUwsbUJBQW1CLE9BQUs7QUFDbEMscUJBQU8sS0FBSyxHQUFHO0FBQ2Y7QUFBQSxZQUNGO0FBQUEsVUFDRjtBQUFBLFFBQ0Y7QUFDQSxnQkFBUSxJQUFJLE1BQU07QUFDbEIsY0FBTSxlQUFlLE9BQU8sU0FBUztBQUNyQyxZQUFJLFlBQWEsZUFBZSxPQUFTLFFBQVEsbUNBQW1DLE9BQU8sV0FBVyxLQUFLLE1BQU0sZUFBYSxHQUFHLDRCQUE0QixHQUFFO0FBQzdKLGVBQUssWUFBWSxNQUFNO0FBQ3ZCLGVBQUssSUFBSSxNQUFNLElBQUk7QUFDbkIsa0JBQVEsSUFBSSxVQUFVLE9BQU8sb0JBQW9CO0FBQUEsUUFDbkQ7QUFBQSxNQUNGO0FBQUEsTUFDQSxJQUFJLGVBQWU7QUFBRSxlQUFPLEtBQUssSUFBSSxLQUFLLElBQUksS0FBSyxJQUFJLFVBQVUsY0FBYyxFQUFFLElBQUk7QUFBQSxNQUFHO0FBQUEsTUFDeEYsSUFBSSxTQUFTO0FBQUUsYUFBSyxJQUFJLGFBQWEsU0FBUyxLQUFLLGFBQWEsTUFBTTtBQUFBLE1BQUc7QUFBQSxJQUMzRTtBQUNBLFFBQU0sWUFBTixjQUF3QixZQUFZO0FBQUEsTUFDbEMsV0FBVyxXQUFXO0FBQ3BCLGVBQU87QUFBQSxVQUNMLE1BQU07QUFBQSxZQUNKLFNBQVMsQ0FBQztBQUFBO0FBQUEsVUFDWjtBQUFBLFVBQ0EsY0FBYztBQUFBO0FBQUEsUUFDaEI7QUFBQSxNQUNGO0FBQUEsTUFDQSxNQUFNLE9BQU87QUE5VmY7QUErVkksY0FBTSxVQUFVLE1BQU0sS0FBSyxZQUFZO0FBQ3ZDLGNBQU0sT0FBTyxNQUFNLFlBQVksT0FBTztBQUN0QyxZQUFHLFdBQVMsVUFBSyxpQkFBTCxtQkFBbUIsT0FBSztBQUNsQyxlQUFLLEtBQUssUUFBUSxLQUFLLEVBQUUsUUFBUSxDQUFDLEdBQUcsT0FBTyxLQUFLLE9BQU8sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLEtBQUssTUFBTSxLQUFLLENBQUM7QUFDdkcsZUFBSyxLQUFLLFlBQVksQ0FBQztBQUFBLFFBQ3pCLE9BQUs7QUFDSCxlQUFLLGFBQWEsUUFBUSxLQUFLLE9BQU8sS0FBSztBQUMzQyxlQUFLLGFBQWEsT0FBTyxLQUFLLE9BQU8sS0FBSztBQUFBLFFBQzVDO0FBQ0EsYUFBSyxJQUFJLGFBQWEsT0FBTyxNQUFNLEVBQUUsYUFBYSxNQUFNLENBQUM7QUFBQSxNQUMzRDtBQUFBLE1BQ0EsTUFBTSxrQkFBa0I7QUFDdEIsWUFBRyxPQUFPLEtBQUssaUJBQWlCLFlBQVksS0FBSyxhQUFhO0FBQVEsaUJBQU8sS0FBSztBQUNsRixjQUFNLFVBQVUsTUFBTSxLQUFLLFlBQVk7QUFDdkMsY0FBTSxjQUFjLEtBQUssS0FBSyxLQUFLLE1BQU0sR0FBRyxFQUFFLEtBQUssS0FBSyxFQUFFLFFBQVEsT0FBTyxFQUFFO0FBQzNFLGFBQUssZUFBZSxHQUFHO0FBQUEsRUFBaUI7QUFDeEMsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBLE1BQ0EsbUJBQW1CO0FBQ2pCLFlBQUksVUFBVSxDQUFDO0FBQ2YsWUFBRyxDQUFDLEtBQUssT0FBTyxDQUFDLEtBQUssa0JBQWlCO0FBRXJDLGdCQUFNLHNCQUFzQjtBQUFBLFlBQzFCLE1BQU07QUFBQSxZQUNOLFVBQVUsTUFBTTtBQUNkLG1CQUFLLFdBQVcsT0FBTyxFQUFFLEtBQUssTUFBTSxLQUFLLElBQUksS0FBSyxLQUFLLGVBQWUsSUFBSSxDQUFDO0FBQUEsWUFDN0U7QUFBQSxVQUNGO0FBQ0EsZUFBSyxJQUFJLEtBQUssUUFBUSxLQUFLLHNCQUFzQiwyQkFBMkIsS0FBSyxTQUFTLEVBQUUsU0FBUyxvQkFBb0IsQ0FBQztBQUMxSCxpQkFBTztBQUFBLFFBQ1Q7QUFDQSxZQUFHLEtBQUssT0FBTyxLQUFLLG9CQUFvQixLQUFLLElBQUksYUFBYSxlQUFlLEtBQUssV0FBVyxhQUFZO0FBQ3ZHLGdCQUFNLGlCQUFpQixLQUFLLElBQUksYUFBYSxRQUFRLEtBQUssa0JBQWtCLEVBQUUseUJBQXlCLEtBQUssSUFBSSxDQUFDO0FBQ2pILGdCQUFNLGdCQUFnQixLQUFLLElBQUksWUFBWSxRQUFRLEtBQUssS0FBSyxFQUFFLHlCQUF5QixLQUFLLElBQUksQ0FBQztBQUNsRyxvQkFBVSxlQUNQLElBQUksV0FBUztBQUNaLGtCQUFNLE9BQU8sY0FBYyxLQUFLLENBQUFDLFVBQVFBLE1BQUssUUFBUSxNQUFNLFFBQVE7QUFDbkUsZ0JBQUcsQ0FBQztBQUFNLG9CQUFNLFFBQVEsTUFBTTtBQUFBO0FBQ3pCLG9CQUFNLFNBQVMsTUFBTSxNQUFNLEtBQUssT0FBTztBQUM1QyxtQkFBTztBQUFBLFVBQ1QsQ0FBQyxFQUVBLEtBQUssQ0FBQyxHQUFHLE1BQU07QUFDZCxnQkFBRyxFQUFFLFVBQVUsRUFBRTtBQUFPLHFCQUFPO0FBQy9CLG1CQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVMsS0FBSztBQUFBLFVBQ3BDLENBQUM7QUFBQSxRQUVMLFdBQVMsS0FBSyxvQkFBb0IsS0FBSyxJQUFJLGFBQWEsYUFBWTtBQUNsRSxnQkFBTSxpQkFBaUIsS0FBSyxJQUFJLGFBQWEsUUFBUSxLQUFLLGtCQUFrQixFQUFFLHlCQUF5QixLQUFLLElBQUksQ0FBQztBQUVqSCxvQkFBVSxlQUNQLElBQUksV0FBUztBQWxadEI7QUFtWlUsZ0JBQUcsR0FBQyxXQUFNLFNBQU4sbUJBQVksaUJBQWlCLFNBQU87QUFDdEMsb0JBQU0sUUFBUSxNQUFNO0FBQ3BCLHFCQUFPO0FBQUEsWUFDVDtBQUNBLGtCQUFNLFNBQVMsTUFBTSxNQUFNLFFBQVEsS0FBSyxrQkFBa0IsTUFBTSxLQUFLLGdCQUFnQixLQUFLO0FBQzFGLG1CQUFPO0FBQUEsVUFDVCxDQUFDLEVBRUEsS0FBSyxDQUFDLEdBQUcsTUFBTTtBQUNkLGdCQUFHLEVBQUUsVUFBVSxFQUFFO0FBQU8scUJBQU87QUFDL0IsbUJBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUyxLQUFLO0FBQUEsVUFDcEMsQ0FBQztBQUFBLFFBRUwsV0FBUyxLQUFLLE9BQU8sS0FBSyxXQUFXLGFBQVk7QUFDL0MsZ0JBQU0sZ0JBQWdCLEtBQUssSUFBSSxZQUFZLFFBQVEsS0FBSyxLQUFLLEVBQUUseUJBQXlCLEtBQUssSUFBSSxDQUFDO0FBQ2xHLG9CQUFVLGNBQ1AsSUFBSSxVQUFRO0FBQ1gsaUJBQUssUUFBUSxLQUFLO0FBQ2xCLG1CQUFPO0FBQUEsVUFDVCxDQUFDLEVBRUEsS0FBSyxDQUFDLEdBQUcsTUFBTTtBQUNkLGdCQUFHLEVBQUUsVUFBVSxFQUFFO0FBQU8scUJBQU87QUFDL0IsbUJBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUyxLQUFLO0FBQUEsVUFDcEMsQ0FBQztBQUFBLFFBRUw7QUFDQSxlQUFPO0FBQUEsTUFDVDtBQUFBLE1BQ0EsT0FBTztBQUFFLGFBQUssSUFBSSxLQUFLLFVBQVUsS0FBSyxLQUFLLElBQUk7QUFBQSxNQUFHO0FBQUEsTUFDbEQsa0JBQWtCLE1BQU07QUFBRSxlQUFPLEtBQUssT0FBTyxLQUFLLFdBQVMsTUFBTSxLQUFLLE1BQU0sQ0FBQyxLQUFLLFFBQVEsTUFBTSxLQUFLLE1BQU0sQ0FBQyxLQUFLLElBQUk7QUFBQSxNQUFHO0FBQUEsTUFDeEgsSUFBSSxhQUFhO0FBQUUsZUFBTyxLQUFLLE9BQU8sSUFBSSxXQUFTLE1BQU0sS0FBSyxVQUFVLEdBQUcsRUFBRSxPQUFPLFNBQU8sR0FBRztBQUFBLE1BQUc7QUFBQTtBQUFBLE1BQ2pHLElBQUksU0FBUztBQUFFLGVBQU8sT0FBTyxLQUFLLEtBQUssYUFBYSxNQUFNLEVBQUUsSUFBSSxlQUFhLEtBQUssSUFBSSxhQUFhLElBQUksU0FBUyxDQUFDLEVBQUUsT0FBTyxXQUFTLEtBQUs7QUFBQSxNQUFHO0FBQUE7QUFBQSxNQUMzSSxJQUFJLGNBQWM7QUFBRSxlQUFPLEtBQUssZUFBZSxLQUFLLGVBQWUsS0FBSyxnQkFBZ0I7QUFBQSxNQUFHO0FBQUEsTUFDM0YsSUFBSSxlQUFlO0FBQ2pCLFlBQUcsQ0FBQyxLQUFLO0FBQWMsaUJBQU87QUFDOUIsZUFBUSxLQUFLLGFBQWEsVUFBVSxLQUFLLE9BQU8sS0FBSyxTQUFXLEtBQUssYUFBYSxTQUFTLEtBQUssT0FBTyxLQUFLO0FBQUEsTUFDOUc7QUFBQSxNQUNBLElBQUksWUFBWTtBQUFFLGVBQU8sS0FBSyxLQUFLLEtBQUssU0FBUyxRQUFRO0FBQUEsTUFBRztBQUFBLE1BQzVELElBQUksZ0JBQWdCO0FBQUUsZUFBTyxLQUFLLEtBQUssS0FBSyxTQUFTLGVBQWU7QUFBQSxNQUFHO0FBQUEsTUFDdkUsSUFBSSxVQUFVO0FBQUUsZUFBTyxLQUFLLFdBQVc7QUFBQSxNQUFNO0FBQUEsTUFDN0MsSUFBSSxlQUFlO0FBQUUsZUFBTyxLQUFLLEtBQUssUUFBUSxTQUFTLEtBQUssS0FBSyxRQUFRLEtBQUssS0FBSyxRQUFRLFNBQVMsQ0FBQyxJQUFJO0FBQUEsTUFBTTtBQUFBLE1BQy9HLElBQUksaUJBQWlCO0FBQUUsZUFBTyxLQUFLLGtCQUFrQixLQUFLLGtCQUFrQixLQUFLLGtCQUFrQixLQUFLLFdBQVcsT0FBTyxDQUFDLEtBQUssUUFBUSxJQUFJLElBQUksQ0FBQyxLQUFLLE1BQU0sTUFBTSxJQUFJLENBQUMsQ0FBQyxHQUFHLE1BQU0sR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsSUFBSSxTQUFPLE1BQU0sS0FBSyxXQUFXLE1BQU07QUFBQSxNQUFHO0FBQUEsTUFDek8sSUFBSSxtQkFBbUI7QUE5YnpCO0FBOGIyQixlQUFPLEtBQUssb0JBQW9CLEtBQUssb0JBQW9CLEtBQUsscUJBQW9CLFVBQUssV0FBVyxDQUFDLE1BQWpCLG1CQUFvQixJQUFJLENBQUMsS0FBSyxNQUFNLEtBQUssV0FBVyxJQUFJLFNBQU8sSUFBSSxDQUFDLENBQUMsRUFBRSxLQUFLLEVBQUUsS0FBSyxNQUFNLEtBQUssV0FBVyxTQUFTLENBQUMsQ0FBQztBQUFBLE1BQUk7QUFBQSxNQUNuTyxJQUFJLFlBQVk7QUFBRSxlQUFPLEtBQUssS0FBSyxNQUFNLEdBQUcsRUFBRSxJQUFJLEVBQUUsUUFBUSxPQUFPLEVBQUU7QUFBQSxNQUFHO0FBQUEsTUFDeEUsSUFBSSxTQUFTO0FBQUUsZUFBTyxLQUFLLElBQUksVUFBVSxLQUFLLEtBQUssSUFBSTtBQUFBLE1BQUc7QUFBQSxJQUM1RDtBQUNBLFFBQU0sY0FBTixjQUEwQixjQUFjO0FBQUEsTUFDdEMsTUFBTSxPQUFPLE1BQU07QUFDakIsWUFBRztBQUNELGdCQUFNLFlBQVksS0FBSyxLQUFLO0FBQzVCLGdCQUFNLGVBQWUsTUFBTSxLQUFLLFlBQVk7QUFDNUMsZ0JBQU0sRUFBRSxPQUFPLElBQUksS0FBSyxJQUFJLGVBQWUsTUFBTSxFQUFFLFNBQVMsY0FBYyxXQUFXLFVBQVUsQ0FBQztBQUNoRyxpQkFBTyxRQUFRLFdBQVM7QUFDdEIsa0JBQU0sT0FBTyxLQUFLLGlCQUFpQixLQUFLO0FBQ3hDLGlCQUFLLGFBQWEsT0FBTyxLQUFLLEdBQUcsSUFBSTtBQUFBLFVBQ3ZDLENBQUM7QUFBQSxRQUNILFNBQU8sR0FBTjtBQUNDLGtCQUFRLElBQUksbUNBQW1DLEtBQUssR0FBRztBQUN2RCxrQkFBUSxJQUFJLENBQUM7QUFBQSxRQUNmO0FBQUEsTUFDRjtBQUFBLE1BQ0EsTUFBTSxNQUFNLFdBQVcsT0FBTztBQUM1QixjQUFNLFNBQVMsQ0FBQztBQUNoQixjQUFNLG9CQUFvQixLQUFLLGVBQWU7QUFFOUMsWUFBRyxDQUFDLG1CQUFrQjtBQUVwQjtBQUFBLFFBQ0Y7QUFDQSxtQkFBVSxDQUFDLEtBQUssS0FBSyxLQUFLLE9BQU8sUUFBUSxLQUFLLEtBQUssR0FBRztBQUNwRCxjQUFHLE1BQU07QUFBUyxtQkFBTyxLQUFLLEdBQUc7QUFBQSxRQUNuQztBQUNBLGNBQU0sZUFBZSxPQUFPLFNBQVM7QUFDckMsWUFBSSxZQUFhLGVBQWUsT0FBUyxRQUFRLG1DQUFtQyxPQUFPLFdBQVcsS0FBSyxNQUFNLGVBQWEsR0FBRyw2QkFBNkIsR0FBRTtBQUM5SixlQUFLLFlBQVksTUFBTTtBQUN2QixjQUFHLENBQUM7QUFBVSxpQkFBSyxJQUFJLE1BQU0sSUFBSTtBQUFBLFFBQ25DO0FBQ0EsZ0JBQVEsSUFBSSxVQUFVLE9BQU8scUJBQXFCO0FBQUEsTUFDcEQ7QUFBQSxJQUNGO0FBQ0EsUUFBTSxhQUFOLGNBQXlCLFlBQVk7QUFBQSxNQUNuQyxXQUFXLFdBQVc7QUFDcEIsZUFBTztBQUFBLFVBQ0wsTUFBTTtBQUFBLFlBQ0osTUFBTTtBQUFBO0FBQUEsWUFFTixRQUFRO0FBQUEsVUFDVjtBQUFBLFVBQ0EsY0FBYztBQUFBO0FBQUEsUUFDaEI7QUFBQSxNQUNGO0FBQUE7QUFBQSxNQUVBLFlBQVksTUFBTTtBQWhmcEI7QUFpZkksWUFBRyxDQUFDLEtBQUssUUFBTztBQUVkLGNBQUcsS0FBSyxLQUFLLFdBQVcsS0FBSztBQUFRLGlCQUFLLEtBQUssWUFBWSxDQUFDO0FBQUEsUUFDOUQ7QUFDQSxZQUFHLEdBQUMsVUFBSyxLQUFLLGNBQVYsbUJBQXFCO0FBQUssZUFBSyxnQkFBZ0IsS0FBSztBQUN4RCxlQUFPLEtBQUs7QUFDWixjQUFNLFlBQVksSUFBSTtBQUN0QixlQUFPO0FBQUEsTUFDVDtBQUFBLE1BQ0EsT0FBTztBQUNMLFlBQUcsQ0FBQyxLQUFLO0FBQU0saUJBQU8sUUFBUSxJQUFJLEVBQUMscUJBQXFCLEtBQUssS0FBSSxDQUFDO0FBQ2xFLFlBQUcsTUFBTSxRQUFRLEtBQUssS0FBSyxhQUFhLE1BQU07QUFBRyxlQUFLLEtBQUssYUFBYSxTQUFTLENBQUM7QUFDbEYsYUFBSyxLQUFLLGFBQWEsT0FBTyxLQUFLLEdBQUcsSUFBSTtBQUFBLE1BQzVDO0FBQUEsTUFDQSxNQUFNLGNBQWM7QUEvZnRCO0FBZ2dCSSxjQUFNLGVBQWUsUUFBTSxVQUFLLFNBQUwsbUJBQVc7QUFDdEMsWUFBRyxDQUFDO0FBQWMsaUJBQU87QUFDekIsY0FBTSxnQkFBZ0IsS0FBSyxJQUFJLGVBQWUsb0JBQW9CLEtBQUssS0FBSyxNQUFNLFlBQVk7QUFDOUYsZUFBTztBQUFBLE1BQ1Q7QUFBQSxNQUNBLE1BQU0sa0JBQWtCO0FBQ3RCLFlBQUcsT0FBTyxLQUFLLGlCQUFpQixZQUFZLEtBQUssYUFBYTtBQUFRLGlCQUFPLEtBQUs7QUFDbEYsYUFBSyxlQUFlLEtBQUssY0FBYyxPQUFRLE1BQU0sS0FBSyxZQUFZO0FBQ3RFLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQSxNQUNBLE1BQU0sZ0JBQWdCLEdBQUc7QUFDdkIsWUFBRyxDQUFDLEtBQUs7QUFBWSxpQkFBTztBQUM1QixjQUFNLFVBQVUsTUFBTSxLQUFLLFlBQVk7QUFDdkMsY0FBTSxPQUFPLE1BQU0sS0FBSyxXQUFXLFlBQVk7QUFDL0MsZUFBTyxvQkFBb0I7QUFBQSxFQUFTO0FBQUEsaUJBQTJCO0FBQUEsZ0JBQXVCO0FBQUEsRUFBUztBQUFBLGNBQXFCO0FBQUE7QUFBQSxNQUN0SDtBQUFBLE1BQ0EsbUJBQW1CO0FBQ2pCLFlBQUcsQ0FBQyxLQUFLO0FBQUssaUJBQU8sQ0FBQztBQUN0QixlQUFPLEtBQUssSUFBSSxhQUFhLFFBQVEsS0FBSyxLQUFLLEVBQUUseUJBQXlCLEtBQUssS0FBSyxJQUFJLENBQUM7QUFBQSxNQUMzRjtBQUFBLE1BQ0EsSUFBSSxjQUFjO0FBQUUsZUFBTyxLQUFLLEtBQUssS0FBSyxNQUFNLEdBQUcsRUFBRSxLQUFLLEtBQUssRUFBRSxNQUFNLEdBQUcsRUFBRSxLQUFLLEtBQUssRUFBRSxRQUFRLE9BQU8sRUFBRTtBQUFBLE1BQUc7QUFBQSxNQUM1RyxJQUFJLGNBQWM7QUFBRSxlQUFPLEtBQUssZUFBZSxLQUFLLGVBQWUsS0FBSyxnQkFBZ0I7QUFBQSxNQUFHO0FBQUEsTUFDM0YsSUFBSSxRQUFRO0FBQUUsZUFBTyxFQUFFLE9BQU8sS0FBSyxLQUFLLE1BQU0sQ0FBQyxHQUFHLEtBQUssS0FBSyxLQUFLLE1BQU0sQ0FBQyxFQUFFO0FBQUEsTUFBRTtBQUFBLE1BQzVFLElBQUksU0FBUztBQUFFLGVBQU8sS0FBSyxLQUFLLEtBQUssTUFBTSxHQUFHLEVBQUUsTUFBTSxHQUFHLEVBQUUsRUFBRSxLQUFLLEdBQUc7QUFBQSxNQUFHO0FBQUEsTUFDeEUsSUFBSSxXQUFXO0FBQUUsYUFBSyxLQUFLLEtBQUssU0FBUyxHQUFHO0FBQUEsTUFBRztBQUFBLE1BQy9DLElBQUksVUFBVTtBQUNaLFlBQUcsS0FBSyxJQUFJLFlBQVksaUJBQWlCO0FBQVEsaUJBQU87QUFDeEQsWUFBRyxDQUFDLEtBQUs7QUFBTSxpQkFBTztBQUN0QixZQUFHLEtBQUssS0FBSztBQUFTLGlCQUFPO0FBQzdCLFlBQUcsQ0FBQyxLQUFLLEtBQUssYUFBYSxPQUFPLEtBQUssR0FBRztBQUFHLGlCQUFPO0FBQ3BELGVBQU87QUFBQSxNQUNUO0FBQUE7QUFBQSxNQUVBLElBQUksT0FBTztBQUFFLGdCQUFRLENBQUMsS0FBSyxJQUFJLEtBQUssU0FBUyxpQkFBaUIsS0FBSyxLQUFLLEtBQUssTUFBTSxHQUFHLEVBQUUsSUFBSSxJQUFJLEtBQUssS0FBSyxLQUFLLE1BQU0sR0FBRyxFQUFFLEtBQUssS0FBSyxHQUFHLE1BQU0sR0FBRyxFQUFFLEtBQUssS0FBSyxFQUFFLFFBQVEsT0FBTyxFQUFFO0FBQUEsTUFBRztBQUFBO0FBQUEsTUFFbEwsSUFBSSxhQUFhO0FBbmlCbkI7QUFvaUJJLFlBQUcsQ0FBQyxLQUFLLEtBQUs7QUFBTyxpQkFBTztBQUM1QixjQUFNLFlBQVksS0FBSyxLQUFLLE1BQU0sQ0FBQyxJQUFJO0FBQ3ZDLGdCQUFPLFVBQUssS0FBSyxXQUFWLG1CQUFrQixLQUFLLFdBQU07QUF0aUJ4QyxjQUFBQyxLQUFBO0FBc2lCMkMsaUNBQWMsTUFBQUEsTUFBQSxNQUFNLFNBQU4sZ0JBQUFBLElBQVksVUFBWixtQkFBb0I7QUFBQTtBQUFBLE1BQzNFO0FBQUEsTUFDQSxJQUFJLE9BQU87QUFBRSxlQUFPLEtBQUssSUFBSSxZQUFZLElBQUksS0FBSyxRQUFRO0FBQUEsTUFBRztBQUFBLE1BQzdELElBQUksV0FBVztBQUFFLGVBQU8sS0FBSyxLQUFLLEtBQUssTUFBTSxHQUFHLEVBQUUsQ0FBQztBQUFBLE1BQUc7QUFBQSxNQUN0RCxJQUFJLFlBQVk7QUFBRSxlQUFPLEtBQUssU0FBUyxNQUFNLEdBQUcsRUFBRSxJQUFJLEVBQUUsUUFBUSxPQUFPLEVBQUU7QUFBQSxNQUFHO0FBQUE7QUFBQSxNQUU1RSxJQUFJLE9BQU87QUFBRSxlQUFPLEtBQUssS0FBSztBQUFBLE1BQU07QUFBQSxJQUN0QztBQUVBLG1CQUFlLFlBQVksTUFBTTtBQUMvQixZQUFNLFdBQVcsSUFBSSxZQUFZLEVBQUUsT0FBTyxLQUFLLEtBQUssQ0FBQztBQUNyRCxZQUFNLGFBQWEsTUFBTSxPQUFPLE9BQU8sT0FBTyxXQUFXLFFBQVE7QUFDakUsWUFBTSxZQUFZLE1BQU0sS0FBSyxJQUFJLFdBQVcsVUFBVSxDQUFDO0FBQ3ZELFlBQU0sVUFBVSxVQUFVLElBQUksT0FBSyxFQUFFLFNBQVMsRUFBRSxFQUFFLFNBQVMsR0FBRyxHQUFHLENBQUMsRUFBRSxLQUFLLEVBQUU7QUFDM0UsYUFBTztBQUFBLElBQ1Q7QUFFQSxJQUFBRixTQUFRLGFBQWE7QUFDckIsSUFBQUEsU0FBUSxjQUFjO0FBQ3RCLElBQUFBLFNBQVEsWUFBWTtBQUNwQixJQUFBQSxTQUFRLGFBQWE7QUFBQTtBQUFBOzs7QUMxakJyQjtBQUFBLHNDQUFBRyxVQUFBO0FBQUEsbUJBQWUsMkJBQTJCLGNBQWMsV0FBVyxPQUFPLENBQUMsR0FBRztBQUM1RSxhQUFPO0FBQUEsUUFDTCxZQUFZO0FBQUEsUUFDWixHQUFHO0FBQUEsTUFDTDtBQUNBLFlBQU0sZUFBZSxpQ0FBUztBQUM5QixVQUFJLENBQUM7QUFBYyxlQUFPO0FBQzFCLFlBQU0sdUJBQXVCLGFBQWEsTUFBTSx1QkFBdUI7QUFDdkUsVUFBRyxDQUFDO0FBQXNCLGVBQU87QUFFakMsZUFBUyxJQUFJLEdBQUcsSUFBSSxxQkFBcUIsUUFBUSxLQUFLO0FBRXBELFlBQUksS0FBSyxjQUFjLEtBQUssYUFBYSxhQUFhLFFBQVEscUJBQXFCLENBQUMsQ0FBQztBQUFHO0FBRXhGLGNBQU0sc0JBQXNCLHFCQUFxQixDQUFDO0FBRWxELGNBQU0sOEJBQThCLG9CQUFvQixRQUFRLGVBQWUsRUFBRSxFQUFFLFFBQVEsT0FBTyxFQUFFO0FBRXBHLGNBQU0sd0JBQXdCLE1BQU0sYUFBYSxjQUFjLDZCQUE2QixXQUFXLElBQUk7QUFFM0csWUFBSSxzQkFBc0IsWUFBWTtBQUNwQyx5QkFBZSxhQUFhLFFBQVEscUJBQXFCLHNCQUFzQixLQUFLO0FBQUEsUUFDdEY7QUFBQSxNQUNGO0FBQ0EsYUFBTztBQUFBLElBQ1Q7QUFDQSxJQUFBQSxTQUFRLDZCQUE2QjtBQUFBO0FBQUE7OztBQzFCckM7QUFBQSx1QkFBQUMsVUFBQTtBQUFBLFFBQU07QUFBQSxNQUNKLFlBQVk7QUFBQSxNQUNaO0FBQUEsTUFDQSxXQUFXO0FBQUEsTUFDWDtBQUFBLElBQ0YsSUFBSTtBQUNKLFFBQU0sRUFBRSwyQkFBMkIsSUFBSTtBQUN2QyxRQUFNLFlBQU4sY0FBd0IsY0FBYztBQUFBLE1BQ3BDLE1BQU0sY0FBYztBQUFFLGVBQU8sTUFBTSxLQUFLLE1BQU0sWUFBWSxLQUFLLEtBQUssSUFBSTtBQUFBLE1BQUc7QUFBQSxNQUMzRSxNQUFNLGVBQWUsU0FBUyxDQUFDLEdBQUc7QUFDaEMsY0FBTSxVQUFVLE1BQU0sMkJBQTJCLE1BQU0sS0FBSyxZQUFZLEdBQUcsS0FBSyxLQUFLLElBQUk7QUFDekYsZUFBTyxnQkFBZ0IsT0FBTyxJQUFJLE1BQU0sT0FBTyxJQUFJLFFBQVEsS0FBSztBQUFBLEVBQWM7QUFBQSxhQUF1QixPQUFPLElBQUksTUFBTSxPQUFPLElBQUk7QUFBQSxNQUNuSTtBQUFBLElBQ0Y7QUFDQSxRQUFNLGFBQU4sY0FBeUIsZUFBZTtBQUFBLE1BQ3RDLE1BQU0sZUFBZSxTQUFTLENBQUMsR0FBRztBQUNoQyxjQUFNLFVBQVUsTUFBTSwyQkFBMkIsTUFBTSxLQUFLLFlBQVksR0FBRyxLQUFLLEtBQUssSUFBSTtBQUN6RixlQUFPLGdCQUFnQixPQUFPLElBQUksTUFBTSxPQUFPLElBQUksUUFBUSxLQUFLO0FBQUEsRUFBYztBQUFBLGFBQXVCLE9BQU8sSUFBSSxNQUFNLE9BQU8sSUFBSTtBQUFBLE1BQ25JO0FBQUEsSUFDRjtBQUNBLElBQUFBLFNBQVEsYUFBYTtBQUNyQixJQUFBQSxTQUFRLFlBQVk7QUFDcEIsSUFBQUEsU0FBUSxjQUFjO0FBQ3RCLElBQUFBLFNBQVEsYUFBYTtBQUFBO0FBQUE7OztBQ3ZCckI7QUFBQSx3QkFBQUMsVUFBQTtBQUFBLFFBQU0sY0FBTixNQUFrQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLaEIsWUFBWSxNQUFNO0FBQ2hCLGFBQUssT0FBTztBQUNaLGFBQUssYUFBYTtBQUVsQixhQUFLLEtBQUs7QUFDVixhQUFLLFFBQVE7QUFBQSxNQUNmO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1BLE1BQU0sUUFBUSxRQUFRLE9BQU87QUFDM0IsYUFBSyxRQUFRO0FBQ2IsWUFBSSxDQUFDLEtBQUssdUJBQXVCLEtBQUs7QUFBRztBQUV6QyxZQUFHO0FBQU8sZ0JBQU0sS0FBSyxrQkFBa0IsS0FBSztBQUM1QyxZQUFHLE9BQU8sS0FBSyxzQkFBc0IsWUFBVztBQUM5QyxnQkFBTSxhQUFhLE1BQU0sS0FBSyxrQkFBa0I7QUFDaEQsY0FBRyxDQUFDLFlBQVc7QUFDYixvQkFBUSxJQUFJLCtEQUErRDtBQUMzRSxpQkFBSyxRQUFRLElBQUk7QUFDakI7QUFBQSxVQUNGO0FBQUEsUUFDRjtBQUVBLFlBQUk7QUFDRixnQkFBTSxLQUFLLHFCQUFxQjtBQUFBLFFBQ2xDLFNBQVMsS0FBUDtBQUVBLGNBQUksVUFBVyxLQUFLLGFBQWEsTUFBUSxPQUFPLEtBQUssc0JBQXNCLGFBQWM7QUFDdkYsa0JBQU0sS0FBSyx3QkFBd0IsTUFBTSxHQUFHO0FBQUEsVUFDOUMsT0FBTztBQUNMLGlCQUFLLHFCQUFxQjtBQUFBLFVBQzVCO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSx1QkFBdUIsT0FBTztBQUM1QixnQkFBUSxTQUFTLEtBQUs7QUFDdEIsWUFBSSxLQUFLLE1BQU0sS0FBSyxHQUFHLGVBQWUsVUFBVSxNQUFNO0FBQ3BELGtCQUFRLElBQUksa0VBQWtFO0FBQzlFLGlCQUFPO0FBQUEsUUFDVDtBQUNBLFlBQUksU0FBUyxLQUFLLGNBQWMsSUFBSTtBQUNsQyxrQkFBUSxNQUFNLHVDQUF1QztBQUNyRCxlQUFLLHFCQUFxQjtBQUMxQixpQkFBTztBQUFBLFFBQ1Q7QUFDQSxlQUFPO0FBQUEsTUFDVDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLGtCQUFrQixPQUFPO0FBQ3ZCLFlBQUksU0FBUyxLQUFLLE9BQU87QUFDdkIsZUFBSyxjQUFjO0FBQ25CLGdCQUFNLGVBQWUsS0FBSyxJQUFJLE1BQU8sS0FBSyxJQUFJLEdBQUcsS0FBSyxVQUFVLEdBQUcsR0FBSztBQUN4RSxrQkFBUSxJQUFJLDhCQUE4QixlQUFlLGdCQUFpQjtBQUMxRSxpQkFBTyxJQUFJLFFBQVEsYUFBVyxXQUFXLFNBQVMsWUFBWSxDQUFDO0FBQUEsUUFDakU7QUFDQSxlQUFPLFFBQVEsUUFBUTtBQUFBLE1BQ3pCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1BLE1BQU0sdUJBQXVCO0FBRTNCLGFBQUssa0JBQWtCO0FBRXZCLGNBQU0sSUFBSSxRQUFRLENBQUMsU0FBUyxXQUFXO0FBQ3JDLGdCQUFNLGFBQWEsV0FBVyxNQUFNO0FBdEYxQztBQXVGUSxnQkFBSSxDQUFDLEtBQUssTUFBTSxLQUFLLEdBQUcsZUFBZSxVQUFVLE1BQU07QUFDckQseUJBQUssT0FBTCxtQkFBUztBQUNULHFCQUFPLElBQUksTUFBTSw2QkFBNkIsQ0FBQztBQUFBLFlBQ2pEO0FBQUEsVUFDRixHQUFHLEdBQUs7QUFFUixlQUFLLEtBQUssSUFBSSxVQUFVLGtCQUFrQixLQUFLLE1BQU07QUFDckQsZUFBSyxHQUFHLFNBQVMsTUFBTTtBQUNyQix5QkFBYSxVQUFVO0FBQ3ZCLGlCQUFLLFFBQVE7QUFDYixpQkFBSyxhQUFhO0FBQ2xCLGlCQUFLLFFBQVE7QUFDYixvQkFBUTtBQUFBLFVBQ1Y7QUFDQSxlQUFLLEdBQUcsVUFBVSxDQUFDLFVBQVU7QUFDM0IsaUJBQUssa0JBQWtCO0FBQ3ZCLG1CQUFPLElBQUksTUFBTSxrQkFBa0IsQ0FBQztBQUNwQyxpQkFBSyxTQUFTO0FBQUEsVUFDaEI7QUFDQSxlQUFLLEdBQUcsVUFBVSxDQUFDLFFBQVE7QUFDekIsaUJBQUssa0JBQWtCO0FBQ3ZCLG1CQUFPLEdBQUc7QUFDVixpQkFBSyxTQUFTLEdBQUc7QUFBQSxVQUNuQjtBQUNBLGVBQUssR0FBRyxZQUFZLEtBQUssZUFBZSxLQUFLLElBQUk7QUFBQSxRQUNuRCxDQUFDO0FBQUEsTUFDSDtBQUFBLE1BRUEsb0JBQW9CO0FBQ2xCLFlBQUksS0FBSyxJQUFJO0FBRVgsZUFBSyxHQUFHLFNBQVM7QUFDakIsZUFBSyxHQUFHLFVBQVU7QUFDbEIsZUFBSyxHQUFHLFVBQVU7QUFDbEIsZUFBSyxHQUFHLFlBQVk7QUFFcEIsY0FBSSxLQUFLLEdBQUcsZUFBZSxVQUFVLFFBQVEsS0FBSyxHQUFHLGVBQWUsVUFBVSxZQUFZO0FBQ3hGLGlCQUFLLEdBQUcsTUFBTTtBQUFBLFVBQ2hCO0FBQ0EsZUFBSyxLQUFLO0FBQUEsUUFDWjtBQUFBLE1BQ0Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxNQUFNLHdCQUF3QixPQUFPLEtBQUs7QUFDeEMsZ0JBQVEsSUFBSSxpREFBaUQsS0FBSyxJQUFJO0FBQ3RFLFlBQUksU0FBUyxLQUFLLGFBQWEsSUFBSTtBQUNqQyxnQkFBTSxLQUFLLFFBQVEsSUFBSTtBQUFBLFFBQ3pCLFdBQVcsQ0FBQyxTQUFTLEtBQUssY0FBYyxJQUFJO0FBQzFDLGtCQUFRLE1BQU0sK0NBQStDO0FBQzdELGtCQUFRLElBQUksR0FBRztBQUNmLGVBQUsscUJBQXFCO0FBQUEsUUFDNUI7QUFBQSxNQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLFNBQVMsS0FBSztBQUFBLE1BRWQ7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUtBLFdBQVc7QUFDVCxnQkFBUSxJQUFJLDZCQUE2QjtBQUd6QyxZQUFHLEtBQUssU0FBUyxLQUFLLDBCQUEwQjtBQUM5QyxlQUFLLFFBQVEsSUFBSTtBQUFBLFFBQ25CLE9BQU87QUFDTCxrQkFBUSxJQUFJLDhGQUE4RjtBQUFBLFFBRTVHO0FBQUEsTUFDRjtBQUFBLE1BRUEsSUFBSSwyQkFBMkI7QUFDN0IsZUFBTyxLQUFLLGFBQWE7QUFBQSxNQUMzQjtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTUEsVUFBVTtBQUNSLGdCQUFRLElBQUksa0NBQWtDLEtBQUssTUFBTTtBQUFBLE1BQzNEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1BLGVBQWUsT0FBTztBQUNwQixnQkFBUSxJQUFJLHVCQUF1QixNQUFNLElBQUk7QUFBQSxNQUMvQztBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0EsdUJBQXVCO0FBQ3JCLGdCQUFRLE1BQU0sd0NBQXdDO0FBQUEsTUFDeEQ7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUlBLFNBQVM7QUFDUCxhQUFLLGtCQUFrQjtBQUFBLE1BQ3pCO0FBQUEsSUFDRjtBQUNBLElBQUFBLFNBQVEsY0FBYztBQUFBO0FBQUE7OztBQzNNdEI7QUFBQSwyQkFBQUMsVUFBQTtBQUFBLFFBQU0sRUFBRSxZQUFZLElBQUk7QUFFeEIsUUFBTSxpQkFBTixjQUE2QixZQUFZO0FBQUEsTUFDdkMsWUFBWSxLQUFLLE1BQU07QUFDckIsY0FBTSxJQUFJO0FBQ1YsYUFBSyxNQUFNO0FBQ1gsYUFBSyxRQUFRLEtBQUs7QUFDbEIsYUFBSyxlQUFlO0FBQUEsTUFDdEI7QUFBQSxNQUNBLGFBQWEsT0FBTyxLQUFLLE1BQU07QUFDN0IsY0FBTSxlQUFlLElBQUksZUFBZSxLQUFLLElBQUk7QUFDakQsWUFBSSxRQUFRO0FBQ1osY0FBTSxhQUFhLEtBQUs7QUFDeEIsZUFBTztBQUFBLE1BQ1Q7QUFBQSxNQUNBLE1BQU0sT0FBTztBQUNYLGNBQU0sS0FBSyxpQkFBaUI7QUFDNUIsY0FBTSxLQUFLLFFBQVE7QUFBQSxNQUVyQjtBQUFBLE1BQ0EsTUFBTSxvQkFBbUI7QUFwQjNCO0FBcUJJLFlBQUc7QUFDRCxnQkFBTSxXQUFXLFFBQU0sVUFBSyxJQUFJLEtBQUssYUFBZCxtQkFBd0IsV0FBVyxFQUFDLEtBQUssMkJBQTJCLFFBQVEsTUFBSztBQUN4RyxrQkFBUSxJQUFJLFFBQVE7QUFDcEIsa0JBQU8scUNBQVUsWUFBVztBQUFBLFFBQzlCLFNBQU8sS0FBTjtBQUVDLGlCQUFPO0FBQUEsUUFDVDtBQUFBLE1BQ0Y7QUFBQSxNQUNBLE1BQU0saUJBQWlCLFVBQVUsR0FBRztBQUNsQyxhQUFLLGVBQWUsT0FBTyxhQUFhO0FBQ3hDLFlBQUksQ0FBQyxLQUFLLGNBQWM7QUFDdEIsY0FBSSxVQUFVLElBQUk7QUFDaEIsa0JBQU0sSUFBSSxRQUFRLGFBQVcsV0FBVyxTQUFTLFVBQVUsR0FBSSxDQUFDO0FBQ2hFLG1CQUFPLEtBQUssaUJBQWlCLFVBQVUsQ0FBQztBQUFBLFVBQzFDLE9BQU87QUFDTCxpQkFBSyxNQUFNLEtBQUssWUFBWSx3QkFBd0I7QUFBQSxVQUN0RDtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQUEsTUFDQSxNQUFNLGVBQWUsT0FBTztBQUMxQixnQkFBUSxJQUFJLHdCQUF3QixNQUFNLElBQUk7QUFDOUMsZ0JBQVEsSUFBSSxPQUFPLE1BQU0sSUFBSTtBQUM3QixjQUFNLE9BQU8sS0FBSyxNQUFNLE1BQU0sSUFBSTtBQUNsQyxZQUFJO0FBQ0YsZ0JBQU0sT0FBTyxNQUFNLEtBQUssYUFBYSxjQUFjLEtBQUssT0FBTyxLQUFLLFVBQVUsSUFBSTtBQUNsRixrQkFBUSxJQUFJLElBQUk7QUFDaEIsZUFBSyxHQUFHLEtBQUssS0FBSyxVQUFVLElBQUksQ0FBQztBQUFBLFFBQ25DLFNBQVMsS0FBUDtBQUNBLGtCQUFRLE1BQU0sR0FBRztBQUNqQixlQUFLLEdBQUcsS0FBSyxLQUFLLFVBQVUsRUFBRSxRQUFRLFNBQVMsU0FBUyxJQUFJLENBQUMsQ0FBQztBQUFBLFFBQ2hFO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFDQSxJQUFBQSxTQUFRLGlCQUFpQjtBQUFBO0FBQUE7OztBQ3ZEekI7QUFBQSxxQkFBQUMsVUFBQUMsU0FBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxNQUNFLGFBQWU7QUFBQSxNQUNmLFdBQWE7QUFBQSxNQUNiLFlBQWM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BQ2QsZ0JBQWtCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUNsQixxQkFBdUI7QUFBQSxNQUN2Qix1QkFBeUI7QUFBQSxNQUN6QixtQkFBcUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFDckIsc0JBQXdCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BQ3hCLGdCQUFrQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQ3BCO0FBQUE7QUFBQTs7O0FDVkE7QUFBQSxlQUFBQyxVQUFBQyxTQUFBO0FBQUEsS0FBQyxTQUFTLEdBQUU7QUFBQyxVQUFHLE9BQU9ELGFBQVUsWUFBVSxPQUFPQyxZQUFTLGFBQVk7QUFBQyxRQUFBQSxRQUFPLFVBQVEsRUFBRTtBQUFBLE1BQUMsV0FBUyxPQUFPLFdBQVMsY0FBWSxPQUFPLEtBQUk7QUFBQyxlQUFPLENBQUMsR0FBRSxDQUFDO0FBQUEsTUFBQyxPQUFLO0FBQUMsWUFBSTtBQUFFLFlBQUcsT0FBTyxXQUFTLGFBQVk7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QUFBUSxhQUFLLFNBQVMsbUJBQW1CO0FBQzFFLFdBQUssU0FBUyxtQkFBbUI7QUFDakMsV0FBSyxjQUFjO0FBQUEsSUFDckI7QUFFQSxRQUFHLEtBQUssU0FBUyw0QkFBNEIsUUFBTztBQUNsRCxXQUFLLFNBQVMsMEJBQTBCO0FBQ3hDLFdBQUssY0FBYztBQUFBLElBQ3JCO0FBRUEsUUFBRyxDQUFDLGFBQWEsS0FBSyxTQUFTLHVCQUF1QixHQUFHO0FBQ3ZELFdBQUssU0FBUywwQkFBMEIsS0FBSyxZQUFZLFNBQVM7QUFDbEUsV0FBSyxjQUFjO0FBQUEsSUFDckI7QUFDQSxRQUFHLENBQUMsYUFBYSxLQUFLLFNBQVMsd0JBQXdCLEtBQUssS0FBSyxTQUFTLDZCQUE2QixRQUFRO0FBQzdHLFdBQUssU0FBUywyQkFBMkIsS0FBSyxZQUFZLFNBQVM7QUFDbkUsV0FBSyxjQUFjO0FBQUEsSUFDckI7QUFFQSxRQUFJLEtBQUssU0FBUyxtQkFBbUI7QUFDbkMsV0FBSyxTQUFTLG9CQUFvQixLQUFLLFNBQVM7QUFDaEQsYUFBTyxLQUFLLFNBQVM7QUFBQSxJQUN2QjtBQUFBLEVBQ0Y7QUFDRjtBQUNBLE9BQU8sVUFBVTsiLAogICJuYW1lcyI6IFsiZXhwb3J0cyIsICJleHBvcnRzIiwgIk9ic0FKU09OIiwgImkiLCAiZXhwb3J0cyIsICJPYnNNdWx0aUFKU09OIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgImxpbmUiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJmdW5jcyIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAicmVxdWVzdCIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAicmVzcCIsICJ0b2tlbnMiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAiZW1iZWRfbW9kZWxzIiwgImV4cG9ydHMiLCAibm90ZSIsICJfYSIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImRlZmluZSIsICJpIiwgInIiLCAibiIsICJyZXF1aXJlIiwgInBhdGgiLCAic2VsZiIsICJwcm9jZXNzIiwgImUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAicmVxdWlyZV9hZGFwdGVycyIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJyZXF1aXJlX2NvaGVyZSIsICJleHBvcnRzIiwgInJlcXVpcmVfYW50aHJvcGljIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgInJlcXVlc3QiLCAiZXhwb3J0cyIsICJpIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAiU2NDaGF0VmlldyIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAiX2EiLCAiZXhwb3J0cyIsICJTY0NoYXRWaWV3IiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgIlNjRW52IiwgImV4cG9ydHMiLCAiZGVmYXVsdF9zZXR0aW5ncyIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAiU2NTbWFydFZpZXciLCAib2JzZXJ2ZXIiLCAiX2EiLCAiZXhwb3J0cyIsICJTbWFydFNlYXJjaCIsICJleHBvcnRzIiwgIlNtYXJ0Tm90aWNlcyIsICJleHBvcnRzIiwgIlNjU2V0dGluZ3NUYWIiLCAiZXhwb3J0cyIsICJTY0FjdGlvbnNVeCIsICJleHBvcnRzIiwgIm9wZW5fbm90ZSJdCn0K
